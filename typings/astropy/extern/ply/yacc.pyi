from _typeshed import Incomplete

__version__: str
__tabversion__: str
yaccdebug: bool
debug_file: str
tab_module: str
default_lr: str
error_count: int
yaccdevel: bool
resultlimit: int
pickle_protocol: int
string_types = str
MAXINT: Incomplete

class PlyLogger:
    f: Incomplete
    def __init__(self, f) -> None: ...
    def debug(self, msg, *args, **kwargs) -> None: ...
    info = debug
    def warning(self, msg, *args, **kwargs) -> None: ...
    def error(self, msg, *args, **kwargs) -> None: ...
    critical = debug

class NullLogger:
    def __getattribute__(self, name): ...
    def __call__(self, *args, **kwargs): ...

class YaccError(Exception): ...

def format_result(r): ...
def format_stack_entry(r): ...

_errok: Incomplete
_token: Incomplete
_restart: Incomplete
_warnmsg: str

def errok(): ...
def restart(): ...
def token(): ...
def call_errorfunc(errorfunc, token, parser): ...

class YaccSymbol:
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...

class YaccProduction:
    slice: Incomplete
    stack: Incomplete
    lexer: Incomplete
    parser: Incomplete
    def __init__(self, s, stack: Incomplete | None = None) -> None: ...
    def __getitem__(self, n): ...
    def __setitem__(self, n, v) -> None: ...
    def __getslice__(self, i, j): ...
    def __len__(self) -> int: ...
    def lineno(self, n): ...
    def set_lineno(self, n, lineno) -> None: ...
    def linespan(self, n): ...
    def lexpos(self, n): ...
    def set_lexpos(self, n, lexpos) -> None: ...
    def lexspan(self, n): ...
    def error(self) -> None: ...

class LRParser:
    productions: Incomplete
    action: Incomplete
    goto: Incomplete
    errorfunc: Incomplete
    errorok: bool
    def __init__(self, lrtab, errorf) -> None: ...
    def errok(self) -> None: ...
    def restart(self) -> None: ...
    defaulted_states: Incomplete
    def set_defaulted_states(self) -> None: ...
    def disable_defaulted_states(self) -> None: ...
    def parse(self, input: Incomplete | None = None, lexer: Incomplete | None = None, debug: bool = False, tracking: bool = False, tokenfunc: Incomplete | None = None): ...
    token: Incomplete
    statestack: Incomplete
    symstack: Incomplete
    state: Incomplete
    def parsedebug(self, input: Incomplete | None = None, lexer: Incomplete | None = None, debug: bool = False, tracking: bool = False, tokenfunc: Incomplete | None = None): ...
    def parseopt(self, input: Incomplete | None = None, lexer: Incomplete | None = None, debug: bool = False, tracking: bool = False, tokenfunc: Incomplete | None = None): ...
    def parseopt_notrack(self, input: Incomplete | None = None, lexer: Incomplete | None = None, debug: bool = False, tracking: bool = False, tokenfunc: Incomplete | None = None): ...

_is_identifier: Incomplete

class Production:
    reduced: int
    name: Incomplete
    prod: Incomplete
    number: Incomplete
    func: Incomplete
    callable: Incomplete
    file: Incomplete
    line: Incomplete
    prec: Incomplete
    len: Incomplete
    usyms: Incomplete
    lr_items: Incomplete
    lr_next: Incomplete
    str: Incomplete
    def __init__(self, number, name, prod, precedence=('right', 0), func: Incomplete | None = None, file: str = '', line: int = 0) -> None: ...
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...
    def __len__(self) -> int: ...
    def __nonzero__(self): ...
    def __getitem__(self, index): ...
    def lr_item(self, n): ...
    def bind(self, pdict) -> None: ...

class MiniProduction:
    name: Incomplete
    len: Incomplete
    func: Incomplete
    callable: Incomplete
    file: Incomplete
    line: Incomplete
    str: Incomplete
    def __init__(self, str, name, len, func, file, line) -> None: ...
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...
    def bind(self, pdict) -> None: ...

class LRItem:
    name: Incomplete
    prod: Incomplete
    number: Incomplete
    lr_index: Incomplete
    lookaheads: Incomplete
    len: Incomplete
    usyms: Incomplete
    def __init__(self, p, n) -> None: ...
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...

def rightmost_terminal(symbols, terminals): ...

class GrammarError(YaccError): ...

class Grammar:
    Productions: Incomplete
    Prodnames: Incomplete
    Prodmap: Incomplete
    Terminals: Incomplete
    Nonterminals: Incomplete
    First: Incomplete
    Follow: Incomplete
    Precedence: Incomplete
    UsedPrecedence: Incomplete
    Start: Incomplete
    def __init__(self, terminals) -> None: ...
    def __len__(self) -> int: ...
    def __getitem__(self, index): ...
    def set_precedence(self, term, assoc, level) -> None: ...
    def add_production(self, prodname, syms, func: Incomplete | None = None, file: str = '', line: int = 0) -> None: ...
    def set_start(self, start: Incomplete | None = None) -> None: ...
    def find_unreachable(self): ...
    def infinite_cycles(self): ...
    def undefined_symbols(self): ...
    def unused_terminals(self): ...
    def unused_rules(self): ...
    def unused_precedence(self): ...
    def _first(self, beta): ...
    def compute_first(self): ...
    def compute_follow(self, start: Incomplete | None = None): ...
    def build_lritems(self) -> None: ...

class VersionError(YaccError): ...

class LRTable:
    lr_action: Incomplete
    lr_goto: Incomplete
    lr_productions: Incomplete
    lr_method: Incomplete
    def __init__(self) -> None: ...
    def read_table(self, module): ...
    def read_pickle(self, filename): ...
    def bind_callables(self, pdict) -> None: ...

def digraph(X, R, FP): ...
def traverse(x, N, stack, F, X, R, FP) -> None: ...

class LALRError(YaccError): ...

class LRGeneratedTable(LRTable):
    grammar: Incomplete
    lr_method: Incomplete
    log: Incomplete
    lr_action: Incomplete
    lr_goto: Incomplete
    lr_productions: Incomplete
    lr_goto_cache: Incomplete
    lr0_cidhash: Incomplete
    _add_count: int
    sr_conflict: int
    rr_conflict: int
    conflicts: Incomplete
    sr_conflicts: Incomplete
    rr_conflicts: Incomplete
    def __init__(self, grammar, method: str = 'LALR', log: Incomplete | None = None) -> None: ...
    def lr0_closure(self, I): ...
    def lr0_goto(self, I, x): ...
    def lr0_items(self): ...
    def compute_nullable_nonterminals(self): ...
    def find_nonterminal_transitions(self, C): ...
    def dr_relation(self, C, trans, nullable): ...
    def reads_relation(self, C, trans, empty): ...
    def compute_lookback_includes(self, C, trans, nullable): ...
    def compute_read_sets(self, C, ntrans, nullable): ...
    def compute_follow_sets(self, ntrans, readsets, inclsets): ...
    def add_lookaheads(self, lookbacks, followset) -> None: ...
    def add_lalr_lookaheads(self, C) -> None: ...
    def lr_parse_table(self) -> None: ...
    def write_table(self, tabmodule, outputdir: str = '', signature: str = '') -> None: ...
    def pickle_table(self, filename, signature: str = '') -> None: ...

def get_caller_module_dict(levels): ...
def parse_grammar(doc, file, line): ...

class ParserReflect:
    pdict: Incomplete
    start: Incomplete
    error_func: Incomplete
    tokens: Incomplete
    modules: Incomplete
    grammar: Incomplete
    error: bool
    log: Incomplete
    def __init__(self, pdict, log: Incomplete | None = None) -> None: ...
    def get_all(self) -> None: ...
    def validate_all(self): ...
    def signature(self): ...
    def validate_modules(self) -> None: ...
    def get_start(self) -> None: ...
    def validate_start(self) -> None: ...
    def get_error_func(self) -> None: ...
    def validate_error_func(self) -> None: ...
    def get_tokens(self) -> None: ...
    def validate_tokens(self) -> None: ...
    prec: Incomplete
    def get_precedence(self) -> None: ...
    preclist: Incomplete
    def validate_precedence(self) -> None: ...
    pfuncs: Incomplete
    def get_pfunctions(self): ...
    def validate_pfunctions(self) -> None: ...

def yacc(method: str = 'LALR', debug=..., module: Incomplete | None = None, tabmodule=..., start: Incomplete | None = None, check_recursion: bool = True, optimize: bool = False, write_tables: bool = True, debugfile=..., outputdir: Incomplete | None = None, debuglog: Incomplete | None = None, errorlog: Incomplete | None = None, picklefile: Incomplete | None = None): ...
