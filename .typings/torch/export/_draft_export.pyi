import torch
import torch._logging._internal
import types
from ._trace import _export as _export
from .dynamic_shapes import Dim as Dim, _DimHint as _DimHint, _DimHintType as _DimHintType
from .exported_program import ExportedProgram as ExportedProgram
from _typeshed import Incomplete
from dataclasses import dataclass
from enum import IntEnum
from torch._export.passes.insert_custom_op_guards import OpProfile as OpProfile, get_op_profiles as get_op_profiles, insert_custom_op_guards as insert_custom_op_guards
from typing import Any

log: Incomplete

class FailureType(IntEnum):
    MISSING_FAKE_KERNEL = 1
    DATA_DEPENDENT_ERROR = 2
    GUARD_ADDED = 3
    MISMATCHED_FAKE_KERNEL = 4
    def __str__(self) -> str: ...

def prettify_stack(stack: list[dict[str, str]], str_to_filename: dict[int, str]) -> str: ...
def prettify_frame_locals(loc: str, locals: dict[str, Any], symbols: dict[str, Any]) -> str: ...
def get_loc(filename: str, lineno: int) -> str | None: ...

class FailureReport:
    failure_type: FailureType
    data: dict[str, Any]
    xfail: bool
    def __init__(self, failure_type: FailureType, data: dict[str, Any], xfail: bool = False) -> None: ...
    def __repr__(self) -> str: ...
    def print(self, str_to_filename: dict[int, str]) -> str: ...

class DraftExportReport:
    failures: list[FailureReport]
    str_to_filename: Incomplete
    expressions_created: dict[int, dict[str, Any]]
    op_profiles: Incomplete
    def __init__(self, failures: list[FailureReport], str_to_filename: dict[int, str], expressions_created: dict[int, dict[str, Any]], op_profiles: dict[str, set[OpProfile]]) -> None: ...
    def successful(self) -> bool: ...
    def __repr__(self) -> str: ...
    def __str__(self) -> str: ...
    def apply_suggested_fixes(self) -> None: ...

@dataclass
class ExpressionCreatedNode:
    result_id: int
    argument_ids: list[int]
    record: dict[str, object]
    visited: bool = ...

class LogRecord:
    log_count: dict[int, int]
    logs: list[tuple[str, dict[str, Any]]]
    def __init__(self) -> None: ...
    def _hash(self, element: tuple[str, dict[str, Any]]) -> int: ...
    def try_add(self, element: tuple[str, dict[str, str]]) -> bool: ...
    def get_log_count(self, element: tuple[str, dict[str, Any]]) -> int: ...

class CaptureStructuredTrace(torch._logging._internal.LazyTraceHandler):
    specific_log_keys: Incomplete
    log_record: LogRecord
    expression_created_logs: dict[int, ExpressionCreatedNode]
    symbol_to_expressions: dict[str, list[dict[str, Any]]]
    logger: Incomplete
    prev_get_dtrace: bool
    def __init__(self) -> None: ...
    def __enter__(self) -> CaptureStructuredTrace: ...
    def __exit__(self, exc_type: type[BaseException] | None, exc_value: BaseException | None, traceback: types.TracebackType | None) -> None: ...
    def emit(self, record: Any) -> None: ...

def draft_export(mod: torch.nn.Module, args: tuple[Any, ...], kwargs: dict[str, Any] | None = None, *, dynamic_shapes: dict[str, Any] | tuple[Any] | list[Any] | None = None, preserve_module_call_signature: tuple[str, ...] = (), strict: bool = False, pre_dispatch: bool = True) -> ExportedProgram: ...
