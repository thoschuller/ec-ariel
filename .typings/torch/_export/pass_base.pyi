import torch
from _typeshed import Incomplete
from torch import fx
from torch._export.pass_infra.node_metadata import NodeMetadata
from torch._export.pass_infra.proxy_value import ProxyValue
from torch._subclasses.fake_tensor import FakeTensorMode
from torch.fx.experimental.proxy_tensor import PythonKeyTracer
from torch.fx.graph import CodeGen
from torch.fx.passes.infra.pass_base import PassBase, PassResult
from typing import Any, Callable

__all__ = ['_ExportPassBaseDeprecatedDoNotUse']

Argument = Any
Value = Any
Fn = Callable[..., Any]
PassType = Callable[[torch.fx.GraphModule], PassResult | None]

class ExportPassBaseError(RuntimeError): ...

class _ExportPassBaseDeprecatedDoNotUse(PassBase):
    """
    Interpreter-based pass class to help users maintain the IR spec while writing
    transformations.
    """
    @staticmethod
    def _create_dummy_node_metadata(): ...
    class ExportTracer(PythonKeyTracer):
        callback: Incomplete
        root: Incomplete
        graph: Incomplete
        tensor_attrs: dict[str, torch.Tensor]
        fake_tensor_mode: FakeTensorMode | None
        submodules: dict[torch.nn.Module, str]
        def __init__(self, callback: _ExportPassBaseDeprecatedDoNotUse, codegen: CodeGen) -> None: ...
        def trace(self) -> None: ...
        def create_arg(self, a: Argument) -> torch.fx.Node: ...
        def set_metadata(self, node: torch.fx.Node, value: Argument) -> None: ...
    class ExportInterpreter(fx.Interpreter):
        callback: Incomplete
        node: torch.fx.Node
        def __init__(self, callback: _ExportPassBaseDeprecatedDoNotUse, gm: fx.GraphModule) -> None: ...
        def placeholder(self, target: str, args: tuple[Argument, ...], kwargs: dict[str, Argument]) -> ProxyValue: ...
        def output(self, target: torch.fx.node.Target, args: tuple[Argument, ...], kwargs: dict[str, Argument]) -> ProxyValue: ...
        def call_function(self, target: torch.fx.node.Target, args: tuple[Argument, ...], kwargs: dict[str, Argument]) -> ProxyValue: ...
        def get_attr(self, target: str, args: tuple[Argument, ...], kwargs: dict[str, Argument]) -> Argument: ...
        def call_module(self, target: torch.fx.node.Target, args: tuple[Argument, ...], kwargs: dict[str, Argument]) -> None: ...
        def call_method(self, target: str, args: tuple[Argument, ...], kwargs: dict[str, Argument]) -> None: ...
        def run_node(self, n: torch.fx.Node) -> Argument: ...
    interpreter: Incomplete
    tracer: Incomplete
    fake_tensor_mode: FakeTensorMode | None
    _initialized: bool
    node_debug_str: str | None
    def __init__(self) -> None: ...
    def _fx(self, kind: str, target: torch.fx.node.Target, args: tuple[Argument, ...], kwargs: dict[str, Argument], meta: NodeMetadata) -> ProxyValue: ...
    def inputs(self, graph_module: torch.fx.GraphModule) -> list[Argument]: ...
    def on_attr(self, attr: ProxyValue) -> None: ...
    def placeholder(self, name: str, arg: Argument, meta: NodeMetadata) -> ProxyValue: ...
    def call_operator(self, op, args: tuple[Argument, ...], kwargs: dict[str, Argument], meta: NodeMetadata) -> ProxyValue: ...
    def call_sym(self, target: Fn, args: tuple[Argument, ...], meta: NodeMetadata) -> ProxyValue: ...
    def call_cond(self, pred: ProxyValue, true_fn: torch.fx.GraphModule, false_fn: torch.fx.GraphModule, inputs: list[Argument], meta: NodeMetadata) -> ProxyValue: ...
    def call_map(self, f: torch.fx.GraphModule, mapped_args: list[ProxyValue], operands: list[ProxyValue], meta: NodeMetadata) -> ProxyValue: ...
    def call_getitem(self, value: ProxyValue, key: int, meta: NodeMetadata) -> ProxyValue: ...
    def output(self, results: list[Argument], meta: NodeMetadata) -> ProxyValue: ...
    def call_submodule(self, graph_module: fx.GraphModule, inputs: tuple[Argument, ...]) -> PassResult: ...
    def call(self, graph_module: fx.GraphModule) -> PassResult: ...
