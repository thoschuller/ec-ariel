import dataclasses
from .utils import _materialize_cpp_cia_ops as _materialize_cpp_cia_ops
from .wrappers import _wrap_submodules as _wrap_submodules
from _typeshed import Incomplete
from collections import OrderedDict as OrderedDict
from contextlib import contextmanager as contextmanager
from functools import lru_cache
from torch._C._aoti import AOTIModelContainerRunner as AOTIModelContainerRunner
from torch._dispatch.python import enable_python_dispatcher as enable_python_dispatcher
from torch._guards import compile_context as compile_context
from torch._utils_internal import log_export_usage as log_export_usage
from torch.export._tree_utils import reorder_kwargs as reorder_kwargs
from torch.export.graph_signature import ArgumentSpec as ArgumentSpec, ConstantArgument as ConstantArgument, ExportGraphSignature as ExportGraphSignature, InputKind as InputKind, InputSpec as InputSpec, OutputKind as OutputKind, OutputSpec as OutputSpec, SymBoolArgument as SymBoolArgument, SymFloatArgument as SymFloatArgument, SymIntArgument as SymIntArgument, TensorArgument as TensorArgument
from torch.fx._compatibility import compatibility as compatibility
from torch.fx.experimental.proxy_tensor import make_fx as make_fx
from torch.fx.graph import _PyTreeCodeGen as _PyTreeCodeGen, _PyTreeInfo as _PyTreeInfo
from typing import Any, Callable
from unittest.mock import patch as patch

log: Incomplete

@dataclasses.dataclass
class ExportDynamoConfig:
    """
    Manage Export-specific configurations of Dynamo.
    """
    allow_rnn: bool = ...

@lru_cache
def aot_compile_warning() -> None: ...
def aot_compile(f: Callable, args: tuple[Any], kwargs: dict[str, Any] | None = None, *, dynamic_shapes: dict[str, Any] | None = None, options: dict[str, Any] | None = None, remove_runtime_assertions: bool = False, disable_constraint_solver: bool = False, same_signature: bool = True) -> list[Any] | str:
    """
    Note: this function is not stable yet

    Traces either an nn.Module's forward function or just a callable with PyTorch
    operations inside, generates executable cpp code from the program, and returns
    the path to the generated shared library

    Args:
        f: the `nn.Module` or callable to trace.

        args: example positional inputs.

        kwargs: optional example keyword inputs.

        dynamic_shapes: Should either be:
            1) a dict from argument names of ``f`` to their dynamic shape specifications,
            2) a tuple that specifies dynamic shape specifications for each input in original order.
            If you are specifying dynamism on keyword args, you will need to pass them in the order that
            is defined in the original function signature.

            The dynamic shape of a tensor argument can be specified as either
            (1) a dict from dynamic dimension indices to :func:`Dim` types, where it is
            not required to include static dimension indices in this dict, but when they are,
            they should be mapped to None; or (2) a tuple / list of :func:`Dim` types or None,
            where the :func:`Dim` types correspond to dynamic dimensions, and static dimensions
            are denoted by None. Arguments that are dicts or tuples / lists of tensors are
            recursively specified by using mappings or sequences of contained specifications.

        options: A dictionary of options to control inductor

        disable_constraint_solver: Whether the dim constraint solver must be disabled.

    Returns:
        Path to the generated shared library
    """
def aot_load(so_path: str, device: str) -> Callable:
    """
    Loads a shared library generated by aot_compile and returns a callable

    Args:
        so_path: Path to the shared library

    Returns:
        A callable
    """
