from _typeshed import Incomplete
from collections.abc import Iterable, Sequence
from torch.fx.graph_module import GraphModule as GraphModule
from torch.fx.node import Node as Node, _get_qualified_name as _get_qualified_name
from torch.fx.passes.operator_support import OperatorSupportBase as OperatorSupportBase
from torch.fx.passes.utils.fuser_utils import fuse_by_partitions as fuse_by_partitions

logger: Incomplete

class Partition:
    id: Incomplete
    nodes: Incomplete
    def __init__(self, id: int | None = None, nodes: Iterable[Node] | None = None) -> None: ...
    def __repr__(self) -> str: ...
    def add_node(self, node: Node): ...
    def remove_node(self, node: Node): ...
    def size(self): ...

class _DependencyViewer:
    downstreams: Incomplete
    def __init__(self, graph_module: GraphModule) -> None: ...
    def downstreams_of(self, node: Node) -> set[Node]: ...

class CapabilityBasedPartitioner:
    graph_module: Incomplete
    operator_support: Incomplete
    allows_single_node_partition: Incomplete
    non_compute_ops: Incomplete
    allowed_single_node_partition_ops: Incomplete
    dependency_viewer: Incomplete
    def __init__(self, graph_module: GraphModule, operator_support: OperatorSupportBase, allows_single_node_partition: bool = False, non_compute_ops: Sequence[str] | None = None, allowed_single_node_partition_ops: Sequence[str] | None = None) -> None: ...
    def _is_node_supported(self, node: Node) -> bool: ...
    def propose_partitions(self) -> list[Partition]: ...
    def fuse_partitions(self, partitions: list[Partition], prefix: str = 'fused_') -> GraphModule: ...
    def remove_bookend_non_compute_ops(self, partitions: list[Partition]): ...
    def partition_and_fuse(self, prefix: str = 'fused_') -> GraphModule: ...
