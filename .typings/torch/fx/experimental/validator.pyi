import sympy
import torch
import torch.fx
import z3
from _typeshed import Incomplete
from dataclasses import dataclass
from torch._dynamo.exc import TorchDynamoException
from torch.fx.node import Argument, Target
from typing import Any

__all__ = ['translation_validation_enabled', 'translation_validation_timeout', 'ValidationException', 'BisectValidationException']

@dataclass
class _Z3Ops:
    validator: TranslationValidator
    @staticmethod
    def to_real(x: z3.ArithRef) -> z3.ArithRef: ...
    @staticmethod
    def to_int(x: z3.ArithRef) -> z3.ArithRef: ...
    def sym_sum(self, args: z3.ArithRef) -> z3.ArithRef: ...
    def div(self, numerator: z3.ArithRef, denominator: z3.ArithRef) -> z3.ArithRef: ...
    def floor(self, number: z3.ArithRef) -> z3.ArithRef: ...
    def floordiv(self, numerator: z3.ArithRef, denominator: z3.ArithRef) -> z3.ArithRef: ...
    def ceil(self, number: z3.ArithRef) -> z3.ArithRef: ...
    def trunc(self, number: z3.ArithRef) -> z3.ArithRef: ...
    def max(self, a: z3.ArithRef, b: z3.ArithRef) -> z3.ArithRef: ...
    def min(self, a: z3.ArithRef, b: z3.ArithRef) -> z3.ArithRef: ...
    def mod(self, p: z3.ArithRef, q: z3.ArithRef) -> z3.ArithRef: ...
    def pow(self, base: z3.ArithRef, exp: z3.ArithRef) -> z3.ArithRef: ...
    def sqrt(self, number: z3.ArithRef) -> z3.ArithRef: ...
    def abs(self, number: z3.ArithRef) -> z3.ArithRef: ...
    def round_to_int(self, number: z3.ArithRef) -> z3.ArithRef: ...
    bitwise_and = ...
    bitwise_or = ...
    lshift = ...
    rshift = ...

class PopulateValidator(torch.fx.Interpreter):
    validator: Incomplete
    def __init__(self, graph: torch.fx.Graph, validator: TranslationValidator) -> None: ...
    def placeholder(self, target: Target, args: tuple[Argument, ...], kwargs: dict[str, Any]) -> Any: ...
    def call_function(self, target: Target, args: tuple[Argument, ...], kwargs: dict[str, Any]) -> Any: ...

class SympyToZ3:
    OPERATOR_HANDLES: Incomplete
    _validator: Incomplete
    _ops: Incomplete
    def __init__(self, validator: TranslationValidator) -> None: ...
    def constant(self, value: Any, dtype: torch.dtype) -> z3.ExprRef: ...
    def to_dtype(self, x: z3.ArithRef, dtype: torch.dtype) -> z3.ArithRef: ...
    def trunc_to_int(self, x: z3.ArithRef, dtype: torch.dtype) -> z3.ArithRef: ...
    def round_to_int(self, x: z3.ArithRef, dtype: torch.dtype) -> z3.ArithRef: ...
    def int_truediv(self, numerator: z3.ArithRef, denominator: z3.ArithRef) -> z3.ArithRef: ...
    def truediv(self, numerator: z3.ArithRef, denominator: z3.ArithRef) -> z3.ArithRef: ...
    def floordiv(self, numerator: z3.ArithRef, denominator: z3.ArithRef) -> z3.ArithRef: ...
    def div(self, numerator: z3.ArithRef, denominator: z3.ArithRef) -> z3.ArithRef: ...
    def pow(self, base: z3.ArithRef, exp: z3.ArithRef) -> z3.ArithRef: ...
    def pow_by_natural(self, base: z3.ArithRef, exp: z3.ArithRef) -> z3.ArithRef: ...
    def mod(self, p: z3.ArithRef, q: z3.ArithRef) -> z3.ArithRef: ...
    def ceil_to_int(self, x: z3.ArithRef, dtype: torch.dtype) -> z3.ArithRef: ...
    def floor_to_int(self, x: z3.ArithRef, dtype: torch.dtype) -> z3.ArithRef: ...
    def __getattr__(self, name: str) -> Any: ...
    def run(self, expr: sympy.Basic) -> z3.ExprRef: ...

class TranslationValidator:
    symbols: dict[sympy.Symbol, z3.ExprRef]
    _source_exprs: set[z3.BoolRef]
    _target_exprs: set[z3.BoolRef]
    _assertions: set[z3.BoolRef]
    def __init__(self) -> None: ...
    def z3var(self, symbol: sympy.Symbol) -> z3.ExprRef: ...
    def add_var(self, symbol: sympy.Symbol, type: type) -> z3.ExprRef: ...
    def _check_freesymbols(self, e: sympy.Basic) -> None: ...
    def to_z3_boolean_expr(self, e: sympy.Basic) -> z3.BoolRef: ...
    def add_source_expr(self, e: z3.BoolRef) -> None: ...
    def add_target_expr(self, e: sympy.logic.boolalg.Boolean) -> None: ...
    def add_assertion(self, e: z3.BoolRef | sympy.Basic) -> None: ...
    def validate(self) -> None: ...
    def _validate(self) -> None: ...

def translation_validation_enabled() -> bool: ...
def translation_validation_timeout() -> int: ...

class ValidationException(TorchDynamoException):
    msg: str
    details: Incomplete
    def __init__(self, model, assertions, target_exprs, failed_source_exprs) -> None: ...
    def __str__(self) -> str: ...

class BisectValidationException(TorchDynamoException):
    msg: Incomplete
    details: Incomplete
    def __init__(self, validation_exc, expr, failed_action, traced_node) -> None: ...
    def __str__(self) -> str: ...
