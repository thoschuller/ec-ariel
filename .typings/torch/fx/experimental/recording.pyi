import torch
from dataclasses import dataclass
from typing import Any, Callable

__all__ = ['ShapeEnvEvent', 'record_shapeenv_event', 'replay_shape_env_events', 'FakeTensorMeta', 'shape_env_check_state_equal', 'NotEqualError']

@dataclass
class ShapeEnvEvent:
    f: Callable
    args: list[Any] | None = ...
    kwargs: dict[str, Any] | None = ...
    tracked_fakes: list[Any] | None = ...
    name: str | None = ...
    def run(self, shape_env=None) -> Any: ...
    def __str__(self) -> str: ...
    def is_create_fx_call_function(self) -> bool: ...
    def is_evaluate_expr(self) -> bool: ...
    def is_defer_runtime_assert(self) -> bool: ...

def record_shapeenv_event(*, save_tracked_fakes: bool = False, name: str | None = None) -> Callable: ...
def replay_shape_env_events(events): ...

@dataclass
class FakeTensorMeta:
    tensor_size: tuple[int | torch.SymInt, ...]
    tensor_stride: tuple[int | torch.SymInt, ...]
    tensor_storage_offset: int | torch.SymInt
    is_nested: bool
    def size(self) -> tuple[int | torch.SymInt, ...]: ...
    def stride(self) -> tuple[int | torch.SymInt, ...]: ...
    def storage_offset(self) -> int | torch.SymInt: ...
    def dim(self) -> int: ...
    @staticmethod
    def from_fake(fake) -> FakeTensorMeta: ...

def shape_env_check_state_equal(env1, env2, non_state_variable_names, map_value): ...

class NotEqualError(Exception):
    def __init__(self, msg: str, mismatched: list[tuple[str, str, str]]) -> None: ...
