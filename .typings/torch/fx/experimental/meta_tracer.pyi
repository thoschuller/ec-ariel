import torch
import torch.fx
from _typeshed import Incomplete
from typing import Any, Callable

def embedding_override(self, input): ...
def nn_layernorm_override(self, input): ...
def torch_relu_override(x): ...
def torch_nn_relu_override(self, x): ...
def functional_relu_override(x, inplace: bool = False): ...
def torch_where_override(condition, x, y): ...
def torch_abs_override(input, *, out=None): ...

manual_meta_overrides: dict[Callable, Callable]

def gen_constructor_wrapper(target): ...

class MetaProxy(torch.fx.Proxy):
    _tensor_meta: Incomplete
    def install_tensor_meta(self, tensor_meta) -> None: ...
    def size(self, dim=None): ...
    def dim(self): ...
    @property
    def shape(self): ...
    @property
    def dtype(self): ...
    @property
    def device(self): ...
    def __getattr__(self, k): ...

class MetaAttribute(MetaProxy):
    root: Incomplete
    attr: Incomplete
    tracer: Incomplete
    _node: Incomplete
    def __init__(self, root, attr: str) -> None: ...
    @property
    def node(self): ...
    def __call__(self, *args, **kwargs): ...

class MetaDeviceAttribute(MetaAttribute): ...

def proxys_to_metas(v): ...

class MetaTracer(torch.fx.Tracer):
    allow_insert_stateless_mods: bool
    _TORCH_METHODS_TO_PATCH: Incomplete
    _disable_module_getattr: bool
    def create_proxy(self, kind, target, args, kwargs, name=None, type_expr=None, proxy_factory_fn=None): ...
    def getattr(self, attr, attr_val, parameter_proxy_cache): ...
    orig_forward: Incomplete
    def call_module(self, m, forward, args, kwargs): ...
    def _insert_module_as_submodule(self, mod: torch.nn.Module) -> str:
        """
        Helper method which tries to insert a module that was not declared as submodule.
        """
    prev_module: Incomplete
    def path_of_module(self, mod: torch.nn.Module) -> str: ...
    def proxy(self, node): ...
    meta_args: Incomplete
    patched_torch_methods: Incomplete
    orig_fns: Incomplete
    def trace(self, root, meta_args: dict[str, torch.Tensor], concrete_args=None): ...

def symbolic_trace(root: torch.nn.Module | Callable[..., Any], meta_args: dict[str, torch.Tensor] | None = None, concrete_args: dict[str, Any] | None = None) -> torch.fx.GraphModule: ...
