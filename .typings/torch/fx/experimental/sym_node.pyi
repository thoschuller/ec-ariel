import builtins
from _typeshed import Incomplete
from torch.fx.experimental.symbolic_shapes import ShapeEnv

__all__ = ['SymNode', 'method_to_operator', 'magic_methods', 'sym_sqrt', 'sym_cos', 'sym_cosh', 'sym_sin', 'sym_sinh', 'sym_tan', 'sym_tanh', 'sym_asin', 'sym_acos', 'sym_atan', 'sym_log2']

class SymNode:
    """
    This is a type erased SymInt/SymFloat which we use to do actual operations.
    End users don't touch this.  Magic methods are NOT defined on this object.
    """
    _optimized_summation: bool
    _expr: Incomplete
    shape_env: Incomplete
    pytype: Incomplete
    _hint: Incomplete
    constant: int | float | bool | None
    fx_node: Incomplete
    def __init__(self, expr, shape_env, pytype, hint: int | float | bool | None, constant=None, fx_node=None, optimized_summation: bool = False) -> None: ...
    def with_shape_env(self, shape_env: ShapeEnv) -> SymNode: ...
    def _value_eq(self, other: SymNode) -> bool: ...
    def _value_hash(self) -> int: ...
    @property
    def expr(self): ...
    @property
    def hint(self): ...
    def has_hint(self): ...
    def require_hint(self, fallback=None): ...
    def maybe_as_int(self): ...
    def maybe_as_float(self): ...
    def maybe_as_bool(self): ...
    def is_int(self): ...
    def is_float(self): ...
    def is_bool(self): ...
    def is_nested_int(self): ...
    def wrap_int(self, num): ...
    def wrap_float(self, num): ...
    def wrap_bool(self, num): ...
    def clone(self): ...
    def str(self): ...
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...
    def _graph_repr(self) -> builtins.str: ...
    def abs(self) -> SymNode: ...
    def pos(self) -> SymNode: ...
    def round(self, ndigits=None) -> SymNode: ...
    def trunc(self) -> SymNode: ...
    def add(self, other) -> SymNode: ...
    def sub(self, other) -> SymNode: ...
    def mul(self, other) -> SymNode: ...
    def mod(self, other) -> SymNode: ...
    def float_pow(self, other) -> SymNode: ...
    def pow_by_natural(self, other) -> SymNode: ...
    def and_(self, other) -> SymNode: ...
    def or_(self, other) -> SymNode: ...
    def float_truediv(self, other) -> SymNode: ...
    def int_truediv(self, other) -> SymNode: ...
    def int_floordiv(self, other) -> SymNode: ...
    def lshift(self, other) -> SymNode: ...
    def rshift(self, other) -> SymNode: ...
    def sym_not(self) -> SymNode: ...
    def eq(self, other) -> SymNode: ...
    def ne(self, other) -> SymNode: ...
    def gt(self, other) -> SymNode: ...
    def lt(self, other) -> SymNode: ...
    def le(self, other) -> SymNode: ...
    def ge(self, other) -> SymNode: ...
    def floor(self) -> SymNode: ...
    def is_integer(self) -> SymNode: ...
    def sym_float(self) -> SymNode: ...
    def sym_int(self) -> SymNode: ...
    def ceil(self) -> SymNode: ...
    def neg(self) -> SymNode: ...
    def sym_min(self, other) -> SymNode: ...
    def sym_max(self, other) -> SymNode: ...
    def sym_ite(self, then_val, else_val) -> SymNode: ...
    def is_contiguous(self, sizes, strides) -> SymNode: ...
    def is_channels_last_contiguous_2d(self, sizes, strides) -> SymNode: ...
    def is_channels_last_contiguous_3d(self, sizes, strides) -> SymNode: ...
    def is_channels_last_strides_2d(self, sizes, strides) -> SymNode: ...
    def is_channels_last_strides_3d(self, sizes, strides) -> SymNode: ...
    def is_non_overlapping_and_dense_indicator(self, sizes, strides) -> SymNode: ...
    def sym_or(self, other): ...
    def sym_and(self, other): ...
    def bitwise_and(self, other): ...
    def bitwise_or(self, other): ...
    def truediv(self, other): ...
    def floordiv(self, other) -> SymNode: ...
    def pow(self, other): ...
    def is_non_overlapping_and_dense(self, sizes, strides): ...
    def int_(self): ...
    def sym_sum(self, args) -> SymNode: ...
    def evaluate(self, size_oblivious: bool = False): ...
    def guard_int(self, file, line): ...
    def guard_float(self, file, line): ...
    def guard_bool(self, file, line): ...
    def expect_true(self, file, line): ...
    def expect_size(self, file, line): ...
    def statically_known_true(self, file, line): ...
    def guard_size_oblivious(self, file, line):
        """
        Like guard_bool, but if we encounter unbacked symbols, if those symbols
        are size-like, we will treat them as >= 2 for the purposes of the analysis.

        This CHANGES the runtime semantics, but all size-oblivious sites have been
        audited to ensure that the runtime semantics don't change in a material way.
        Acceptable runtime semantic changes are, e.g., squeeze() no longer dropping
        an unbacked one size, or a tensor reporting as non-contiguous even if it's
        contiguous if it would have been reported contiguous due to being empty.
        """
    def guard_or_false(self, file, line): ...
    def guard_or_true(self, file, line): ...
    def bool_(self): ...
    def is_symbolic(self): ...
    def nested_int(self) -> None: ...
    def is_constant(self): ...
unary_methods = unary_magic_methods | unary_nonmagic_methods
bool_magic_methods = only_bool_magic_methods | also_bool_magic_methods
magic_methods: Incomplete

def method_to_operator(method): ...

# Names in __all__ with no definition:
#   sym_acos
#   sym_asin
#   sym_atan
#   sym_cos
#   sym_cosh
#   sym_log2
#   sym_sin
#   sym_sinh
#   sym_sqrt
#   sym_tan
#   sym_tanh
