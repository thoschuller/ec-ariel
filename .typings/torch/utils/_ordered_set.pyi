from _typeshed import Incomplete
from collections.abc import Iterable, Iterator, MutableSet, Reversible, Set as AbstractSet
from typing import Any, TypeVar

__all__ = ['OrderedSet']

T = TypeVar('T')
T_co = TypeVar('T_co', covariant=True)

class OrderedSet(MutableSet[T], Reversible[T]):
    """
    Insertion ordered set, similar to OrderedDict.
    """
    __slots__: Incomplete
    _dict: Incomplete
    def __init__(self, iterable: Iterable[T] | None = None) -> None: ...
    @staticmethod
    def _from_dict(dict_inp: dict[T, None]) -> OrderedSet[T]: ...
    def __contains__(self, elem: object) -> bool: ...
    def __iter__(self) -> Iterator[T]: ...
    def __len__(self) -> int: ...
    def __reversed__(self) -> Iterator[T]: ...
    def add(self, elem: T) -> None: ...
    def discard(self, elem: T) -> None: ...
    def clear(self) -> None: ...
    @classmethod
    def _wrap_iter_in_set(cls, other: Any) -> Any:
        """
        Wrap non-Set Iterables in OrderedSets

        Some of the magic methods are more strict on input types than
        the public apis, so we need to wrap inputs in sets.
        """
    def pop(self) -> T: ...
    def copy(self) -> OrderedSet[T]: ...
    def difference(self, *others: Iterable[T]) -> OrderedSet[T]: ...
    def difference_update(self, *others: Iterable[T]) -> None: ...
    def update(self, *others: Iterable[T]) -> None: ...
    def intersection(self, *others: Iterable[T]) -> OrderedSet[T]: ...
    def intersection_update(self, *others: Iterable[T]) -> None: ...
    def issubset(self, other: Iterable[T]) -> bool: ...
    def issuperset(self, other: Iterable[T]) -> bool: ...
    def symmetric_difference(self, other: Iterable[T]) -> OrderedSet[T]: ...
    def symmetric_difference_update(self, other: Iterable[T]) -> None: ...
    def union(self, *others: Iterable[T]) -> OrderedSet[T]: ...
    def __sub__(self, other: AbstractSet[T_co]) -> OrderedSet[T]: ...
    def __ior__(self, other: Iterable[T]) -> OrderedSet[T]: ...
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __or__(self, other: AbstractSet[T_co]) -> OrderedSet[T]: ...
    def __and__(self, other: AbstractSet[T_co]) -> OrderedSet[T]: ...
    def __xor__(self, other: AbstractSet[T_co]) -> OrderedSet[T]: ...
    def __repr__(self) -> str: ...
    def __getstate__(self) -> list[T]: ...
    def __setstate__(self, state: list[T]) -> None: ...
    def __reduce__(self) -> tuple[type[OrderedSet[T]], tuple[list[T]]]: ...
