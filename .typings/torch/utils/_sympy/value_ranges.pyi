import dataclasses
import functools
import sympy
from sympy.logic.boolalg import Boolean as SympyBoolean
from typing import Callable, Generic, TypeVar, overload

__all__ = ['ValueRanges', 'bound_sympy']

_T = TypeVar('_T', sympy.Expr, SympyBoolean)

class ValueRangeError(RuntimeError): ...
BoolIn = bool | SympyBoolean
AllIn = ExprIn | BoolIn
BoolFn = Callable[[SympyBoolean], SympyBoolean]
BoolFn2 = Callable[[SympyBoolean, SympyBoolean], SympyBoolean]
AllFn = ExprFn | BoolFn
AllFn2 = ExprFn2 | BoolFn2

@dataclasses.dataclass(frozen=True)
class ValueRanges(Generic[_T]):
    ExprVR = ...
    BoolVR = ValueRanges[SympyBoolean]
    AllVR = ExprVR | BoolVR
    lower: _T
    upper: _T
    is_bool: bool
    is_int: bool
    is_float: bool
    def __repr__(self) -> str: ...
    @overload
    def __init__(self, lower: ExprIn, upper: ExprIn) -> None: ...
    @overload
    def __init__(self, lower: BoolIn, upper: BoolIn) -> None: ...
    def boolify(self) -> ValueRanges[SympyBoolean]: ...
    def __contains__(self, x: AllIn) -> bool: ...
    def issubset(self, other): ...
    def tighten(self, other) -> ValueRanges:
        """Given two ValueRanges, returns their intersection"""
    @overload
    def __and__(self, other: ValueRanges[sympy.Expr]) -> ValueRanges[sympy.Expr]: ...
    @overload
    def __and__(self, other: ValueRanges[SympyBoolean]) -> ValueRanges[SympyBoolean]: ...
    @overload
    def __or__(self, other: ValueRanges[sympy.Expr]) -> ValueRanges[sympy.Expr]: ...
    @overload
    def __or__(self, other: ValueRanges[SympyBoolean]) -> ValueRanges[SympyBoolean]: ...
    def is_singleton(self) -> bool: ...
    @staticmethod
    @functools.cache
    def unknown() -> ValueRanges[sympy.Expr]: ...
    @staticmethod
    @functools.cache
    def unknown_int() -> ValueRanges[sympy.Expr]: ...
    @staticmethod
    @functools.cache
    def unknown_bool() -> ValueRanges[SympyBoolean]: ...
    @overload
    @staticmethod
    def wrap(arg: ExprIn | ExprVR) -> ExprVR: ...
    @overload
    @staticmethod
    def wrap(arg: BoolIn | BoolVR) -> BoolVR: ...
    @staticmethod
    def increasing_map(x: ExprIn | ExprVR, fn: ExprFn) -> ExprVR:
        """Increasing: x <= y => f(x) <= f(y)."""
    @overload
    @staticmethod
    def decreasing_map(x: ExprIn | ExprVR, fn: ExprFn) -> ExprVR: ...
    @overload
    @staticmethod
    def decreasing_map(x: BoolIn | BoolVR, fn: BoolFn) -> BoolVR: ...
    @staticmethod
    def monotone_map(x: ExprIn | ExprVR, fn: ExprFn) -> ExprVR:
        """It's increasing or decreasing."""
    @staticmethod
    def convex_min_zero_map(x: ExprIn | ExprVR, fn: ExprFn) -> ExprVR:
        """Fn is convex and has a minimum at 0."""
    @overload
    @staticmethod
    def coordinatewise_increasing_map(x: ExprIn | ExprVR, y: ExprIn | ExprVR, fn: ExprFn2) -> ExprVR: ...
    @overload
    @staticmethod
    def coordinatewise_increasing_map(x: BoolIn | BoolVR, y: BoolIn | BoolVR, fn: BoolFn2) -> BoolVR: ...
    @classmethod
    def coordinatewise_monotone_map(cls, x, y, fn):
        """It's increasing or decreasing on each coordinate."""

class SymPyValueRangeAnalysis:
    """
    It gives bounds on a SymPy operator given bounds on its arguments
    See the function `bound_sympy` for a function that applies this logic to a full SymPy expression
    """
    @staticmethod
    def constant(value, dtype): ...
    @staticmethod
    def to_dtype(a, dtype, src_dtype=None): ...
    @staticmethod
    def trunc_to_int(a, dtype): ...
    @staticmethod
    def not_(a): ...
    @staticmethod
    def or_(a, b): ...
    @staticmethod
    def and_(a, b): ...
    @staticmethod
    def _bool_to_int(x): ...
    @classmethod
    def bitwise_and(cls, a, b): ...
    @classmethod
    def bitwise_or(cls, a, b): ...
    @staticmethod
    def eq(a, b): ...
    @classmethod
    def ne(cls, a, b): ...
    @classmethod
    def identity(cls, a): ...
    @classmethod
    def lt(cls, a, b): ...
    @classmethod
    def gt(cls, a, b): ...
    @classmethod
    def le(cls, a, b): ...
    @classmethod
    def ge(cls, a, b): ...
    @staticmethod
    def add(a, b): ...
    @classmethod
    def mul(cls, a, b): ...
    @staticmethod
    def int_truediv(a, b): ...
    @staticmethod
    def truediv(a, b): ...
    @staticmethod
    def floordiv(a, b): ...
    @classmethod
    def mod(cls, x, y): ...
    @classmethod
    def modular_indexing(cls, a, b, c): ...
    @classmethod
    def is_non_overlapping_and_dense_indicator(cls, *args): ...
    @classmethod
    def pow_by_natural(cls, a, b): ...
    @classmethod
    def pow(cls, a, b): ...
    @staticmethod
    def reciprocal(x):
        """Needed as it's used in pow, but it won't appear on a SymPy expression"""
    @staticmethod
    def abs(x): ...
    @staticmethod
    def exp(x): ...
    @staticmethod
    def log(x): ...
    @staticmethod
    def log2(x): ...
    @classmethod
    def minimum(cls, a, b): ...
    @classmethod
    def maximum(cls, a, b): ...
    @staticmethod
    def min_or_max(a, b, fn): ...
    @classmethod
    def floor_to_int(cls, x, dtype): ...
    @classmethod
    def ceil_to_int(cls, x, dtype): ...
    @classmethod
    def floor(cls, x): ...
    @classmethod
    def ceil(cls, x): ...
    @classmethod
    def round_decimal(cls, number, ndigits): ...
    @classmethod
    def round_to_int(cls, number, dtype): ...
    @staticmethod
    def sqrt(x): ...
    @staticmethod
    def where(a, b, c): ...
    @staticmethod
    def expr_cond_pair(a, b): ...
    @staticmethod
    def piecewise(*ranges): ...
    @staticmethod
    def cos(x): ...
    @staticmethod
    def cosh(x): ...
    @staticmethod
    def sin(x): ...
    @staticmethod
    def sinh(x): ...
    @staticmethod
    def tan(x): ...
    @staticmethod
    def tanh(x): ...
    @staticmethod
    def asin(x): ...
    @staticmethod
    def acos(x): ...
    @staticmethod
    def atan(x): ...
    @staticmethod
    def trunc(x): ...

def bound_sympy(expr: sympy.Expr, ranges: dict[sympy.Symbol, ValueRanges] | None = None) -> ValueRanges: ...
