import types
from _typeshed import Incomplete
from torch.utils.data.datapipes.datapipe import DFIterDataPipe, IterDataPipe
from typing import Any

__all__ = ['Capture', 'CaptureA', 'CaptureAdd', 'CaptureCall', 'CaptureControl', 'CaptureDataFrame', 'CaptureDataFrameWithDataPipeOps', 'CaptureF', 'CaptureGetAttr', 'CaptureGetItem', 'CaptureInitial', 'CaptureLikeMock', 'CaptureMul', 'CaptureSetItem', 'CaptureSub', 'CaptureVariable', 'CaptureVariableAssign', 'DataFrameTracer', 'DataFrameTracedOps', 'disable_capture', 'get_val']

def disable_capture() -> None: ...

class CaptureControl:
    disabled: bool

class DataFrameTracedOps(DFIterDataPipe):
    source_datapipe: Incomplete
    output_var: Incomplete
    def __init__(self, source_datapipe, output_var) -> None: ...
    def __iter__(self): ...

class Capture:
    ctx: Incomplete
    def __init__(self, schema_df=None) -> None: ...
    def __str__(self) -> str: ...
    def _ops_str(self): ...
    def __getstate__(self): ...
    def __setstate__(self, state) -> None: ...
    def __getattr__(self, attrname): ...
    def __getitem__(self, key): ...
    def __setitem__(self, key, value) -> None: ...
    def __add__(self, add_val): ...
    def __sub__(self, add_val): ...
    def __mul__(self, add_val): ...
    def _is_context_empty(self): ...
    def apply_ops_2(self, dataframe) -> None: ...
    @property
    def columns(self): ...
    def __call__(self, *args, **kwargs): ...

class CaptureF(Capture):
    ctx: Incomplete
    kwargs: Incomplete
    def __init__(self, ctx=None, **kwargs) -> None: ...

class CaptureA(CaptureF):
    def __str__(self) -> str: ...
    def execute(self): ...

class CaptureLikeMock:
    get_target: Incomplete
    attribute: Incomplete
    name: Incomplete
    def __init__(self, name) -> None: ...
    save: Incomplete
    def __enter__(self) -> None: ...
    def __exit__(self, *exc_info) -> None: ...

class CaptureCall(Capture):
    ctx: Incomplete
    kwargs: Incomplete
    callable: Incomplete
    def __init__(self, callable, ctx=None, **kwargs) -> None: ...
    def __str__(self) -> str: ...
    def execute(self): ...

class CaptureVariableAssign(CaptureF):
    def __str__(self) -> str: ...
    def execute(self) -> None: ...

class CaptureVariable(Capture):
    names_idx: int
    ctx: Incomplete
    value: Incomplete
    name: Incomplete
    def __init__(self, value, ctx) -> None: ...
    def __str__(self) -> str: ...
    def execute(self): ...
    def apply_ops(self, dataframe): ...

class CaptureGetItem(Capture):
    ctx: Incomplete
    left: Incomplete
    key: Incomplete
    def __init__(self, left, key, ctx) -> None: ...
    def __str__(self) -> str: ...
    def execute(self): ...

class CaptureSetItem(Capture):
    ctx: Incomplete
    left: Incomplete
    key: Incomplete
    value: Incomplete
    def __init__(self, left, key, value, ctx) -> None: ...
    def __str__(self) -> str: ...
    def execute(self) -> None: ...

class CaptureAdd(Capture):
    ctx: Incomplete
    left: Incomplete
    right: Incomplete
    def __init__(self, left, right, ctx) -> None: ...
    def __str__(self) -> str: ...
    def execute(self): ...

class CaptureMul(Capture):
    ctx: Incomplete
    left: Incomplete
    right: Incomplete
    def __init__(self, left, right, ctx) -> None: ...
    def __str__(self) -> str: ...
    def execute(self): ...

class CaptureSub(Capture):
    ctx: Incomplete
    left: Incomplete
    right: Incomplete
    def __init__(self, left, right, ctx) -> None: ...
    def __str__(self) -> str: ...
    def execute(self): ...

class CaptureGetAttr(Capture):
    ctx: Incomplete
    src: Incomplete
    name: Incomplete
    def __init__(self, src, name, ctx) -> None: ...
    def __str__(self) -> str: ...
    def execute(self): ...

def get_val(capture): ...

class CaptureInitial(CaptureVariable):
    name: Incomplete
    def __init__(self, schema_df=None) -> None: ...

class CaptureDataFrame(CaptureInitial): ...

class CaptureDataFrameWithDataPipeOps(CaptureDataFrame):
    def as_datapipe(self): ...
    def raw_iterator(self): ...
    def __iter__(self): ...
    def batch(self, batch_size: int = 10, drop_last: bool = False, wrapper_class=...): ...
    def groupby(self, group_key_fn, *, buffer_size: int = 10000, group_size=None, guaranteed_group_size=None, drop_remaining: bool = False): ...
    def shuffle(self, *args, **kwargs): ...
    def filter(self, *args, **kwargs): ...
    def collate(self, *args, **kwargs) -> None: ...
    def __getattr__(self, attrname): ...

class DataFrameTracer(CaptureDataFrameWithDataPipeOps, IterDataPipe):
    source_datapipe: Any | None
    def set_shuffle_settings(self, *args, **kwargs) -> None: ...
    def is_shardable(self): ...
    def __init__(self, source_datapipe, schema_df=None) -> None: ...
