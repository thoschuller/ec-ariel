import types
from _typeshed import Incomplete
from torch._utils import IMPORT_MAPPING as IMPORT_MAPPING, NAME_MAPPING as NAME_MAPPING, _sparse_tensors_to_validate as _sparse_tensors_to_validate
from typing import Any, Callable

_blocklisted_modules: Incomplete
_marked_safe_globals_set: set[Callable | tuple[Callable, str]]

def _add_safe_globals(safe_globals: list[Callable | tuple[Callable, str]]): ...
def _get_safe_globals() -> list[Callable | tuple[Callable, str]]: ...
def _clear_safe_globals() -> None: ...
def _remove_safe_globals(globals_to_remove: list[Callable | tuple[Callable, str]]): ...

class _safe_globals:
    safe_globals: Incomplete
    def __init__(self, safe_globals: list[Callable | tuple[Callable, str]]) -> None: ...
    def __enter__(self) -> None: ...
    def __exit__(self, type: type[BaseException] | None, value: BaseException | None, tb: types.TracebackType | None) -> None: ...

def _get_user_allowed_globals(): ...
def _tensor_rebuild_functions(): ...
def _get_allowed_globals(): ...
def _read_global_instruction(readline: Callable) -> tuple[str, str]: ...
def get_globals_in_pkl(file) -> set[str]: ...

class Unpickler:
    encoding: Incomplete
    readline: Incomplete
    read: Incomplete
    memo: dict[int, Any]
    proto: int
    def __init__(self, file, *, encoding: str = 'bytes') -> None: ...
    metastack: Incomplete
    stack: list[Any]
    append: Incomplete
    def load(self):
        """Read a pickled object representation from the open file.

        Return the reconstituted object hierarchy specified in the file.
        """
    def pop_mark(self): ...
    def persistent_load(self, pid) -> None: ...

def load(file, *, encoding: str = 'ASCII'): ...
