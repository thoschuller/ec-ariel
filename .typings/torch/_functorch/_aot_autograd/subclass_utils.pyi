import torch
from .schemas import MemoryFormatMeta as MemoryFormatMeta, MutationType as MutationType, PlainTensorMeta as PlainTensorMeta, SubclassCreationMeta as SubclassCreationMeta, ViewAndMutationMeta as ViewAndMutationMeta
from .utils import strict_zip as strict_zip
from collections.abc import Iterable
from torch import SymInt as SymInt, Tensor as Tensor
from torch._subclasses.fake_tensor import get_plain_tensors as get_plain_tensors
from torch.types import IntLikeType as IntLikeType
from torch.utils._python_dispatch import is_traceable_wrapper_subclass as is_traceable_wrapper_subclass
from typing import Any, Callable, TypeVar

zip = strict_zip
T = TypeVar('T', bound=torch.Tensor)

def requires_subclass_dispatch(args, fw_metadata: ViewAndMutationMeta) -> bool: ...
def maybe_suggest_memory_format(t, with_memory_format: bool) -> MemoryFormatMeta | None: ...
def get_subclass_typing_container(tensor_subclass: torch.Tensor) -> dict[type[torch.Tensor], list[type[torch.Tensor]]]:
    """
    Given a subclass, returns a recursive dictionary mapping each
    inner tensors to its' subclass types.
    """
def create_subclass_metadata(a: Any, start_idx: int, count_symints: bool, with_memory_format: bool = False): ...
def create_subclass_meta(curr_args: list[Any] | tuple[Any, ...], *, count_symints: bool = True, with_memory_format: bool = False) -> list[PlainTensorMeta | SubclassCreationMeta]: ...
def filter_symints(lst: Iterable[IntLikeType]): ...
def compute_symint_placeholders(lst: Iterable[None | int | SymInt]) -> list[bool]: ...
def unwrap_tensor_subclasses(wrapped_args: list[Tensor | int], *, append_symints: bool): ...
def runtime_unwrap_tensor_subclasses(wrapped_args: list[Tensor | int], *, append_symints: bool, subclass_metas: list[PlainTensorMeta | SubclassCreationMeta] | None = None): ...
def unwrap_tensor_subclasses_with_indices_to_original(wrapped_args): ...
def remap_unwrapped_subclass_arg_indices(wrapped_args, static_input_indices): ...
def wrap_tensor_subclasses(unwrapped_args: tuple[Any, ...] | list[Any], *, subclass_metas: list[PlainTensorMeta | SubclassCreationMeta], num_fw_outs_saved_for_bw: int | None = None, included_subclass_symints: bool = False, is_runtime: bool = False, make_subclass_override: Callable | None = None) -> tuple[Any, ...]: ...
def wrap_tensor_subclasses_maybe_joint(unwrapped_args, *, is_joint_structure: bool, meta: ViewAndMutationMeta) -> tuple[Any, ...] | list[Any]: ...
def compute_inner_mutated_inp_indices_from_subclass_meta(fw_metadata: ViewAndMutationMeta, inner_metadata: ViewAndMutationMeta) -> list[int]: ...
