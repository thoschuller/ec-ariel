import contextlib
from _typeshed import Incomplete
from collections.abc import Generator
from torch import Tensor as Tensor
from torch._C._functorch import _add_batch_dim as _add_batch_dim, _remove_batch_dim as _remove_batch_dim, _vmap_decrement_nesting as _vmap_decrement_nesting, _vmap_increment_nesting as _vmap_increment_nesting, is_batchedtensor as is_batchedtensor
from torch.utils._pytree import TreeSpec as TreeSpec, _broadcast_to_and_flatten as _broadcast_to_and_flatten, tree_flatten as tree_flatten, tree_map_ as tree_map_, tree_unflatten as tree_unflatten
from typing import Any, Callable

in_dims_t = int | tuple
out_dims_t = int | tuple[int, ...]

def doesnt_support_saved_tensors_hooks(f): ...
def _validate_and_get_batch_size(flat_in_dims: list[int | None], flat_args: list) -> int: ...
def _num_outputs(batched_outputs: Tensor | tuple[Tensor, ...]) -> int: ...
def _as_tuple(value: Any, num_elements: int, error_message_lambda: Callable[[], str]) -> tuple: ...
def _process_batched_inputs(in_dims: in_dims_t, args: tuple, func: Callable) -> tuple[int, list[Any], list[Any], TreeSpec]: ...
def _create_batched_inputs(flat_in_dims: list[Any], flat_args: list[Any], vmap_level: int, args_spec) -> tuple: ...
def _maybe_remove_batch_dim(name, batched_output, vmap_level, batch_size, out_dim): ...
def _unwrap_batched(batched_outputs: Tensor | tuple[Tensor, ...], out_dims: out_dims_t, vmap_level: int, batch_size: int, func: Callable) -> tuple: ...
def _check_int_or_none(x, func, out_dims) -> None: ...
def _check_out_dims_is_int_or_int_pytree(out_dims: out_dims_t, func: Callable) -> None: ...
def _get_name(func: Callable): ...

DECOMPOSITIONS_LOADED: bool
DECOMPOSITIONS_LOCK: Incomplete
VMAP_DECOMPOSITIONS_LIB: Incomplete

def lazy_load_decompositions() -> None: ...
def vmap_impl(func, in_dims, out_dims, randomness, chunk_size, *args, **kwargs): ...
def get_chunk_sizes(total_elems, chunk_size): ...
def _get_chunked_inputs(flat_args, flat_in_dims, batch_size, chunk_size): ...
def _flatten_chunks_output(chunks_output_): ...
def _concat_chunked_outputs(out_dims, arg_spec, flat_output_chunks): ...
def _chunked_vmap(func, flat_in_dims, chunks_flat_args, args_spec, out_dims, randomness, **kwargs): ...
def _check_randomness_arg(randomness) -> None: ...
@contextlib.contextmanager
def vmap_increment_nesting(batch_size, randomness) -> Generator[Incomplete]: ...
def _flat_vmap(func, batch_size, flat_in_dims, flat_args, args_spec, out_dims, randomness, **kwargs): ...
def restore_vmap(func, in_dims, batch_size, randomness): ...
def wrap_batched(args, bdims, level): ...
def unwrap_batched(args, level): ...
