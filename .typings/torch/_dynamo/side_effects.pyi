import contextlib
from . import graph_break_hints as graph_break_hints, utils as utils, variables as variables
from .bytecode_transformation import bytecode_from_template as bytecode_from_template, create_call_function as create_call_function, create_call_method as create_call_method, create_instruction as create_instruction
from .codegen import PyCodegen as PyCodegen
from .exc import SideEffectsError as SideEffectsError, unimplemented_v2 as unimplemented_v2
from .source import GlobalSource as GlobalSource, LocalCellSource as LocalCellSource, LocalSource as LocalSource, Source as Source
from .utils import is_frozen_dataclass as is_frozen_dataclass, nn_module_new as nn_module_new, object_new as object_new
from .variables.base import AttributeMutation as AttributeMutation, AttributeMutationExisting as AttributeMutationExisting, AttributeMutationNew as AttributeMutationNew, ValueMutationExisting as ValueMutationExisting, ValueMutationNew as ValueMutationNew, VariableTracker as VariableTracker, is_side_effect_safe as is_side_effect_safe
from .variables.user_defined import FrozenDataClassVariable as FrozenDataClassVariable
from _typeshed import Incomplete
from torch._dynamo.symbolic_convert import InstructionTranslator as InstructionTranslator
from types import CellType
from typing import Any

def _manual_dict_setitem(dict_from, dict_to, mro_index) -> None: ...
def _manual_list_update(list_from, list_to) -> None: ...

class SideEffects:
    """
    Maintain records of mutations and provide methods to apply them during code generation.

    Handles tracking and applying side effects during PyTorch Dynamo compilation,
    maintaining Python semantics by managing mutations, attribute modifications,
    and other side effects that occur during program execution.

    Key responsibilities:
    - Tracks mutations to Python objects, lists, and dictionaries that need to be
    applied after an FX graph is run.
    - Manages attribute modifications and deletions
    - Handles tensor hooks and backward pass state
    - Tracks cell variable mutations and global variable changes
    - Ensures correct ordering and application of side effects after graph execution

    This ensures that optimized code behaves identically to the original Python code with
    respect to object mutations and other side effects.
    """
    id_to_variable: dict[int, VariableTracker]
    store_attr_mutations: dict[VariableTracker, dict[str, VariableTracker]]
    keepalive: list[Any]
    output_graph_weakref: Incomplete
    save_for_backward: Incomplete
    tensor_hooks: Incomplete
    _has_existing_dict_mutation: bool
    ca_final_callbacks_var: Incomplete
    def __init__(self, output_graph, id_to_variable=None, store_attr_mutations=None, keepalive=None, save_for_backward=None, tensor_hooks=None) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def diff(self, other: SideEffects) -> str | None: ...
    def clone(self):
        """Create a shallow copy"""
    def __contains__(self, item) -> bool: ...
    def __getitem__(self, item): ...
    def should_allow_side_effects_under_checkpoint(self): ...
    def should_allow_externally_visible_side_effects_in_subtracer(self): ...
    def is_reconstructing_generator(self): ...
    def check_allowed_side_effect(self, item): ...
    def store_attr(self, item: VariableTracker, name: str, value: VariableTracker): ...
    def load_attr(self, item, name, deleted_ok: bool = False, check: bool = False): ...
    def store_cell(self, cellvar, value) -> None: ...
    def load_cell(self, cellvar): ...
    def load_global(self, gvar: VariableTracker, name: str): ...
    def store_global(self, gvar: VariableTracker, name: str, value: VariableTracker): ...
    @staticmethod
    def cls_supports_mutation_side_effects(cls): ...
    def is_attribute_mutation(self, item): ...
    def has_pending_mutation(self, item): ...
    def has_pending_mutation_of_attr(self, item, name): ...
    def is_modified(self, item): ...
    def _track_obj(self, item: Any, variable: VariableTracker, mutation_type_cls=...):
        """Start tracking an existing or new variable for mutation"""
    track_mutable = _track_obj
    def track_object_existing(self, item: Any, variable: VariableTracker): ...
    def track_object_new(self, cls_source: Source, user_cls: Any, variable_cls: Any, options): ...
    def get_variable_cls(self, user_cls): ...
    def get_example_value(self, base_cls_vt, cls_vt, init_args): ...
    def track_new_user_defined_object(self, base_cls_vt, cls_vt, init_args):
        """
        Creates a UserDefinedObjectVariable (or its subclass) variable tracker
        and mark it for attribute mutation tracking.

        Also records the variable trackers to call __new__ method on
        reconstruction. Roughly, the reconstruction looks like this
            base_cls_vt.__new__(user_cls, *init_args)
        """
    def track_cell_new(self): ...
    def track_cell_existing(self, source: Source | None, cell: CellType, contents: VariableTracker): ...
    def track_global_existing(self, source: Source, item: Any): ...
    def track_save_for_backward(self, ctx, args) -> None: ...
    def track_tensor_variables_from_runahead_side_effects(self, other) -> None: ...
    def prune_dead_object_new(self, tx): ...
    def mutation(self, var) -> None: ...
    def has_existing_dict_mutation(self): ...
    def _get_modified_vars(self): ...
    def codegen_save_tempvars(self, cg: PyCodegen): ...
    def register_hook(self, tensor, hook, handle, name) -> None: ...
    def remove_hook(self, idx) -> None: ...
    def codegen_hooks(self, cg) -> None: ...
    def get_ca_final_callbacks_var(self): ...
    def codegen_update_mutated(self, cg: PyCodegen): ...
    def is_empty(self): ...
    def clear(self) -> None: ...

@contextlib.contextmanager
def allow_side_effects_under_checkpoint(tx: InstructionTranslator): ...
@contextlib.contextmanager
def allow_externally_visible_side_effects_in_subtracer(tx: InstructionTranslator): ...
@contextlib.contextmanager
def disallow_side_effects_in_generator(tx: InstructionTranslator): ...
