import types
import typing
from . import config as config
from .symbolic_convert import InstructionTranslatorBase as InstructionTranslatorBase
from .types import DynamoFrameType as DynamoFrameType
from .utils import counters as counters
from _typeshed import Incomplete
from enum import Enum
from torch._guards import CompileId as CompileId
from traceback import StackSummary
from typing import Any, NoReturn

def exportdb_error_message(case_name: str) -> str: ...

log: Incomplete
graph_breaks_log: Incomplete

class TorchDynamoException(RuntimeError): ...
class InternalTorchDynamoError(TorchDynamoException): ...

class RestartAnalysis(TorchDynamoException):
    restart_reason: str | None
    def __init__(self, *args: Any, restart_reason: str | None = None) -> None: ...

class SpeculationRestartAnalysis(RestartAnalysis): ...
class UnspecializeRestartAnalysis(RestartAnalysis): ...
class CompileCollectiveRestartAnalysis(RestartAnalysis): ...
class TensorifyScalarRestartAnalysis(RestartAnalysis): ...
class SkipFrame(TorchDynamoException): ...
class TorchRuntimeError(TorchDynamoException): ...

class InvalidBackend(TorchDynamoException):
    def __init__(self, name: str) -> None: ...

class ResetRequired(TorchDynamoException):
    def __init__(self) -> None: ...

class ShortenTraceback(TorchDynamoException):
    first_useful_frame: Incomplete
    def __init__(self, *args: Any, first_useful_frame: types.FrameType | None, **kwargs: Any) -> None: ...
    def remove_dynamo_frames(self) -> typing.Self: ...

class BackendCompilerFailed(ShortenTraceback):
    backend_name: Incomplete
    inner_exception: Incomplete
    def __init__(self, backend_fn: Any, inner_exception: Exception, first_useful_frame: types.FrameType | None) -> None: ...

class Unsupported(TorchDynamoException):
    real_stack: Incomplete
    msg: Incomplete
    category: str | None
    case_name: str | None
    def __init__(self, msg: str, *, case_name: str | None = None) -> None: ...
    def remove_from_stats(self) -> None: ...
    def add_to_stats(self, category: str = 'unimplemented') -> None: ...

class UnknownPropertiesDuringBackwardTrace(Unsupported): ...
class RecompileError(TorchDynamoException): ...

class ArgsMismatchError(Unsupported):
    def __init__(self, msg: str) -> None: ...

class AttributeMutationError(Unsupported):
    def __init__(self, msg: str) -> None: ...

class InfiniteGeneratorError(Unsupported):
    def __init__(self, msg: str) -> None: ...

class SideEffectsError(Unsupported):
    def __init__(self, msg: str) -> None: ...

class CondOpArgsMismatchError(ArgsMismatchError):
    """
    Internal error from cond() due to arguments mismatch.
    """
    def __init__(self, msg: str) -> None: ...

class UserErrorType(Enum):
    DYNAMIC_CONTROL_FLOW = ...
    ANTI_PATTERN = ...
    STANDARD_LIBRARY = ...
    CONSTRAINT_VIOLATION = ...
    DYNAMIC_DIM = ...
    INVALID_INPUT = ...
    INVALID_OUTPUT = ...
    UNSUPPORTED_ALIASED_MUTATED_DYNAMIC_INPUTS = ...

class UserError(Unsupported):
    error_type: Incomplete
    message: Incomplete
    def __init__(self, error_type: UserErrorType, msg: str, case_name: str | None = None) -> None:
        """
        Type of errors that would be valid in Eager, but not supported in TorchDynamo.
        The error message should tell user about next actions.

        error_type: Type of user error
        msg: Actionable error message
        case_name: (Optional) Unique name (snake case) for the usage example in exportdb.
        """

class SkipCodeRecursiveException(TorchDynamoException): ...
class RecompileLimitExceeded(Unsupported): ...
class UnsafeScriptObjectError(TorchDynamoException): ...
class UncapturedHigherOrderOpError(TorchDynamoException): ...
class IncorrectUsage(Exception): ...
class FailOnRecompileLimitHit(Exception): ...
class PackageError(TorchDynamoException): ...
class ObservedException(TorchDynamoException): ...

class ObservedUserStopIteration(ObservedException):
    value: Any | None
    def __init__(self, *args: Any, **kwargs: Any) -> None: ...

class ObservedLookupError(ObservedException): ...
class ObservedIndexError(ObservedLookupError): ...
class ObservedKeyError(ObservedLookupError): ...
class ObservedGeneratorExit(ObservedException): ...
class ObservedAttributeError(ObservedException): ...
class ObservedRuntimeError(ObservedException): ...
class ObservedNotImplementedError(ObservedException): ...
class ObservedTypeError(ObservedException): ...

observed_exception_map: Incomplete

def get_dynamo_observed_exception(exc_type: type[Exception]) -> type[ObservedException]: ...
def raise_observed_exception(exc_type: type[Exception], tx: InstructionTranslatorBase, *, args: list[Any] | None = None, kwargs: dict[str, Any] | None = None) -> NoReturn: ...
def handle_observed_exception(tx: Any) -> None: ...

exceptions_allowed_to_be_fallback: Incomplete

def unimplemented_with_warning(e: Exception, code: types.CodeType, msg: str) -> NoReturn: ...

_NOTHING: Incomplete

def unimplemented(msg: str, *, from_exc: Any = ..., case_name: str | None = None) -> NoReturn: ...
def unimplemented_v2_with_warning(e: Exception, code: types.CodeType, gb_type: str, context: str, explanation: str, hints: list[str]) -> NoReturn: ...
def format_graph_break_message(gb_type: str, context: str, explanation: str, hints: list[str]) -> str: ...
def unimplemented_v2(gb_type: str, context: str, explanation: str, hints: list[str], *, from_exc: Any = ..., log_warning: bool = False) -> NoReturn:
    """
    Called within dynamo to cause a graph break.
    Args:
        gb_type: Context-free graph break type. It should be a short string without any
                 information specific to the tracing context (i.e. no dynamically-generated strings)
        context: Developer context for the graph break. It can contain tracing context/dynamic strings.
        explanation: User-facing context-dependent explanation for the graph break. Can be dynamic.
        hints: List of user-facing hints for the graph break.
    """
def warning(msg: str) -> None: ...

class KeyErrorMsg:
    value: Incomplete
    def __init__(self, value: Any) -> None: ...
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...

def augment_exc_message(exc: Exception, msg: str = '\n', export: bool = False) -> None: ...
def get_exc_message(e: Exception, compile_id: CompileId) -> tuple[str | None, int | None]: ...
def get_stack_above_dynamo() -> StackSummary: ...
def get_real_stack(exc: Exception, frame: DynamoFrameType | None = None) -> StackSummary | None: ...
def filter_stack(stack: StackSummary) -> StackSummary: ...
def remove_resume_prefix(name: str) -> str | None: ...
def collapse_resume_frames(stack: StackSummary) -> StackSummary:
    '''
    When we graph break, we create a resume function and make a regular Python call
    to it, which gets intercepted by Dynamo. This behavior is normally shown in the
    traceback, which can be confusing to a user. So we can filter out resume frames
    for better traceback clarity.

    Example:
    File "..." line 3, in f
        <line 3>
    File "..." line 5, in torch_dynamo_resume_in_f_at_80
        <line 5>
    File "..." line 10, in torch_dynamo_resume_in_f_at_120
        <line 10>

    becomes
    File "..." line 10, in f
        <line 10>
    '''
def format_error_msg_verbose(exc: Exception, code: types.CodeType, record_filename: str | None = None, frame: DynamoFrameType | None = None) -> str: ...
def format_error_msg(exc: Exception, code: types.CodeType, record_filename: str | None = None, frame: DynamoFrameType | None = None) -> str: ...
