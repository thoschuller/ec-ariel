import torch.fx
from .. import graph_break_hints as graph_break_hints, polyfills as polyfills, variables as variables
from ..bytecode_transformation import create_call_function as create_call_function, create_instruction as create_instruction
from ..exc import raise_observed_exception as raise_observed_exception, unimplemented_v2 as unimplemented_v2
from ..source import AttrSource as AttrSource
from ..utils import Lit as Lit, cmp_name_to_op_mapping as cmp_name_to_op_mapping, cmp_name_to_op_str_mapping as cmp_name_to_op_str_mapping, get_fake_value as get_fake_value, guard_if_dyn as guard_if_dyn, iter_contains as iter_contains, namedtuple_fields as namedtuple_fields, odict_values as odict_values, set_example_value as set_example_value
from .base import ValueMutationNew as ValueMutationNew, VariableTracker as VariableTracker
from .constant import ConstantVariable as ConstantVariable
from .functions import UserFunctionVariable as UserFunctionVariable, UserMethodVariable as UserMethodVariable
from .iter import IteratorVariable as IteratorVariable
from _typeshed import Incomplete
from torch._dynamo.codegen import PyCodegen as PyCodegen
from torch._dynamo.symbolic_convert import InstructionTranslator as InstructionTranslator

class BaseListVariable(VariableTracker):
    @staticmethod
    def cls_for_instance(obj): ...
    @staticmethod
    def cls_for(obj): ...
    items: list[VariableTracker]
    def __init__(self, items: list[VariableTracker], **kwargs) -> None: ...
    def _as_proxy(self): ...
    def modified(self, items, **kwargs): ...
    @property
    def value(self): ...
    def debug_repr_helper(self, prefix, suffix): ...
    def as_python_constant(self): ...
    def as_proxy(self): ...
    def getitem_const(self, tx: InstructionTranslator, arg: VariableTracker): ...
    def unpack_var_sequence(self, tx): ...
    def call_method(self, tx, name, args: list['VariableTracker'], kwargs: dict[str, 'VariableTracker']) -> VariableTracker: ...

class RangeVariable(BaseListVariable):
    def __init__(self, items, **kwargs) -> None: ...
    def debug_repr(self): ...
    def python_type(self): ...
    def start(self): ...
    def stop(self): ...
    def step(self): ...
    def range_length(self): ...
    def _get_slice_indices(self, length, slice): ...
    def apply_index(self, index): ...
    def apply_slice(self, slice): ...
    def as_python_constant(self): ...
    def getitem_const(self, tx: InstructionTranslator, arg: VariableTracker): ...
    def as_proxy(self): ...
    def unpack_var_sequence(self, tx=None): ...
    def reconstruct(self, codegen: PyCodegen) -> None: ...
    def var_getattr(self, tx: InstructionTranslator, name): ...

class CommonListMethodsVariable(BaseListVariable):
    """
    Implement methods common to List and other List-like things
    """
    def call_method(self, tx, name, args: list['VariableTracker'], kwargs: dict[str, 'VariableTracker']) -> VariableTracker: ...

class ListVariable(CommonListMethodsVariable):
    def python_type(self): ...
    def __repr__(self) -> str: ...
    def debug_repr(self): ...
    def reconstruct(self, codegen: PyCodegen) -> None: ...
    def call_method(self, tx, name, args: list['VariableTracker'], kwargs: dict[str, 'VariableTracker']) -> VariableTracker: ...
    def var_getattr(self, tx, name): ...
    def call_obj_hasattr(self, tx: InstructionTranslator, name: str) -> VariableTracker: ...

class DequeVariable(CommonListMethodsVariable):
    maxlen: Incomplete
    def __init__(self, items, maxlen=None, **kwargs) -> None: ...
    def python_type(self): ...
    def debug_repr(self): ...
    def as_python_constant(self): ...
    def reconstruct(self, codegen: PyCodegen) -> None: ...
    def var_getattr(self, tx: InstructionTranslator, name): ...
    def call_method(self, tx, name, args: list['VariableTracker'], kwargs: dict[str, 'VariableTracker']) -> VariableTracker: ...

class TupleVariable(BaseListVariable):
    def python_type(self): ...
    def __repr__(self) -> str: ...
    def debug_repr(self): ...
    def reconstruct(self, codegen: PyCodegen) -> None: ...
    def call_method(self, tx, name, args: list['VariableTracker'], kwargs: dict[str, 'VariableTracker']) -> VariableTracker: ...
    def var_getattr(self, tx, name): ...
    def call_obj_hasattr(self, tx: InstructionTranslator, name: str) -> VariableTracker: ...

class SizeVariable(TupleVariable):
    """torch.Size(...)"""
    _nonvar_fields: Incomplete
    proxy: Incomplete
    def __init__(self, items: list[VariableTracker], proxy: torch.fx.Proxy | None = None, **kwargs) -> None: ...
    def debug_repr(self): ...
    def python_type(self): ...
    def as_proxy(self): ...
    def reconstruct(self, codegen: PyCodegen) -> None: ...
    def unpack_var_sequence(self, tx): ...
    def numel(self, tx): ...
    def call_method(self, tx, name, args: list['VariableTracker'], kwargs: dict[str, 'VariableTracker']) -> VariableTracker: ...
    def get_item_dyn(self, tx: InstructionTranslator, arg: VariableTracker): ...
    def call_obj_hasattr(self, tx: InstructionTranslator, name: str) -> VariableTracker: ...

class NamedTupleVariable(TupleVariable):
    _nonvar_fields: Incomplete
    tuple_cls: Incomplete
    dynamic_attributes: Incomplete
    def __init__(self, items, tuple_cls, **kwargs) -> None: ...
    def is_namedtuple(self): ...
    def is_structseq(self): ...
    def fields(self): ...
    def debug_repr(self): ...
    def python_type(self): ...
    def as_python_constant(self): ...
    def as_proxy(self): ...
    def reconstruct(self, codegen: PyCodegen) -> None: ...
    def call_method(self, tx, name, args: list[VariableTracker], kwargs: dict[str, VariableTracker]) -> VariableTracker: ...
    def var_getattr(self, tx: InstructionTranslator, name): ...
    def call_obj_hasattr(self, tx: InstructionTranslator, name: str) -> VariableTracker: ...

class SliceVariable(VariableTracker):
    items: Incomplete
    def __init__(self, items, **kwargs) -> None: ...
    def debug_repr(self): ...
    def as_proxy(self): ...
    def python_type(self): ...
    def as_python_constant(self): ...
    def reconstruct(self, codegen: PyCodegen) -> None: ...
    def var_getattr(self, tx: InstructionTranslator, name): ...

class ListIteratorVariable(IteratorVariable):
    _nonvar_fields: Incomplete
    items: Incomplete
    index: Incomplete
    def __init__(self, items, index: int = 0, **kwargs) -> None: ...
    def __repr__(self) -> str: ...
    def next_variable(self, tx): ...
    def call_method(self, tx, name, args: list[VariableTracker], kwargs: dict[str, VariableTracker]): ...
    def python_type(self): ...
    def as_python_constant(self): ...
    def unpack_var_sequence(self, tx): ...
    def force_unpack_var_sequence(self, tx) -> list[VariableTracker]: ...
    def reconstruct(self, codegen: PyCodegen) -> None: ...

class TupleIteratorVariable(ListIteratorVariable): ...
