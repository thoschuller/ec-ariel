from .. import graph_break_hints as graph_break_hints, polyfills as polyfills, variables as variables
from ..bytecode_transformation import create_call_function as create_call_function, create_instruction as create_instruction
from ..exc import raise_observed_exception as raise_observed_exception, unimplemented_v2 as unimplemented_v2
from ..guards import GuardBuilder as GuardBuilder, install_guard as install_guard
from ..source import is_from_local_source as is_from_local_source
from ..utils import cmp_name_to_op_mapping as cmp_name_to_op_mapping, dict_items as dict_items, dict_keys as dict_keys, dict_values as dict_values, istype as istype, specialize_symnode as specialize_symnode
from .base import ValueMutationNew as ValueMutationNew, VariableTracker as VariableTracker
from .constant import ConstantVariable as ConstantVariable
from _typeshed import Incomplete
from torch._dynamo.codegen import PyCodegen as PyCodegen
from torch._dynamo.symbolic_convert import InstructionTranslator as InstructionTranslator
from torch._subclasses.fake_tensor import is_fake as is_fake

def raise_args_mismatch(tx, name) -> None: ...
def was_instancecheck_override(obj): ...
def raise_unhashable(arg, tx=None) -> None: ...
def is_hashable(x): ...

class ConstDictVariable(VariableTracker):
    _nonvar_fields: Incomplete
    class _HashableTracker:
        """
        Auxiliary opaque internal class that wraps a VariableTracker and makes it hashable
        This should not be seen or touched by anything outside of ConstDictVariable and its children
        Note that it's also fine to put VTs into dictionaries and sets, but doing so does not take into account aliasing
        """
        vt: Incomplete
        def __init__(self, vt) -> None: ...
        @property
        def underlying_value(self): ...
        def __hash__(self): ...
        @staticmethod
        def _eq_impl(a, b): ...
        def __eq__(self, other: ConstDictVariable._HashableTracker) -> bool: ...
    items: Incomplete
    should_reconstruct_all: Incomplete
    original_items: Incomplete
    user_cls: Incomplete
    def __init__(self, items: dict[VariableTracker, VariableTracker], user_cls=..., **kwargs) -> None: ...
    def as_proxy(self): ...
    def debug_repr(self): ...
    def as_python_constant(self): ...
    def keys_as_python_constant(self): ...
    def python_type(self): ...
    def __contains__(self, vt) -> bool: ...
    def len(self): ...
    def has_new_items(self): ...
    def is_new_item(self, value, other): ...
    def reconstruct_kvs_into_new_dict(self, codegen) -> None: ...
    def reconstruct(self, codegen: PyCodegen): ...
    def getitem_const_raise_exception_if_absent(self, tx: InstructionTranslator, arg: VariableTracker): ...
    def getitem_const(self, tx: InstructionTranslator, arg: VariableTracker): ...
    def maybe_getitem_const(self, arg: VariableTracker): ...
    def realize_key_vt(self, arg: VariableTracker): ...
    def install_dict_keys_match_guard(self) -> None: ...
    def install_dict_contains_guard(self, tx, args) -> None: ...
    def call_method(self, tx, name, args: list[VariableTracker], kwargs: dict[str, VariableTracker]) -> VariableTracker: ...
    def unpack_var_sequence(self, tx): ...
    def call_obj_hasattr(self, tx, name): ...
    def clone(self, **kwargs): ...

class MappingProxyVariable(VariableTracker):
    dv_dict: Incomplete
    def __init__(self, dv_dict: ConstDictVariable, **kwargs) -> None: ...
    def python_type(self): ...
    def unpack_var_sequence(self, tx): ...
    def reconstruct(self, codegen: PyCodegen): ...
    def call_method(self, tx, name, args: list['VariableTracker'], kwargs: dict[str, 'VariableTracker']) -> VariableTracker: ...

class NNModuleHooksDictVariable(ConstDictVariable):
    def install_dict_keys_match_guard(self) -> None: ...
    def install_dict_contains_guard(self, tx, args) -> None: ...

class DefaultDictVariable(ConstDictVariable):
    default_factory: Incomplete
    def __init__(self, items, user_cls, default_factory=None, **kwargs) -> None: ...
    def is_python_constant(self): ...
    def debug_repr(self): ...
    @staticmethod
    def is_supported_arg(arg): ...
    def call_method(self, tx, name, args: list[VariableTracker], kwargs: dict[str, VariableTracker]) -> VariableTracker: ...
    def reconstruct(self, codegen): ...

class SetVariable(ConstDictVariable):
    """We model a sets as dictionary with None values"""
    def __init__(self, items: list[VariableTracker], **kwargs) -> None: ...
    def debug_repr(self): ...
    @property
    def set_items(self): ...
    @staticmethod
    def _default_value(): ...
    def as_proxy(self): ...
    def python_type(self): ...
    def as_python_constant(self): ...
    def reconstruct(self, codegen: PyCodegen): ...
    def call_method(self, tx, name, args: list[VariableTracker], kwargs: dict[str, VariableTracker]) -> VariableTracker: ...
    def getitem_const(self, tx: InstructionTranslator, arg: VariableTracker): ...
    def install_dict_keys_match_guard(self) -> None: ...
    def install_dict_contains_guard(self, tx, args) -> None: ...

class FrozensetVariable(SetVariable):
    def __init__(self, items: list[VariableTracker], **kwargs) -> None: ...
    def debug_repr(self): ...
    @property
    def set_items(self): ...
    def python_type(self): ...
    def as_python_constant(self): ...
    def reconstruct(self, codegen: PyCodegen): ...
    def call_method(self, tx, name, args: list[VariableTracker], kwargs: dict[str, VariableTracker]) -> VariableTracker: ...

class DictKeySetVariable(SetVariable):
    def __init__(self, items: list[VariableTracker], **kwargs) -> None: ...
    def debug_repr(self): ...
    @property
    def set_items(self): ...
    def python_type(self): ...
    def as_python_constant(self): ...
    def call_method(self, tx, name, args: list[VariableTracker], kwargs: dict[str, VariableTracker]) -> VariableTracker: ...

class DictViewVariable(VariableTracker):
    '''
    Models _PyDictViewObject

    This is an "abstract" class. Subclasses will override kv and the items method
    '''
    kv: str | None
    dv_dict: Incomplete
    def __init__(self, dv_dict: ConstDictVariable, **kwargs) -> None: ...
    @property
    def view_items(self): ...
    @property
    def view_items_vt(self) -> None: ...
    def unpack_var_sequence(self, tx): ...
    def reconstruct(self, codegen: PyCodegen): ...
    def call_method(self, tx, name, args: list['VariableTracker'], kwargs: dict[str, 'VariableTracker']) -> VariableTracker: ...

class DictKeysVariable(DictViewVariable):
    kv: str
    @property
    def set_items(self): ...
    @property
    def view_items_vt(self): ...
    def python_type(self): ...
    def call_method(self, tx, name, args: list['VariableTracker'], kwargs: dict[str, 'VariableTracker']) -> VariableTracker: ...

class DictValuesVariable(DictViewVariable):
    kv: str
    @property
    def view_items_vt(self): ...
    def python_type(self): ...

class DictItemsVariable(DictViewVariable):
    kv: str
    @property
    def view_items_vt(self): ...
    def python_type(self): ...
