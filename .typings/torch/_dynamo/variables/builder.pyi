import dataclasses
import functools
import re
import torch
import weakref
from .. import config as config, graph_break_hints as graph_break_hints, mutation_guard as mutation_guard, replay_record as replay_record, trace_rules as trace_rules
from ..device_interface import get_registered_device_interfaces as get_registered_device_interfaces
from ..exc import InternalTorchDynamoError as InternalTorchDynamoError, raise_observed_exception as raise_observed_exception, unimplemented_v2 as unimplemented_v2
from ..guards import GuardBuilder as GuardBuilder, install_guard as install_guard, make_dupe_guard as make_dupe_guard
from ..pgo import FrameStateSizeEntry as FrameStateSizeEntry, InferStride as InferStride, auto_dynamic as auto_dynamic, auto_unset as auto_unset, process_automatic_dynamic as process_automatic_dynamic
from ..side_effects import SideEffects as SideEffects
from ..source import AttrProxySource as AttrProxySource, AttrSource as AttrSource, CallMethodItemSource as CallMethodItemSource, ChainedSource as ChainedSource, ConstDictKeySource as ConstDictKeySource, ConvertIntSource as ConvertIntSource, DictGetItemSource as DictGetItemSource, DictSubclassGetItemSource as DictSubclassGetItemSource, FloatTensorSource as FloatTensorSource, GetItemSource as GetItemSource, GradSource as GradSource, ListGetItemSource as ListGetItemSource, LocalSource as LocalSource, NumpyTensorSource as NumpyTensorSource, OptimizerSource as OptimizerSource, RandomValueSource as RandomValueSource, Source as Source, SubclassAttrListSource as SubclassAttrListSource, TupleIteratorGetItemSource as TupleIteratorGetItemSource, UnspecializedBuiltinNNModuleSource as UnspecializedBuiltinNNModuleSource, UnspecializedNNModuleSource as UnspecializedNNModuleSource, is_constant_source as is_constant_source, is_from_global_source as is_from_global_source, is_from_nonlocal_source as is_from_nonlocal_source, is_from_optimizer_source as is_from_optimizer_source, is_from_unspecialized_nn_module_source as is_from_unspecialized_nn_module_source
from ..utils import _extract_tensor_dict as _extract_tensor_dict, build_checkpoint_variable as build_checkpoint_variable, build_invoke_subgraph_variable as build_invoke_subgraph_variable, clone_input as clone_input, common_constant_types as common_constant_types, dict_keys as dict_keys, get_fake_value as get_fake_value, get_items_from_dict as get_items_from_dict, get_locals_to_steal as get_locals_to_steal, get_static_address_type as get_static_address_type, is_frozen_dataclass as is_frozen_dataclass, is_function_or_wrapper as is_function_or_wrapper, is_invoke_subgraph as is_invoke_subgraph, is_lru_cache_wrapped_function as is_lru_cache_wrapped_function, is_namedtuple as is_namedtuple, is_parameter_freezing as is_parameter_freezing, is_typing as is_typing, is_utils_checkpoint as is_utils_checkpoint, is_wrapper_or_member_descriptor as is_wrapper_or_member_descriptor, istype as istype, namedtuple_fields as namedtuple_fields, odict_values as odict_values, proxy_args_kwargs as proxy_args_kwargs, range_iterator as range_iterator, set_example_value as set_example_value, tensor_always_has_static_shape as tensor_always_has_static_shape, tuple_iterator as tuple_iterator, tuple_iterator_getitem as tuple_iterator_getitem, tuple_iterator_len as tuple_iterator_len, unwrap_with_attr_name_if_wrapper as unwrap_with_attr_name_if_wrapper, wrap_fake_exception as wrap_fake_exception
from .base import AttributeMutationNew as AttributeMutationNew, ValueMutationExisting as ValueMutationExisting, ValueMutationNew as ValueMutationNew, VariableTracker as VariableTracker, VariableTrackerMeta as VariableTrackerMeta, typestr as typestr
from .constant import ConstantVariable as ConstantVariable, EnumVariable as EnumVariable
from .ctx_manager import AutocastModeVariable as AutocastModeVariable, DynamoConfigPatchVariable as DynamoConfigPatchVariable, EventVariable as EventVariable, NullContextVariable as NullContextVariable, PreserveVersionContextVariable as PreserveVersionContextVariable, StreamContextVariable as StreamContextVariable, StreamVariable as StreamVariable
from .dicts import ConstDictVariable as ConstDictVariable, DefaultDictVariable as DefaultDictVariable, DictKeySetVariable as DictKeySetVariable, FrozensetVariable as FrozensetVariable, MappingProxyVariable as MappingProxyVariable, SetVariable as SetVariable
from .distributed import DeviceMeshVariable as DeviceMeshVariable, PlacementClassVariable as PlacementClassVariable, PlacementVariable as PlacementVariable, ProcessGroupVariable as ProcessGroupVariable, WorldMetaClassVariable as WorldMetaClassVariable
from .functions import BuiltinMethodVariable as BuiltinMethodVariable, CollectionsNamedTupleFunction as CollectionsNamedTupleFunction, CollectiveFunctionRewriteVariable as CollectiveFunctionRewriteVariable, CreateTMADescriptorExperimentalVariable as CreateTMADescriptorExperimentalVariable, CreateTMADescriptorStableVariable as CreateTMADescriptorStableVariable, FunctoolsPartialVariable as FunctoolsPartialVariable, FunctoolsWrapsVariable as FunctoolsWrapsVariable, SysFunctionVariable as SysFunctionVariable, TracebackVariable as TracebackVariable, TritonKernelVariable as TritonKernelVariable, UserFunctionVariable as UserFunctionVariable, UserMethodVariable as UserMethodVariable, WrapperUserFunctionVariable as WrapperUserFunctionVariable
from .higher_order_ops import TorchHigherOrderOperatorVariable as TorchHigherOrderOperatorVariable
from .iter import ItertoolsVariable as ItertoolsVariable
from .lazy import LazyVariableTracker as LazyVariableTracker
from .lists import BaseListVariable as BaseListVariable, ListIteratorVariable as ListIteratorVariable, ListVariable as ListVariable, NamedTupleVariable as NamedTupleVariable, RangeVariable as RangeVariable, SizeVariable as SizeVariable, SliceVariable as SliceVariable, TupleIteratorVariable as TupleIteratorVariable, TupleVariable as TupleVariable
from .misc import AutogradEngineVariable as AutogradEngineVariable, AutogradFunctionContextVariable as AutogradFunctionContextVariable, AutogradFunctionVariable as AutogradFunctionVariable, ComptimeVariable as ComptimeVariable, DebuggingVariable as DebuggingVariable, DelayGraphBreakVariable as DelayGraphBreakVariable, GetAttrVariable as GetAttrVariable, GetSetDescriptorVariable as GetSetDescriptorVariable, LambdaVariable as LambdaVariable, LoggingLoggerVariable as LoggingLoggerVariable, MethodWrapperVariable as MethodWrapperVariable, NumpyDTypeVariable as NumpyDTypeVariable, NumpyTypeInfoVariable as NumpyTypeInfoVariable, NumpyVariable as NumpyVariable, PythonModuleVariable as PythonModuleVariable, RandomClassVariable as RandomClassVariable, RandomVariable as RandomVariable, RegexPatternVariable as RegexPatternVariable, SavedTensorBox as SavedTensorBox, TorchVersionVariable as TorchVersionVariable, TypingVariable as TypingVariable, WeakRefVariable as WeakRefVariable
from .nn_module import FSDPManagedNNModuleVariable as FSDPManagedNNModuleVariable, UnspecializedBuiltinNNModuleVariable as UnspecializedBuiltinNNModuleVariable, UnspecializedNNModuleVariable as UnspecializedNNModuleVariable
from .optimizer import OptimizerVariable as OptimizerVariable
from .script_object import TorchScriptObjectVariable as TorchScriptObjectVariable
from .sdpa import SDPAParamsVariable as SDPAParamsVariable
from .tensor import NumpyNdarrayVariable as NumpyNdarrayVariable, SymNodeVariable as SymNodeVariable, TensorSubclassVariable as TensorSubclassVariable, TensorVariable as TensorVariable, UnspecializedPythonVariable as UnspecializedPythonVariable, supported_const_comparison_op_values as supported_const_comparison_op_values
from .torch import DispatchKeySetVariable as DispatchKeySetVariable, FuncTorchInterpreterVariable as FuncTorchInterpreterVariable, TorchCtxManagerClassVariable as TorchCtxManagerClassVariable, TorchInGraphFunctionVariable as TorchInGraphFunctionVariable
from .torch_function import TensorWithTFOverrideVariable as TensorWithTFOverrideVariable, TorchFunctionModeVariable as TorchFunctionModeVariable, torch_function_mode_stack_state_mgr as torch_function_mode_stack_state_mgr
from .user_defined import FrozenDataClassVariable as FrozenDataClassVariable, IntWrapperVariable as IntWrapperVariable, KeyedJaggedTensorVariable as KeyedJaggedTensorVariable, MutableMappingVariable as MutableMappingVariable, SourcelessGraphModuleVariable as SourcelessGraphModuleVariable, UserDefinedClassVariable as UserDefinedClassVariable, UserDefinedDictVariable as UserDefinedDictVariable, UserDefinedExceptionClassVariable as UserDefinedExceptionClassVariable, UserDefinedListVariable as UserDefinedListVariable, UserDefinedObjectVariable as UserDefinedObjectVariable, UserDefinedTupleVariable as UserDefinedTupleVariable
from _typeshed import Incomplete
from torch import SymInt as SymInt
from torch._dynamo.codegen import PyCodegen as PyCodegen
from torch._dynamo.symbolic_convert import InstructionTranslator as InstructionTranslator
from torch._dynamo.utils import get_metrics_context as get_metrics_context, is_int_specialization_case as is_int_specialization_case, is_torch_sym as is_torch_sym, set_feature_use as set_feature_use
from torch._guards import TracingContext as TracingContext
from torch._higher_order_ops.torchbind import call_torchbind as call_torchbind
from torch._ops import HigherOrderOperator as HigherOrderOperator
from torch._subclasses.fake_tensor import FakeTensor as FakeTensor, is_fake as is_fake, maybe_get_fake_mode as maybe_get_fake_mode
from torch._subclasses.meta_utils import is_sparse_any as is_sparse_any, safe_grad as safe_grad
from torch._utils_internal import justknobs_check as justknobs_check
from torch.fx.experimental._backward_state import BackwardState as BackwardState
from torch.fx.experimental._dynamism import normalize_source_name as normalize_source_name
from torch.fx.experimental.symbolic_shapes import DimDynamic as DimDynamic, RelaxedUnspecConstraint as RelaxedUnspecConstraint, StatefulSymbolicContext as StatefulSymbolicContext, SubclassSymbolicContext as SubclassSymbolicContext, SymIntSymbolicContext as SymIntSymbolicContext, SymbolicContext as SymbolicContext, TrackedFake as TrackedFake, _constrain_range_for_size as _constrain_range_for_size, _nested_int_aware_sort as _nested_int_aware_sort
from torch.fx.immutable_collections import immutable_dict as immutable_dict, immutable_list as immutable_list
from torch.nn.utils._expanded_weights import ExpandedWeight as ExpandedWeight
from torch.utils._python_dispatch import is_traceable_wrapper_subclass as is_traceable_wrapper_subclass, is_traceable_wrapper_subclass_type as is_traceable_wrapper_subclass_type
from torch.utils._sympy.value_ranges import ValueRanges as ValueRanges
from torch.utils.weak import TensorWeakRef as TensorWeakRef
from typing import Any, Callable, NamedTuple

log: Incomplete
static_inputs_log: Incomplete
DimList = list

def safe_has_grad(t): ...

class _missing: ...

@dataclasses.dataclass
class GraphArg:
    source: Source
    _example: TensorWeakRef | torch.SymInt
    pass_arg_as_tensor: bool
    fake_tensor: torch._subclasses.fake_tensor.FakeTensor | None
    is_tensor: bool = ...
    example_strong_ref: torch.Tensor | None = ...
    @property
    def example(self): ...
    def __post_init__(self) -> None: ...
    def reconstruct(self, codegen: PyCodegen): ...
    def erase(self) -> None: ...
    def __eq__(self, other): ...

class BackwardStateGraphArg(GraphArg):
    def __init__(self) -> None: ...
    def reconstruct(self, codegen: PyCodegen): ...

ITERTOOLS_TYPE_IDS: frozenset[int]
ITERTOOLS_POLYFILLED_TYPE_IDS: set[int]
og_module_named_buffers_fn_ptr: Incomplete
og_module_named_parameters_fn_ptr: Incomplete

class VariableBuilder:
    """Wrap a python value in a VariableTracker() instance"""
    tx: Incomplete
    source: Incomplete
    name: Incomplete
    def __init__(self, tx, source: Source) -> None: ...
    def __call__(self, value): ...
    def _can_lift_attrs_to_inputs(self, vt): ...
    def get_source(self): ...
    def install_guards(self, *guards): ...
    @classmethod
    def _type_dispatch(cls): ...
    @classmethod
    @functools.cache
    def _type_dispatch_impl(cls, trace_numpy): ...
    def wrap_regex_pattern(self, value: re.Pattern): ...
    def wrap_weakref(self, value: weakref.ReferenceType): ...
    def wrap_removable_handle(self, value) -> None: ...
    def wrap_jit_function(self, value): ...
    def wrap_mapping_proxy(self, value): ...
    @classmethod
    @functools.cache
    def _id_dispatch(cls) -> dict[int, Callable[[VariableBuilder, Any], VariableTracker]]: ...
    def _wrap(self, value): ...
    def wrap_user_defined(self, value: Any): ...
    def wrap_listlike(self, value: tuple | list | odict_values | NamedTuple): ...
    def wrap_tuple_iterator(self, value: tuple_iterator): ...
    def wrap_range_iterator(self, value: range_iterator): ...
    def wrap_slice_range(self, value: slice | range): ...
    def mark_static_input(self, value: torch.Tensor, guard: bool): ...
    def wrap_module(self, value: torch.nn.Module): ...
    def wrap_literal(self, value): ...
    def assert_not_wrapped_by_this_graph(self, value: torch.Tensor): ...
    def wrap_tensor(self, value: torch.Tensor): ...
    def wrap_numpy_ndarray(self, value): ...
    def wrap_symint(self, value, dynamism: DimDynamic | None = None, context: SymIntSymbolicContext | None = None): ...
    def wrap_symfloat(self, value): ...
    def wrap_unspecialized_primitive(self, value): ...

def _dataclasses_fields_lambda(obj): ...
def _clone_input(value, fake_mode): ...
def wrap_fx_proxy(tx, proxy, example_value=None, subclass_type=None, **options) -> VariableTracker: ...
def cache_real_value_when_export(tx, proxy, example_value) -> None: ...
def wrap_fx_proxy_cls(target_cls, tx, proxy, example_value=None, subclass_type=None, **options): ...
def _wrap_fx_preexisting_tensor(target_cls, tx, proxy, tensor, subclass_type=None, **options): ...
def _wrap_fx_proxy(target_cls, tx, proxy, example_value=None, subclass_type=None, **options): ...
def handle_traced_output(example_value, tx, proxy, options, subclass_type, target_cls): ...
def construct_tensor_variable(target_cls, tx, proxy, example_value, subclass_type, options):
    """
    Actually construct a tensor variable after all the pre-processing from
    wrapping a pre-existing or newly created tensor value.
    """
def get_automatic_dynamic_shapes_mark_as(): ...

_DYNAMIC_SOURCES: set[str] | None
_DYNAMIC_SOURCES_CONFIG_HASH: int | None

def get_dynamic_sources() -> set[str]: ...
def is_dynamic_source(source_name: str) -> bool: ...
def record_automatic_dynamic(tx: InstructionTranslator, name: str, e: torch.Tensor) -> FrameStateSizeEntry: ...

_UNBACKED_SOURCES: set[str] | None
_UNBACKED_SOURCES_CONFIG_HASH: int | None

def get_unbacked_sources() -> set[str]: ...
def is_unbacked_source(source_name: str) -> bool: ...
def _automatic_dynamic(e, tx, source, static_shapes, outer_only: bool = False) -> SymbolicContext: ...
def wrap_to_fake_tensor_and_record(e, tx, *, source: Source | None, is_tensor: bool, parent_context=None): ...

class SourcelessBuilder:
    """
    Like builder, but stateless and does not require a source. Useful for simple type->VT objects, or objects
    that are being created/evaporated during inlining (ex: consider a locally made list of tensors we then iterate over
    .), such a list should not show up as an artifact from inputs, nor in reconstruction, nor in the graph. However,
    there may be reasons to represent it as a ListVariable internally.

    NOTE - Objects produced here are born UNGUARDED due to the nature of sources!

    NOTE - This class is very new! It will have some rough edges, but it was created to stem the bleeding of giant
    if/else type->VariableTracker trees that were cropping up all over dynamo.
    """
    def __init__(self) -> None: ...
    @staticmethod
    def create(tx: InstructionTranslator, value) -> VariableTracker: ...
    @staticmethod
    def wrap_constant_literal(value): ...
    @staticmethod
    def make_type_handlers(): ...

class SourcelessUserDefinedObjectBuilder:
    """
    SourceLessBuilder does not return a UserDefinedObjectVariable, but in some
    cases it might be ok to return UserDefinedObjects. In such case, use this
    builder.
    """
    def __init__(self) -> None: ...
    @staticmethod
    def create(tx: InstructionTranslator, value) -> VariableTracker: ...
