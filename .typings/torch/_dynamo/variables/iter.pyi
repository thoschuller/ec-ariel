from .. import graph_break_hints as graph_break_hints, polyfills as polyfills, variables as variables
from ..bytecode_transformation import create_call_function as create_call_function, create_instruction as create_instruction
from ..exc import ObservedUserStopIteration as ObservedUserStopIteration, UserError as UserError, handle_observed_exception as handle_observed_exception, raise_observed_exception as raise_observed_exception, unimplemented_v2 as unimplemented_v2
from .base import ValueMutationNew as ValueMutationNew, VariableTracker as VariableTracker
from .constant import ConstantVariable as ConstantVariable
from _typeshed import Incomplete
from torch._dynamo.codegen import PyCodegen as PyCodegen
from torch._dynamo.symbolic_convert import InstructionTranslator as InstructionTranslator

MAX_ITERATOR_LIMIT: Incomplete

class ItertoolsVariable(VariableTracker):
    value: Incomplete
    def __init__(self, value, **kwargs) -> None: ...
    def __repr__(self) -> str: ...
    def as_python_constant(self): ...
    def call_function(self, tx: InstructionTranslator, args: list[VariableTracker], kwargs: dict[str, VariableTracker]) -> VariableTracker: ...

class IteratorVariable(VariableTracker):
    def __init__(self, **kwargs) -> None: ...
    def next_variable(self, tx) -> None: ...
    def force_unpack_var_sequence(self, tx) -> list[VariableTracker]: ...
    def force_apply_to_var_sequence(self, tx, fn) -> None: ...
    def has_force_unpack_var_sequence(self, tx) -> bool: ...

class RepeatIteratorVariable(IteratorVariable):
    item: Incomplete
    def __init__(self, item: VariableTracker, **kwargs) -> None: ...
    def next_variable(self, tx): ...
    def reconstruct(self, codegen: PyCodegen): ...

class CountIteratorVariable(IteratorVariable):
    item: Incomplete
    step: Incomplete
    def __init__(self, item: int = 0, step: int = 1, **kwargs) -> None: ...
    def next_variable(self, tx): ...
    def reconstruct(self, codegen: PyCodegen): ...

class CycleIteratorVariable(IteratorVariable):
    iterator: Incomplete
    saved: Incomplete
    saved_index: Incomplete
    item: Incomplete
    def __init__(self, iterator: IteratorVariable, saved: list[VariableTracker] | None = None, saved_index: int = 0, item: VariableTracker | None = None, **kwargs) -> None: ...
    def next_variable(self, tx): ...

class ZipVariable(IteratorVariable):
    """
    Represents zip(*iterables)
    """
    _nonvar_fields: Incomplete
    iterables: Incomplete
    index: int
    strict: Incomplete
    def __init__(self, iterables: list[list[VariableTracker] | VariableTracker], strict: bool = False, **kwargs) -> None: ...
    def python_type(self): ...
    def has_unpack_var_sequence(self, tx) -> bool: ...
    def unpack_var_sequence(self, tx) -> list['VariableTracker']: ...
    def next_variable(self, tx): ...
    def reconstruct_items(self, codegen: PyCodegen): ...
    def reconstruct(self, codegen: PyCodegen): ...

class MapVariable(ZipVariable):
    """
    Represents map(fn, *iterables)
    """
    fn: Incomplete
    def __init__(self, fn: VariableTracker, iterables: list[list[VariableTracker] | VariableTracker], **kwargs) -> None: ...
    def python_type(self): ...
    def has_unpack_var_sequence(self, tx) -> bool: ...
    def next_variable(self, tx): ...
    def reconstruct(self, codegen: PyCodegen): ...

class FilterVariable(IteratorVariable):
    """
    Represents filter(fn, iterable)
    """
    _nonvar_fields: Incomplete
    fn: Incomplete
    iterable: Incomplete
    index: int
    def __init__(self, fn: VariableTracker, iterable: list[VariableTracker] | VariableTracker, **kwargs) -> None: ...
    def python_type(self): ...
    def has_unpack_var_sequence(self, tx) -> bool: ...
    def unpack_var_sequence(self, tx) -> list['VariableTracker']: ...
    def next_variable(self, tx): ...
    def reconstruct_items(self, codegen: PyCodegen): ...
    def reconstruct(self, codegen: PyCodegen): ...
