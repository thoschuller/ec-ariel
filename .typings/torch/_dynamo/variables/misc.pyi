import dataclasses
import random
import torch
import types
from .. import config as config, graph_break_hints as graph_break_hints, trace_rules as trace_rules, variables as variables
from ..bytecode_transformation import create_call_function as create_call_function, create_instruction as create_instruction
from ..create_parameter_op import do_not_convert_to_tracable_parameter as do_not_convert_to_tracable_parameter
from ..exc import raise_observed_exception as raise_observed_exception, unimplemented as unimplemented, unimplemented_v2 as unimplemented_v2
from ..guards import GuardBuilder as GuardBuilder, install_guard as install_guard
from ..mutation_guard import unpatched_nn_module_init as unpatched_nn_module_init
from ..source import AttrSource as AttrSource, GenericAttrSource as GenericAttrSource, GetItemSource as GetItemSource, TypeSource as TypeSource, WeakRefCallSource as WeakRefCallSource
from ..utils import check_unspec_or_constant_args as check_unspec_or_constant_args, cmp_name_to_op_mapping as cmp_name_to_op_mapping, identity as identity, is_tensor_base_attr_getter as is_tensor_base_attr_getter, istype as istype, list_methods as list_methods, proxy_args_kwargs as proxy_args_kwargs, tuple_methods as tuple_methods
from .base import VariableTracker as VariableTracker
from .constant import ConstantVariable as ConstantVariable
from .functions import NestedUserFunctionVariable as NestedUserFunctionVariable, UserFunctionVariable as UserFunctionVariable
from .user_defined import UserDefinedObjectVariable as UserDefinedObjectVariable, call_random_fn as call_random_fn, is_standard_setattr as is_standard_setattr
from _typeshed import Incomplete
from torch._dynamo.codegen import PyCodegen as PyCodegen
from torch._dynamo.symbolic_convert import InstructionTranslator as InstructionTranslator

class NO_SUCH_SUBOBJ: ...

class SuperVariable(VariableTracker):
    _nonvar_fields: Incomplete
    typevar: Incomplete
    objvar: Incomplete
    def __init__(self, typevar, objvar=None, **kwargs) -> None: ...
    def reconstruct(self, codegen: PyCodegen): ...
    def _resolved_getattr_and_source(self, tx: InstructionTranslator, name): ...
    def var_getattr(self, tx: InstructionTranslator, name: str) -> VariableTracker: ...
    def call_method(self, tx: InstructionTranslator, name, args: list[VariableTracker], kwargs: dict[str, VariableTracker]) -> VariableTracker: ...

class ExceptionVariable(VariableTracker):
    exc_type: Incomplete
    args: Incomplete
    __context__: Incomplete
    __cause__: Incomplete
    __suppress_context__: Incomplete
    __traceback__: Incomplete
    def __init__(self, exc_type, args, **kwargs) -> None: ...
    def set_context(self, context: ExceptionVariable): ...
    def reconstruct(self, codegen: PyCodegen): ...
    def python_type(self): ...
    def call_setattr(self, tx: InstructionTranslator, name_var: VariableTracker, val: VariableTracker): ...
    def call_method(self, tx, name, args, kwargs): ...
    def var_getattr(self, tx, name): ...
    def __str__(self) -> str: ...
    __repr__ = __str__

class UnknownVariable(VariableTracker):
    """
    It could be anything!
    """

class DelayGraphBreakVariable(UnknownVariable):
    """
    Used to insert a dummy variable in the stack to do the graph break at CALL_FUNCTION.
    """
    msg: Incomplete
    def __init__(self, msg=None, **kwargs) -> None: ...
    def call_function(self, tx: InstructionTranslator, args: list[VariableTracker], kwargs: dict[str, VariableTracker]) -> VariableTracker: ...

class ComptimeVariable(VariableTracker):
    """
    This variable is special, it lets you execute arbitrary code at
    Dynamo compile time
    """
    def reconstruct(self, codegen: PyCodegen): ...
    def var_getattr(self, tx: InstructionTranslator, name: str) -> VariableTracker: ...
    def call_function(self, tx: InstructionTranslator, args: list[VariableTracker], kwargs: dict[str, VariableTracker]) -> VariableTracker: ...

class CellVariable(VariableTracker):
    pre_existing_contents: VariableTracker | None
    local_name: str | None
    def __init__(self, pre_existing_contents: VariableTracker | None = None, **kwargs) -> None: ...

class NewGlobalVariable(VariableTracker):
    def __init__(self, **kwargs) -> None: ...

def produce_trampoline_autograd_apply(fn_cls): ...

class AutogradFunctionVariable(VariableTracker):
    """represents a torch.autograd.Function subclass"""
    _nonvar_fields: Incomplete
    fn_cls: Incomplete
    def __init__(self, fn_cls, **kwargs) -> None: ...
    def call_apply(self, tx: InstructionTranslator, args, kwargs): ...
    def call_backward(self, tx: InstructionTranslator, args, kwargs): ...
    def call_function(self, tx: InstructionTranslator, args, kwargs): ...
    def call_method(self, tx: InstructionTranslator, name, args: list[VariableTracker], kwargs: dict[str, VariableTracker]): ...

@dataclasses.dataclass
class SavedTensorBox:
    tensors: list[VariableTracker] = dataclasses.field(default_factory=list)

class AutogradFunctionContextVariable(UserDefinedObjectVariable):
    """
    Tracks an autograd.Function() context using mutation tracking in side_effects.py
    """
    _nonvar_fields: Incomplete
    inference: Incomplete
    saved_tensors: Incomplete
    needs_input_grad: Incomplete
    non_differentiable: Incomplete
    def __init__(self, value, value_type=None, inference: bool = False, saved_tensors=None, needs_input_grad=None, non_differentiable=None, **kwargs) -> None: ...
    @staticmethod
    def create(tx: InstructionTranslator, args=None, kwargs=None): ...
    def as_proxy(self): ...
    def call_method(self, tx: InstructionTranslator, name, args: list[VariableTracker], kwargs: dict[str, VariableTracker]) -> VariableTracker: ...
    def var_getattr(self, tx: InstructionTranslator, name): ...

class AutogradEngineVariable(UserDefinedObjectVariable):
    """
    Represents a torch._C._ImperativeEngine instance.
    """
    def __init__(self, value, value_type=None, **kwargs) -> None: ...
    def call_method(self, tx: InstructionTranslator, name, args: list[VariableTracker], kwargs: dict[str, VariableTracker]) -> VariableTracker: ...

class LambdaVariable(VariableTracker):
    fn: Incomplete
    def __init__(self, fn, **kwargs) -> None: ...
    def call_function(self, tx: InstructionTranslator, args: list[VariableTracker], kwargs: dict[str, VariableTracker]) -> VariableTracker: ...

class GetAttrVariable(VariableTracker):
    _nonvar_fields: Incomplete
    obj: Incomplete
    name: Incomplete
    py_type: Incomplete
    def __init__(self, obj, name, py_type=None, **kwargs) -> None: ...
    def python_type(self): ...
    def __repr__(self) -> str: ...
    @staticmethod
    def create_getattr_proxy(base_proxy: torch.fx.Proxy, attr): ...
    def as_proxy(self): ...
    def as_python_constant(self): ...
    def const_getattr(self, tx: InstructionTranslator, name): ...
    def reconstruct(self, codegen: PyCodegen): ...
    def call_function(self, tx: InstructionTranslator, args: list[VariableTracker], kwargs: dict[str, VariableTracker]) -> VariableTracker: ...
    def call_method(self, tx: InstructionTranslator, name, args: list[VariableTracker], kwargs: dict[str, VariableTracker]) -> VariableTracker: ...

class MethodWrapperVariable(VariableTracker):
    method_wrapper: Incomplete
    _builtin_fns: Incomplete
    def __init__(self, method_wrapper, **kwargs) -> None: ...
    def call_function(self, tx: InstructionTranslator, args: list[VariableTracker], kwargs: dict[str, VariableTracker]) -> VariableTracker: ...
    def is_python_constant(self): ...
    def as_python_constant(self): ...

class GetSetDescriptorVariable(VariableTracker):
    desc: Incomplete
    def __init__(self, desc, **kwargs) -> None: ...
    def var_getattr(self, tx: InstructionTranslator, name): ...
    def is_python_constant(self): ...
    def as_python_constant(self): ...

class PythonModuleVariable(VariableTracker):
    _nonvar_fields: Incomplete
    value: Incomplete
    is_torch: Incomplete
    def __init__(self, value: types.ModuleType, **kwargs) -> None: ...
    def python_type(self): ...
    def as_python_constant(self): ...
    def __repr__(self) -> str: ...
    def call_obj_hasattr(self, tx: InstructionTranslator, name): ...
    def var_getattr(self, tx: InstructionTranslator, name): ...

class TypingVariable(VariableTracker):
    value: Incomplete
    def __init__(self, value, **kwargs) -> None: ...
    def call_method(self, tx: InstructionTranslator, name, args: list[VariableTracker], kwargs: dict[str, VariableTracker]) -> VariableTracker: ...
    def var_getattr(self, tx: InstructionTranslator, name: str): ...
    def as_python_constant(self): ...
    def reconstruct(self, codegen: PyCodegen) -> None: ...

def get_np_to_tnp_map():
    """
    This generates a mapping from numpy modules to their torch._numpy
    modules equivalents.
    """
def get_tnp_to_np_map():
    """
    This is just the reverse mapping of get_np_to_tnp_map() - mapping from
    torch._numpy modules to numpy equivalents.
    """

class NumpyVariable(VariableTracker):
    """
    Wrapper around `numpy.*`. Currently, is able to trace a small subset of numpy functions as well as numpy dtypes.
    """
    constant_fold_functions: Incomplete
    value: Incomplete
    def __init__(self, value, **kwargs) -> None: ...
    @classmethod
    def can_constant_fold_through(cls, fn): ...
    @classmethod
    def get_constant_collection_for_func(cls, fn): ...
    def call_function(self, tx: InstructionTranslator, args: list[VariableTracker], kwargs: dict[str, VariableTracker]) -> VariableTracker: ...
    def call_method(self, tx: InstructionTranslator, name, args: list[VariableTracker], kwargs: dict[str, VariableTracker]) -> VariableTracker: ...
    def as_python_constant(self): ...
    def as_proxy(self): ...

class NullVariable(VariableTracker):
    def __init__(self, **kwargs) -> None: ...
    def __repr__(self) -> str: ...
    def reconstruct(self, codegen: PyCodegen): ...

class DeletedVariable(VariableTracker):
    """Marker used to implement delattr()"""

class StringFormatVariable(VariableTracker):
    """
    Represents a call to str.format(), we delay calling format until after the graph.
    """
    _nonvar_fields: Incomplete
    @classmethod
    def create(cls, format_string, sym_args, sym_kwargs): ...
    format_string: Incomplete
    sym_args: Incomplete
    sym_kwargs: Incomplete
    def __init__(self, format_string, sym_args, sym_kwargs, **kwargs) -> None: ...
    def __repr__(self) -> str: ...
    def reconstruct(self, codegen: PyCodegen): ...

class DebuggingVariable(VariableTracker):
    """
    Represents a call to a debugging function like print(), or something
    registered to config.reorderable_logging_functions.
    """
    value: Incomplete
    def __init__(self, value, **kwargs) -> None: ...
    @staticmethod
    def is_reorderable_logging_function(obj): ...
    def call_function(self, tx: InstructionTranslator, args, kwargs): ...
    def reconstruct(self, codegen: PyCodegen): ...
    @staticmethod
    def can_reorder_logs(fn, args, kwargs) -> True:
        """
        Run some additional checks for what sort of function calls can we
        actually reorder.
        """

class LoggingLoggerVariable(VariableTracker):
    """
    Represents a call to any of logging.Logger methods
    """
    value: Incomplete
    def __init__(self, value, **kwargs) -> None: ...
    def call_method(self, tx: InstructionTranslator, name, args: list[VariableTracker], kwargs: dict[str, VariableTracker]) -> VariableTracker: ...

class ConstantLikeVariable(VariableTracker):
    """self.value is a compile-time constant, but not a literal"""
    _error_prefix: str
    value: Incomplete
    def __init__(self, value, **kwargs) -> None: ...
    def as_python_constant(self): ...
    def call_method(self, tx: InstructionTranslator, name, args: list[VariableTracker], kwargs: dict[str, VariableTracker]) -> VariableTracker: ...
    def var_getattr(self, tx: InstructionTranslator, name: str) -> VariableTracker: ...

class RegexPatternVariable(ConstantLikeVariable):
    _error_prefix: str

class ConstantRegexMatchVariable(ConstantLikeVariable):
    _error_prefix: str

class TorchVersionVariable(ConstantLikeVariable):
    _error_prefix: str
    def __init__(self, **kwargs) -> None: ...

class NumpyTypeInfoVariable(ConstantLikeVariable):
    _error_prefix: str

class NumpyDTypeVariable(ConstantLikeVariable):
    _error_prefix: str
    def as_proxy(self):
        """Similar to how numpy dtype descriptors (e.g. np.float32 ) are handled by NumpyVariable:

        np.dtype() objects are serialized as strings, torch._numpy wrappers will normalize to the torch dtype.
        This also handles unsupported things nicely (i.e. structured arrays and object arrays).
        """

np_constant_collections_map: Incomplete

class RandomClassVariable(VariableTracker):
    """random.Random"""
    def __init__(self, **kwargs) -> None: ...
    def call_function(self, tx: InstructionTranslator, args, kwargs): ...

class RandomVariable(VariableTracker):
    """random.Random()

    Implemented by wrapping a VariableTracker around a random.Random object.
    The supported methods for the random.Random object cannot be overridden.
    Assumes that random objects behave the same given a set seed or state.
    """
    _nonvar_fields: Incomplete
    _supported_fn_names: Incomplete
    random: Incomplete
    def __init__(self, rand: random.Random | None = None, seed: VariableTracker | None = None, **kwargs) -> None: ...
    def python_type(self): ...
    def as_python_constant(self): ...
    @staticmethod
    def is_supported_random_obj(val): ...
    @staticmethod
    def check_state(state) -> None: ...
    @staticmethod
    def wrap_state(state): ...
    @staticmethod
    def unwrap_state(state): ...
    def call_method(self, tx: InstructionTranslator, name, args: list[VariableTracker], kwargs: dict[str, VariableTracker]) -> VariableTracker: ...
    def reconstruct(self, codegen: PyCodegen): ...

class WeakRefVariable(VariableTracker):
    @staticmethod
    def build(tx, weakref_value, **options): ...
    referent_vt: Incomplete
    callback_vt: Incomplete
    def __init__(self, referent_vt, callback_vt, **options) -> None: ...
    def call_function(self, tx: InstructionTranslator, args: list[VariableTracker], kwargs: dict[str, VariableTracker]) -> VariableTracker: ...
    def reconstruct(self, codegen: PyCodegen): ...
