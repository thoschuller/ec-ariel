import functools
from .. import polyfills as polyfills, variables as variables
from ..bytecode_transformation import create_call_function as create_call_function
from ..create_parameter_op import do_not_convert_to_tracable_parameter as do_not_convert_to_tracable_parameter
from ..exc import ObservedAttributeError as ObservedAttributeError, handle_observed_exception as handle_observed_exception, raise_observed_exception as raise_observed_exception, unimplemented as unimplemented
from ..guards import GuardBuilder as GuardBuilder, install_guard as install_guard
from ..source import AttrSource as AttrSource, CallFunctionNoArgsSource as CallFunctionNoArgsSource, DataclassFieldsSource as DataclassFieldsSource, GetItemSource as GetItemSource, RandomValueSource as RandomValueSource, TypeSource as TypeSource, UnspecializedParamBufferSource as UnspecializedParamBufferSource
from ..utils import build_checkpoint_variable as build_checkpoint_variable, check_constant_args as check_constant_args, cmp_name_to_op_mapping as cmp_name_to_op_mapping, dict_methods as dict_methods, get_custom_getattr as get_custom_getattr, has_torch_function as has_torch_function, is_frozen_dataclass as is_frozen_dataclass, is_lru_cache_wrapped_function as is_lru_cache_wrapped_function, is_namedtuple_cls as is_namedtuple_cls, is_utils_checkpoint as is_utils_checkpoint, is_wrapper_or_member_descriptor as is_wrapper_or_member_descriptor, istype as istype, list_methods as list_methods, namedtuple_fields as namedtuple_fields, object_has_getattribute as object_has_getattribute, proxy_args_kwargs as proxy_args_kwargs, tensortype_to_dtype as tensortype_to_dtype, tuple_methods as tuple_methods, unpatched_nn_module_getattr as unpatched_nn_module_getattr
from .base import AttributeMutationExisting as AttributeMutationExisting, ValueMutationNew as ValueMutationNew, VariableTracker as VariableTracker
from .dicts import DefaultDictVariable as DefaultDictVariable
from .lists import SizeVariable as SizeVariable
from _typeshed import Incomplete
from torch._dynamo.codegen import PyCodegen as PyCodegen
from torch._dynamo.symbolic_convert import InstructionTranslator as InstructionTranslator
from torch._guards import TracingContext as TracingContext
from torch.utils._cxx_pytree import PyTreeSpec as PyTreeSpec
from torch.utils._python_dispatch import is_traceable_wrapper_subclass_type as is_traceable_wrapper_subclass_type

def is_standard_setattr(val): ...
def is_standard_delattr(val): ...
def is_forbidden_context_manager(ctx): ...

class UserDefinedVariable(VariableTracker):
    value: object

class UserDefinedClassVariable(UserDefinedVariable):
    value: type[object]
    def __init__(self, value, **kwargs) -> None: ...
    def as_python_constant(self): ...
    def as_proxy(self): ...
    def __repr__(self) -> str: ...
    @staticmethod
    @functools.cache
    def _constant_fold_classes(): ...
    @staticmethod
    @functools.cache
    def _in_graph_classes(): ...
    @staticmethod
    @functools.cache
    def supported_c_new_functions(): ...
    @staticmethod
    def is_supported_new_method(value): ...
    def can_constant_fold_through(self): ...
    def has_key_in_generic_dict(self, tx: InstructionTranslator, key): ...
    def var_getattr(self, tx: InstructionTranslator, name: str) -> VariableTracker: ...
    def _call_cross_entropy_loss(self, tx: InstructionTranslator, args, kwargs):
        """
        functional: input, target, weight=None, size_average=None, ignore_index=- 100, reduce=None, reduction='mean',
        label_smoothing=0.0

        non functional ctor: weight=None, size_average=None, ignore_index=- 100, reduce=None, reduction='mean',
        label_smoothing=0.0

        non functional loss call: input, target, optional_output
        """
    def call_method(self, tx, name, args: list[VariableTracker], kwargs: dict[str, VariableTracker]) -> VariableTracker: ...
    def call_function(self, tx: InstructionTranslator, args: list[VariableTracker], kwargs: dict[str, VariableTracker]) -> VariableTracker: ...
    def is_standard_new(self):
        """Check for __new__ being overridden"""
    def call_obj_hasattr(self, tx: InstructionTranslator, name: str) -> VariableTracker: ...
    def const_getattr(self, tx: InstructionTranslator, name): ...

class UserDefinedExceptionClassVariable(UserDefinedClassVariable):
    @property
    def fn(self): ...
    def python_type(self): ...

class NO_SUCH_SUBOBJ: ...

def call_random_fn(tx, fn, args, kwargs): ...

class UserDefinedObjectVariable(UserDefinedVariable):
    """
    Mostly objects of defined type.  Catch-all for something where we only know the type.
    """
    _nonvar_fields: Incomplete
    value: Incomplete
    value_type: Incomplete
    cls_source: Incomplete
    base_cls_vt: Incomplete
    init_args: Incomplete
    attrs_directly_modifed_on_dict: Incomplete
    def __init__(self, value, *, value_type=None, cls_source=None, base_cls_vt=None, init_args=None, **kwargs) -> None: ...
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...
    def is_underlying_vt_modified(self, side_effects): ...
    def python_type(self): ...
    def as_python_constant(self): ...
    def guard_as_python_constant(self): ...
    def torch_function_check(self) -> None: ...
    def get_torch_fn(self, tx): ...
    def call_torch_function(self, tx: InstructionTranslator, fn, types, args, kwargs): ...
    @staticmethod
    @functools.cache
    def _supported_random_functions(): ...
    def _maybe_get_baseclass_method(self, name): ...
    def call_method(self, tx, name, args: list[VariableTracker], kwargs: dict[str, VariableTracker]) -> VariableTracker: ...
    def method_setattr_standard(self, tx: InstructionTranslator, name, value, directly_update_dict: bool = False): ...
    def needs_slow_setattr(self): ...
    def unpack_var_sequence(self, tx): ...
    def next_variable(self, tx): ...
    def is_supported_random(self): ...
    def call_function(self, tx: InstructionTranslator, args: list[VariableTracker], kwargs: dict[str, VariableTracker]) -> VariableTracker: ...
    def _check_for_getattr(self): ...
    def _is_c_defined_property(self, subobj): ...
    def _getattr_static(self, name): ...
    def should_skip_descriptor_setter(self, attr_name): ...
    def try_get_descritor_and_setter_py_func(self, attr_name): ...
    def has_key_in_generic_dict(self, tx: InstructionTranslator, key): ...
    def get_source_by_walking_mro(self, name): ...
    def var_getattr(self, tx: InstructionTranslator, name): ...
    def call_obj_hasattr(self, tx: InstructionTranslator, name: str) -> VariableTracker: ...

class FrozenDataClassVariable(UserDefinedObjectVariable):
    @staticmethod
    def create(tx, value, source): ...
    fields: Incomplete
    def __init__(self, value, fields=None, **kwargs) -> None: ...
    def as_python_constant(self): ...
    def as_proxy(self): ...
    def method_setattr_standard(self, tx: InstructionTranslator, name, value): ...
    def __repr__(self) -> str: ...

class SourcelessGraphModuleVariable(UserDefinedObjectVariable):
    def __init__(self, value, **kwargs) -> None: ...
    def call_method(self, tx, name, args: list[VariableTracker], kwargs: dict[str, VariableTracker]) -> VariableTracker: ...

class UserDefinedExceptionObjectVariable(UserDefinedObjectVariable):
    exc_vt: Incomplete
    def __init__(self, value, **kwargs) -> None: ...
    @property
    def fn(self): ...
    def call_method(self, tx, name, args, kwargs): ...
    @property
    def __context__(self): ...
    def set_context(self, context: variables.ExceptionVariable): ...
    @property
    def exc_type(self): ...

class KeyedJaggedTensorVariable(UserDefinedObjectVariable):
    @staticmethod
    def is_matching_object(obj): ...
    def __init__(self, value, **kwargs) -> None: ...
    def var_getattr(self, tx: InstructionTranslator, name): ...

class IntWrapperVariable(UserDefinedObjectVariable):
    @staticmethod
    def is_matching_object(obj): ...

class RemovableHandleClass: ...

class RemovableHandleVariable(VariableTracker):
    REMOVED: int
    mutation_type: Incomplete
    idx: Incomplete
    def __init__(self, mutation_type=None, idx=None, **kwargs) -> None: ...
    def call_method(self, tx: InstructionTranslator, method_name, args, kwargs): ...
    def reconstruct(self, codegen: PyCodegen): ...
    def python_type(self): ...

class UserDefinedDictVariable(UserDefinedObjectVariable):
    """
    Represents user defined objects that are subclasses of dict/OrderedDict.

    Internally, it uses a ConstDictVariable to represent the dict part of the
    variable tracker. For everything else, it falls back to
    UserDefinedObjectVariable.
    """
    _nonvar_fields: Incomplete
    _dict_vt: Incomplete
    _dict_methods: Incomplete
    def __init__(self, value, dict_vt=None, **kwargs) -> None: ...
    def call_method(self, tx, name, args: list[VariableTracker], kwargs: dict[str, VariableTracker]) -> VariableTracker: ...
    def unpack_var_sequence(self, tx): ...
    def is_underlying_vt_modified(self, side_effects): ...

class UserDefinedListVariable(UserDefinedObjectVariable):
    """
    Represents user defined objects that are subclasses of lists.

    Internally, it uses a ListVariable to represent the list part of the
    variable tracker. For everything else, it falls back to
    UserDefinedObjectVariable.
    """
    _nonvar_fields: Incomplete
    _list_vt: Incomplete
    def __init__(self, value, list_vt=None, **kwargs) -> None: ...
    def call_method(self, tx, name, args: list[VariableTracker], kwargs: dict[str, VariableTracker]) -> VariableTracker: ...
    def unpack_var_sequence(self, tx): ...
    def is_underlying_vt_modified(self, side_effects): ...

class UserDefinedTupleVariable(UserDefinedObjectVariable):
    """
    Represents user defined objects that are subclasses of tuple.

    Internally, it uses a TupleVariable to represent the tuple part of the
    variable tracker. For everything else, it falls back to
    UserDefinedObjectVariable.
    """
    _nonvar_fields: Incomplete
    _tuple_vt: Incomplete
    def __init__(self, value, tuple_vt=None, init_args=None, **kwargs) -> None: ...
    def call_method(self, tx, name, args: list[VariableTracker], kwargs: dict[str, VariableTracker]) -> VariableTracker: ...
    def unpack_var_sequence(self, tx): ...

class MutableMappingVariable(UserDefinedObjectVariable):
    _nonvar_fields: Incomplete
    generic_dict_vt: Incomplete
    mutation_type: Incomplete
    def __init__(self, value, **kwargs) -> None: ...
    def var_getattr(self, tx: InstructionTranslator, name: str) -> VariableTracker: ...

class RandomVariable(UserDefinedObjectVariable): ...
