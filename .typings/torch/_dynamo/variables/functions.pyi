import builtins
import functools
import torch
import types
from .. import config as config, graph_break_hints as graph_break_hints, polyfills as polyfills, variables as variables
from ..bytecode_transformation import create_call_function as create_call_function, create_rot_n as create_rot_n, is_generator as is_generator
from ..exc import InfiniteGeneratorError as InfiniteGeneratorError, ObservedException as ObservedException, ObservedGeneratorExit as ObservedGeneratorExit, ObservedUserStopIteration as ObservedUserStopIteration, SkipFrame as SkipFrame, Unsupported as Unsupported, get_dynamo_observed_exception as get_dynamo_observed_exception, handle_observed_exception as handle_observed_exception, raise_observed_exception as raise_observed_exception, unimplemented_v2 as unimplemented_v2
from ..guards import GuardBuilder as GuardBuilder, install_guard as install_guard
from ..source import AttrSource as AttrSource, ConstantSource as ConstantSource, DefaultsSource as DefaultsSource, GetItemSource as GetItemSource
from ..utils import check_constant_args as check_constant_args, check_unspec_or_constant_args as check_unspec_or_constant_args, cmp_name_to_op_mapping as cmp_name_to_op_mapping, counters as counters, identity as identity, is_function as is_function, is_wrapper_or_member_descriptor as is_wrapper_or_member_descriptor, istype as istype, make_cell as make_cell
from .base import AsPythonConstantNotImplementedError as AsPythonConstantNotImplementedError, AttributeMutationNew as AttributeMutationNew, ValueMutationNew as ValueMutationNew, VariableTracker as VariableTracker
from .constant import ConstantVariable as ConstantVariable
from _typeshed import Incomplete
from collections.abc import Sequence
from torch._dynamo.codegen import PyCodegen as PyCodegen
from torch._dynamo.exc import get_stack_above_dynamo as get_stack_above_dynamo
from torch._dynamo.symbolic_convert import InstructionTranslator as InstructionTranslator
from torch._higher_order_ops.triton_kernel_wrap import TMADescriptorMetadata as TMADescriptorMetadata, TritonGridType as TritonGridType, TritonHOPifier as TritonHOPifier, TritonKernelType as TritonKernelType, create_tma_experimental_metadata as create_tma_experimental_metadata, create_tma_stable_metadata as create_tma_stable_metadata
from torch.distributed.fsdp._fully_shard import _fsdp_param_group as _fsdp_param_group
from types import FunctionType
from typing import Any, Callable, TypeVar
from typing_extensions import Never

_F = TypeVar('_F', bound=Callable)
CO_VARARGS: int
CO_VARKEYWORDS: int
_spec_cache: Incomplete

class FunctionSpec:
    posonly_count: Incomplete
    arg_count: Incomplete
    kwonly_count: Incomplete
    posonly_names: Incomplete
    pos_or_kw_names: Incomplete
    all_pos_names: Incomplete
    kwonly_names: Incomplete
    varargs_name: Incomplete
    varkw_name: Incomplete
    def __init__(self, func: FunctionType) -> None: ...
    defaults: Incomplete
    kwdefaults: Incomplete
    pos_default_map: Incomplete
    def update_defaults(self, func: FunctionType): ...

def _get_spec(func: FunctionType) -> FunctionSpec: ...
def bind_args_cached(func, tx, fn_source, args, kwargs): ...
def wrap_bound_arg(tx: InstructionTranslator, val, source=None): ...
def wrap_args_kwargs(tx: InstructionTranslator, result): ...
def init_cellvars(parent, result: dict[str, VariableTracker], code):
    """
    Update `result` to add mapping from local name to new cells created
    directly by `code`, or update SideEffects in `parent` if the a local cell is
    already in `result` (cell argument).
    """
def _create_nested_fn(code, f_globals, name, defaults, closure, kwdefaults, annotations): ...

fn_known_dunder_attrs: Incomplete

def fn_var_getattr(tx, fn, source, name): ...

class BaseUserFunctionVariable(VariableTracker):
    def get_filename(self): ...
    def get_name(self): ...
    def call_function(self, tx: InstructionTranslator, args: list[VariableTracker], kwargs: dict[str, VariableTracker]) -> VariableTracker: ...
    def call_obj_hasattr(self, tx: InstructionTranslator, name: str) -> VariableTracker: ...
    def inspect_parameter_names(self): ...
    def closure_vars(self, tx): ...

class UserFunctionVariable(BaseUserFunctionVariable):
    """Some unsupported user-defined global function"""
    _nonvar_fields: Incomplete
    @classmethod
    def create_with_source(cls, value, source): ...
    is_constant: bool
    fn: types.FunctionType
    def __init__(self, fn, is_constant: bool = False, **kwargs) -> None: ...
    def as_python_constant(self): ...
    def self_args(self): ...
    def get_function(self): ...
    def get_code(self): ...
    def python_type(self): ...
    def has_self(self): ...
    def get_globals(self): ...
    def bind_args(self, parent, args, kwargs) -> dict[str, VariableTracker]:
        """
        Assume `args` and `kwargs` are VariableTracker arguments for a call to
        this function, create new bindings for initial locals.
        """
    def var_getattr(self, tx: InstructionTranslator, name: str): ...
    def call_obj_hasattr(self, tx: InstructionTranslator, name: str) -> VariableTracker: ...
    def call_function(self, tx: InstructionTranslator, args: list[VariableTracker], kwargs: dict[str, VariableTracker]) -> VariableTracker: ...

class BuiltinMethodVariable(BaseUserFunctionVariable):
    fn: Incomplete
    def __init__(self, fn, is_constant: bool = False, **kwargs) -> None: ...
    @staticmethod
    def is_supported_builtin_method(obj): ...
    def call_function(self, tx: InstructionTranslator, args: list[VariableTracker], kwargs: dict[str, VariableTracker]) -> VariableTracker: ...

class LocalGeneratorObjectVariable(VariableTracker):
    code: Incomplete
    f_globals: Incomplete
    inline_tracer: Incomplete
    def __init__(self, code: types.CodeType, f_globals, inline_tracer: InstructionTranslator | None, **kwargs) -> None: ...
    def get_code(self): ...
    def get_filename(self): ...
    def get_name(self): ...
    def get_function(self) -> None: ...
    def has_self(self): ...
    def __name__(self): ...
    def __str__(self) -> str: ...
    __repr__ = __str__
    remaining_items: Incomplete
    def reconstruct(self, codegen: PyCodegen): ...
    def bind_args(self, tx, args, kwargs): ...
    def get_globals(self): ...
    def python_type(self): ...
    def _get_inline_tracer(self, tx): ...
    def next_variable(self, tx): ...
    def has_unpack_var_sequence(self, tx): ...
    def has_force_unpack_var_sequence(self, tx) -> builtins.bool: ...
    def force_unpack_var_sequence(self, tx) -> list[VariableTracker]: ...
    def force_apply_to_var_sequence(self, tx, fn) -> None: ...
    def _setup_exception(self, tx, exc) -> None: ...
    def _is_generator_just_started(self): ...
    def _is_generator_exhausted(self): ...
    def call_method(self, tx: InstructionTranslator, name: str, args: list[VariableTracker], kwargs: dict[str, VariableTracker]) -> VariableTracker: ...

class ContextlibContextManagerLocalGeneratorObjectVariable(LocalGeneratorObjectVariable):
    """
    .. note::

        This is only used when the function is annotated with @contextlib.contextmanager

        It is a special case of a generator function as we do not allow return a context manager
        from a torch.compile function.
    """

class LocalGeneratorFunctionVariable(BaseUserFunctionVariable):
    """functions that behaves like iterators

    .. note::

        This is a wrapper around (Nested)UserFunctionVariable
    """
    vt: Incomplete
    generator_cls: Incomplete
    def __init__(self, vt: VariableTracker, *, generator_cls=..., **kwargs) -> None: ...
    def __getattr__(self, name): ...
    def _build_inline_tracer(self, tx, args, kwargs): ...
    def call_function(self, tx: InstructionTranslator, args: list[VariableTracker], kwargs: dict[str, VariableTracker]) -> VariableTracker: ...

class FunctionDecoratedByContextlibContextManagerVariable(LocalGeneratorFunctionVariable):
    """
    .. note::

        This is only used when the function is annotated with @contextlib.contextmanager
    """
    def __init__(self, vt, **kwargs) -> None: ...
    def _build_inline_tracer(self, tx, args, kwargs): ...

class UserMethodVariable(UserFunctionVariable):
    """Some unsupported user-defined method"""
    obj: Incomplete
    def __init__(self, fn, obj, **kwargs) -> None: ...
    def __repr__(self) -> str: ...
    def self_args(self): ...
    def python_type(self): ...
    def call_function(self, tx: InstructionTranslator, args: list[VariableTracker], kwargs: dict[str, VariableTracker]) -> VariableTracker: ...
    def inspect_parameter_names(self): ...
    def var_getattr(self, tx: InstructionTranslator, name: str): ...

class WrappedUserMethodVariable(UserMethodVariable):
    wrapped: Incomplete
    context: Incomplete
    def __init__(self, wrapped, context, **kwargs) -> None: ...
    def call_function(self, tx: InstructionTranslator, args: list[VariableTracker], kwargs: dict[str, VariableTracker]) -> VariableTracker: ...
    def reconstruct(self, codegen): ...

class WrappedUserFunctionVariable(UserFunctionVariable):
    wrapped: Incomplete
    context: Incomplete
    def __init__(self, wrapped, context, **kwargs) -> None: ...
    def call_function(self, tx: InstructionTranslator, args: list[VariableTracker], kwargs: dict[str, VariableTracker]) -> VariableTracker: ...
    def reconstruct(self, codegen): ...

def invoke_and_store_as_constant(tx: InstructionTranslator, fn, name, args, kwargs): ...

class NestedUserFunctionVariable(BaseUserFunctionVariable):
    _nonvar_fields: Incomplete
    fn_name: Incomplete
    code: Incomplete
    f_globals: Incomplete
    defaults: Incomplete
    kwdefaults: Incomplete
    annotations: Incomplete
    closure: Incomplete
    wrapped_fn: VariableTracker | None
    def __init__(self, fn_name, code, f_globals, defaults, kwdefaults, annotations, closure, wrapped_fn=None, **kwargs) -> None: ...
    def self_args(self): ...
    def get_code(self): ...
    def python_type(self): ...
    def get_function(self): ...
    def call_setattr(self, tx: InstructionTranslator, name_var: VariableTracker, val: VariableTracker): ...
    def call_method(self, tx, name, args, kwargs): ...
    def has_closure(self): ...
    def const_getattr(self, tx, name): ...
    def has_self(self): ...
    def get_globals(self): ...
    def bind_args(self, parent, args, kwargs): ...
    def reconstruct(self, codegen: PyCodegen): ...

class WrappedNestedUserFunctionVariable(NestedUserFunctionVariable):
    wrapped: Incomplete
    context: Incomplete
    def __init__(self, wrapped, context, **kwargs) -> None: ...
    def call_function(self, tx: InstructionTranslator, args: list[VariableTracker], kwargs: dict[str, VariableTracker]) -> VariableTracker: ...
    def reconstruct(self, codegen): ...

class SkipFunctionVariable(VariableTracker):
    _nonvar_fields: Incomplete
    value: Incomplete
    reason: Incomplete
    def __init__(self, value, reason=None, **kwargs) -> None: ...
    def as_python_constant(self): ...
    @classmethod
    def create_with_source(cls, value, source): ...
    def call_function(self, tx: InstructionTranslator, args: list[VariableTracker], kwargs: dict[str, VariableTracker]) -> VariableTracker: ...
    def call_obj_hasattr(self, tx: InstructionTranslator, name): ...
    def var_getattr(self, tx: InstructionTranslator, name: str): ...

class WrappedSkipFunctionVariable(SkipFunctionVariable):
    wrapped: Incomplete
    context: Incomplete
    def __init__(self, wrapped, context, **kwargs) -> None: ...
    def call_function(self, tx: InstructionTranslator, args: list[VariableTracker], kwargs: dict[str, VariableTracker]) -> VariableTracker: ...
    def reconstruct(self, codegen): ...

class WrapperUserFunctionVariable(VariableTracker):
    '''
    Used to represent a wrapper object that contains the actual callable as an
    attribute. For example, torch.jit.script/trace have the original function at
    their _torchdynamo_inline attribute. Similarly, functions with
    __script_if_tracing_wrapper have the original attr at "__original_fn".
    '''
    wrapper_obj: Incomplete
    attr_to_trace: Incomplete
    def __init__(self, wrapper_obj, attr_to_trace, **kwargs) -> None: ...
    def var_getattr(self, tx: InstructionTranslator, name): ...
    def self_args(self): ...
    def call_function(self, tx: InstructionTranslator, args: list[VariableTracker], kwargs: dict[str, VariableTracker]) -> VariableTracker: ...

class WrapperUserMethodVariable(WrapperUserFunctionVariable):
    """
    Similar to WrapperUserFunctionVariable, but for methods. The only delta is
    saving the vt for `self` object of the method which is then used by
    WrapperUserFunctionVariable in `call_function` method.
    """
    obj: Incomplete
    def __init__(self, wrapper_obj, attr_to_trace, self_obj, **kwargs) -> None: ...
    def self_args(self): ...

def _traceable_collective_remaps(): ...
def _traceable_collectives_source(tx: InstructionTranslator, fn): ...

class CollectiveFunctionRewriteVariable(UserFunctionVariable):
    """
    Some of the torch.distributed.* collective APIs are possible to rewrite to 'traceable' collectives.

    This class provides both a way to check if a function is remappable, and perform the remapping.

    In the case that a function is 'remappable' but only for some combinations of call-time arguments,
    we check the args at `call_function` time and fall back to graph-breaking if needed.  This is no worse
    than status-quo as we currently graph-break on all distributed.* collectives.
    """
    replacement_var: Incomplete
    def __init__(self, fn, *, replacement_var, **kwargs) -> None: ...
    @staticmethod
    def create(tx: InstructionTranslator, old_fn, source, **options): ...
    @staticmethod
    def can_rewrite(variable): ...
    @staticmethod
    def rewrite(tx: InstructionTranslator, fn): ...
    def call_function(self, tx: InstructionTranslator, args: list[VariableTracker], kwargs: dict[str, VariableTracker]) -> VariableTracker: ...

class FunctoolsWrapsVariable(UserFunctionVariable):
    def call_function(self, tx: InstructionTranslator, args: list[VariableTracker], kwargs: dict[str, VariableTracker]) -> VariableTracker: ...

class CollectionsNamedTupleFunction(UserFunctionVariable):
    def as_python_constant(self): ...
    def call_function(self, tx: InstructionTranslator, args: list[VariableTracker], kwargs: dict[str, VariableTracker]) -> VariableTracker: ...

class FunctoolsPartialVariable(VariableTracker):
    func: Incomplete
    args: Incomplete
    keywords: Incomplete
    fake_value: Incomplete
    def __init__(self, func: VariableTracker, args, keywords, **kwargs) -> None: ...
    def python_type(self): ...
    def reconstruct(self, codegen: PyCodegen): ...
    def get_function(self): ...
    def call_function(self, tx: InstructionTranslator, args: list[VariableTracker], kwargs: dict[str, VariableTracker]) -> VariableTracker: ...
    def call_obj_hasattr(self, tx: InstructionTranslator, name: str) -> VariableTracker: ...
    def var_getattr(self, tx: InstructionTranslator, name: str): ...
    def as_python_constant(self): ...
    def guard_as_python_constant(self):
        """Similar to as_python_constant(), but add ID_MATCH guards to try to force things to become constants"""

class PolyfilledFunctionVariable(VariableTracker):
    _nonvar_fields: Incomplete
    @classmethod
    @functools.cache
    def _get_polyfill_handlers(cls) -> dict[Callable[..., Any], types.FunctionType]: ...
    @classmethod
    def create_with_source(cls, value, source): ...
    fn: _F
    wrapped_fn: _F
    traceable_fn: _F
    def __init__(self, fn: _F, **kwargs) -> None: ...
    @property
    def polyfill_fn(self) -> _F: ...
    def can_constant_fold_through(self): ...
    def get_function(self): ...
    def call_function(self, tx: InstructionTranslator, args: list[VariableTracker], kwargs: dict[str, VariableTracker]) -> VariableTracker: ...
    def call_method(self, tx, name, args: list[VariableTracker], kwargs: dict[str, VariableTracker]) -> VariableTracker: ...
    def as_python_constant(self): ...

class TracebackVariable(VariableTracker):
    def call_function(self, tx, args, kwargs) -> None: ...

class SysFunctionVariable(VariableTracker):
    value: Incomplete
    def __init__(self, value, **kwargs) -> None: ...
    def exc_info(self, tx): ...
    def exception(self, tx): ...
    def call_function(self, tx, args, kwargs): ...

class DynamoTritonHOPifier(TritonHOPifier):
    def raise_unsupported(self, msg: str) -> Never: ...
    def is_callable(self, maybe_callable: Any) -> bool: ...
    def get_value(self, val: Any) -> Any: ...
    def check_grid(self, grid) -> tuple[torch.fx.proxy.Proxy, ...]: ...
    def call_grid(self, grid, meta, tx): ...
    def call_user_defined_fn(self, user_fn, args, kwargs, tx, variable): ...
    def wrap_user_defined_obj(self, user_obj, tx, variable, name): ...
    def maybe_unpack_configs(self, configs, tx): ...
    def maybe_unpack_heuristic_result(self, result: Any) -> Any: ...
    def call_getitem(self, variable: TritonKernelVariable, args: Sequence[Any]) -> TritonKernelVariable: ...
    def call_HOP(self, variable, grids, combined_args_raw, tx) -> ConstantVariable: ...

dynamo_triton_hopifier_singleton: Incomplete

class TritonKernelVariable(VariableTracker):
    grid: TritonGridType
    kernel: TritonKernelType
    kernel_idx: int | None
    kernel_source: AttrSource
    def __init__(self, kernel, kernel_idx, grid, **kwargs) -> None: ...
    def call_function(self, tx: InstructionTranslator, args: list[VariableTracker], kwargs: dict[str, VariableTracker]) -> VariableTracker: ...
    def call_method(self, tx, name, args: list[VariableTracker], kwargs: dict[str, VariableTracker]) -> VariableTracker: ...
    def specialize_symbolic(self, arg: Any) -> Any: ...

class TMADescriptorExperimentalVariable(VariableTracker):
    data_ptr: Incomplete
    dims: Incomplete
    block_dims: Incomplete
    element_size: Incomplete
    def __init__(self, data_ptr: variables.DataPtrVariable, dims: list[ConstantVariable], block_dims: list[ConstantVariable], element_size: ConstantVariable, **kwargs) -> None: ...
    def to_metadata(self): ...
    def reconstruct(self, codegen: PyCodegen): ...
    def get_tensor(self): ...

class TMADescriptorStableVariable(VariableTracker):
    tensor: Incomplete
    block_shape: Incomplete
    def __init__(self, tensor: variables.TensorVariable, block_shape: variables.ListVariable, **kwargs) -> None: ...
    def to_metadata(self): ...
    def reconstruct(self, codegen: PyCodegen): ...
    def get_tensor(self) -> variables.TensorVariable: ...

class CreateTMADescriptorExperimentalVariable(VariableTracker):
    rank: Incomplete
    def __init__(self, rank: int, **kwargs) -> None: ...
    def call_function(self, tx: InstructionTranslator, args: list[VariableTracker], kwargs: dict[str, VariableTracker]) -> VariableTracker: ...

class CreateTMADescriptorStableVariable(VariableTracker):
    def call_function(self, tx: InstructionTranslator, args: list[VariableTracker], kwargs: dict[str, VariableTracker]) -> VariableTracker: ...
