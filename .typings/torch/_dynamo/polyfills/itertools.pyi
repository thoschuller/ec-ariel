from collections.abc import Iterable, Iterator
from typing import Callable, TypeVar, overload
from typing_extensions import TypeAlias

__all__ = ['chain', 'chain_from_iterable', 'compress', 'dropwhile', 'islice', 'tee', 'zip_longest', 'pairwise']

_T = TypeVar('_T')
_U = TypeVar('_U')
_Predicate: TypeAlias = Callable[[_T], object]
_T1 = TypeVar('_T1')
_T2 = TypeVar('_T2')

def chain(*iterables: Iterable[_T]) -> Iterator[_T]: ...
def chain_from_iterable(iterable: Iterable[Iterable[_T]], /) -> Iterator[_T]: ...
def compress(data: Iterable[_T], selectors: Iterable[_U], /) -> Iterator[_T]: ...
def dropwhile(predicate: _Predicate[_T], iterable: Iterable[_T], /) -> Iterator[_T]: ...
def islice(iterable: Iterable[_T], /, *args: int | None) -> Iterator[_T]: ...
def pairwise(iterable: Iterable[_T], /) -> Iterator[tuple[_T, _T]]: ...
def tee(iterable: Iterable[_T], n: int = 2, /) -> tuple[Iterator[_T], ...]: ...
@overload
def zip_longest(iter1: Iterable[_T1], /, *, fillvalue: _U = ...) -> Iterator[tuple[_T1]]: ...
@overload
def zip_longest(iter1: Iterable[_T1], iter2: Iterable[_T2], /) -> Iterator[tuple[_T1 | None, _T2 | None]]: ...
@overload
def zip_longest(iter1: Iterable[_T1], iter2: Iterable[_T2], /, *, fillvalue: _U = ...) -> Iterator[tuple[_T1 | _U, _T2 | _U]]: ...
@overload
def zip_longest(iter1: Iterable[_T], iter2: Iterable[_T], iter3: Iterable[_T], /, *iterables: Iterable[_T]) -> Iterator[tuple[_T | None, ...]]: ...
@overload
def zip_longest(iter1: Iterable[_T], iter2: Iterable[_T], iter3: Iterable[_T], /, *iterables: Iterable[_T], fillvalue: _U = ...) -> Iterator[tuple[_T | _U, ...]]: ...
