import builtins
from ..decorators import substitute_in_graph as substitute_in_graph
from _typeshed import Incomplete
from collections.abc import Iterable
from dataclasses import dataclass, field
from torch.utils._cxx_pytree import PyTree as PyTree
from torch.utils._pytree import BUILTIN_TYPES as BUILTIN_TYPES, STANDARD_DICT_TYPES as STANDARD_DICT_TYPES
from typing import Any, Callable, Literal
from typing_extensions import Self, TypeIs

__all__: list[str]

def _(*args: Any, **kwargs: Any) -> bool: ...

__name: str
__func: Incomplete

def tree_is_leaf(tree: PyTree, is_leaf: Callable[[PyTree], bool] | None = None) -> bool: ...
def tree_iter(tree: PyTree, is_leaf: Callable[[PyTree], bool] | None = None) -> Iterable[Any]: ...
def tree_leaves(tree: PyTree, is_leaf: Callable[[PyTree], bool] | None = None) -> list[Any]: ...

class _Asterisk(str):
    __slots__: Incomplete
    def __new__(cls) -> Self: ...
    def __repr__(self) -> str: ...

_asterisk: Incomplete

@dataclass(frozen=True)
class PyTreeSpec:
    """Analog for :class:`optree.PyTreeSpec` in Python."""
    _children: tuple[PyTreeSpec, ...]
    _type: builtins.type | None
    _metadata: Any
    _entries: tuple[Any, ...]
    _unflatten_func: Callable[[Any | None, Iterable[PyTree]], PyTree] | None
    num_nodes: int = field(init=False)
    num_leaves: int = field(init=False)
    num_children: int = field(init=False)
    none_is_leaf: Literal[True] = field(init=False)
    namespace: Literal['torch'] = field(init=False)
    def __post_init__(self) -> None: ...
    def __repr__(self) -> str: ...
    def __len__(self) -> int: ...
    @property
    def type(self) -> builtins.type | None: ...
    def is_leaf(self) -> bool: ...
    def children(self) -> list[PyTreeSpec]: ...
    def child(self, index: int) -> PyTreeSpec: ...
    def entries(self) -> list[Any]: ...
    def entry(self, index: int) -> Any: ...
    def flatten_up_to(self, tree: PyTree) -> list[PyTree]: ...
    def unflatten(self, leaves: Iterable[Any]) -> PyTree: ...

_LEAF_SPEC: Incomplete

def _is_pytreespec_instance(obj: Any, /) -> TypeIs[PyTreeSpec]: ...
def tree_flatten(tree: PyTree, is_leaf: Callable[[PyTree], bool] | None = None) -> tuple[list[Any], PyTreeSpec]: ...
def tree_structure(tree: PyTree, is_leaf: Callable[[PyTree], bool] | None = None) -> PyTreeSpec: ...
def tree_unflatten(leaves: Iterable[Any], treespec: PyTreeSpec) -> PyTree: ...
def tree_map(func: Callable[..., Any], tree: PyTree, *rests: PyTree, is_leaf: Callable[[PyTree], bool] | None = None) -> PyTree: ...
def tree_map_(func: Callable[..., Any], tree: PyTree, *rests: PyTree, is_leaf: Callable[[PyTree], bool] | None = None) -> PyTree: ...
