from ..utils import dict_keys as dict_keys
from _typeshed import Incomplete
from collections.abc import Generator, Sequence
from torch.overrides import BaseTorchFunctionMode as BaseTorchFunctionMode
from typing import Any, Callable

class NoEnterTorchFunctionMode(BaseTorchFunctionMode):
    def __enter__(self) -> None: ...

def index(iterator, item, start: int = 0, end=None): ...
def repeat(item, count) -> Generator[Incomplete]: ...
def radians(x): ...
def accumulate_grad(x, new_grad) -> None: ...
def list_cmp(op: Callable[[Any, Any], bool], left: Sequence[Any], right: Sequence[Any]):
    """emulate `(1,2,3) > (1,2)` etc"""
def set_symmetric_difference(set1, set2): ...
def set_symmetric_difference_update(set1, set2) -> None: ...
def set_isdisjoint(set1, set2): ...
def set_intersection(set1, *others): ...
def set_intersection_update(set1, *others) -> None: ...
def set_union(set1, *others): ...
def set_update(set1, *others): ...
def set_difference(set1, *others): ...
def set_difference_update(set1, *others) -> None: ...
def getattr_and_trace(*args, **kwargs): ...
def mapping_get(obj, key, value=None): ...
def instantiate_user_defined_class_object(cls, /, *args, **kwargs): ...
def construct_dict(cls, /, *args, **kwargs): ...
def foreach_map_fn(*args): ...
def foreach_lerp_inplace(self, end, weight): ...
def foreach_pow_scalar(scalar, exps): ...
def addcmul_inplace(self, tensor1, tensor2, value): ...
def predicate(obj: Any) -> bool: ...
def cmp_eq(a, b): ...
def cmp_ne(a, b): ...
def cmp_lt(a, b): ...
def cmp_le(a, b): ...
def cmp_gt(a, b): ...
def cmp_ge(a, b): ...
