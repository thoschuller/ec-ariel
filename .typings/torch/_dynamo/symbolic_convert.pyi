import contextlib
import dataclasses
import functools
import types
import typing
from . import config as config, exc as exc, graph_break_hints as graph_break_hints, trace_rules as trace_rules, variables as variables
from .bytecode_analysis import JUMP_OPNAMES as JUMP_OPNAMES, get_indexof as get_indexof, livevars_analysis as livevars_analysis, propagate_line_nums as propagate_line_nums
from .bytecode_transformation import Instruction as Instruction, cleaned_instructions as cleaned_instructions, create_call_function as create_call_function, create_instruction as create_instruction, create_jump_absolute as create_jump_absolute, create_swap as create_swap, get_code_keys as get_code_keys, is_generator as is_generator, unique_id as unique_id
from .code_context import code_context as code_context
from .codegen import PyCodegen as PyCodegen
from .exc import ArgsMismatchError as ArgsMismatchError, BackendCompilerFailed as BackendCompilerFailed, Unsupported as Unsupported, collapse_resume_frames as collapse_resume_frames, format_graph_break_message as format_graph_break_message, get_stack_above_dynamo as get_stack_above_dynamo, unimplemented_v2 as unimplemented_v2
from .funcname_cache import get_funcname as get_funcname
from .guards import GuardBuilder as GuardBuilder, install_guard as install_guard
from .output_graph import GraphCompileReason as GraphCompileReason, OutputGraph as OutputGraph
from .package import CompilePackage as CompilePackage
from .replay_record import DummyModule as DummyModule, ExecutionRecorder as ExecutionRecorder
from .resume_execution import ContinueExecutionCache as ContinueExecutionCache, ReenterWith as ReenterWith
from .source import AttrSource as AttrSource, DictGetItemSource as DictGetItemSource, GlobalSource as GlobalSource, GlobalWeakRefSource as GlobalWeakRefSource, LocalCellSource as LocalCellSource, LocalSource as LocalSource, Source as Source
from .trace_rules import is_builtin_constant as is_builtin_constant, is_forbidden as is_forbidden
from .utils import LazyString as LazyString, counters as counters, get_fake_value as get_fake_value, get_instruction_source_311 as get_instruction_source_311, get_metrics_context as get_metrics_context, graph_break_dup_warning_checker as graph_break_dup_warning_checker, istype as istype, proxy_args_kwargs as proxy_args_kwargs
from .variables.base import ValueMutationNew as ValueMutationNew, VariableTracker as VariableTracker, typestr as typestr
from .variables.builder import FrameStateSizeEntry as FrameStateSizeEntry, VariableBuilder as VariableBuilder, wrap_fx_proxy as wrap_fx_proxy
from .variables.builtin import BuiltinVariable as BuiltinVariable
from .variables.constant import ConstantVariable as ConstantVariable
from .variables.ctx_manager import ContextWrappingVariable as ContextWrappingVariable, GenericContextWrappingVariable as GenericContextWrappingVariable, WithExitFunctionVariable as WithExitFunctionVariable
from .variables.dicts import ConstDictVariable as ConstDictVariable, SetVariable as SetVariable
from .variables.functions import BaseUserFunctionVariable as BaseUserFunctionVariable, LocalGeneratorFunctionVariable as LocalGeneratorFunctionVariable, LocalGeneratorObjectVariable as LocalGeneratorObjectVariable, NestedUserFunctionVariable as NestedUserFunctionVariable, SkipFunctionVariable as SkipFunctionVariable, UserFunctionVariable as UserFunctionVariable, UserMethodVariable as UserMethodVariable
from .variables.iter import MAX_ITERATOR_LIMIT as MAX_ITERATOR_LIMIT
from .variables.lazy import LazyVariableTracker as LazyVariableTracker
from .variables.lists import BaseListVariable as BaseListVariable, ListIteratorVariable as ListIteratorVariable, ListVariable as ListVariable, SliceVariable as SliceVariable, TupleVariable as TupleVariable
from .variables.misc import CellVariable as CellVariable, ExceptionVariable as ExceptionVariable, GetAttrVariable as GetAttrVariable, NullVariable as NullVariable, PythonModuleVariable as PythonModuleVariable, UnknownVariable as UnknownVariable
from .variables.nn_module import NNModuleVariable as NNModuleVariable
from .variables.tensor import SymNodeVariable as SymNodeVariable, TensorVariable as TensorVariable, supported_comparison_ops as supported_comparison_ops
from .variables.torch_function import SymbolicTorchFunctionState as SymbolicTorchFunctionState, TorchFunctionModeVariable as TorchFunctionModeVariable
from .variables.user_defined import RemovableHandleVariable as RemovableHandleVariable, UserDefinedClassVariable as UserDefinedClassVariable, UserDefinedExceptionClassVariable as UserDefinedExceptionClassVariable, UserDefinedExceptionObjectVariable as UserDefinedExceptionObjectVariable, UserDefinedObjectVariable as UserDefinedObjectVariable
from _typeshed import Incomplete
from collections.abc import Generator
from torch._dynamo.exc import TensorifyScalarRestartAnalysis as TensorifyScalarRestartAnalysis
from torch._guards import TracingContext as TracingContext, tracing as tracing
from torch._logging.structured import dump_file as dump_file
from torch.fx.experimental.symbolic_shapes import guard_bool as guard_bool
from torch.utils._functools import cache_method as cache_method
from typing import Any, Callable, NoReturn

log: Incomplete
graph_break_log: Incomplete
trace_call_log: Incomplete
trace_source_log: Incomplete
trace_bytecode_log: Incomplete
tls: Incomplete
compare_op_handlers: dict[str, Any]
handle_contains: Incomplete
handle_not: Incomplete
PT2_ISSUE_TRACKER_URL: str

@functools.cache
def _import_module(name: str) -> types.ModuleType:
    """
    Import the named module and cache the result. importlib.import_module()
    seems to do some filesystem checking to validate the name so not caching
    this can be slow.
    """

@dataclasses.dataclass
class SpeculationEntry:
    filename: str
    lineno: int
    instruction_pointer: int
    inst: Instruction
    failed: bool = ...
    reason: GraphCompileReason | None = ...
    def fail_and_restart_analysis(self) -> None:
        """
        Start tracing of the current frame over again, and don't take this branch.
        """

@dataclasses.dataclass
class SpeculationLog:
    """
    SpeculationLog replaces the prior copy_graphstate/restore_graphstate
    checkpointing.  Rather than saving/restoring state, we restart the
    dynamo conversion process over from the beginning -- but when we
    hit the start of the speculation that failed, we instead generate
    a graph break.
    """
    entries: list[SpeculationEntry] = dataclasses.field(default_factory=list)
    index: int = ...
    def restart(self) -> None: ...
    def clear(self) -> None: ...
    def next(self, filename: str, lineno: int, instruction_pointer, inst) -> SpeculationEntry:
        """
        Lookup or create a SpeculationEntry() that is shared across
        RestartAnalysis calls.  Args are used only for debug checks.
        """

@dataclasses.dataclass
class LocalState:
    automatic_dynamic: dict[str, FrameStateSizeEntry] = dataclasses.field(default_factory=dict)
    def render(self) -> str: ...

@dataclasses.dataclass
class DistributedState:
    compile_pg: Any
    local_state: LocalState
    all_states: list[LocalState] | None = ...

class TensorifyState:
    force_specializations: set[str]
    @classmethod
    def specialize(cls, index: str) -> None: ...
    @classmethod
    def should_specialize(cls, index: str) -> bool: ...
    @classmethod
    def clear(cls) -> None: ...
    @classmethod
    def empty(cls) -> bool: ...

@functools.cache
def _step_logger(): ...
@contextlib.contextmanager
def save_and_restart_speculation_log(tx: InstructionTranslatorBase): ...
@contextlib.contextmanager
def temporarely_allow_writes_to_output_graph(tx: InstructionTranslatorBase): ...

@dataclasses.dataclass
class BlockStackEntry:
    inst: Instruction
    target: Instruction
    stack_index: int
    with_context: ContextWrappingVariable | GenericContextWrappingVariable | None = ...
    def can_restore(self): ...
    def resume_fn(self): ...
    def exit(self, tx, is_graph_break): ...

class SpeculationLogDivergence(AssertionError): ...
class ReturnValueOp(Exception): ...
class YieldValueOp(Exception):
    """
    Signal to the symbolic tracer to stop and return control flow to the
    caller
    """

def stack_op(fn: typing.Callable[..., object]): ...
def _detect_and_normalize_assert_statement(self, truth_fn: typing.Callable[[object], bool], push: bool): ...

explain: bool

def log_graph_break(code_options, reason: str = '', exc_info: bool = False, user_stack=None): ...
def generic_jump(truth_fn: typing.Callable[[object], bool], push: bool): ...
def break_graph_if_unsupported(*, push): ...

class BytecodeDistpatchTableMeta(type):
    """Installs a `cls.dispatch_table` on every subclass to speed up calls to self.OPCODE()"""
    def __init__(cls, name, bases, dct) -> None: ...

@dataclasses.dataclass
class ExceptionStack:
    """
    Exception stack that it is shared among all InstructionTranslator instances
    """
    _exc_stack: list[VariableTracker] = dataclasses.field(default_factory=list)
    _current_exception: VariableTracker | None = dataclasses.field(default=None)
    def clear_current_exception(self) -> None: ...
    def set_current_exception(self, val) -> None: ...
    def move_current_exception_to_stack(self) -> None: ...
    def get_current_exception(self): ...
    def _set_context_recursive(self, val, prev_idx): ...
    def _break_context_reference_cycle(self, val) -> None: ...
    def _set_context_and_break_context_reference_cycle(self, val) -> None: ...
    def pop(self): ...
    def append(self, val) -> None: ...
    def __len__(self) -> int: ...
    def __getitem__(self, index): ...
    def __str__(self) -> str: ...
    __repr__ = __str__

class InstructionTranslatorBase(metaclass=BytecodeDistpatchTableMeta):
    output: OutputGraph
    symbolic_locals: dict[str, VariableTracker]
    symbolic_globals: dict[str, VariableTracker]
    symbolic_torch_function_state: SymbolicTorchFunctionState
    stack: list[VariableTracker]
    instruction_pointer: int | None
    current_instruction: Instruction
    block_stack: list[BlockStackEntry]
    lineno: int
    kw_names: ConstantVariable | None
    accept_prefix_inst: bool
    prefix_insts: list[Instruction]
    inline_depth: int
    inconsistent_side_effects: bool
    current_speculation: SpeculationEntry | None
    dispatch_table: list[Any]
    exn_vt_stack: ExceptionStack
    exec_recorder: ExecutionRecorder | None
    strict_checks_fn: Callable[[VariableTracker], bool] | None
    start_point: int | None
    is_leaf_tracer: bool
    parent: InstructionTranslatorBase | None
    debug_locals: list[tuple[VariableTracker, list[VariableTracker]]]
    package: CompilePackage | None
    def mark_inconsistent_side_effects(self) -> None:
        """
        InstructionTranslator has encountered instructions which may cause
        dynamo to see a different version of history from eager
        See: https://github.com/pytorch/pytorch/issues/110765
        """
    def maybe_has_backedge(self): ...
    _cellvars: Incomplete
    def cellvars(self): ...
    _freevars: Incomplete
    def freevars(self): ...
    _cell_and_freevars: Incomplete
    def cell_and_freevars(self): ...
    def prune_dead_locals(self) -> None: ...
    def call_function(self, fn: VariableTracker, args: list[VariableTracker], kwargs: dict[str, VariableTracker]): ...
    def inline_generator_function(self, fn, args, kwargs):
        '''
        Redirect the call to the generator "call_function"
        '''
    def inline_user_function_return(self, fn, args, kwargs):
        """
        A call to some user defined function by inlining it.
        """
    def get_line_of_code_header(self, lineno=None): ...
    def get_log_starts_line_log_str(self): ...
    def starts_line(self, lineno) -> None: ...
    def step(self):
        """Process exactly one instruction, return False we should exit"""
    def update_block_stack(self, inst) -> None: ...
    @property
    def next_instruction(self): ...
    def step_graph_break(self, continue_inst) -> None: ...
    def run_ctx_mgr(self): ...
    def run(self) -> None: ...
    def push(self, val: VariableTracker | None): ...
    def push_many(self, vals: list[VariableTracker]): ...
    def pop(self) -> VariableTracker: ...
    def popn(self, n: int) -> list[VariableTracker]: ...
    def LOAD_FAST(self, inst) -> None: ...
    def LOAD_DEREF(self, inst) -> None: ...
    def STORE_FAST(self, inst) -> None: ...
    def DELETE_FAST(self, inst) -> None: ...
    def STORE_DEREF(self, inst) -> None: ...
    LOAD_CLOSURE = LOAD_FAST
    def _load_const(self, inst): ...
    def LOAD_CONST(self, inst) -> None: ...
    def _load_global(self, inst): ...
    @functools.cached_property
    def nn_modules_globals_vt(self): ...
    def LOAD_GLOBAL(self, inst) -> None: ...
    def STORE_GLOBAL(self, inst) -> None: ...
    @cache_method
    def import_source(self, module_name):
        """Create an alias to a module for use in guards"""
    def resolve_name(self, name, package, level):
        """
        Copied from the Cpython implementation of __import__
        Resolve a relative module name to an absolute one.
        https://github.com/python/cpython/blob/5a094f0255eea1db58fb2cf14c200971e64ec36e/Lib/importlib/_bootstrap.py#L902
        """
    def calc_package(self):
        """
        Copied from the Cpython implementation of __import__
        https://github.com/python/cpython/blob/5a094f0255eea1db58fb2cf14c200971e64ec36e/Lib/importlib/_bootstrap.py#L1090
        """
    def IMPORT_NAME(self, inst) -> None: ...
    EAGER_IMPORT_NAME = IMPORT_NAME
    def IMPORT_FROM(self, inst) -> None: ...
    @cache_method
    def load_builtin_from_argval(self, argval): ...
    def load_builtin(self, inst) -> None: ...
    def jump(self, inst) -> None: ...
    JUMP_FORWARD = jump
    JUMP_ABSOLUTE = jump
    POP_JUMP_IF_FALSE: Incomplete
    POP_JUMP_IF_TRUE: Incomplete
    JUMP_IF_FALSE_OR_POP: Incomplete
    JUMP_IF_TRUE_OR_POP: Incomplete
    def SETUP_LOOP(self, inst) -> None: ...
    def SETUP_EXCEPT(self, inst) -> None: ...
    def POP_BLOCK(self, inst) -> None: ...
    def SETUP_WITH(self, inst) -> None: ...
    def SETUP_FINALLY(self, inst) -> None: ...
    def BEGIN_FINALLY(self, inst) -> None: ...
    def WITH_CLEANUP_START(self, inst) -> None: ...
    def WITH_CLEANUP_FINISH(self, inst) -> None: ...
    def FOR_ITER(self, inst) -> None: ...
    def _create_exception_type(self, val): ...
    def _raise_exception_variable(self, val) -> NoReturn: ...
    def RAISE_VARARGS(self, inst) -> None: ...
    def CLEANUP_THROW(self, inst) -> None: ...
    def RERAISE(self, inst) -> None: ...
    def _isinstance_exception(self, val): ...
    def WITH_EXCEPT_START(self, inst) -> None: ...
    def exception_handler(self, raised_exception) -> None: ...
    def PUSH_EXC_INFO(self, inst) -> None: ...
    def POP_EXCEPT(self, inst) -> None: ...
    def check_if_exc_matches(self): ...
    def CHECK_EXC_MATCH(self, inst) -> None: ...
    def JUMP_IF_NOT_EXC_MATCH(self, inst) -> None: ...
    def COMPARE_OP(self, inst) -> None: ...
    def GET_ITER(self, inst) -> None: ...
    def CALL_FUNCTION(self, inst) -> None: ...
    def CALL_FUNCTION_EX(self, inst) -> None: ...
    def CALL_FUNCTION_KW(self, inst) -> None: ...
    def LOAD_METHOD_SUPER(self, inst) -> None: ...
    def LOAD_ATTR_SUPER(self, inst) -> None: ...
    def LOAD_METHOD(self, inst) -> None: ...
    def CALL_METHOD(self, inst) -> None: ...
    def _load_attr(self, inst) -> None: ...
    def LOAD_ATTR(self, inst) -> None: ...
    def STORE_ATTR(self, inst): ...
    def store_attr_graph_break(self, inst) -> None: ...
    def DELETE_ATTR(self, inst) -> None: ...
    def create_call_resume_at(self, offset, all_stack_locals_metadata) -> None: ...
    def should_compile_partial_graph(self) -> bool: ...
    def STORE_SUBSCR(self, inst) -> None: ...
    def DELETE_SUBSCR(self, inst) -> None: ...
    def BUILD_TUPLE(self, inst) -> None: ...
    def BUILD_SLICE(self, inst) -> None: ...
    def BUILD_LIST(self, inst) -> None: ...
    def BUILD_SET(self, inst) -> None: ...
    def BUILD_LIST_UNPACK(self, inst, cls=...) -> None: ...
    def BUILD_TUPLE_UNPACK(self, inst) -> None: ...
    BUILD_TUPLE_UNPACK_WITH_CALL = BUILD_TUPLE_UNPACK
    def BUILD_MAP(self, inst) -> None: ...
    def BUILD_MAP_UNPACK(self, inst) -> None: ...
    BUILD_MAP_UNPACK_WITH_CALL = BUILD_MAP_UNPACK
    def BUILD_CONST_KEY_MAP(self, inst) -> None: ...
    def MAP_ADD(self, inst) -> None: ...
    def SET_ADD(self, inst): ...
    def SET_UPDATE(self, inst) -> None: ...
    def LIST_APPEND(self, inst) -> None: ...
    def MAKE_FUNCTION(self, inst) -> None: ...
    def UNPACK_SEQUENCE(self, inst) -> None: ...
    def UNPACK_EX(self, inst) -> None: ...
    def NOP(self, inst) -> None: ...
    def POP_TOP(self, inst) -> None: ...
    def ROT_TWO(self, inst) -> None: ...
    def ROT_THREE(self, inst) -> None: ...
    def ROT_FOUR(self, inst) -> None: ...
    def DUP_TOP(self, inst) -> None: ...
    def DUP_TOP_TWO(self, inst) -> None: ...
    def _convert_value(self, value, flag): ...
    def _format_value(self, fmt_spec, flags) -> None: ...
    def FORMAT_VALUE(self, inst): ...
    def BUILD_STRING(self, inst) -> None: ...
    def IS_OP(self, inst) -> None: ...
    def CONTAINS_OP(self, inst) -> None: ...
    def LIST_EXTEND(self, inst) -> None: ...
    def LIST_TO_TUPLE(self, inst) -> None: ...
    def STOPITERATION_ERROR(self, inst) -> None: ...
    def DICT_MERGE(self, inst) -> None: ...
    DICT_UPDATE = DICT_MERGE
    def GEN_START(self, inst) -> None: ...
    def GET_LEN(self, inst) -> None: ...
    def MATCH_MAPPING(self, inst) -> None: ...
    def MATCH_SEQUENCE(self, inst) -> None: ...
    def MATCH_KEYS(self, inst) -> None: ...
    def LOAD_ASSERTION_ERROR(self, inst) -> None: ...
    def LOAD_BUILD_CLASS(self, inst) -> None: ...
    UNARY_POSITIVE: Incomplete
    UNARY_NEGATIVE: Incomplete
    UNARY_NOT: Incomplete
    UNARY_INVERT: Incomplete
    BINARY_POWER: Incomplete
    BINARY_MULTIPLY: Incomplete
    BINARY_MATRIX_MULTIPLY: Incomplete
    BINARY_FLOOR_DIVIDE: Incomplete
    BINARY_TRUE_DIVIDE: Incomplete
    BINARY_MODULO: Incomplete
    BINARY_REMAINDER: Incomplete
    BINARY_ADD: Incomplete
    BINARY_SUBTRACT: Incomplete
    BINARY_SUBSCR: Incomplete
    BINARY_LSHIFT: Incomplete
    BINARY_RSHIFT: Incomplete
    BINARY_AND: Incomplete
    BINARY_OR: Incomplete
    BINARY_XOR: Incomplete
    INPLACE_POWER: Incomplete
    INPLACE_MULTIPLY: Incomplete
    INPLACE_MATRIX_MULTIPLY: Incomplete
    INPLACE_FLOOR_DIVIDE: Incomplete
    INPLACE_TRUE_DIVIDE: Incomplete
    INPLACE_MODULO: Incomplete
    INPLACE_REMAINDER: Incomplete
    INPLACE_ADD: Incomplete
    INPLACE_SUBTRACT: Incomplete
    INPLACE_LSHIFT: Incomplete
    INPLACE_RSHIFT: Incomplete
    INPLACE_AND: Incomplete
    INPLACE_XOR: Incomplete
    INPLACE_OR: Incomplete
    def RESUME(self, inst) -> None: ...
    def BINARY_OP(self, inst): ...
    def PRECALL(self, inst) -> None: ...
    def KW_NAMES(self, inst) -> None: ...
    def PUSH_NULL(self, inst) -> None: ...
    def _call(self, inst, call_kw: bool = False) -> None: ...
    def CALL(self, inst) -> None: ...
    def COPY(self, inst) -> None: ...
    def SWAP(self, inst) -> None: ...
    JUMP_BACKWARD = jump
    JUMP_BACKWARD_NO_INTERRUPT = jump
    POP_JUMP_FORWARD_IF_TRUE: Incomplete
    POP_JUMP_BACKWARD_IF_TRUE: Incomplete
    POP_JUMP_FORWARD_IF_FALSE: Incomplete
    POP_JUMP_BACKWARD_IF_FALSE: Incomplete
    def CACHE(self, inst) -> None: ...
    def BEFORE_WITH(self, inst) -> None: ...
    def setup_or_before_with(self, inst) -> None: ...
    def append_prefix_inst(self, inst) -> None: ...
    def MAKE_CELL(self, inst) -> None: ...
    def COPY_FREE_VARS(self, inst) -> None: ...
    def RETURN_GENERATOR(self, inst) -> None: ...
    def END_FOR(self, inst) -> None: ...
    def LOAD_FAST_CHECK(self, inst) -> None: ...
    def LOAD_FAST_AND_CLEAR(self, inst) -> None: ...
    def LOAD_SUPER_ATTR(self, inst) -> None: ...
    def CALL_INTRINSIC_1(self, inst) -> None: ...
    def END_SEND(self, inst) -> None: ...
    def CALL_KW(self, inst) -> None: ...
    def TO_BOOL(self, inst) -> None: ...
    def SET_FUNCTION_ATTRIBUTE(self, inst) -> None: ...
    def CONVERT_VALUE(self, inst) -> None: ...
    def FORMAT_SIMPLE(self, inst) -> None: ...
    def FORMAT_WITH_SPEC(self, inst) -> None: ...
    def is_non_empty_graph(self): ...
    def format_frame_summary(self, additional_stack_frames=None): ...
    def frame_summary(self): ...
    def is_co_filename_from_nn_modules(self): ...
    def store_global_weakref_by_id(self, prefix, value): ...
    @property
    def fake_mode(self): ...
    @contextlib.contextmanager
    def strict_translation_mode(self, check_fn: Callable[[VariableTracker], bool]):
        """
        Strict mode is enabled on a per-VariableTracker level depending on the return value of check_fn(node).
        """
    def speculate(self) -> SpeculationEntry: ...
    speculation_log: Incomplete
    distributed_state: Incomplete
    active_generic_context_managers: list[GenericContextWrappingVariable]
    instructions: list[Instruction]
    indexof: dict[Instruction, int]
    f_locals: dict[str, Any]
    f_globals: dict[str, Any]
    f_builtins: dict[str, Any]
    code_options: dict[str, Any]
    f_code: types.CodeType
    nn_module_stack: dict[str, tuple[str, type[Any]]]
    num_calls: dict[str, int]
    export: Incomplete
    one_graph: bool
    _constants_cache: list[VariableTracker | None]
    is_trace_bytecode_log_enabled: bool | None
    is_trace_source_log_enabled: bool | None
    def __init__(self, output: OutputGraph, instructions: list[Instruction], f_locals: dict[str, Any], f_globals: dict[str, Any], f_builtins: dict[str, Any], code_options: dict[str, Any], symbolic_locals: dict[str, VariableTracker], symbolic_globals: dict[str, VariableTracker], symbolic_torch_function_state: SymbolicTorchFunctionState, f_code: types.CodeType, export: bool, inline_depth: int, speculation_log: SpeculationLog, exn_vt_stack: ExceptionStack, distributed_state: DistributedState | None, closure: tuple[types.CellType] | None = None, package: CompilePackage | None = None) -> None: ...

class InstructionTranslator(InstructionTranslatorBase):
    @staticmethod
    def current_tx() -> InstructionTranslator: ...
    @contextlib.contextmanager
    def set_current_tx(self) -> Generator[None]: ...
    one_graph: bool
    export: Incomplete
    symbolic_locals: Incomplete
    symbolic_torch_function_state: Incomplete
    def __init__(self, instructions: list[Instruction], f_code, f_locals, f_globals, f_builtins, closure, torch_function_mode_stack, code_options, compiler_fn, one_graph, export, export_constraints, frame_state, speculation_log: SpeculationLog, exn_vt_stack: ExceptionStack, distributed_state: DistributedState | None, package: CompilePackage | None) -> None: ...
    def _throw_if_in_functorch(self) -> None: ...
    def get_example_value(self, source: Source): ...
    def run(self) -> None: ...
    def should_compile_partial_graph(self): ...
    instruction_pointer: Incomplete
    def create_call_resume_at(self, inst, all_stack_locals_metadata): ...
    def symbolic_locals_contain_module_class(self): ...
    def replace_tos_if_return_is_generator(self) -> None: ...
    def _return(self, inst) -> None: ...
    def RETURN_VALUE(self, inst) -> None: ...
    def RETURN_CONST(self, inst) -> None: ...

_binary_op_lookup: Incomplete

class InliningInstructionTranslator(InstructionTranslatorBase):
    """Trace and inline a called method"""
    symbolic_result: VariableTracker | None
    parent: InstructionTranslatorBase
    @classmethod
    def inline_call(cls, parent, func, args, kwargs): ...
    @staticmethod
    def check_inlineable(func): ...
    @staticmethod
    def build_inline_tracer(parent, func: VariableTracker, args: list[VariableTracker], kwargs): ...
    def inline_call_(self): ...
    funcvar: Incomplete
    num_calls: Incomplete
    nn_module_stack: Incomplete
    one_graph: Incomplete
    def __init__(self, parent: InstructionTranslatorBase, code: types.CodeType, symbolic_locals: dict[str, VariableTracker], symbolic_globals: dict[str, VariableTracker], symbolic_torch_function_state: SymbolicTorchFunctionState, funcvar: BaseUserFunctionVariable) -> None: ...
    @property
    def fake_mode(self): ...
    def run_ctx_mgr(self): ...
    def should_compile_partial_graph(self): ...
    def create_call_resume_at(self, inst, all_stack_locals_metadata) -> None: ...
    instruction_pointer: Incomplete
    def RETURN_VALUE(self, inst) -> None: ...
    def RETURN_CONST(self, inst) -> None: ...
    def get_globals_source_and_value(self, name): ...
    def _load_global(self, inst): ...
    def STORE_GLOBAL(self, inst) -> None: ...

class InliningGeneratorInstructionTranslator(InliningInstructionTranslator):
    generated_items: list[VariableTracker]
    generator_exhausted: bool
    is_generator_from_ctx_manager: bool
    def __init__(self, *args, **kwargs) -> None: ...
    symbolic_result: Incomplete
    def YIELD_VALUE(self, inst: Instruction): ...
    def GET_YIELD_FROM_ITER(self, inst) -> None: ...
    def RETURN_VALUE(self, inst): ...
    def RETURN_CONST(self, inst): ...
    def YIELD_FROM(self, inst) -> None: ...
    def SEND(self, inst) -> None: ...
