import dataclasses
import functools
import types
from . import config as config
from .resume_execution import TORCH_DYNAMO_RESUME_IN_PREFIX as TORCH_DYNAMO_RESUME_IN_PREFIX
from .utils import NP_SUPPORTED_MODULES as NP_SUPPORTED_MODULES, getfile as getfile, hashable as hashable, unwrap_if_wrapper as unwrap_if_wrapper
from .variables import BuiltinVariable as BuiltinVariable, FunctionalCallVariable as FunctionalCallVariable, FunctorchHigherOrderVariable as FunctorchHigherOrderVariable, LocalGeneratorFunctionVariable as LocalGeneratorFunctionVariable, LocalGeneratorObjectVariable as LocalGeneratorObjectVariable, NestedUserFunctionVariable as NestedUserFunctionVariable, PolyfilledFunctionVariable as PolyfilledFunctionVariable, SkipFunctionVariable as SkipFunctionVariable, TorchInGraphFunctionVariable as TorchInGraphFunctionVariable, UserFunctionVariable as UserFunctionVariable, UserMethodVariable as UserMethodVariable
from .variables.base import VariableTracker as VariableTracker
from _typeshed import Incomplete
from torch._environment import is_fbcode as is_fbcode
from torch.utils import _config_module as _config_module
from typing import Any, Callable

np: types.ModuleType | None
manual_torch_name_rule_map: dict[str, Any]
torch_c_binding_in_graph_functions: Incomplete
torch_non_c_binding_in_graph_functions: Incomplete
torch_name_rule_map: Incomplete

@functools.cache
def get_torch_obj_rule_map() -> dict[Any, type['VariableTracker']]: ...
def _load_obj_from_str(fully_qualified_name): ...
def load_object(name): ...
@functools.cache
def get_tensor_method(): ...
def is_aten_op_or_tensor_method(obj): ...

class FunctionIdSet:
    """
    Track a set of `id()`s of objects which are either allowed or not
    allowed to go into the generated FX graph.  Use to test for torch.*,
    numpy.*, builtins.*, etc.

    Support user modification to permit customization of what can be
    added to the graph and what will cause a graph break.
    """
    function_ids: set[int] | None
    function_names: dict[int, str] | None
    lazy_initializer: Incomplete
    def __init__(self, lazy_initializer: Callable[[], dict[int, str] | set[int]]) -> None: ...
    def __call__(self) -> set[int]: ...
    def get_name(self, idx: int, default: str): ...
    def add(self, idx: int): ...
    def remove(self, idx: int): ...
    def __contains__(self, idx: int) -> bool: ...

@FunctionIdSet
def _allowed_callable_ids() -> dict[int, str]: ...
@FunctionIdSet
def _disallowed_callable_ids() -> dict[int, str]: ...
@FunctionIdSet
def _nonstrict_trace_callable_ids() -> dict[int, str]: ...
@FunctionIdSet
def _builtin_function_ids() -> dict[int, str]: ...
@FunctionIdSet
def _polyfilled_function_ids() -> set[int]: ...
@FunctionIdSet
def _numpy_function_ids() -> dict[int, str]: ...
@FunctionIdSet
def _builtin_constant_ids() -> dict[int, str]:
    """
    Collects constant builtins by eliminating callable items.
    """

_lazy_module_init: dict[str, list[Callable[[], None]]]

def add_module_init_func(name: str, init_func: Callable[[], None]) -> None:
    """Register a module without eagerly importing it"""
def _maybe_init_lazy_module(obj: object) -> None: ...
def is_callable_allowed(obj) -> bool: ...
def is_nonstrict_trace_callable(obj) -> bool: ...
def is_callable_disallowed(obj) -> bool: ...
def is_forbidden(obj) -> bool: ...
def is_builtin_callable(obj) -> bool: ...
def is_builtin_constant(obj) -> bool: ...
def is_polyfilled_callable(obj) -> bool: ...
def is_numpy(obj) -> bool: ...
def is_numpy_dtype(obj) -> bool: ...
def is_numpy_type_info(obj) -> bool: ...

BUILTIN_SKIPLIST: Incomplete
THIRDPARTY_SKIPLIST: Incomplete

def _as_posix_path(path): ...
def _strip_init_py(s): ...
def _module_dir(m: types.ModuleType): ...

LEGACY_MOD_INLINELIST: Incomplete
MOD_INLINELIST: Incomplete
MOD_SKIPLIST: Incomplete

@functools.cache
def get_legacy_mod_inlinelist(): ...
@functools.cache
def get_mod_inlinelist(): ...
@functools.cache
def get_mod_skiplist(): ...

SKIP_DIRS: Incomplete
SKIP_DIRS_RE: Incomplete
FBCODE_SKIP_DIRS: set[str]
FBCODE_SKIP_DIRS_RE: Incomplete
FBCODE_SKIP_TORCHREC_DIRS: Incomplete
FBCODE_SKIP_TORCHREC_DIRS_RE: Incomplete
FBCODE_INLINE_FILES_IN_SKIPPED_DIRS: Incomplete
FBCODE_INLINE_FILES_IN_SKIPPED_DIRS_RE: Incomplete
FORCE_SKIP_FILES: Incomplete

def _recompile_re() -> None: ...
def add(import_name: str): ...

@dataclasses.dataclass
class SkipResult:
    skipped: bool
    reason: str | None

def check_file(filename, is_inlined_call: bool = False):
    """Should skip this file?"""

@dataclasses.dataclass
class FunctionInfo:
    py_obj: object | None
    name: str | None
    filename: str
    code: types.CodeType | None

def check_verbose(obj, is_inlined_call: bool = False): ...
def check(obj, is_inlined_call: bool = False): ...
def is_torch_inline_allowed(filename): ...
@functools.cache
def dynamo_dir(): ...
def is_torch(filename): ...
def lookup_callable(obj): ...
def lookup(obj): ...
def lookup_inner(obj, name=None, filename=None, is_direct_call: bool = True, reasons: None | set[str] = None): ...
def _lookup_inner(obj, name=None, filename=None, is_direct_call: bool = True, reasons: None | set[str] = None): ...
def clear_lru_cache() -> None: ...
