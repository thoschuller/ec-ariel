import numpy
import torch
import types
from _typeshed import Incomplete
from torch import AVG as AVG, AcceleratorError as AcceleratorError, AggregationType as AggregationType, AliasDb as AliasDb, AnyType as AnyType, Argument as Argument, ArgumentSpec as ArgumentSpec, AwaitType as AwaitType, BenchmarkConfig as BenchmarkConfig, BenchmarkExecutionStats as BenchmarkExecutionStats, Block as Block, BoolType as BoolType, BufferDict as BufferDict, CallStack as CallStack, Capsule as Capsule, ClassType as ClassType, Code as Code, CompleteArgumentSpec as CompleteArgumentSpec, ComplexType as ComplexType, ConcreteModuleType as ConcreteModuleType, ConcreteModuleTypeBuilder as ConcreteModuleTypeBuilder, DeepCopyMemoTable as DeepCopyMemoTable, DeserializationStorageContext as DeserializationStorageContext, DeviceObjType as DeviceObjType, DictType as DictType, DispatchKey as DispatchKey, DispatchKeySet as DispatchKeySet, EnumType as EnumType, ErrorReport as ErrorReport, Event as Event, ExcludeDispatchKeyGuard as ExcludeDispatchKeyGuard, ExecutionPlan as ExecutionPlan, FatalError as FatalError, FileCheck as FileCheck, FloatType as FloatType, FunctionSchema as FunctionSchema, Future as Future, FutureType as FutureType, Gradient as Gradient, Graph as Graph, GraphExecutorState as GraphExecutorState, IODescriptor as IODescriptor, InferredType as InferredType, IntType as IntType, InterfaceType as InterfaceType, ListType as ListType, LiteScriptModule as LiteScriptModule, LockingLogger as LockingLogger, ModuleDict as ModuleDict, Node as Node, NoneType as NoneType, NoopLogger as NoopLogger, NumberType as NumberType, OperatorInfo as OperatorInfo, OptionalType as OptionalType, OutOfMemoryError as OutOfMemoryError, ParameterDict as ParameterDict, PyObjectType as PyObjectType, PyTorchFileReader as PyTorchFileReader, PyTorchFileWriter as PyTorchFileWriter, RRefType as RRefType, SUM as SUM, ScriptClass as ScriptClass, ScriptClassFunction as ScriptClassFunction, ScriptDict as ScriptDict, ScriptDictIterator as ScriptDictIterator, ScriptDictKeyIterator as ScriptDictKeyIterator, ScriptList as ScriptList, ScriptListIterator as ScriptListIterator, ScriptMethod as ScriptMethod, ScriptModule as ScriptModule, ScriptModuleSerializer as ScriptModuleSerializer, ScriptObject as ScriptObject, ScriptObjectProperty as ScriptObjectProperty, SerializationStorageContext as SerializationStorageContext, Size as Size, StaticModule as StaticModule, Stream as Stream, StreamObjType as StreamObjType, StringType as StringType, SymBoolType as SymBoolType, SymIntType as SymIntType, Tag as Tag, TensorType as TensorType, ThroughputBenchmark as ThroughputBenchmark, TracingState as TracingState, TupleType as TupleType, Type as Type, UnionType as UnionType, Use as Use, Value as Value, _additional_keys_to_prop_for_wrapper_tensors as _additional_keys_to_prop_for_wrapper_tensors, _after_ADInplaceOrView_keyset as _after_ADInplaceOrView_keyset, _after_autograd_keyset as _after_autograd_keyset, _dispatch_autogradother_backends as _dispatch_autogradother_backends, autocast_decrement_nesting as autocast_decrement_nesting, autocast_increment_nesting as autocast_increment_nesting, clear_autocast_cache as clear_autocast_cache, device as device, dtype as dtype, finfo as finfo, fork as fork, get_autocast_cpu_dtype as get_autocast_cpu_dtype, get_autocast_dtype as get_autocast_dtype, get_autocast_gpu_dtype as get_autocast_gpu_dtype, get_autocast_ipu_dtype as get_autocast_ipu_dtype, get_autocast_xla_dtype as get_autocast_xla_dtype, get_default_dtype as get_default_dtype, get_num_interop_threads as get_num_interop_threads, get_num_threads as get_num_threads, iinfo as iinfo, import_ir_module as import_ir_module, import_ir_module_from_buffer as import_ir_module_from_buffer, init_num_threads as init_num_threads, is_anomaly_check_nan_enabled as is_anomaly_check_nan_enabled, is_anomaly_enabled as is_anomaly_enabled, is_autocast_cache_enabled as is_autocast_cache_enabled, is_autocast_cpu_enabled as is_autocast_cpu_enabled, is_autocast_enabled as is_autocast_enabled, is_autocast_ipu_enabled as is_autocast_ipu_enabled, is_autocast_xla_enabled as is_autocast_xla_enabled, is_grad_enabled as is_grad_enabled, is_inference_mode_enabled as is_inference_mode_enabled, layout as layout, memory_format as memory_format, merge_type_from_type_comment as merge_type_from_type_comment, parse_ir as parse_ir, parse_schema as parse_schema, parse_type_comment as parse_type_comment, qscheme as qscheme, read_vitals as read_vitals, set_anomaly_enabled as set_anomaly_enabled, set_autocast_cache_enabled as set_autocast_cache_enabled, set_autocast_cpu_dtype as set_autocast_cpu_dtype, set_autocast_cpu_enabled as set_autocast_cpu_enabled, set_autocast_dtype as set_autocast_dtype, set_autocast_enabled as set_autocast_enabled, set_autocast_gpu_dtype as set_autocast_gpu_dtype, set_autocast_ipu_dtype as set_autocast_ipu_dtype, set_autocast_ipu_enabled as set_autocast_ipu_enabled, set_autocast_xla_dtype as set_autocast_xla_dtype, set_autocast_xla_enabled as set_autocast_xla_enabled, set_flush_denormal as set_flush_denormal, set_num_interop_threads as set_num_interop_threads, set_num_threads as set_num_threads, set_vital as set_vital, unify_type_list as unify_type_list, vitals_enabled as vitals_enabled, wait as wait
from torch._utils import _CUDAGraph as _CUDAGraph, _CudaEventBase as _CudaEventBase, _CudaStreamBase as _CudaStreamBase, _MemPool as _MemPool, _XpuEventBase as _XpuEventBase, _XpuStreamBase as _XpuStreamBase, _cuda_CUDAAllocator as _cuda_CUDAAllocator, _cuda_beginAllocateCurrentThreadToPool as _cuda_beginAllocateCurrentThreadToPool, _cuda_beginAllocateToPool as _cuda_beginAllocateToPool, _cuda_endAllocateToPool as _cuda_endAllocateToPool, _cuda_isCurrentStreamCapturing as _cuda_isCurrentStreamCapturing, _cuda_releasePool as _cuda_releasePool, _graph_pool_handle as _graph_pool_handle
from torch.backends.cuda import _SDPAParams as _SDPAParams
from torch.cuda.gds import _gds_deregister_buffer as _gds_deregister_buffer, _gds_deregister_handle as _gds_deregister_handle, _gds_load_storage as _gds_load_storage, _gds_register_buffer as _gds_register_buffer, _gds_register_handle as _gds_register_handle, _gds_save_storage as _gds_save_storage
from torch.distributed import _DistBackendError as _DistBackendError, _DistError as _DistError, _DistNetworkError as _DistNetworkError, _DistQueueEmptyError as _DistQueueEmptyError, _DistStoreError as _DistStoreError
from torch.jit import CompilationUnit as CompilationUnit, JITException as JITException, ScriptFunction as ScriptFunction
from torch.nn.attention import _SDPBackend as _SDPBackend
from typing import Any, Callable, ClassVar, overload

_GLIBCXX_USE_CXX11_ABI: bool
_PYBIND11_BUILD_ABI: str
_PYBIND11_COMPILER_TYPE: str
_PYBIND11_STDLIB: str
_VariableFunctions: _VariableFunctionsClass
_has_cuda: bool
_has_cudnn: bool
_has_cusparselt: bool
_has_kleidiai: bool
_has_magma: bool
_has_mkldnn: bool
_has_mps: bool
_has_xpu: bool
default_generator: Generator
has_lapack: bool
has_mkl: bool
has_openmp: bool
has_spectral: bool

class DisableTorchFunction:
    @classmethod
    def __init__(cls, *args, **kwargs) -> None:
        """Create and return a new object.  See help(type) for accurate signature."""
    def __enter__(self): ...
    def __exit__(self, type: type[BaseException] | None, value: BaseException | None, traceback: types.TracebackType | None): ...

class DisableTorchFunctionSubclass:
    @classmethod
    def __init__(cls, *args, **kwargs) -> None:
        """Create and return a new object.  See help(type) for accurate signature."""
    def __enter__(self): ...
    def __exit__(self, type: type[BaseException] | None, value: BaseException | None, traceback: types.TracebackType | None): ...

class Generator:
    """
    Generator(device='cpu') -> Generator

    Creates and returns a generator object that manages the state of the algorithm which
    produces pseudo random numbers. Used as a keyword argument in many :ref:`inplace-random-sampling`
    functions.

    Arguments:
        device (:class:`torch.device`, optional): the desired device for the generator.

    Returns:
        Generator: An torch.Generator object.

    Example::

        >>> # xdoctest: +REQUIRES(env:TORCH_DOCTEST_CUDA)
        >>> g_cpu = torch.Generator()
        >>> g_cuda = torch.Generator(device='cuda')
    """
    _cdata: Incomplete
    device: Any
    @overload
    @classmethod
    def __init__(cls, device=...) -> Generator:
        """Create and return a new object.  See help(type) for accurate signature."""
    @overload
    @classmethod
    def __init__(cls) -> Any:
        """Create and return a new object.  See help(type) for accurate signature."""
    @overload
    @classmethod
    def __init__(cls, device=...) -> Any:
        """Create and return a new object.  See help(type) for accurate signature."""
    @overload
    def clone_state(self) -> torch.Generator:
        """
        Generator.clone_state() -> torch.Generator

        Clones the current state of the generator and returns a new generator pointing to this cloned state.
        This method is beneficial for preserving a particular state of a generator to restore at a later point.

        Returns:
            torch.Generator: A Generator pointing to the newly cloned state.

        Example:
            >>> g_cuda = torch.Generator(device='cuda')
            >>> cloned_state = g_cuda.clone_state()
        """
    @overload
    def clone_state(self) -> Any:
        """
        Generator.clone_state() -> torch.Generator

        Clones the current state of the generator and returns a new generator pointing to this cloned state.
        This method is beneficial for preserving a particular state of a generator to restore at a later point.

        Returns:
            torch.Generator: A Generator pointing to the newly cloned state.

        Example:
            >>> g_cuda = torch.Generator(device='cuda')
            >>> cloned_state = g_cuda.clone_state()
        """
    def get_offset(self, *args, **kwargs): ...
    @overload
    def get_state(self) -> Tensor:
        """
        Generator.get_state() -> Tensor

        Returns the Generator state as a ``torch.ByteTensor``.

        Returns:
            Tensor: A ``torch.ByteTensor`` which contains all the necessary bits
            to restore a Generator to a specific point in time.

        Example::

            >>> g_cpu = torch.Generator()
            >>> g_cpu.get_state()
        """
    @overload
    def get_state(self) -> Any:
        """
        Generator.get_state() -> Tensor

        Returns the Generator state as a ``torch.ByteTensor``.

        Returns:
            Tensor: A ``torch.ByteTensor`` which contains all the necessary bits
            to restore a Generator to a specific point in time.

        Example::

            >>> g_cpu = torch.Generator()
            >>> g_cpu.get_state()
        """
    def graphsafe_get_state(self) -> torch.Generator:
        """
        Generator.graphsafe_get_state() -> torch.Generator

        Retrieves the current state of the generator in a manner that is safe for graph capture.
        This method is crucial for ensuring that the generator's state can be captured in the CUDA graph.

        Returns:
            torch.Generator: A Generator point to the current state of the generator

        Example:
            >>> g_cuda = torch.Generator(device='cuda')
            >>> current_state = g_cuda.graphsafe_get_state()
        """
    def graphsafe_set_state(self, state) -> None:
        """
        Generator.graphsafe_set_state(state) -> None

        Sets the state of the generator to the specified state in a manner that is safe for use in graph capture.
        This method is crucial for ensuring that the generator's state can be captured in the CUDA graph.

        Arguments:
            state (torch.Generator): A Generator point to the new state for the generator, typically obtained from `graphsafe_get_state`.

        Example:
            >>> g_cuda = torch.Generator(device='cuda')
            >>> g_cuda_other = torch.Generator(device='cuda')
            >>> current_state = g_cuda_other.graphsafe_get_state()
            >>> g_cuda.graphsafe_set_state(current_state)
        """
    @overload
    def initial_seed(self) -> int:
        """
        Generator.initial_seed() -> int

        Returns the initial seed for generating random numbers.

        Example::

            >>> g_cpu = torch.Generator()
            >>> g_cpu.initial_seed()
            2147483647
        """
    @overload
    def initial_seed(self) -> Any:
        """
        Generator.initial_seed() -> int

        Returns the initial seed for generating random numbers.

        Example::

            >>> g_cpu = torch.Generator()
            >>> g_cpu.initial_seed()
            2147483647
        """
    def manual_seed(self, seed) -> Generator:
        """
        Generator.manual_seed(seed) -> Generator

        Sets the seed for generating random numbers. Returns a `torch.Generator` object. Any 32-bit integer is a valid seed.

        Arguments:
            seed (int): The desired seed. Value must be within the inclusive range
                `[-0x8000_0000_0000_0000, 0xffff_ffff_ffff_ffff]`. Otherwise, a RuntimeError
                is raised. Negative inputs are remapped to positive values with the formula
                `0xffff_ffff_ffff_ffff + seed`.

        Returns:
            Generator: An torch.Generator object.

        Example::

            >>> g_cpu = torch.Generator()
            >>> g_cpu.manual_seed(2147483647)
        """
    @overload
    def seed(self) -> int:
        """
        Generator.seed() -> int

        Gets a non-deterministic random number from std::random_device or the current
        time and uses it to seed a Generator.

        Example::

            >>> g_cpu = torch.Generator()
            >>> g_cpu.seed()
            1516516984916
        """
    @overload
    def seed(self) -> Any:
        """
        Generator.seed() -> int

        Gets a non-deterministic random number from std::random_device or the current
        time and uses it to seed a Generator.

        Example::

            >>> g_cpu = torch.Generator()
            >>> g_cpu.seed()
            1516516984916
        """
    def set_offset(self, *args, **kwargs): ...
    def set_state(self, new_state) -> void:
        """
        Generator.set_state(new_state) -> void

        Sets the Generator state.

        Arguments:
            new_state (torch.ByteTensor): The desired state.

        Example::

            >>> g_cpu = torch.Generator()
            >>> g_cpu_other = torch.Generator()
            >>> g_cpu.set_state(g_cpu_other.get_state())
        """
    def __reduce__(self): ...

class LoggerBase:
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def _pybind11_conduit_v1_(self, *args, **kwargs): ...

class StorageBase:
    _cdata: Incomplete
    device: Incomplete
    @classmethod
    def __init__(cls, *args, **kwargs) -> None:
        """Create and return a new object.  See help(type) for accurate signature."""
    def _byteswap(self, *args, **kwargs): ...
    @staticmethod
    def _expired(*args, **kwargs): ...
    def _fix_weakref(self, *args, **kwargs): ...
    @staticmethod
    def _free_weak_ref(*args, **kwargs): ...
    def _get_filename(self, *args, **kwargs): ...
    def _get_shared_fd(self, *args, **kwargs): ...
    @staticmethod
    def _new_shared_cuda(*args, **kwargs): ...
    @staticmethod
    def _new_shared_fd_cpu(*args, **kwargs): ...
    @staticmethod
    def _new_shared_filename_cpu(*args, **kwargs): ...
    @staticmethod
    def _new_using_fd_cpu(*args, **kwargs): ...
    @staticmethod
    def _new_using_filename_cpu(*args, **kwargs): ...
    @staticmethod
    def _new_with_file(*args, **kwargs): ...
    @classmethod
    def _new_with_weak_ptr(cls, *args, **kwargs): ...
    @staticmethod
    def _release_ipc_counter_cuda(*args, **kwargs): ...
    def _set_cdata(self, *args, **kwargs): ...
    def _set_from_file(self, *args, **kwargs): ...
    def _share_cuda_(self, *args, **kwargs): ...
    def _share_fd_cpu_(self, *args, **kwargs): ...
    def _share_filename_cpu_(self, *args, **kwargs): ...
    def _shared_decref(self, *args, **kwargs): ...
    def _shared_incref(self, *args, **kwargs): ...
    def _weak_ref(self, *args, **kwargs): ...
    def _write_file(self, *args, **kwargs): ...
    def copy_(self, *args, **kwargs): ...
    def data_ptr(self, *args, **kwargs): ...
    def element_size(self, *args, **kwargs): ...
    def fill_(self, *args, **kwargs): ...
    @staticmethod
    def from_buffer(*args, **kwargs): ...
    @staticmethod
    def from_file(filename, shared=..., nbytes=...) -> Storage:
        """
        from_file(filename, shared=False, nbytes=0) -> Storage

        Creates a CPU storage backed by a memory-mapped file.

        If ``shared`` is ``True``, then memory is shared between all processes.
        All changes are written to the file. If ``shared`` is ``False``, then the changes on
        the storage do not affect the file.

        ``nbytes`` is the number of bytes of storage. If ``shared`` is ``False``,
        then the file must contain at least ``nbytes`` bytes. If ``shared`` is
        ``True`` the file will be created if needed. (Note that for ``UntypedStorage``
        this argument differs from that of ``TypedStorage.from_file``)

        Args:
            filename (str): file name to map
            shared (bool): whether to share memory (whether ``MAP_SHARED`` or ``MAP_PRIVATE`` is passed to the
                            underlying `mmap(2) call <https://man7.org/linux/man-pages/man2/mmap.2.html>`_)
            nbytes (int): number of bytes of storage
        """
    def is_shared(self, *args, **kwargs): ...
    def nbytes(self, *args, **kwargs): ...
    def new(self, *args, **kwargs): ...
    def resizable(self, *args, **kwargs): ...
    def resize_(self, *args, **kwargs): ...
    def __delitem__(self, other) -> None:
        """Delete self[key]."""
    def __getitem__(self, index):
        """Return self[key]."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __setitem__(self, index, object) -> None:
        """Set self[key] to value."""

class TensorBase:
    H: Incomplete
    T: Incomplete
    _backward_hooks: Incomplete
    _base: Incomplete
    _cdata: Incomplete
    _grad: Incomplete
    _grad_fn: Incomplete
    _has_symbolic_sizes_strides: Incomplete
    _post_accumulate_grad_hooks: Incomplete
    _python_dispatch: Incomplete
    _version: Incomplete
    data: Incomplete
    device: Incomplete
    dtype: Incomplete
    grad: Incomplete
    grad_fn: Incomplete
    imag: Incomplete
    is_cpu: Incomplete
    is_cuda: Incomplete
    is_ipu: Incomplete
    is_leaf: Incomplete
    is_maia: Incomplete
    is_meta: Incomplete
    is_mkldnn: Incomplete
    is_mps: Incomplete
    is_mtia: Incomplete
    is_nested: Incomplete
    is_quantized: Incomplete
    is_sparse: Incomplete
    is_sparse_csr: Incomplete
    is_vulkan: Incomplete
    is_xla: Incomplete
    is_xpu: Incomplete
    itemsize: Incomplete
    layout: Incomplete
    mH: Incomplete
    mT: Incomplete
    name: Incomplete
    names: Incomplete
    nbytes: Incomplete
    ndim: Incomplete
    output_nr: Incomplete
    real: Incomplete
    requires_grad: Incomplete
    retains_grad: Incomplete
    shape: torch.Size
    volatile: Incomplete
    @classmethod
    def __init__(cls, *args, **kwargs) -> None:
        """Create and return a new object.  See help(type) for accurate signature."""
    def _addmm_activation(self, *args, **kwargs): ...
    def _autocast_to_full_precision(self, *args, **kwargs): ...
    def _autocast_to_reduced_precision(self, *args, **kwargs): ...
    def _coalesced_(self, *args, **kwargs): ...
    def _conj(self, *args, **kwargs): ...
    def _conj_physical(self, *args, **kwargs): ...
    def _dimI(self, *args, **kwargs): ...
    def _dimV(self, *args, **kwargs): ...
    def _fix_weakref(self, *args, **kwargs): ...
    def _indices(self, *args, **kwargs): ...
    def _is_all_true(self, *args, **kwargs): ...
    def _is_any_true(self, *args, **kwargs): ...
    def _is_view(self, *args, **kwargs): ...
    def _is_zerotensor(self, *args, **kwargs): ...
    def _lazy_clone(self, *args, **kwargs): ...
    @staticmethod
    def _make_subclass(*args, **kwargs): ...
    @staticmethod
    def _make_wrapper_subclass(*args, **kwargs): ...
    def _neg_view(self, *args, **kwargs): ...
    def _nested_tensor_size(self, *args, **kwargs): ...
    def _nested_tensor_storage_offsets(self, *args, **kwargs): ...
    def _nested_tensor_strides(self, *args, **kwargs): ...
    def _nnz(self, *args, **kwargs): ...
    def _rev_view_func_unsafe(self, *args, **kwargs): ...
    def _sparse_mask_projection(self, *args, **kwargs): ...
    def _to_dense(self, *args, **kwargs): ...
    def _to_sparse(self, *args, **kwargs): ...
    def _to_sparse_bsc(self, *args, **kwargs): ...
    def _to_sparse_bsr(self, *args, **kwargs): ...
    def _to_sparse_csc(self, *args, **kwargs): ...
    def _to_sparse_csr(self, *args, **kwargs): ...
    def _use_count(self, *args, **kwargs): ...
    def _values(self, *args, **kwargs): ...
    def _view_func(self, *args, **kwargs): ...
    def _view_func_unsafe(self, *args, **kwargs): ...
    def abs(self) -> Tensor:
        """
        abs() -> Tensor

        See :func:`torch.abs`
        """
    def abs_(self) -> Tensor:
        """
        abs_() -> Tensor

        In-place version of :meth:`~Tensor.abs`
        """
    def absolute(self) -> Tensor:
        """
        absolute() -> Tensor

        Alias for :func:`abs`
        """
    def absolute_(self) -> Tensor:
        """
        absolute_() -> Tensor

        In-place version of :meth:`~Tensor.absolute`
        Alias for :func:`abs_`
        """
    def acos(self) -> Tensor:
        """
        acos() -> Tensor

        See :func:`torch.acos`
        """
    def acos_(self) -> Tensor:
        """
        acos_() -> Tensor

        In-place version of :meth:`~Tensor.acos`
        """
    def acosh(self) -> Tensor:
        """
        acosh() -> Tensor

        See :func:`torch.acosh`
        """
    def acosh_(self) -> Tensor:
        """
        acosh_() -> Tensor

        In-place version of :meth:`~Tensor.acosh`
        """
    def add(self, other, alpha=...) -> Tensor:
        """
        add(other, *, alpha=1) -> Tensor

        Add a scalar or tensor to :attr:`self` tensor. If both :attr:`alpha`
        and :attr:`other` are specified, each element of :attr:`other` is scaled by
        :attr:`alpha` before being used.

        When :attr:`other` is a tensor, the shape of :attr:`other` must be
        :ref:`broadcastable <broadcasting-semantics>` with the shape of the underlying
        tensor

        See :func:`torch.add`
        """
    def add_(self, other, alpha=...) -> Tensor:
        """
        add_(other, *, alpha=1) -> Tensor

        In-place version of :meth:`~Tensor.add`
        """
    def addbmm(self, batch1, batch2, beta=..., alpha=...) -> Tensor:
        """
        addbmm(batch1, batch2, *, beta=1, alpha=1) -> Tensor

        See :func:`torch.addbmm`
        """
    def addbmm_(self, batch1, batch2, beta=..., alpha=...) -> Tensor:
        """
        addbmm_(batch1, batch2, *, beta=1, alpha=1) -> Tensor

        In-place version of :meth:`~Tensor.addbmm`
        """
    def addcdiv(self, tensor1, tensor2, value=...) -> Tensor:
        """
        addcdiv(tensor1, tensor2, *, value=1) -> Tensor

        See :func:`torch.addcdiv`
        """
    def addcdiv_(self, tensor1, tensor2, value=...) -> Tensor:
        """
        addcdiv_(tensor1, tensor2, *, value=1) -> Tensor

        In-place version of :meth:`~Tensor.addcdiv`
        """
    def addcmul(self, tensor1, tensor2, value=...) -> Tensor:
        """
        addcmul(tensor1, tensor2, *, value=1) -> Tensor

        See :func:`torch.addcmul`
        """
    def addcmul_(self, tensor1, tensor2, value=...) -> Tensor:
        """
        addcmul_(tensor1, tensor2, *, value=1) -> Tensor

        In-place version of :meth:`~Tensor.addcmul`
        """
    def addmm(self, mat1, mat2, beta=..., alpha=...) -> Tensor:
        """
        addmm(mat1, mat2, *, beta=1, alpha=1) -> Tensor

        See :func:`torch.addmm`
        """
    def addmm_(self, mat1, mat2, beta=..., alpha=...) -> Tensor:
        """
        addmm_(mat1, mat2, *, beta=1, alpha=1) -> Tensor

        In-place version of :meth:`~Tensor.addmm`
        """
    def addmv(self, mat, vec, beta=..., alpha=...) -> Tensor:
        """
        addmv(mat, vec, *, beta=1, alpha=1) -> Tensor

        See :func:`torch.addmv`
        """
    def addmv_(self, mat, vec, beta=..., alpha=...) -> Tensor:
        """
        addmv_(mat, vec, *, beta=1, alpha=1) -> Tensor

        In-place version of :meth:`~Tensor.addmv`
        """
    def addr(self, vec1, vec2, beta=..., alpha=...) -> Tensor:
        """
        addr(vec1, vec2, *, beta=1, alpha=1) -> Tensor

        See :func:`torch.addr`
        """
    def addr_(self, vec1, vec2, beta=..., alpha=...) -> Tensor:
        """
        addr_(vec1, vec2, *, beta=1, alpha=1) -> Tensor

        In-place version of :meth:`~Tensor.addr`
        """
    def adjoint(self) -> Tensor:
        """
        adjoint() -> Tensor

        Alias for :func:`adjoint`
        """
    @overload
    def align_as(self, other) -> Tensor:
        """
        align_as(other) -> Tensor

        Permutes the dimensions of the :attr:`self` tensor to match the dimension order
        in the :attr:`other` tensor, adding size-one dims for any new names.

        This operation is useful for explicit broadcasting by names (see examples).

        All of the dims of :attr:`self` must be named in order to use this method.
        The resulting tensor is a view on the original tensor.

        All dimension names of :attr:`self` must be present in ``other.names``.
        :attr:`other` may contain named dimensions that are not in ``self.names``;
        the output tensor has a size-one dimension for each of those new names.

        To align a tensor to a specific order, use :meth:`~Tensor.align_to`.

        Examples::

            # Example 1: Applying a mask
            >>> mask = torch.randint(2, [127, 128], dtype=torch.bool).refine_names('W', 'H')
            >>> imgs = torch.randn(32, 128, 127, 3, names=('N', 'H', 'W', 'C'))
            >>> imgs.masked_fill_(mask.align_as(imgs), 0)


            # Example 2: Applying a per-channel-scale
            >>> def scale_channels(input, scale):
            >>>    scale = scale.refine_names('C')
            >>>    return input * scale.align_as(input)

            >>> num_channels = 3
            >>> scale = torch.randn(num_channels, names=('C',))
            >>> imgs = torch.rand(32, 128, 128, num_channels, names=('N', 'H', 'W', 'C'))
            >>> more_imgs = torch.rand(32, num_channels, 128, 128, names=('N', 'C', 'H', 'W'))
            >>> videos = torch.randn(3, num_channels, 128, 128, 128, names=('N', 'C', 'H', 'W', 'D'))

            # scale_channels is agnostic to the dimension order of the input
            >>> scale_channels(imgs, scale)
            >>> scale_channels(more_imgs, scale)
            >>> scale_channels(videos, scale)

        .. warning::
            The named tensor API is experimental and subject to change.

        """
    @overload
    def align_as(self, imgs) -> Any:
        """
        align_as(other) -> Tensor

        Permutes the dimensions of the :attr:`self` tensor to match the dimension order
        in the :attr:`other` tensor, adding size-one dims for any new names.

        This operation is useful for explicit broadcasting by names (see examples).

        All of the dims of :attr:`self` must be named in order to use this method.
        The resulting tensor is a view on the original tensor.

        All dimension names of :attr:`self` must be present in ``other.names``.
        :attr:`other` may contain named dimensions that are not in ``self.names``;
        the output tensor has a size-one dimension for each of those new names.

        To align a tensor to a specific order, use :meth:`~Tensor.align_to`.

        Examples::

            # Example 1: Applying a mask
            >>> mask = torch.randint(2, [127, 128], dtype=torch.bool).refine_names('W', 'H')
            >>> imgs = torch.randn(32, 128, 127, 3, names=('N', 'H', 'W', 'C'))
            >>> imgs.masked_fill_(mask.align_as(imgs), 0)


            # Example 2: Applying a per-channel-scale
            >>> def scale_channels(input, scale):
            >>>    scale = scale.refine_names('C')
            >>>    return input * scale.align_as(input)

            >>> num_channels = 3
            >>> scale = torch.randn(num_channels, names=('C',))
            >>> imgs = torch.rand(32, 128, 128, num_channels, names=('N', 'H', 'W', 'C'))
            >>> more_imgs = torch.rand(32, num_channels, 128, 128, names=('N', 'C', 'H', 'W'))
            >>> videos = torch.randn(3, num_channels, 128, 128, 128, names=('N', 'C', 'H', 'W', 'D'))

            # scale_channels is agnostic to the dimension order of the input
            >>> scale_channels(imgs, scale)
            >>> scale_channels(more_imgs, scale)
            >>> scale_channels(videos, scale)

        .. warning::
            The named tensor API is experimental and subject to change.

        """
    @overload
    def align_as(self, input) -> Any:
        """
        align_as(other) -> Tensor

        Permutes the dimensions of the :attr:`self` tensor to match the dimension order
        in the :attr:`other` tensor, adding size-one dims for any new names.

        This operation is useful for explicit broadcasting by names (see examples).

        All of the dims of :attr:`self` must be named in order to use this method.
        The resulting tensor is a view on the original tensor.

        All dimension names of :attr:`self` must be present in ``other.names``.
        :attr:`other` may contain named dimensions that are not in ``self.names``;
        the output tensor has a size-one dimension for each of those new names.

        To align a tensor to a specific order, use :meth:`~Tensor.align_to`.

        Examples::

            # Example 1: Applying a mask
            >>> mask = torch.randint(2, [127, 128], dtype=torch.bool).refine_names('W', 'H')
            >>> imgs = torch.randn(32, 128, 127, 3, names=('N', 'H', 'W', 'C'))
            >>> imgs.masked_fill_(mask.align_as(imgs), 0)


            # Example 2: Applying a per-channel-scale
            >>> def scale_channels(input, scale):
            >>>    scale = scale.refine_names('C')
            >>>    return input * scale.align_as(input)

            >>> num_channels = 3
            >>> scale = torch.randn(num_channels, names=('C',))
            >>> imgs = torch.rand(32, 128, 128, num_channels, names=('N', 'H', 'W', 'C'))
            >>> more_imgs = torch.rand(32, num_channels, 128, 128, names=('N', 'C', 'H', 'W'))
            >>> videos = torch.randn(3, num_channels, 128, 128, 128, names=('N', 'C', 'H', 'W', 'D'))

            # scale_channels is agnostic to the dimension order of the input
            >>> scale_channels(imgs, scale)
            >>> scale_channels(more_imgs, scale)
            >>> scale_channels(videos, scale)

        .. warning::
            The named tensor API is experimental and subject to change.

        """
    def align_to(self, *args, **kwargs): ...
    def all(self, dim=..., keepdim=...) -> Tensor:
        """
        all(dim=None, keepdim=False) -> Tensor

        See :func:`torch.all`
        """
    def allclose(self, other, rtol=..., atol=..., equal_nan=...) -> Tensor:
        """
        allclose(other, rtol=1e-05, atol=1e-08, equal_nan=False) -> Tensor

        See :func:`torch.allclose`
        """
    def amax(self, dim=..., keepdim=...) -> Tensor:
        """
        amax(dim=None, keepdim=False) -> Tensor

        See :func:`torch.amax`
        """
    def amin(self, dim=..., keepdim=...) -> Tensor:
        """
        amin(dim=None, keepdim=False) -> Tensor

        See :func:`torch.amin`
        """
    def aminmax(self, *args, **kwargs):
        """
        aminmax(*, dim=None, keepdim=False) -> (Tensor min, Tensor max)

        See :func:`torch.aminmax`
        """
    def angle(self) -> Tensor:
        """
        angle() -> Tensor

        See :func:`torch.angle`
        """
    def any(self, dim=..., keepdim=...) -> Tensor:
        """
        any(dim=None, keepdim=False) -> Tensor

        See :func:`torch.any`
        """
    def apply_(self, callable) -> Tensor:
        """
        apply_(callable) -> Tensor

        Applies the function :attr:`callable` to each element in the tensor, replacing
        each element with the value returned by :attr:`callable`.

        .. note::

            This function only works with CPU tensors and should not be used in code
            sections that require high performance.
        """
    def arccos(self) -> Tensor:
        """
        arccos() -> Tensor

        See :func:`torch.arccos`
        """
    def arccos_(self) -> Tensor:
        """
        arccos_() -> Tensor

        In-place version of :meth:`~Tensor.arccos`
        """
    def arccosh(self, *args, **kwargs):
        """
        acosh() -> Tensor

        See :func:`torch.arccosh`
        """
    def arccosh_(self, *args, **kwargs):
        """
        acosh_() -> Tensor

        In-place version of :meth:`~Tensor.arccosh`
        """
    def arcsin(self) -> Tensor:
        """
        arcsin() -> Tensor

        See :func:`torch.arcsin`
        """
    def arcsin_(self) -> Tensor:
        """
        arcsin_() -> Tensor

        In-place version of :meth:`~Tensor.arcsin`
        """
    def arcsinh(self) -> Tensor:
        """
        arcsinh() -> Tensor

        See :func:`torch.arcsinh`
        """
    def arcsinh_(self) -> Tensor:
        """
        arcsinh_() -> Tensor

        In-place version of :meth:`~Tensor.arcsinh`
        """
    def arctan(self) -> Tensor:
        """
        arctan() -> Tensor

        See :func:`torch.arctan`
        """
    def arctan2(self, other) -> Tensor:
        """
        arctan2(other) -> Tensor

        See :func:`torch.arctan2`
        """
    def arctan2_(self, *args, **kwargs):
        """
        atan2_(other) -> Tensor

        In-place version of :meth:`~Tensor.arctan2`
        """
    def arctan_(self) -> Tensor:
        """
        arctan_() -> Tensor

        In-place version of :meth:`~Tensor.arctan`
        """
    def arctanh(self) -> Tensor:
        """
        arctanh() -> Tensor

        See :func:`torch.arctanh`
        """
    def arctanh_(self, other) -> Tensor:
        """
        arctanh_(other) -> Tensor

        In-place version of :meth:`~Tensor.arctanh`
        """
    def argmax(self, dim=..., keepdim=...) -> LongTensor:
        """
        argmax(dim=None, keepdim=False) -> LongTensor

        See :func:`torch.argmax`
        """
    def argmin(self, dim=..., keepdim=...) -> LongTensor:
        """
        argmin(dim=None, keepdim=False) -> LongTensor

        See :func:`torch.argmin`
        """
    def argsort(self, dim=..., descending=...) -> LongTensor:
        """
        argsort(dim=-1, descending=False) -> LongTensor

        See :func:`torch.argsort`
        """
    def argwhere(self) -> Tensor:
        """
        argwhere() -> Tensor

        See :func:`torch.argwhere`
        """
    def as_strided(self, size, stride, storage_offset=...) -> Tensor:
        """
        as_strided(size, stride, storage_offset=None) -> Tensor

        See :func:`torch.as_strided`
        """
    def as_strided_(self, size, stride, storage_offset=...) -> Tensor:
        """
        as_strided_(size, stride, storage_offset=None) -> Tensor

        In-place version of :meth:`~Tensor.as_strided`
        """
    def as_strided_scatter(self, src, size, stride, storage_offset=...) -> Tensor:
        """
        as_strided_scatter(src, size, stride, storage_offset=None) -> Tensor

        See :func:`torch.as_strided_scatter`
        """
    @classmethod
    def as_subclass(cls) -> Tensor:
        """
        as_subclass(cls) -> Tensor

        Makes a ``cls`` instance with the same data pointer as ``self``. Changes
        in the output mirror changes in ``self``, and the output stays attached
        to the autograd graph. ``cls`` must be a subclass of ``Tensor``.
        """
    def asin(self) -> Tensor:
        """
        asin() -> Tensor

        See :func:`torch.asin`
        """
    def asin_(self) -> Tensor:
        """
        asin_() -> Tensor

        In-place version of :meth:`~Tensor.asin`
        """
    def asinh(self) -> Tensor:
        """
        asinh() -> Tensor

        See :func:`torch.asinh`
        """
    def asinh_(self) -> Tensor:
        """
        asinh_() -> Tensor

        In-place version of :meth:`~Tensor.asinh`
        """
    def atan(self) -> Tensor:
        """
        atan() -> Tensor

        See :func:`torch.atan`
        """
    def atan2(self, other) -> Tensor:
        """
        atan2(other) -> Tensor

        See :func:`torch.atan2`
        """
    def atan2_(self, other) -> Tensor:
        """
        atan2_(other) -> Tensor

        In-place version of :meth:`~Tensor.atan2`
        """
    def atan_(self) -> Tensor:
        """
        atan_() -> Tensor

        In-place version of :meth:`~Tensor.atan`
        """
    def atanh(self) -> Tensor:
        """
        atanh() -> Tensor

        See :func:`torch.atanh`
        """
    def atanh_(self, other) -> Tensor:
        """
        atanh_(other) -> Tensor

        In-place version of :meth:`~Tensor.atanh`
        """
    def baddbmm(self, batch1, batch2, beta=..., alpha=...) -> Tensor:
        """
        baddbmm(batch1, batch2, *, beta=1, alpha=1) -> Tensor

        See :func:`torch.baddbmm`
        """
    def baddbmm_(self, batch1, batch2, beta=..., alpha=...) -> Tensor:
        """
        baddbmm_(batch1, batch2, *, beta=1, alpha=1) -> Tensor

        In-place version of :meth:`~Tensor.baddbmm`
        """
    def bernoulli(self, generator=...) -> Tensor:
        """
        bernoulli(*, generator=None) -> Tensor

        Returns a result tensor where each :math:`\\texttt{result[i]}` is independently
        sampled from :math:`\\text{Bernoulli}(\\texttt{self[i]})`. :attr:`self` must have
        floating point ``dtype``, and the result will have the same ``dtype``.

        See :func:`torch.bernoulli`
        """
    def bernoulli_(self, p=..., generator=...) -> Tensor:
        """
        bernoulli_(p=0.5, *, generator=None) -> Tensor

        Fills each location of :attr:`self` with an independent sample from
        :math:`\\text{Bernoulli}(\\texttt{p})`. :attr:`self` can have integral
        ``dtype``.

        :attr:`p` should either be a scalar or tensor containing probabilities to be
        used for drawing the binary random number.

        If it is a tensor, the :math:`\\text{i}^{th}` element of :attr:`self` tensor
        will be set to a value sampled from
        :math:`\\text{Bernoulli}(\\texttt{p\\_tensor[i]})`. In this case `p` must have
        floating point ``dtype``.

        See also :meth:`~Tensor.bernoulli` and :func:`torch.bernoulli`
        """
    @overload
    def bfloat16(self, memory_format=...) -> Tensor:
        """
        bfloat16(memory_format=torch.preserve_format) -> Tensor
        ``self.bfloat16()`` is equivalent to ``self.to(torch.bfloat16)``. See :func:`to`.

        Args:
            memory_format (:class:`torch.memory_format`, optional): the desired memory format of
                returned Tensor. Default: ``torch.preserve_format``.
        """
    @overload
    def bfloat16(self) -> Any:
        """
        bfloat16(memory_format=torch.preserve_format) -> Tensor
        ``self.bfloat16()`` is equivalent to ``self.to(torch.bfloat16)``. See :func:`to`.

        Args:
            memory_format (:class:`torch.memory_format`, optional): the desired memory format of
                returned Tensor. Default: ``torch.preserve_format``.
        """
    def bincount(self, weights=..., minlength=...) -> Tensor:
        """
        bincount(weights=None, minlength=0) -> Tensor

        See :func:`torch.bincount`
        """
    def bitwise_and(self) -> Tensor:
        """
        bitwise_and() -> Tensor

        See :func:`torch.bitwise_and`
        """
    def bitwise_and_(self) -> Tensor:
        """
        bitwise_and_() -> Tensor

        In-place version of :meth:`~Tensor.bitwise_and`
        """
    def bitwise_left_shift(self, other) -> Tensor:
        """
        bitwise_left_shift(other) -> Tensor

        See :func:`torch.bitwise_left_shift`
        """
    def bitwise_left_shift_(self, other) -> Tensor:
        """
        bitwise_left_shift_(other) -> Tensor

        In-place version of :meth:`~Tensor.bitwise_left_shift`
        """
    def bitwise_not(self) -> Tensor:
        """
        bitwise_not() -> Tensor

        See :func:`torch.bitwise_not`
        """
    def bitwise_not_(self) -> Tensor:
        """
        bitwise_not_() -> Tensor

        In-place version of :meth:`~Tensor.bitwise_not`
        """
    def bitwise_or(self) -> Tensor:
        """
        bitwise_or() -> Tensor

        See :func:`torch.bitwise_or`
        """
    def bitwise_or_(self) -> Tensor:
        """
        bitwise_or_() -> Tensor

        In-place version of :meth:`~Tensor.bitwise_or`
        """
    def bitwise_right_shift(self, other) -> Tensor:
        """
        bitwise_right_shift(other) -> Tensor

        See :func:`torch.bitwise_right_shift`
        """
    def bitwise_right_shift_(self, other) -> Tensor:
        """
        bitwise_right_shift_(other) -> Tensor

        In-place version of :meth:`~Tensor.bitwise_right_shift`
        """
    def bitwise_xor(self) -> Tensor:
        """
        bitwise_xor() -> Tensor

        See :func:`torch.bitwise_xor`
        """
    def bitwise_xor_(self) -> Tensor:
        """
        bitwise_xor_() -> Tensor

        In-place version of :meth:`~Tensor.bitwise_xor`
        """
    def bmm(self, batch2) -> Tensor:
        """
        bmm(batch2) -> Tensor

        See :func:`torch.bmm`
        """
    @overload
    def bool(self, memory_format=...) -> Tensor:
        """
        bool(memory_format=torch.preserve_format) -> Tensor

        ``self.bool()`` is equivalent to ``self.to(torch.bool)``. See :func:`to`.

        Args:
            memory_format (:class:`torch.memory_format`, optional): the desired memory format of
                returned Tensor. Default: ``torch.preserve_format``.
        """
    @overload
    def bool(self) -> Any:
        """
        bool(memory_format=torch.preserve_format) -> Tensor

        ``self.bool()`` is equivalent to ``self.to(torch.bool)``. See :func:`to`.

        Args:
            memory_format (:class:`torch.memory_format`, optional): the desired memory format of
                returned Tensor. Default: ``torch.preserve_format``.
        """
    def broadcast_to(self, shape) -> Tensor:
        """
        broadcast_to(shape) -> Tensor

        See :func:`torch.broadcast_to`.
        """
    @overload
    def byte(self, memory_format=...) -> Tensor:
        """
        byte(memory_format=torch.preserve_format) -> Tensor

        ``self.byte()`` is equivalent to ``self.to(torch.uint8)``. See :func:`to`.

        Args:
            memory_format (:class:`torch.memory_format`, optional): the desired memory format of
                returned Tensor. Default: ``torch.preserve_format``.
        """
    @overload
    def byte(self) -> Any:
        """
        byte(memory_format=torch.preserve_format) -> Tensor

        ``self.byte()`` is equivalent to ``self.to(torch.uint8)``. See :func:`to`.

        Args:
            memory_format (:class:`torch.memory_format`, optional): the desired memory format of
                returned Tensor. Default: ``torch.preserve_format``.
        """
    def cauchy_(self, median=..., sigma=..., generator=...) -> Tensor:
        """
        cauchy_(median=0, sigma=1, *, generator=None) -> Tensor

        Fills the tensor with numbers drawn from the Cauchy distribution:

        .. math::

            f(x) = \\dfrac{1}{\\pi} \\dfrac{\\sigma}{(x - \\text{median})^2 + \\sigma^2}

        .. note::
          Sigma (:math:`\\sigma`) is used to denote the scale parameter in Cauchy distribution.
        """
    def ccol_indices(self, *args, **kwargs): ...
    @overload
    def cdouble(self, memory_format=...) -> Tensor:
        """
        cdouble(memory_format=torch.preserve_format) -> Tensor

        ``self.cdouble()`` is equivalent to ``self.to(torch.complex128)``. See :func:`to`.

        Args:
            memory_format (:class:`torch.memory_format`, optional): the desired memory format of
                returned Tensor. Default: ``torch.preserve_format``.
        """
    @overload
    def cdouble(self) -> Any:
        """
        cdouble(memory_format=torch.preserve_format) -> Tensor

        ``self.cdouble()`` is equivalent to ``self.to(torch.complex128)``. See :func:`to`.

        Args:
            memory_format (:class:`torch.memory_format`, optional): the desired memory format of
                returned Tensor. Default: ``torch.preserve_format``.
        """
    def ceil(self) -> Tensor:
        """
        ceil() -> Tensor

        See :func:`torch.ceil`
        """
    def ceil_(self) -> Tensor:
        """
        ceil_() -> Tensor

        In-place version of :meth:`~Tensor.ceil`
        """
    @overload
    def cfloat(self, memory_format=...) -> Tensor:
        """
        cfloat(memory_format=torch.preserve_format) -> Tensor

        ``self.cfloat()`` is equivalent to ``self.to(torch.complex64)``. See :func:`to`.

        Args:
            memory_format (:class:`torch.memory_format`, optional): the desired memory format of
                returned Tensor. Default: ``torch.preserve_format``.
        """
    @overload
    def cfloat(self) -> Any:
        """
        cfloat(memory_format=torch.preserve_format) -> Tensor

        ``self.cfloat()`` is equivalent to ``self.to(torch.complex64)``. See :func:`to`.

        Args:
            memory_format (:class:`torch.memory_format`, optional): the desired memory format of
                returned Tensor. Default: ``torch.preserve_format``.
        """
    @overload
    def chalf(self, memory_format=...) -> Tensor:
        """
        chalf(memory_format=torch.preserve_format) -> Tensor

        ``self.chalf()`` is equivalent to ``self.to(torch.complex32)``. See :func:`to`.

        Args:
             memory_format (:class:`torch.memory_format`, optional): the desired memory format of
                returned Tensor. Default: ``torch.preserve_format``.
 """
    @overload
    def chalf(self) -> Any:
        """
        chalf(memory_format=torch.preserve_format) -> Tensor

        ``self.chalf()`` is equivalent to ``self.to(torch.complex32)``. See :func:`to`.

        Args:
             memory_format (:class:`torch.memory_format`, optional): the desired memory format of
                returned Tensor. Default: ``torch.preserve_format``.
 """
    @overload
    def char(self, memory_format=...) -> Tensor:
        """
        char(memory_format=torch.preserve_format) -> Tensor

        ``self.char()`` is equivalent to ``self.to(torch.int8)``. See :func:`to`.

        Args:
            memory_format (:class:`torch.memory_format`, optional): the desired memory format of
                returned Tensor. Default: ``torch.preserve_format``.
        """
    @overload
    def char(self) -> Any:
        """
        char(memory_format=torch.preserve_format) -> Tensor

        ``self.char()`` is equivalent to ``self.to(torch.int8)``. See :func:`to`.

        Args:
            memory_format (:class:`torch.memory_format`, optional): the desired memory format of
                returned Tensor. Default: ``torch.preserve_format``.
        """
    def cholesky(self, upper=...) -> Tensor:
        """
        cholesky(upper=False) -> Tensor

        See :func:`torch.cholesky`
        """
    def cholesky_inverse(self, upper=...) -> Tensor:
        """
        cholesky_inverse(upper=False) -> Tensor

        See :func:`torch.cholesky_inverse`
        """
    def cholesky_solve(self, input2, upper=...) -> Tensor:
        """
        cholesky_solve(input2, upper=False) -> Tensor

        See :func:`torch.cholesky_solve`
        """
    def chunk(self, chunks, dim=...) -> ListofTensors:
        """
        chunk(chunks, dim=0) -> List of Tensors

        See :func:`torch.chunk`
        """
    def clamp(self, min=..., max=...) -> Tensor:
        """
        clamp(min=None, max=None) -> Tensor

        See :func:`torch.clamp`
        """
    def clamp_(self, min=..., max=...) -> Tensor:
        """
        clamp_(min=None, max=None) -> Tensor

        In-place version of :meth:`~Tensor.clamp`
        """
    def clamp_max(self, *args, **kwargs): ...
    def clamp_max_(self, *args, **kwargs): ...
    def clamp_min(self, *args, **kwargs): ...
    def clamp_min_(self, *args, **kwargs): ...
    def clip(self, min=..., max=...) -> Tensor:
        """
        clip(min=None, max=None) -> Tensor

        Alias for :meth:`~Tensor.clamp`.
        """
    def clip_(self, min=..., max=...) -> Tensor:
        """
        clip_(min=None, max=None) -> Tensor

        Alias for :meth:`~Tensor.clamp_`.
        """
    def clone(self, memory_format=...) -> Tensor:
        """
        clone(*, memory_format=torch.preserve_format) -> Tensor

        See :func:`torch.clone`
        """
    def coalesce(self) -> Tensor:
        """
        coalesce() -> Tensor

        Returns a coalesced copy of :attr:`self` if :attr:`self` is an
        :ref:`uncoalesced tensor <sparse-uncoalesced-coo-docs>`.

        Returns :attr:`self` if :attr:`self` is a coalesced tensor.

        .. warning::
          Throws an error if :attr:`self` is not a sparse COO tensor.
        """
    @overload
    def col_indices(self) -> IntTensor:
        """
        col_indices() -> IntTensor

        Returns the tensor containing the column indices of the :attr:`self`
        tensor when :attr:`self` is a sparse CSR tensor of layout ``sparse_csr``.
        The ``col_indices`` tensor is strictly of shape (:attr:`self`.nnz())
        and of type ``int32`` or ``int64``.  When using MKL routines such as sparse
        matrix multiplication, it is necessary to use ``int32`` indexing in order
        to avoid downcasting and potentially losing information.

        Example::

            >>> csr = torch.eye(5,5).to_sparse_csr()
            >>> csr.col_indices()
            tensor([0, 1, 2, 3, 4], dtype=torch.int32)

        """
    @overload
    def col_indices(self) -> Any:
        """
        col_indices() -> IntTensor

        Returns the tensor containing the column indices of the :attr:`self`
        tensor when :attr:`self` is a sparse CSR tensor of layout ``sparse_csr``.
        The ``col_indices`` tensor is strictly of shape (:attr:`self`.nnz())
        and of type ``int32`` or ``int64``.  When using MKL routines such as sparse
        matrix multiplication, it is necessary to use ``int32`` indexing in order
        to avoid downcasting and potentially losing information.

        Example::

            >>> csr = torch.eye(5,5).to_sparse_csr()
            >>> csr.col_indices()
            tensor([0, 1, 2, 3, 4], dtype=torch.int32)

        """
    def conj(self) -> Tensor:
        """
        conj() -> Tensor

        See :func:`torch.conj`
        """
    def conj_physical(self) -> Tensor:
        """
        conj_physical() -> Tensor

        See :func:`torch.conj_physical`
        """
    def conj_physical_(self) -> Tensor:
        """
        conj_physical_() -> Tensor

        In-place version of :meth:`~Tensor.conj_physical`
        """
    def contiguous(self, memory_format=...) -> Tensor:
        """
        contiguous(memory_format=torch.contiguous_format) -> Tensor

        Returns a contiguous in memory tensor containing the same data as :attr:`self` tensor. If
        :attr:`self` tensor is already in the specified memory format, this function returns the
        :attr:`self` tensor.

        Args:
            memory_format (:class:`torch.memory_format`, optional): the desired memory format of
                returned Tensor. Default: ``torch.contiguous_format``.
        """
    def copy_(self, src, non_blocking=...) -> Tensor:
        """
        copy_(src, non_blocking=False) -> Tensor

        Copies the elements from :attr:`src` into :attr:`self` tensor and returns
        :attr:`self`.

        The :attr:`src` tensor must be :ref:`broadcastable <broadcasting-semantics>`
        with the :attr:`self` tensor. It may be of a different data type or reside on a
        different device.

        Args:
            src (Tensor): the source tensor to copy from
            non_blocking (bool): if ``True`` and this copy is between CPU and GPU,
                the copy may occur asynchronously with respect to the host. For other
                cases, this argument has no effect.
        """
    def copysign(self, other) -> Tensor:
        """
        copysign(other) -> Tensor

        See :func:`torch.copysign`
        """
    def copysign_(self, other) -> Tensor:
        """
        copysign_(other) -> Tensor

        In-place version of :meth:`~Tensor.copysign`
        """
    def corrcoef(self) -> Tensor:
        """
        corrcoef() -> Tensor

        See :func:`torch.corrcoef`
        """
    def cos(self) -> Tensor:
        """
        cos() -> Tensor

        See :func:`torch.cos`
        """
    def cos_(self) -> Tensor:
        """
        cos_() -> Tensor

        In-place version of :meth:`~Tensor.cos`
        """
    def cosh(self) -> Tensor:
        """
        cosh() -> Tensor

        See :func:`torch.cosh`
        """
    def cosh_(self) -> Tensor:
        """
        cosh_() -> Tensor

        In-place version of :meth:`~Tensor.cosh`
        """
    def count_nonzero(self, dim=...) -> Tensor:
        """
        count_nonzero(dim=None) -> Tensor

        See :func:`torch.count_nonzero`
        """
    def cov(self, correction=..., fweights=..., aweights=...) -> Tensor:
        """
        cov(*, correction=1, fweights=None, aweights=None) -> Tensor

        See :func:`torch.cov`
        """
    def cpu(self, memory_format=...) -> Tensor:
        """
        cpu(memory_format=torch.preserve_format) -> Tensor

        Returns a copy of this object in CPU memory.

        If this object is already in CPU memory,
        then no copy is performed and the original object is returned.

        Args:
            memory_format (:class:`torch.memory_format`, optional): the desired memory format of
                returned Tensor. Default: ``torch.preserve_format``.

        """
    def cross(self, other, dim=...) -> Tensor:
        """
        cross(other, dim=None) -> Tensor

        See :func:`torch.cross`
        """
    @overload
    def crow_indices(self) -> IntTensor:
        """
        crow_indices() -> IntTensor

        Returns the tensor containing the compressed row indices of the :attr:`self`
        tensor when :attr:`self` is a sparse CSR tensor of layout ``sparse_csr``.
        The ``crow_indices`` tensor is strictly of shape (:attr:`self`.size(0) + 1)
        and of type ``int32`` or ``int64``. When using MKL routines such as sparse
        matrix multiplication, it is necessary to use ``int32`` indexing in order
        to avoid downcasting and potentially losing information.

        Example::

            >>> csr = torch.eye(5,5).to_sparse_csr()
            >>> csr.crow_indices()
            tensor([0, 1, 2, 3, 4, 5], dtype=torch.int32)

        """
    @overload
    def crow_indices(self) -> Any:
        """
        crow_indices() -> IntTensor

        Returns the tensor containing the compressed row indices of the :attr:`self`
        tensor when :attr:`self` is a sparse CSR tensor of layout ``sparse_csr``.
        The ``crow_indices`` tensor is strictly of shape (:attr:`self`.size(0) + 1)
        and of type ``int32`` or ``int64``. When using MKL routines such as sparse
        matrix multiplication, it is necessary to use ``int32`` indexing in order
        to avoid downcasting and potentially losing information.

        Example::

            >>> csr = torch.eye(5,5).to_sparse_csr()
            >>> csr.crow_indices()
            tensor([0, 1, 2, 3, 4, 5], dtype=torch.int32)

        """
    def cuda(self, device=..., non_blocking=..., memory_format=...) -> Tensor:
        """
        cuda(device=None, non_blocking=False, memory_format=torch.preserve_format) -> Tensor

        Returns a copy of this object in CUDA memory.

        If this object is already in CUDA memory and on the correct device,
        then no copy is performed and the original object is returned.

        Args:
            device (:class:`torch.device`): The destination GPU device.
                Defaults to the current CUDA device.
            non_blocking (bool): If ``True`` and the source is in pinned memory,
                the copy will be asynchronous with respect to the host.
                Otherwise, the argument has no effect. Default: ``False``.
            memory_format (:class:`torch.memory_format`, optional): the desired memory format of
                returned Tensor. Default: ``torch.preserve_format``.
        """
    def cummax(self, *args, **kwargs):
        """
        cummax(dim) -> (Tensor, Tensor)

        See :func:`torch.cummax`
        """
    def cummin(self, *args, **kwargs):
        """
        cummin(dim) -> (Tensor, Tensor)

        See :func:`torch.cummin`
        """
    def cumprod(self, dim, dtype=...) -> Tensor:
        """
        cumprod(dim, dtype=None) -> Tensor

        See :func:`torch.cumprod`
        """
    def cumprod_(self, dim, dtype=...) -> Tensor:
        """
        cumprod_(dim, dtype=None) -> Tensor

        In-place version of :meth:`~Tensor.cumprod`
        """
    def cumsum(self, dim, dtype=...) -> Tensor:
        """
        cumsum(dim, dtype=None) -> Tensor

        See :func:`torch.cumsum`
        """
    def cumsum_(self, dim, dtype=...) -> Tensor:
        """
        cumsum_(dim, dtype=None) -> Tensor

        In-place version of :meth:`~Tensor.cumsum`
        """
    def data_ptr(self) -> int:
        """
        data_ptr() -> int

        Returns the address of the first element of :attr:`self` tensor.
        """
    def deg2rad(self) -> Tensor:
        """
        deg2rad() -> Tensor

        See :func:`torch.deg2rad`
        """
    def deg2rad_(self) -> Tensor:
        """
        deg2rad_() -> Tensor

        In-place version of :meth:`~Tensor.deg2rad`
        """
    def dense_dim(self) -> int:
        """
        dense_dim() -> int

        Return the number of dense dimensions in a :ref:`sparse tensor <sparse-docs>` :attr:`self`.

        .. note::
          Returns ``len(self.shape)`` if :attr:`self` is not a sparse tensor.

        See also :meth:`Tensor.sparse_dim` and :ref:`hybrid tensors <sparse-hybrid-coo-docs>`.
        """
    def dequantize(self) -> Tensor:
        """
        dequantize() -> Tensor

        Given a quantized Tensor, dequantize it and return the dequantized float Tensor.
        """
    def det(self) -> Tensor:
        """
        det() -> Tensor

        See :func:`torch.det`
        """
    def detach(self, *args, **kwargs):
        """
            Returns a new Tensor, detached from the current graph.

            The result will never require gradient.

            This method also affects forward mode AD gradients and the result will never
            have forward mode AD gradients.

            .. note::

              Returned Tensor shares the same storage with the original one.
              In-place modifications on either of them will be seen, and may trigger
              errors in correctness checks.
    """
    def detach_(self, *args, **kwargs):
        """
            Detaches the Tensor from the graph that created it, making it a leaf.
            Views cannot be detached in-place.

            This method also affects forward mode AD gradients and the result will never
            have forward mode AD gradients.
    """
    def diag(self, diagonal=...) -> Tensor:
        """
        diag(diagonal=0) -> Tensor

        See :func:`torch.diag`
        """
    def diag_embed(self, offset=..., dim1=..., dim2=...) -> Tensor:
        """
        diag_embed(offset=0, dim1=-2, dim2=-1) -> Tensor

        See :func:`torch.diag_embed`
        """
    def diagflat(self, offset=...) -> Tensor:
        """
        diagflat(offset=0) -> Tensor

        See :func:`torch.diagflat`
        """
    def diagonal(self, offset=..., dim1=..., dim2=...) -> Tensor:
        """
        diagonal(offset=0, dim1=0, dim2=1) -> Tensor

        See :func:`torch.diagonal`
        """
    def diagonal_scatter(self, src, offset=..., dim1=..., dim2=...) -> Tensor:
        """
        diagonal_scatter(src, offset=0, dim1=0, dim2=1) -> Tensor

        See :func:`torch.diagonal_scatter`
        """
    def diff(self, n=..., dim=..., prepend=..., append=...) -> Tensor:
        """
        diff(n=1, dim=-1, prepend=None, append=None) -> Tensor

        See :func:`torch.diff`
        """
    def digamma(self) -> Tensor:
        """
        digamma() -> Tensor

        See :func:`torch.digamma`
        """
    def digamma_(self) -> Tensor:
        """
        digamma_() -> Tensor

        In-place version of :meth:`~Tensor.digamma`
        """
    def dim(self) -> int:
        """
        dim() -> int

        Returns the number of dimensions of :attr:`self` tensor.
        """
    def dist(self, other, p=...) -> Tensor:
        """
        dist(other, p=2) -> Tensor

        See :func:`torch.dist`
        """
    def div(self, value, rounding_mode=...) -> Tensor:
        """
        div(value, *, rounding_mode=None) -> Tensor

        See :func:`torch.div`
        """
    def div_(self, value, rounding_mode=...) -> Tensor:
        """
        div_(value, *, rounding_mode=None) -> Tensor

        In-place version of :meth:`~Tensor.div`
        """
    def divide(self, value, rounding_mode=...) -> Tensor:
        """
        divide(value, *, rounding_mode=None) -> Tensor

        See :func:`torch.divide`
        """
    def divide_(self, value, rounding_mode=...) -> Tensor:
        """
        divide_(value, *, rounding_mode=None) -> Tensor

        In-place version of :meth:`~Tensor.divide`
        """
    def dot(self, other) -> Tensor:
        """
        dot(other) -> Tensor

        See :func:`torch.dot`
        """
    @overload
    def double(self, memory_format=...) -> Tensor:
        """
        double(memory_format=torch.preserve_format) -> Tensor

        ``self.double()`` is equivalent to ``self.to(torch.float64)``. See :func:`to`.

        Args:
            memory_format (:class:`torch.memory_format`, optional): the desired memory format of
                returned Tensor. Default: ``torch.preserve_format``.
        """
    @overload
    def double(self) -> Any:
        """
        double(memory_format=torch.preserve_format) -> Tensor

        ``self.double()`` is equivalent to ``self.to(torch.float64)``. See :func:`to`.

        Args:
            memory_format (:class:`torch.memory_format`, optional): the desired memory format of
                returned Tensor. Default: ``torch.preserve_format``.
        """
    def dsplit(self, split_size_or_sections) -> ListofTensors:
        """
        dsplit(split_size_or_sections) -> List of Tensors

        See :func:`torch.dsplit`
        """
    @overload
    def element_size(self) -> int:
        """
        element_size() -> int

        Returns the size in bytes of an individual element.

        Example::

            >>> torch.tensor([]).element_size()
            4
            >>> torch.tensor([], dtype=torch.uint8).element_size()
            1

        """
    @overload
    def element_size(self) -> Any:
        """
        element_size() -> int

        Returns the size in bytes of an individual element.

        Example::

            >>> torch.tensor([]).element_size()
            4
            >>> torch.tensor([], dtype=torch.uint8).element_size()
            1

        """
    @overload
    def element_size(self) -> Any:
        """
        element_size() -> int

        Returns the size in bytes of an individual element.

        Example::

            >>> torch.tensor([]).element_size()
            4
            >>> torch.tensor([], dtype=torch.uint8).element_size()
            1

        """
    def eq(self, other) -> Tensor:
        """
        eq(other) -> Tensor

        See :func:`torch.eq`
        """
    def eq_(self, other) -> Tensor:
        """
        eq_(other) -> Tensor

        In-place version of :meth:`~Tensor.eq`
        """
    def equal(self, other) -> bool:
        """
        equal(other) -> bool

        See :func:`torch.equal`
        """
    def erf(self) -> Tensor:
        """
        erf() -> Tensor

        See :func:`torch.erf`
        """
    def erf_(self) -> Tensor:
        """
        erf_() -> Tensor

        In-place version of :meth:`~Tensor.erf`
        """
    def erfc(self) -> Tensor:
        """
        erfc() -> Tensor

        See :func:`torch.erfc`
        """
    def erfc_(self) -> Tensor:
        """
        erfc_() -> Tensor

        In-place version of :meth:`~Tensor.erfc`
        """
    def erfinv(self) -> Tensor:
        """
        erfinv() -> Tensor

        See :func:`torch.erfinv`
        """
    def erfinv_(self) -> Tensor:
        """
        erfinv_() -> Tensor

        In-place version of :meth:`~Tensor.erfinv`
        """
    def exp(self) -> Tensor:
        """
        exp() -> Tensor

        See :func:`torch.exp`
        """
    def exp2(self) -> Tensor:
        """
        exp2() -> Tensor

        See :func:`torch.exp2`
        """
    def exp2_(self) -> Tensor:
        """
        exp2_() -> Tensor

        In-place version of :meth:`~Tensor.exp2`
        """
    def exp_(self) -> Tensor:
        """
        exp_() -> Tensor

        In-place version of :meth:`~Tensor.exp`
        """
    def expand(self, *sizes) -> Tensor:
        """
        expand(*sizes) -> Tensor

        Returns a new view of the :attr:`self` tensor with singleton dimensions expanded
        to a larger size.

        Passing -1 as the size for a dimension means not changing the size of
        that dimension.

        Tensor can be also expanded to a larger number of dimensions, and the
        new ones will be appended at the front. For the new dimensions, the
        size cannot be set to -1.

        Expanding a tensor does not allocate new memory, but only creates a
        new view on the existing tensor where a dimension of size one is
        expanded to a larger size by setting the ``stride`` to 0. Any dimension
        of size 1 can be expanded to an arbitrary value without allocating new
        memory.

        Args:
            *sizes (torch.Size or int...): the desired expanded size

        .. warning::

            More than one element of an expanded tensor may refer to a single
            memory location. As a result, in-place operations (especially ones that
            are vectorized) may result in incorrect behavior. If you need to write
            to the tensors, please clone them first.

        Example::

            >>> x = torch.tensor([[1], [2], [3]])
            >>> x.size()
            torch.Size([3, 1])
            >>> x.expand(3, 4)
            tensor([[ 1,  1,  1,  1],
                    [ 2,  2,  2,  2],
                    [ 3,  3,  3,  3]])
            >>> x.expand(-1, 4)   # -1 means not changing the size of that dimension
            tensor([[ 1,  1,  1,  1],
                    [ 2,  2,  2,  2],
                    [ 3,  3,  3,  3]])
        """
    @overload
    def expand_as(self, other) -> Tensor:
        """
        expand_as(other) -> Tensor

        Expand this tensor to the same size as :attr:`other`.
        ``self.expand_as(other)`` is equivalent to ``self.expand(other.size())``.

        Please see :meth:`~Tensor.expand` for more information about ``expand``.

        Args:
            other (:class:`torch.Tensor`): The result tensor has the same size
                as :attr:`other`.
        """
    @overload
    def expand_as(self, other) -> Any:
        """
        expand_as(other) -> Tensor

        Expand this tensor to the same size as :attr:`other`.
        ``self.expand_as(other)`` is equivalent to ``self.expand(other.size())``.

        Please see :meth:`~Tensor.expand` for more information about ``expand``.

        Args:
            other (:class:`torch.Tensor`): The result tensor has the same size
                as :attr:`other`.
        """
    def expm1(self) -> Tensor:
        """
        expm1() -> Tensor

        See :func:`torch.expm1`
        """
    def expm1_(self) -> Tensor:
        """
        expm1_() -> Tensor

        In-place version of :meth:`~Tensor.expm1`
        """
    def exponential_(self, lambd=..., generator=...) -> Tensor:
        """
        exponential_(lambd=1, *, generator=None) -> Tensor

        Fills :attr:`self` tensor with elements drawn from the PDF (probability density function):

        .. math::

            f(x) = \\lambda e^{-\\lambda x}, x > 0

        .. note::
          In probability theory, exponential distribution is supported on interval [0, :math:`\\inf`) (i.e., :math:`x >= 0`)
          implying that zero can be sampled from the exponential distribution.
          However, :func:`torch.Tensor.exponential_` does not sample zero,
          which means that its actual support is the interval (0, :math:`\\inf`).

          Note that :func:`torch.distributions.exponential.Exponential` is supported on the interval [0, :math:`\\inf`) and can sample zero.
        """
    def fill_(self, value) -> Tensor:
        """
        fill_(value) -> Tensor

        Fills :attr:`self` tensor with the specified value.
        """
    def fill_diagonal_(self, fill_value, wrap=...) -> Tensor:
        """
        fill_diagonal_(fill_value, wrap=False) -> Tensor

        Fill the main diagonal of a tensor that has at least 2-dimensions.
        When dims>2, all dimensions of input must be of equal length.
        This function modifies the input tensor in-place, and returns the input tensor.

        Arguments:
            fill_value (Scalar): the fill value
            wrap (bool): the diagonal 'wrapped' after N columns for tall matrices.

        Example::

            >>> a = torch.zeros(3, 3)
            >>> a.fill_diagonal_(5)
            tensor([[5., 0., 0.],
                    [0., 5., 0.],
                    [0., 0., 5.]])
            >>> b = torch.zeros(7, 3)
            >>> b.fill_diagonal_(5)
            tensor([[5., 0., 0.],
                    [0., 5., 0.],
                    [0., 0., 5.],
                    [0., 0., 0.],
                    [0., 0., 0.],
                    [0., 0., 0.],
                    [0., 0., 0.]])
            >>> c = torch.zeros(7, 3)
            >>> c.fill_diagonal_(5, wrap=True)
            tensor([[5., 0., 0.],
                    [0., 5., 0.],
                    [0., 0., 5.],
                    [0., 0., 0.],
                    [5., 0., 0.],
                    [0., 5., 0.],
                    [0., 0., 5.]])

        """
    def fix(self) -> Tensor:
        """
        fix() -> Tensor

        See :func:`torch.fix`.
        """
    def fix_(self) -> Tensor:
        """
        fix_() -> Tensor

        In-place version of :meth:`~Tensor.fix`
        """
    def flatten(self, start_dim=..., end_dim=...) -> Tensor:
        """
        flatten(start_dim=0, end_dim=-1) -> Tensor

        See :func:`torch.flatten`
        """
    def flip(self, dims) -> Tensor:
        """
        flip(dims) -> Tensor

        See :func:`torch.flip`
        """
    def fliplr(self) -> Tensor:
        """
        fliplr() -> Tensor

        See :func:`torch.fliplr`
        """
    def flipud(self) -> Tensor:
        """
        flipud() -> Tensor

        See :func:`torch.flipud`
        """
    @overload
    def float(self, memory_format=...) -> Tensor:
        """
        float(memory_format=torch.preserve_format) -> Tensor

        ``self.float()`` is equivalent to ``self.to(torch.float32)``. See :func:`to`.

        Args:
            memory_format (:class:`torch.memory_format`, optional): the desired memory format of
                returned Tensor. Default: ``torch.preserve_format``.
        """
    @overload
    def float(self) -> Any:
        """
        float(memory_format=torch.preserve_format) -> Tensor

        ``self.float()`` is equivalent to ``self.to(torch.float32)``. See :func:`to`.

        Args:
            memory_format (:class:`torch.memory_format`, optional): the desired memory format of
                returned Tensor. Default: ``torch.preserve_format``.
        """
    def float_power(self, exponent) -> Tensor:
        """
        float_power(exponent) -> Tensor

        See :func:`torch.float_power`
        """
    def float_power_(self, exponent) -> Tensor:
        """
        float_power_(exponent) -> Tensor

        In-place version of :meth:`~Tensor.float_power`
        """
    def floor(self) -> Tensor:
        """
        floor() -> Tensor

        See :func:`torch.floor`
        """
    def floor_(self) -> Tensor:
        """
        floor_() -> Tensor

        In-place version of :meth:`~Tensor.floor`
        """
    def floor_divide(self, value) -> Tensor:
        """
        floor_divide(value) -> Tensor

        See :func:`torch.floor_divide`
        """
    def floor_divide_(self, value) -> Tensor:
        """
        floor_divide_(value) -> Tensor

        In-place version of :meth:`~Tensor.floor_divide`
        """
    def fmax(self, other) -> Tensor:
        """
        fmax(other) -> Tensor

        See :func:`torch.fmax`
        """
    def fmin(self, other) -> Tensor:
        """
        fmin(other) -> Tensor

        See :func:`torch.fmin`
        """
    def fmod(self, divisor) -> Tensor:
        """
        fmod(divisor) -> Tensor

        See :func:`torch.fmod`
        """
    def fmod_(self, divisor) -> Tensor:
        """
        fmod_(divisor) -> Tensor

        In-place version of :meth:`~Tensor.fmod`
        """
    def frac(self) -> Tensor:
        """
        frac() -> Tensor

        See :func:`torch.frac`
        """
    def frac_(self) -> Tensor:
        """
        frac_() -> Tensor

        In-place version of :meth:`~Tensor.frac`
        """
    def frexp(self, *args, **kwargs):
        """
        frexp(input) -> (Tensor mantissa, Tensor exponent)

        See :func:`torch.frexp`
        """
    def gather(self, dim, index) -> Tensor:
        """
        gather(dim, index) -> Tensor

        See :func:`torch.gather`
        """
    def gcd(self, other) -> Tensor:
        """
        gcd(other) -> Tensor

        See :func:`torch.gcd`
        """
    def gcd_(self, other) -> Tensor:
        """
        gcd_(other) -> Tensor

        In-place version of :meth:`~Tensor.gcd`
        """
    def ge(self, other) -> Tensor:
        """
        ge(other) -> Tensor

        See :func:`torch.ge`.
        """
    def ge_(self, other) -> Tensor:
        """
        ge_(other) -> Tensor

        In-place version of :meth:`~Tensor.ge`.
        """
    def geometric_(self, p, generator=...) -> Tensor:
        """
        geometric_(p, *, generator=None) -> Tensor

        Fills :attr:`self` tensor with elements drawn from the geometric distribution:

        .. math::

            P(X=k) = (1 - p)^{k - 1} p, k = 1, 2, ...

        .. note::
          :func:`torch.Tensor.geometric_` `k`-th trial is the first success hence draws samples in :math:`\\{1, 2, \\ldots\\}`, whereas
          :func:`torch.distributions.geometric.Geometric` :math:`(k+1)`-th trial is the first success
          hence draws samples in :math:`\\{0, 1, \\ldots\\}`.
        """
    def geqrf(self, *args, **kwargs):
        """
        geqrf() -> (Tensor, Tensor)

        See :func:`torch.geqrf`
        """
    def ger(self, vec2) -> Tensor:
        """
        ger(vec2) -> Tensor

        See :func:`torch.ger`
        """
    @overload
    def get_device(self) -> Any:
        """
        get_device() -> Device ordinal (Integer)

        For CUDA tensors, this function returns the device ordinal of the GPU on which the tensor resides.
        For CPU tensors, this function returns `-1`.

        Example::

            >>> x = torch.randn(3, 4, 5, device='cuda:0')
            >>> x.get_device()
            0
            >>> x.cpu().get_device()
            -1
        """
    @overload
    def get_device(self) -> Any:
        """
        get_device() -> Device ordinal (Integer)

        For CUDA tensors, this function returns the device ordinal of the GPU on which the tensor resides.
        For CPU tensors, this function returns `-1`.

        Example::

            >>> x = torch.randn(3, 4, 5, device='cuda:0')
            >>> x.get_device()
            0
            >>> x.cpu().get_device()
            -1
        """
    def greater(self, other) -> Tensor:
        """
        greater(other) -> Tensor

        See :func:`torch.greater`.
        """
    def greater_(self, other) -> Tensor:
        """
        greater_(other) -> Tensor

        In-place version of :meth:`~Tensor.greater`.
        """
    def greater_equal(self, other) -> Tensor:
        """
        greater_equal(other) -> Tensor

        See :func:`torch.greater_equal`.
        """
    def greater_equal_(self, other) -> Tensor:
        """
        greater_equal_(other) -> Tensor

        In-place version of :meth:`~Tensor.greater_equal`.
        """
    def gt(self, other) -> Tensor:
        """
        gt(other) -> Tensor

        See :func:`torch.gt`.
        """
    def gt_(self, other) -> Tensor:
        """
        gt_(other) -> Tensor

        In-place version of :meth:`~Tensor.gt`.
        """
    @overload
    def half(self, memory_format=...) -> Tensor:
        """
        half(memory_format=torch.preserve_format) -> Tensor

        ``self.half()`` is equivalent to ``self.to(torch.float16)``. See :func:`to`.

        Args:
            memory_format (:class:`torch.memory_format`, optional): the desired memory format of
                returned Tensor. Default: ``torch.preserve_format``.
        """
    @overload
    def half(self) -> Any:
        """
        half(memory_format=torch.preserve_format) -> Tensor

        ``self.half()`` is equivalent to ``self.to(torch.float16)``. See :func:`to`.

        Args:
            memory_format (:class:`torch.memory_format`, optional): the desired memory format of
                returned Tensor. Default: ``torch.preserve_format``.
        """
    def hardshrink(self, lambd=...) -> Tensor:
        """
        hardshrink(lambd=0.5) -> Tensor

        See :func:`torch.nn.functional.hardshrink`
        """
    def has_names(self, *args, **kwargs):
        """
        Is ``True`` if any of this tensor's dimensions are named. Otherwise, is ``False``.
        """
    def heaviside(self, values) -> Tensor:
        """
        heaviside(values) -> Tensor

        See :func:`torch.heaviside`
        """
    def heaviside_(self, values) -> Tensor:
        """
        heaviside_(values) -> Tensor

        In-place version of :meth:`~Tensor.heaviside`
        """
    def histc(self, bins=..., min=..., max=...) -> Tensor:
        """
        histc(bins=100, min=0, max=0) -> Tensor

        See :func:`torch.histc`
        """
    def histogram(self, *args, **kwargs):
        """
        histogram(input, bins, *, range=None, weight=None, density=False) -> (Tensor, Tensor)

        See :func:`torch.histogram`
        """
    def hsplit(self, split_size_or_sections) -> ListofTensors:
        """
        hsplit(split_size_or_sections) -> List of Tensors

        See :func:`torch.hsplit`
        """
    def hypot(self, other) -> Tensor:
        """
        hypot(other) -> Tensor

        See :func:`torch.hypot`
        """
    def hypot_(self, other) -> Tensor:
        """
        hypot_(other) -> Tensor

        In-place version of :meth:`~Tensor.hypot`
        """
    def i0(self) -> Tensor:
        """
        i0() -> Tensor

        See :func:`torch.i0`
        """
    def i0_(self) -> Tensor:
        """
        i0_() -> Tensor

        In-place version of :meth:`~Tensor.i0`
        """
    def igamma(self, other) -> Tensor:
        """
        igamma(other) -> Tensor

        See :func:`torch.igamma`
        """
    def igamma_(self, other) -> Tensor:
        """
        igamma_(other) -> Tensor

        In-place version of :meth:`~Tensor.igamma`
        """
    def igammac(self, other) -> Tensor:
        """
        igammac(other) -> Tensor
        See :func:`torch.igammac`
        """
    def igammac_(self, other) -> Tensor:
        """
        igammac_(other) -> Tensor
        In-place version of :meth:`~Tensor.igammac`
        """
    def index_add(self, dim, index, source, alpha=...) -> Tensor:
        """
        index_add(dim, index, source, *, alpha=1) -> Tensor

        Out-of-place version of :meth:`torch.Tensor.index_add_`.
        """
    def index_add_(self, dim, index, source, alpha=...) -> Tensor:
        """
        index_add_(dim, index, source, *, alpha=1) -> Tensor

        Accumulate the elements of :attr:`alpha` times ``source`` into the :attr:`self`
        tensor by adding to the indices in the order given in :attr:`index`. For example,
        if ``dim == 0``, ``index[i] == j``, and ``alpha=-1``, then the ``i``\\ th row of
        ``source`` is subtracted from the ``j``\\ th row of :attr:`self`.

        The :attr:`dim`\\ th dimension of ``source`` must have the same size as the
        length of :attr:`index` (which must be a vector), and all other dimensions must
        match :attr:`self`, or an error will be raised.

        For a 3-D tensor the output is given as::

            self[index[i], :, :] += alpha * src[i, :, :]  # if dim == 0
            self[:, index[i], :] += alpha * src[:, i, :]  # if dim == 1
            self[:, :, index[i]] += alpha * src[:, :, i]  # if dim == 2

        Note:
            This operation may behave nondeterministically when given tensors on a CUDA device. See :doc:`/notes/randomness` for more information.

        Args:
            dim (int): dimension along which to index
            index (Tensor): indices of ``source`` to select from,
                    should have dtype either `torch.int64` or `torch.int32`
            source (Tensor): the tensor containing values to add

        Keyword args:
            alpha (Number): the scalar multiplier for ``source``

        Example::

            >>> x = torch.ones(5, 3)
            >>> t = torch.tensor([[1, 2, 3], [4, 5, 6], [7, 8, 9]], dtype=torch.float)
            >>> index = torch.tensor([0, 4, 2])
            >>> x.index_add_(0, index, t)
            tensor([[  2.,   3.,   4.],
                    [  1.,   1.,   1.],
                    [  8.,   9.,  10.],
                    [  1.,   1.,   1.],
                    [  5.,   6.,   7.]])
            >>> x.index_add_(0, index, t, alpha=-1)
            tensor([[  1.,   1.,   1.],
                    [  1.,   1.,   1.],
                    [  1.,   1.,   1.],
                    [  1.,   1.,   1.],
                    [  1.,   1.,   1.]])
        """
    def index_copy(self, dim, index, tensor2) -> Tensor:
        """
        index_copy(dim, index, tensor2) -> Tensor

        Out-of-place version of :meth:`torch.Tensor.index_copy_`.
        """
    def index_copy_(self, dim, index, tensor) -> Tensor:
        """
        index_copy_(dim, index, tensor) -> Tensor

        Copies the elements of :attr:`tensor` into the :attr:`self` tensor by selecting
        the indices in the order given in :attr:`index`. For example, if ``dim == 0``
        and ``index[i] == j``, then the ``i``\\ th row of :attr:`tensor` is copied to the
        ``j``\\ th row of :attr:`self`.

        The :attr:`dim`\\ th dimension of :attr:`tensor` must have the same size as the
        length of :attr:`index` (which must be a vector), and all other dimensions must
        match :attr:`self`, or an error will be raised.

        .. note::
            If :attr:`index` contains duplicate entries, multiple elements from
            :attr:`tensor` will be copied to the same index of :attr:`self`. The result
            is nondeterministic since it depends on which copy occurs last.

        Args:
            dim (int): dimension along which to index
            index (LongTensor): indices of :attr:`tensor` to select from
            tensor (Tensor): the tensor containing values to copy

        Example::

            >>> x = torch.zeros(5, 3)
            >>> t = torch.tensor([[1, 2, 3], [4, 5, 6], [7, 8, 9]], dtype=torch.float)
            >>> index = torch.tensor([0, 4, 2])
            >>> x.index_copy_(0, index, t)
            tensor([[ 1.,  2.,  3.],
                    [ 0.,  0.,  0.],
                    [ 7.,  8.,  9.],
                    [ 0.,  0.,  0.],
                    [ 4.,  5.,  6.]])
        """
    def index_fill(self, dim, index, value) -> Tensor:
        """
        index_fill(dim, index, value) -> Tensor

        Out-of-place version of :meth:`torch.Tensor.index_fill_`.
        """
    def index_fill_(self, dim, index, value) -> Tensor:
        """
        index_fill_(dim, index, value) -> Tensor

        Fills the elements of the :attr:`self` tensor with value :attr:`value` by
        selecting the indices in the order given in :attr:`index`.

        Args:
            dim (int): dimension along which to index
            index (LongTensor): indices of :attr:`self` tensor to fill in
            value (float): the value to fill with

        Example::

            >>> x = torch.tensor([[1, 2, 3], [4, 5, 6], [7, 8, 9]], dtype=torch.float)
            >>> index = torch.tensor([0, 2])
            >>> x.index_fill_(1, index, -1)
            tensor([[-1.,  2., -1.],
                    [-1.,  5., -1.],
                    [-1.,  8., -1.]])
        """
    def index_put(self, indices, values, accumulate=...) -> Tensor:
        """
        index_put(indices, values, accumulate=False) -> Tensor

        Out-place version of :meth:`~Tensor.index_put_`.
        """
    @overload
    def index_put_(self, indices, values, accumulate=...) -> Tensor:
        """
        index_put_(indices, values, accumulate=False) -> Tensor

        Puts values from the tensor :attr:`values` into the tensor :attr:`self` using
        the indices specified in :attr:`indices` (which is a tuple of Tensors). The
        expression ``tensor.index_put_(indices, values)`` is equivalent to
        ``tensor[indices] = values``. Returns :attr:`self`.

        If :attr:`accumulate` is ``True``, the elements in :attr:`values` are added to
        :attr:`self`. If accumulate is ``False``, the behavior is undefined if indices
        contain duplicate elements.

        Args:
            indices (tuple of LongTensor): tensors used to index into `self`.
            values (Tensor): tensor of same dtype as `self`.
            accumulate (bool): whether to accumulate into self
        """
    @overload
    def index_put_(self, indices, values) -> Any:
        """
        index_put_(indices, values, accumulate=False) -> Tensor

        Puts values from the tensor :attr:`values` into the tensor :attr:`self` using
        the indices specified in :attr:`indices` (which is a tuple of Tensors). The
        expression ``tensor.index_put_(indices, values)`` is equivalent to
        ``tensor[indices] = values``. Returns :attr:`self`.

        If :attr:`accumulate` is ``True``, the elements in :attr:`values` are added to
        :attr:`self`. If accumulate is ``False``, the behavior is undefined if indices
        contain duplicate elements.

        Args:
            indices (tuple of LongTensor): tensors used to index into `self`.
            values (Tensor): tensor of same dtype as `self`.
            accumulate (bool): whether to accumulate into self
        """
    def index_reduce(self, *args, **kwargs): ...
    def index_reduce_(self, dim, index, source, reduce, include_self=...) -> Tensor:
        '''
        index_reduce_(dim, index, source, reduce, *, include_self=True) -> Tensor

        Accumulate the elements of ``source`` into the :attr:`self`
        tensor by accumulating to the indices in the order given in :attr:`index`
        using the reduction given by the ``reduce`` argument. For example, if ``dim == 0``,
        ``index[i] == j``, ``reduce == prod`` and ``include_self == True`` then the ``i``\\ th
        row of ``source`` is multiplied by the ``j``\\ th row of :attr:`self`. If
        :obj:`include_self="True"`, the values in the :attr:`self` tensor are included
        in the reduction, otherwise, rows in the :attr:`self` tensor that are accumulated
        to are treated as if they were filled with the reduction identites.

        The :attr:`dim`\\ th dimension of ``source`` must have the same size as the
        length of :attr:`index` (which must be a vector), and all other dimensions must
        match :attr:`self`, or an error will be raised.

        For a 3-D tensor with :obj:`reduce="prod"` and :obj:`include_self=True` the
        output is given as::

            self[index[i], :, :] *= src[i, :, :]  # if dim == 0
            self[:, index[i], :] *= src[:, i, :]  # if dim == 1
            self[:, :, index[i]] *= src[:, :, i]  # if dim == 2

        Note:
            This operation may behave nondeterministically when given tensors on a CUDA device. See :doc:`/notes/randomness` for more information.

        .. note::

            This function only supports floating point tensors.

        .. warning::

            This function is in beta and may change in the near future.

        Args:
            dim (int): dimension along which to index
            index (Tensor): indices of ``source`` to select from,
                should have dtype either `torch.int64` or `torch.int32`
            source (FloatTensor): the tensor containing values to accumulate
            reduce (str): the reduction operation to apply
                (:obj:`"prod"`, :obj:`"mean"`, :obj:`"amax"`, :obj:`"amin"`)

        Keyword args:
            include_self (bool): whether the elements from the ``self`` tensor are
                included in the reduction

        Example::

            >>> x = torch.empty(5, 3).fill_(2)
            >>> t = torch.tensor([[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12]], dtype=torch.float)
            >>> index = torch.tensor([0, 4, 2, 0])
            >>> x.index_reduce_(0, index, t, \'prod\')
            tensor([[20., 44., 72.],
                    [ 2.,  2.,  2.],
                    [14., 16., 18.],
                    [ 2.,  2.,  2.],
                    [ 8., 10., 12.]])
            >>> x = torch.empty(5, 3).fill_(2)
            >>> x.index_reduce_(0, index, t, \'prod\', include_self=False)
            tensor([[10., 22., 36.],
                    [ 2.,  2.,  2.],
                    [ 7.,  8.,  9.],
                    [ 2.,  2.,  2.],
                    [ 4.,  5.,  6.]])
        '''
    def index_select(self, dim, index) -> Tensor:
        """
        index_select(dim, index) -> Tensor

        See :func:`torch.index_select`
        """
    def indices(self) -> Tensor:
        """
        indices() -> Tensor

        Return the indices tensor of a :ref:`sparse COO tensor <sparse-coo-docs>`.

        .. warning::
          Throws an error if :attr:`self` is not a sparse COO tensor.

        See also :meth:`Tensor.values`.

        .. note::
          This method can only be called on a coalesced sparse tensor. See
          :meth:`Tensor.coalesce` for details.
        """
    def inner(self, other) -> Tensor:
        """
        inner(other) -> Tensor

        See :func:`torch.inner`.
        """
    @overload
    def int(self, memory_format=...) -> Tensor:
        """
        int(memory_format=torch.preserve_format) -> Tensor

        ``self.int()`` is equivalent to ``self.to(torch.int32)``. See :func:`to`.

        Args:
            memory_format (:class:`torch.memory_format`, optional): the desired memory format of
                returned Tensor. Default: ``torch.preserve_format``.
        """
    @overload
    def int(self) -> Any:
        """
        int(memory_format=torch.preserve_format) -> Tensor

        ``self.int()`` is equivalent to ``self.to(torch.int32)``. See :func:`to`.

        Args:
            memory_format (:class:`torch.memory_format`, optional): the desired memory format of
                returned Tensor. Default: ``torch.preserve_format``.
        """
    @overload
    def int_repr(self) -> Tensor:
        """
        int_repr() -> Tensor

        Given a quantized Tensor,
        ``self.int_repr()`` returns a CPU Tensor with uint8_t as data type that stores the
        underlying uint8_t values of the given Tensor.
        """
    @overload
    def int_repr(self) -> Any:
        """
        int_repr() -> Tensor

        Given a quantized Tensor,
        ``self.int_repr()`` returns a CPU Tensor with uint8_t as data type that stores the
        underlying uint8_t values of the given Tensor.
        """
    def inverse(self) -> Tensor:
        """
        inverse() -> Tensor

        See :func:`torch.inverse`
        """
    def ipu(self, device=..., non_blocking=..., memory_format=...) -> Tensor:
        """
        ipu(device=None, non_blocking=False, memory_format=torch.preserve_format) -> Tensor

        Returns a copy of this object in IPU memory.

        If this object is already in IPU memory and on the correct device,
        then no copy is performed and the original object is returned.

        Args:
            device (:class:`torch.device`): The destination IPU device.
                Defaults to the current IPU device.
            non_blocking (bool): If ``True`` and the source is in pinned memory,
                the copy will be asynchronous with respect to the host.
                Otherwise, the argument has no effect. Default: ``False``.
            memory_format (:class:`torch.memory_format`, optional): the desired memory format of
                returned Tensor. Default: ``torch.preserve_format``.
        """
    def is_coalesced(self) -> bool:
        """
        is_coalesced() -> bool

        Returns ``True`` if :attr:`self` is a :ref:`sparse COO tensor
        <sparse-coo-docs>` that is coalesced, ``False`` otherwise.

        .. warning::
          Throws an error if :attr:`self` is not a sparse COO tensor.

        See :meth:`coalesce` and :ref:`uncoalesced tensors <sparse-uncoalesced-coo-docs>`.
        """
    def is_complex(self) -> bool:
        """
        is_complex() -> bool

        Returns True if the data type of :attr:`self` is a complex data type.
        """
    def is_conj(self) -> bool:
        """
        is_conj() -> bool

        Returns True if the conjugate bit of :attr:`self` is set to true.
        """
    def is_contiguous(self, memory_format=...) -> bool:
        """
        is_contiguous(memory_format=torch.contiguous_format) -> bool

        Returns True if :attr:`self` tensor is contiguous in memory in the order specified
        by memory format.

        Args:
            memory_format (:class:`torch.memory_format`, optional): Specifies memory allocation
                order. Default: ``torch.contiguous_format``.
        """
    def is_distributed(self, *args, **kwargs): ...
    def is_floating_point(self) -> bool:
        """
        is_floating_point() -> bool

        Returns True if the data type of :attr:`self` is a floating point data type.
        """
    def is_inference(self) -> bool:
        """
        is_inference() -> bool

        See :func:`torch.is_inference`
        """
    def is_neg(self) -> bool:
        """
        is_neg() -> bool

        Returns True if the negative bit of :attr:`self` is set to true.
        """
    def is_nonzero(self, *args, **kwargs): ...
    def is_pinned(self, *args, **kwargs):
        """
        Returns true if this tensor resides in pinned memory.
        By default, the device pinned memory on will be the current :ref:`accelerator<accelerators>`.
        """
    def is_same_size(self, *args, **kwargs): ...
    def is_set_to(self, tensor) -> bool:
        """
        is_set_to(tensor) -> bool

        Returns True if both tensors are pointing to the exact same memory (same
        storage, offset, size and stride).
        """
    def is_signed(self) -> bool:
        """
        is_signed() -> bool

        Returns True if the data type of :attr:`self` is a signed data type.
        """
    def isclose(self, other, rtol=..., atol=..., equal_nan=...) -> Tensor:
        """
        isclose(other, rtol=1e-05, atol=1e-08, equal_nan=False) -> Tensor

        See :func:`torch.isclose`
        """
    def isfinite(self) -> Tensor:
        """
        isfinite() -> Tensor

        See :func:`torch.isfinite`
        """
    def isinf(self) -> Tensor:
        """
        isinf() -> Tensor

        See :func:`torch.isinf`
        """
    def isnan(self) -> Tensor:
        """
        isnan() -> Tensor

        See :func:`torch.isnan`
        """
    def isneginf(self) -> Tensor:
        """
        isneginf() -> Tensor

        See :func:`torch.isneginf`
        """
    def isposinf(self) -> Tensor:
        """
        isposinf() -> Tensor

        See :func:`torch.isposinf`
        """
    def isreal(self) -> Tensor:
        """
        isreal() -> Tensor

        See :func:`torch.isreal`
        """
    def istft(self, n_fft, hop_length=..., win_length=..., window=..., 
center=..., normalized=..., onesided=..., length=...) -> Tensor:
        """
        istft(n_fft, hop_length=None, win_length=None, window=None,
         center=True, normalized=False, onesided=True, length=None) -> Tensor

        See :func:`torch.istft`
        """
    @overload
    def item(self) -> number:
        """
        item() -> number

        Returns the value of this tensor as a standard Python number. This only works
        for tensors with one element. For other cases, see :meth:`~Tensor.tolist`.

        This operation is not differentiable.

        Example::

            >>> x = torch.tensor([1.0])
            >>> x.item()
            1.0

        """
    @overload
    def item(self) -> Any:
        """
        item() -> number

        Returns the value of this tensor as a standard Python number. This only works
        for tensors with one element. For other cases, see :meth:`~Tensor.tolist`.

        This operation is not differentiable.

        Example::

            >>> x = torch.tensor([1.0])
            >>> x.item()
            1.0

        """
    def kron(self, other) -> Tensor:
        """
        kron(other) -> Tensor

        See :func:`torch.kron`
        """
    def kthvalue(self, *args, **kwargs):
        """
        kthvalue(k, dim=None, keepdim=False) -> (Tensor, LongTensor)

        See :func:`torch.kthvalue`
        """
    def lcm(self, other) -> Tensor:
        """
        lcm(other) -> Tensor

        See :func:`torch.lcm`
        """
    def lcm_(self, other) -> Tensor:
        """
        lcm_(other) -> Tensor

        In-place version of :meth:`~Tensor.lcm`
        """
    def ldexp(self, other) -> Tensor:
        """
        ldexp(other) -> Tensor

        See :func:`torch.ldexp`
        """
    def ldexp_(self, other) -> Tensor:
        """
        ldexp_(other) -> Tensor

        In-place version of :meth:`~Tensor.ldexp`
        """
    def le(self, other) -> Tensor:
        """
        le(other) -> Tensor

        See :func:`torch.le`.
        """
    def le_(self, other) -> Tensor:
        """
        le_(other) -> Tensor

        In-place version of :meth:`~Tensor.le`.
        """
    def lerp(self, end, weight) -> Tensor:
        """
        lerp(end, weight) -> Tensor

        See :func:`torch.lerp`
        """
    def lerp_(self, end, weight) -> Tensor:
        """
        lerp_(end, weight) -> Tensor

        In-place version of :meth:`~Tensor.lerp`
        """
    def less(self, *args, **kwargs):
        """
        lt(other) -> Tensor

        See :func:`torch.less`.
        """
    def less_(self, other) -> Tensor:
        """
        less_(other) -> Tensor

        In-place version of :meth:`~Tensor.less`.
        """
    def less_equal(self, other) -> Tensor:
        """
        less_equal(other) -> Tensor

        See :func:`torch.less_equal`.
        """
    def less_equal_(self, other) -> Tensor:
        """
        less_equal_(other) -> Tensor

        In-place version of :meth:`~Tensor.less_equal`.
        """
    def lgamma(self) -> Tensor:
        """
        lgamma() -> Tensor

        See :func:`torch.lgamma`
        """
    def lgamma_(self) -> Tensor:
        """
        lgamma_() -> Tensor

        In-place version of :meth:`~Tensor.lgamma`
        """
    def log(self) -> Tensor:
        """
        log() -> Tensor

        See :func:`torch.log`
        """
    def log10(self) -> Tensor:
        """
        log10() -> Tensor

        See :func:`torch.log10`
        """
    def log10_(self) -> Tensor:
        """
        log10_() -> Tensor

        In-place version of :meth:`~Tensor.log10`
        """
    def log1p(self) -> Tensor:
        """
        log1p() -> Tensor

        See :func:`torch.log1p`
        """
    def log1p_(self) -> Tensor:
        """
        log1p_() -> Tensor

        In-place version of :meth:`~Tensor.log1p`
        """
    def log2(self) -> Tensor:
        """
        log2() -> Tensor

        See :func:`torch.log2`
        """
    def log2_(self) -> Tensor:
        """
        log2_() -> Tensor

        In-place version of :meth:`~Tensor.log2`
        """
    def log_(self) -> Tensor:
        """
        log_() -> Tensor

        In-place version of :meth:`~Tensor.log`
        """
    def log_normal_(self, mean=..., std=..., generator=...) -> Any:
        """
        log_normal_(mean=1, std=2, *, generator=None)

        Fills :attr:`self` tensor with numbers samples from the log-normal distribution
        parameterized by the given mean :math:`\\mu` and standard deviation
        :math:`\\sigma`. Note that :attr:`mean` and :attr:`std` are the mean and
        standard deviation of the underlying normal distribution, and not of the
        returned distribution:

        .. math::

            f(x) = \\dfrac{1}{x \\sigma \\sqrt{2\\pi}}\\ e^{-\\frac{(\\ln x - \\mu)^2}{2\\sigma^2}}
        """
    def log_softmax(self, *args, **kwargs): ...
    def logaddexp(self, other) -> Tensor:
        """
        logaddexp(other) -> Tensor

        See :func:`torch.logaddexp`
        """
    def logaddexp2(self, other) -> Tensor:
        """
        logaddexp2(other) -> Tensor

        See :func:`torch.logaddexp2`
        """
    def logcumsumexp(self, dim) -> Tensor:
        """
        logcumsumexp(dim) -> Tensor

        See :func:`torch.logcumsumexp`
        """
    def logdet(self) -> Tensor:
        """
        logdet() -> Tensor

        See :func:`torch.logdet`
        """
    def logical_and(self) -> Tensor:
        """
        logical_and() -> Tensor

        See :func:`torch.logical_and`
        """
    def logical_and_(self) -> Tensor:
        """
        logical_and_() -> Tensor

        In-place version of :meth:`~Tensor.logical_and`
        """
    def logical_not(self) -> Tensor:
        """
        logical_not() -> Tensor

        See :func:`torch.logical_not`
        """
    def logical_not_(self) -> Tensor:
        """
        logical_not_() -> Tensor

        In-place version of :meth:`~Tensor.logical_not`
        """
    def logical_or(self) -> Tensor:
        """
        logical_or() -> Tensor

        See :func:`torch.logical_or`
        """
    def logical_or_(self) -> Tensor:
        """
        logical_or_() -> Tensor

        In-place version of :meth:`~Tensor.logical_or`
        """
    def logical_xor(self) -> Tensor:
        """
        logical_xor() -> Tensor

        See :func:`torch.logical_xor`
        """
    def logical_xor_(self) -> Tensor:
        """
        logical_xor_() -> Tensor

        In-place version of :meth:`~Tensor.logical_xor`
        """
    def logit(self) -> Tensor:
        """
        logit() -> Tensor

        See :func:`torch.logit`
        """
    def logit_(self) -> Tensor:
        """
        logit_() -> Tensor

        In-place version of :meth:`~Tensor.logit`
        """
    def logsumexp(self, dim, keepdim=...) -> Tensor:
        """
        logsumexp(dim, keepdim=False) -> Tensor

        See :func:`torch.logsumexp`
        """
    @overload
    def long(self, memory_format=...) -> Tensor:
        """
        long(memory_format=torch.preserve_format) -> Tensor

        ``self.long()`` is equivalent to ``self.to(torch.int64)``. See :func:`to`.

        Args:
            memory_format (:class:`torch.memory_format`, optional): the desired memory format of
                returned Tensor. Default: ``torch.preserve_format``.
        """
    @overload
    def long(self) -> Any:
        """
        long(memory_format=torch.preserve_format) -> Tensor

        ``self.long()`` is equivalent to ``self.to(torch.int64)``. See :func:`to`.

        Args:
            memory_format (:class:`torch.memory_format`, optional): the desired memory format of
                returned Tensor. Default: ``torch.preserve_format``.
        """
    def lt(self, other) -> Tensor:
        """
        lt(other) -> Tensor

        See :func:`torch.lt`.
        """
    def lt_(self, other) -> Tensor:
        """
        lt_(other) -> Tensor

        In-place version of :meth:`~Tensor.lt`.
        """
    def lu_solve(self, LU_data, LU_pivots) -> Tensor:
        """
        lu_solve(LU_data, LU_pivots) -> Tensor

        See :func:`torch.lu_solve`
        """
    def map2_(self, *args, **kwargs): ...
    def map_(self, tensor, callable) -> Any:
        """
        map_(tensor, callable)

        Applies :attr:`callable` for each element in :attr:`self` tensor and the given
        :attr:`tensor` and stores the results in :attr:`self` tensor. :attr:`self` tensor and
        the given :attr:`tensor` must be :ref:`broadcastable <broadcasting-semantics>`.

        The :attr:`callable` should have the signature::

            def callable(a, b) -> number
        """
    def masked_fill(self, mask, value) -> Tensor:
        """
        masked_fill(mask, value) -> Tensor

        Out-of-place version of :meth:`torch.Tensor.masked_fill_`
        """
    def masked_fill_(self, mask, value) -> Any:
        """
        masked_fill_(mask, value)

        Fills elements of :attr:`self` tensor with :attr:`value` where :attr:`mask` is
        True. The shape of :attr:`mask` must be
        :ref:`broadcastable <broadcasting-semantics>` with the shape of the underlying
        tensor.

        Args:
            mask (BoolTensor): the boolean mask
            value (float): the value to fill in with
        """
    @overload
    def masked_scatter(self, mask, tensor) -> Tensor:
        """
        masked_scatter(mask, tensor) -> Tensor

        Out-of-place version of :meth:`torch.Tensor.masked_scatter_`

        .. note::

            The inputs :attr:`self` and :attr:`mask`
            :ref:`broadcast <broadcasting-semantics>`.

        Example:

            >>> self = torch.tensor([0, 0, 0, 0, 0])
            >>> mask = torch.tensor(
            ...     [[0, 0, 0, 1, 1], [1, 1, 0, 1, 1]],
            ...     dtype=torch.bool,
            ... )
            >>> source = torch.tensor([[0, 1, 2, 3, 4], [5, 6, 7, 8, 9]])
            >>> self.masked_scatter(mask, source)
            tensor([[0, 0, 0, 0, 1],
                    [2, 3, 0, 4, 5]])

        """
    @overload
    def masked_scatter(self, mask, source) -> Any:
        """
        masked_scatter(mask, tensor) -> Tensor

        Out-of-place version of :meth:`torch.Tensor.masked_scatter_`

        .. note::

            The inputs :attr:`self` and :attr:`mask`
            :ref:`broadcast <broadcasting-semantics>`.

        Example:

            >>> self = torch.tensor([0, 0, 0, 0, 0])
            >>> mask = torch.tensor(
            ...     [[0, 0, 0, 1, 1], [1, 1, 0, 1, 1]],
            ...     dtype=torch.bool,
            ... )
            >>> source = torch.tensor([[0, 1, 2, 3, 4], [5, 6, 7, 8, 9]])
            >>> self.masked_scatter(mask, source)
            tensor([[0, 0, 0, 0, 1],
                    [2, 3, 0, 4, 5]])

        """
    @overload
    def masked_scatter_(self, mask, source) -> Any:
        """
        masked_scatter_(mask, source)

        Copies elements from :attr:`source` into :attr:`self` tensor at positions where
        the :attr:`mask` is True. Elements from :attr:`source` are copied into :attr:`self`
        starting at position 0 of :attr:`source` and continuing in order one-by-one for each
        occurrence of :attr:`mask` being True.
        The shape of :attr:`mask` must be :ref:`broadcastable <broadcasting-semantics>`
        with the shape of the underlying tensor. The :attr:`source` should have at least
        as many elements as the number of ones in :attr:`mask`.

        Args:
            mask (BoolTensor): the boolean mask
            source (Tensor): the tensor to copy from

        .. note::

            The :attr:`mask` operates on the :attr:`self` tensor, not on the given
            :attr:`source` tensor.

        Example:

            >>> self = torch.tensor([[0, 0, 0, 0, 0], [0, 0, 0, 0, 0]])
            >>> mask = torch.tensor(
            ...     [[0, 0, 0, 1, 1], [1, 1, 0, 1, 1]],
            ...     dtype=torch.bool,
            ... )
            >>> source = torch.tensor([[0, 1, 2, 3, 4], [5, 6, 7, 8, 9]])
            >>> self.masked_scatter_(mask, source)
            tensor([[0, 0, 0, 0, 1],
                    [2, 3, 0, 4, 5]])

        """
    @overload
    def masked_scatter_(self, mask, source) -> Any:
        """
        masked_scatter_(mask, source)

        Copies elements from :attr:`source` into :attr:`self` tensor at positions where
        the :attr:`mask` is True. Elements from :attr:`source` are copied into :attr:`self`
        starting at position 0 of :attr:`source` and continuing in order one-by-one for each
        occurrence of :attr:`mask` being True.
        The shape of :attr:`mask` must be :ref:`broadcastable <broadcasting-semantics>`
        with the shape of the underlying tensor. The :attr:`source` should have at least
        as many elements as the number of ones in :attr:`mask`.

        Args:
            mask (BoolTensor): the boolean mask
            source (Tensor): the tensor to copy from

        .. note::

            The :attr:`mask` operates on the :attr:`self` tensor, not on the given
            :attr:`source` tensor.

        Example:

            >>> self = torch.tensor([[0, 0, 0, 0, 0], [0, 0, 0, 0, 0]])
            >>> mask = torch.tensor(
            ...     [[0, 0, 0, 1, 1], [1, 1, 0, 1, 1]],
            ...     dtype=torch.bool,
            ... )
            >>> source = torch.tensor([[0, 1, 2, 3, 4], [5, 6, 7, 8, 9]])
            >>> self.masked_scatter_(mask, source)
            tensor([[0, 0, 0, 0, 1],
                    [2, 3, 0, 4, 5]])

        """
    def masked_select(self, mask) -> Tensor:
        """
        masked_select(mask) -> Tensor

        See :func:`torch.masked_select`
        """
    def matmul(self, tensor2) -> Tensor:
        """
        matmul(tensor2) -> Tensor

        See :func:`torch.matmul`
        """
    def matrix_exp(self) -> Tensor:
        """
        matrix_exp() -> Tensor

        See :func:`torch.matrix_exp`
        """
    def matrix_power(self, n) -> Tensor:
        """
        matrix_power(n) -> Tensor

        .. note:: :meth:`~Tensor.matrix_power` is deprecated, use :func:`torch.linalg.matrix_power` instead.

        Alias for :func:`torch.linalg.matrix_power`
        """
    def max(self, *args, **kwargs):
        """
        max(dim=None, keepdim=False) -> Tensor or (Tensor, Tensor)

        See :func:`torch.max`
        """
    def maximum(self, other) -> Tensor:
        """
        maximum(other) -> Tensor

        See :func:`torch.maximum`
        """
    def mean(self, dim=..., keepdim=..., dtype=...) -> Tensor:
        """
        mean(dim=None, keepdim=False, *, dtype=None) -> Tensor

        See :func:`torch.mean`
        """
    def median(self, *args, **kwargs):
        """
        median(dim=None, keepdim=False) -> (Tensor, LongTensor)

        See :func:`torch.median`
        """
    def min(self, *args, **kwargs):
        """
        min(dim=None, keepdim=False) -> Tensor or (Tensor, Tensor)

        See :func:`torch.min`
        """
    def minimum(self, other) -> Tensor:
        """
        minimum(other) -> Tensor

        See :func:`torch.minimum`
        """
    def mm(self, mat2) -> Tensor:
        """
        mm(mat2) -> Tensor

        See :func:`torch.mm`
        """
    def mode(self, *args, **kwargs):
        """
        mode(dim=None, keepdim=False) -> (Tensor, LongTensor)

        See :func:`torch.mode`
        """
    def moveaxis(self, source, destination) -> Tensor:
        """
        moveaxis(source, destination) -> Tensor

        See :func:`torch.moveaxis`
        """
    def movedim(self, source, destination) -> Tensor:
        """
        movedim(source, destination) -> Tensor

        See :func:`torch.movedim`
        """
    def msort(self) -> Tensor:
        """
        msort() -> Tensor

        See :func:`torch.msort`
        """
    def mtia(self, device=..., non_blocking=..., memory_format=...) -> Tensor:
        """
        mtia(device=None, non_blocking=False, memory_format=torch.preserve_format) -> Tensor

        Returns a copy of this object in MTIA memory.

        If this object is already in MTIA memory and on the correct device,
        then no copy is performed and the original object is returned.

        Args:
            device (:class:`torch.device`): The destination MTIA device.
                Defaults to the current MTIA device.
            non_blocking (bool): If ``True`` and the source is in pinned memory,
                the copy will be asynchronous with respect to the host.
                Otherwise, the argument has no effect. Default: ``False``.
            memory_format (:class:`torch.memory_format`, optional): the desired memory format of
                returned Tensor. Default: ``torch.preserve_format``.
        """
    def mul(self, value) -> Tensor:
        """
        mul(value) -> Tensor

        See :func:`torch.mul`.
        """
    def mul_(self, value) -> Tensor:
        """
        mul_(value) -> Tensor

        In-place version of :meth:`~Tensor.mul`.
        """
    def multinomial(self, num_samples, replacement=..., generator=...) -> Tensor:
        """
        multinomial(num_samples, replacement=False, *, generator=None) -> Tensor

        See :func:`torch.multinomial`
        """
    def multiply(self, value) -> Tensor:
        """
        multiply(value) -> Tensor

        See :func:`torch.multiply`.
        """
    def multiply_(self, value) -> Tensor:
        """
        multiply_(value) -> Tensor

        In-place version of :meth:`~Tensor.multiply`.
        """
    def mv(self, vec) -> Tensor:
        """
        mv(vec) -> Tensor

        See :func:`torch.mv`
        """
    def mvlgamma(self, p) -> Tensor:
        """
        mvlgamma(p) -> Tensor

        See :func:`torch.mvlgamma`
        """
    def mvlgamma_(self, p) -> Tensor:
        """
        mvlgamma_(p) -> Tensor

        In-place version of :meth:`~Tensor.mvlgamma`
        """
    def nan_to_num(self, nan=..., posinf=..., neginf=...) -> Tensor:
        """
        nan_to_num(nan=0.0, posinf=None, neginf=None) -> Tensor

        See :func:`torch.nan_to_num`.
        """
    def nan_to_num_(self, nan=..., posinf=..., neginf=...) -> Tensor:
        """
        nan_to_num_(nan=0.0, posinf=None, neginf=None) -> Tensor

        In-place version of :meth:`~Tensor.nan_to_num`.
        """
    def nanmean(self, dim=..., keepdim=..., dtype=...) -> Tensor:
        """
        nanmean(dim=None, keepdim=False, *, dtype=None) -> Tensor

        See :func:`torch.nanmean`
        """
    def nanmedian(self, *args, **kwargs):
        """
        nanmedian(dim=None, keepdim=False) -> (Tensor, LongTensor)

        See :func:`torch.nanmedian`
        """
    def nanquantile(self, q, dim=..., keepdim=..., interpolation=...) -> Tensor:
        """
        nanquantile(q, dim=None, keepdim=False, *, interpolation='linear') -> Tensor

        See :func:`torch.nanquantile`
        """
    def nansum(self, dim=..., keepdim=..., dtype=...) -> Tensor:
        """
        nansum(dim=None, keepdim=False, dtype=None) -> Tensor

        See :func:`torch.nansum`
        """
    def narrow(self, dimension, start, length) -> Tensor:
        """
        narrow(dimension, start, length) -> Tensor

        See :func:`torch.narrow`.
        """
    def narrow_copy(self, dimension, start, length) -> Tensor:
        """
        narrow_copy(dimension, start, length) -> Tensor

        See :func:`torch.narrow_copy`.
        """
    def ndimension(self) -> int:
        """
        ndimension() -> int

        Alias for :meth:`~Tensor.dim()`
        """
    def ne(self, other) -> Tensor:
        """
        ne(other) -> Tensor

        See :func:`torch.ne`.
        """
    def ne_(self, other) -> Tensor:
        """
        ne_(other) -> Tensor

        In-place version of :meth:`~Tensor.ne`.
        """
    def neg(self) -> Tensor:
        """
        neg() -> Tensor

        See :func:`torch.neg`
        """
    def neg_(self) -> Tensor:
        """
        neg_() -> Tensor

        In-place version of :meth:`~Tensor.neg`
        """
    def negative(self) -> Tensor:
        """
        negative() -> Tensor

        See :func:`torch.negative`
        """
    def negative_(self) -> Tensor:
        """
        negative_() -> Tensor

        In-place version of :meth:`~Tensor.negative`
        """
    def nelement(self) -> int:
        """
        nelement() -> int

        Alias for :meth:`~Tensor.numel`
        """
    def new(self, *args, **kwargs): ...
    def new_empty(self, size, dtype=..., device=..., requires_grad=..., layout=..., pin_memory=...) -> Tensor:
        """
        new_empty(size, *, dtype=None, device=None, requires_grad=False, layout=torch.strided, pin_memory=False) -> Tensor


        Returns a Tensor of size :attr:`size` filled with uninitialized data.
        By default, the returned Tensor has the same :class:`torch.dtype` and
        :class:`torch.device` as this tensor.

        Args:
            size (int...): a list, tuple, or :class:`torch.Size` of integers defining the
                shape of the output tensor.

        Keyword args:
            dtype (:class:`torch.dtype`, optional): the desired type of returned tensor.
                Default: if None, same :class:`torch.dtype` as this tensor.
            device (:class:`torch.device`, optional): the desired device of returned tensor.
                Default: if None, same :class:`torch.device` as this tensor.
            requires_grad (bool, optional): If autograd should record operations on the
                returned tensor. Default: ``False``.
            layout (:class:`torch.layout`, optional): the desired layout of returned Tensor.
                Default: ``torch.strided``.
            pin_memory (bool, optional): If set, returned tensor would be allocated in
                the pinned memory. Works only for CPU tensors. Default: ``False``.

        Example::

            >>> tensor = torch.ones(())
            >>> tensor.new_empty((2, 3))
            tensor([[ 5.8182e-18,  4.5765e-41, -1.0545e+30],
                    [ 3.0949e-41,  4.4842e-44,  0.0000e+00]])

        """
    def new_empty_strided(self, size, stride, dtype=..., device=..., requires_grad=..., layout=..., pin_memory=...) -> Tensor:
        """
        new_empty_strided(size, stride, dtype=None, device=None, requires_grad=False, layout=torch.strided, pin_memory=False) -> Tensor


        Returns a Tensor of size :attr:`size` and strides :attr:`stride` filled with
        uninitialized data. By default, the returned Tensor has the same
        :class:`torch.dtype` and :class:`torch.device` as this tensor.

        Args:
            size (int...): a list, tuple, or :class:`torch.Size` of integers defining the
                shape of the output tensor.

        Keyword args:
            dtype (:class:`torch.dtype`, optional): the desired type of returned tensor.
                Default: if None, same :class:`torch.dtype` as this tensor.
            device (:class:`torch.device`, optional): the desired device of returned tensor.
                Default: if None, same :class:`torch.device` as this tensor.
            requires_grad (bool, optional): If autograd should record operations on the
                returned tensor. Default: ``False``.
            layout (:class:`torch.layout`, optional): the desired layout of returned Tensor.
                Default: ``torch.strided``.
            pin_memory (bool, optional): If set, returned tensor would be allocated in
                the pinned memory. Works only for CPU tensors. Default: ``False``.

        Example::

            >>> tensor = torch.ones(())
            >>> tensor.new_empty_strided((2, 3), (3, 1))
            tensor([[ 5.8182e-18,  4.5765e-41, -1.0545e+30],
                    [ 3.0949e-41,  4.4842e-44,  0.0000e+00]])

        """
    def new_full(self, size, fill_value, dtype=..., device=..., requires_grad=..., layout=..., pin_memory=...) -> Tensor:
        """
        new_full(size, fill_value, *, dtype=None, device=None, requires_grad=False, layout=torch.strided, pin_memory=False) -> Tensor


        Returns a Tensor of size :attr:`size` filled with :attr:`fill_value`.
        By default, the returned Tensor has the same :class:`torch.dtype` and
        :class:`torch.device` as this tensor.

        Args:
            fill_value (scalar): the number to fill the output tensor with.

        Keyword args:
            dtype (:class:`torch.dtype`, optional): the desired type of returned tensor.
                Default: if None, same :class:`torch.dtype` as this tensor.
            device (:class:`torch.device`, optional): the desired device of returned tensor.
                Default: if None, same :class:`torch.device` as this tensor.
            requires_grad (bool, optional): If autograd should record operations on the
                returned tensor. Default: ``False``.
            layout (:class:`torch.layout`, optional): the desired layout of returned Tensor.
                Default: ``torch.strided``.
            pin_memory (bool, optional): If set, returned tensor would be allocated in
                the pinned memory. Works only for CPU tensors. Default: ``False``.

        Example::

            >>> tensor = torch.ones((2,), dtype=torch.float64)
            >>> tensor.new_full((3, 4), 3.141592)
            tensor([[ 3.1416,  3.1416,  3.1416,  3.1416],
                    [ 3.1416,  3.1416,  3.1416,  3.1416],
                    [ 3.1416,  3.1416,  3.1416,  3.1416]], dtype=torch.float64)

        """
    def new_ones(self, size, dtype=..., device=..., requires_grad=..., layout=..., pin_memory=...) -> Tensor:
        """
        new_ones(size, *, dtype=None, device=None, requires_grad=False, layout=torch.strided, pin_memory=False) -> Tensor


        Returns a Tensor of size :attr:`size` filled with ``1``.
        By default, the returned Tensor has the same :class:`torch.dtype` and
        :class:`torch.device` as this tensor.

        Args:
            size (int...): a list, tuple, or :class:`torch.Size` of integers defining the
                shape of the output tensor.

        Keyword args:
            dtype (:class:`torch.dtype`, optional): the desired type of returned tensor.
                Default: if None, same :class:`torch.dtype` as this tensor.
            device (:class:`torch.device`, optional): the desired device of returned tensor.
                Default: if None, same :class:`torch.device` as this tensor.
            requires_grad (bool, optional): If autograd should record operations on the
                returned tensor. Default: ``False``.
            layout (:class:`torch.layout`, optional): the desired layout of returned Tensor.
                Default: ``torch.strided``.
            pin_memory (bool, optional): If set, returned tensor would be allocated in
                the pinned memory. Works only for CPU tensors. Default: ``False``.

        Example::

            >>> tensor = torch.tensor((), dtype=torch.int32)
            >>> tensor.new_ones((2, 3))
            tensor([[ 1,  1,  1],
                    [ 1,  1,  1]], dtype=torch.int32)

        """
    @overload
    def new_tensor(self, data, dtype=..., device=..., requires_grad=..., layout=..., pin_memory=...) -> Tensor:
        """
        new_tensor(data, *, dtype=None, device=None, requires_grad=False, layout=torch.strided, pin_memory=False) -> Tensor


        Returns a new Tensor with :attr:`data` as the tensor data.
        By default, the returned Tensor has the same :class:`torch.dtype` and
        :class:`torch.device` as this tensor.

        .. warning::

            :func:`new_tensor` always copies :attr:`data`. If you have a Tensor
            ``data`` and want to avoid a copy, use :func:`torch.Tensor.requires_grad_`
            or :func:`torch.Tensor.detach`.
            If you have a numpy array and want to avoid a copy, use
            :func:`torch.from_numpy`.

        .. warning::

            When data is a tensor `x`, :func:`new_tensor()` reads out 'the data' from whatever it is passed,
            and constructs a leaf variable. Therefore ``tensor.new_tensor(x)`` is equivalent to ``x.detach().clone()``
            and ``tensor.new_tensor(x, requires_grad=True)`` is equivalent to ``x.detach().clone().requires_grad_(True)``.
            The equivalents using ``detach()`` and ``clone()`` are recommended.

        Args:
            data (array_like): The returned Tensor copies :attr:`data`.

        Keyword args:
            dtype (:class:`torch.dtype`, optional): the desired type of returned tensor.
                Default: if None, same :class:`torch.dtype` as this tensor.
            device (:class:`torch.device`, optional): the desired device of returned tensor.
                Default: if None, same :class:`torch.device` as this tensor.
            requires_grad (bool, optional): If autograd should record operations on the
                returned tensor. Default: ``False``.
            layout (:class:`torch.layout`, optional): the desired layout of returned Tensor.
                Default: ``torch.strided``.
            pin_memory (bool, optional): If set, returned tensor would be allocated in
                the pinned memory. Works only for CPU tensors. Default: ``False``.

        Example::

            >>> tensor = torch.ones((2,), dtype=torch.int8)
            >>> data = [[0, 1], [2, 3]]
            >>> tensor.new_tensor(data)
            tensor([[ 0,  1],
                    [ 2,  3]], dtype=torch.int8)

        """
    @overload
    def new_tensor(self) -> Any:
        """
        new_tensor(data, *, dtype=None, device=None, requires_grad=False, layout=torch.strided, pin_memory=False) -> Tensor


        Returns a new Tensor with :attr:`data` as the tensor data.
        By default, the returned Tensor has the same :class:`torch.dtype` and
        :class:`torch.device` as this tensor.

        .. warning::

            :func:`new_tensor` always copies :attr:`data`. If you have a Tensor
            ``data`` and want to avoid a copy, use :func:`torch.Tensor.requires_grad_`
            or :func:`torch.Tensor.detach`.
            If you have a numpy array and want to avoid a copy, use
            :func:`torch.from_numpy`.

        .. warning::

            When data is a tensor `x`, :func:`new_tensor()` reads out 'the data' from whatever it is passed,
            and constructs a leaf variable. Therefore ``tensor.new_tensor(x)`` is equivalent to ``x.detach().clone()``
            and ``tensor.new_tensor(x, requires_grad=True)`` is equivalent to ``x.detach().clone().requires_grad_(True)``.
            The equivalents using ``detach()`` and ``clone()`` are recommended.

        Args:
            data (array_like): The returned Tensor copies :attr:`data`.

        Keyword args:
            dtype (:class:`torch.dtype`, optional): the desired type of returned tensor.
                Default: if None, same :class:`torch.dtype` as this tensor.
            device (:class:`torch.device`, optional): the desired device of returned tensor.
                Default: if None, same :class:`torch.device` as this tensor.
            requires_grad (bool, optional): If autograd should record operations on the
                returned tensor. Default: ``False``.
            layout (:class:`torch.layout`, optional): the desired layout of returned Tensor.
                Default: ``torch.strided``.
            pin_memory (bool, optional): If set, returned tensor would be allocated in
                the pinned memory. Works only for CPU tensors. Default: ``False``.

        Example::

            >>> tensor = torch.ones((2,), dtype=torch.int8)
            >>> data = [[0, 1], [2, 3]]
            >>> tensor.new_tensor(data)
            tensor([[ 0,  1],
                    [ 2,  3]], dtype=torch.int8)

        """
    @overload
    def new_tensor(self, x) -> Any:
        """
        new_tensor(data, *, dtype=None, device=None, requires_grad=False, layout=torch.strided, pin_memory=False) -> Tensor


        Returns a new Tensor with :attr:`data` as the tensor data.
        By default, the returned Tensor has the same :class:`torch.dtype` and
        :class:`torch.device` as this tensor.

        .. warning::

            :func:`new_tensor` always copies :attr:`data`. If you have a Tensor
            ``data`` and want to avoid a copy, use :func:`torch.Tensor.requires_grad_`
            or :func:`torch.Tensor.detach`.
            If you have a numpy array and want to avoid a copy, use
            :func:`torch.from_numpy`.

        .. warning::

            When data is a tensor `x`, :func:`new_tensor()` reads out 'the data' from whatever it is passed,
            and constructs a leaf variable. Therefore ``tensor.new_tensor(x)`` is equivalent to ``x.detach().clone()``
            and ``tensor.new_tensor(x, requires_grad=True)`` is equivalent to ``x.detach().clone().requires_grad_(True)``.
            The equivalents using ``detach()`` and ``clone()`` are recommended.

        Args:
            data (array_like): The returned Tensor copies :attr:`data`.

        Keyword args:
            dtype (:class:`torch.dtype`, optional): the desired type of returned tensor.
                Default: if None, same :class:`torch.dtype` as this tensor.
            device (:class:`torch.device`, optional): the desired device of returned tensor.
                Default: if None, same :class:`torch.device` as this tensor.
            requires_grad (bool, optional): If autograd should record operations on the
                returned tensor. Default: ``False``.
            layout (:class:`torch.layout`, optional): the desired layout of returned Tensor.
                Default: ``torch.strided``.
            pin_memory (bool, optional): If set, returned tensor would be allocated in
                the pinned memory. Works only for CPU tensors. Default: ``False``.

        Example::

            >>> tensor = torch.ones((2,), dtype=torch.int8)
            >>> data = [[0, 1], [2, 3]]
            >>> tensor.new_tensor(data)
            tensor([[ 0,  1],
                    [ 2,  3]], dtype=torch.int8)

        """
    @overload
    def new_tensor(self, x, requires_grad=...) -> Any:
        """
        new_tensor(data, *, dtype=None, device=None, requires_grad=False, layout=torch.strided, pin_memory=False) -> Tensor


        Returns a new Tensor with :attr:`data` as the tensor data.
        By default, the returned Tensor has the same :class:`torch.dtype` and
        :class:`torch.device` as this tensor.

        .. warning::

            :func:`new_tensor` always copies :attr:`data`. If you have a Tensor
            ``data`` and want to avoid a copy, use :func:`torch.Tensor.requires_grad_`
            or :func:`torch.Tensor.detach`.
            If you have a numpy array and want to avoid a copy, use
            :func:`torch.from_numpy`.

        .. warning::

            When data is a tensor `x`, :func:`new_tensor()` reads out 'the data' from whatever it is passed,
            and constructs a leaf variable. Therefore ``tensor.new_tensor(x)`` is equivalent to ``x.detach().clone()``
            and ``tensor.new_tensor(x, requires_grad=True)`` is equivalent to ``x.detach().clone().requires_grad_(True)``.
            The equivalents using ``detach()`` and ``clone()`` are recommended.

        Args:
            data (array_like): The returned Tensor copies :attr:`data`.

        Keyword args:
            dtype (:class:`torch.dtype`, optional): the desired type of returned tensor.
                Default: if None, same :class:`torch.dtype` as this tensor.
            device (:class:`torch.device`, optional): the desired device of returned tensor.
                Default: if None, same :class:`torch.device` as this tensor.
            requires_grad (bool, optional): If autograd should record operations on the
                returned tensor. Default: ``False``.
            layout (:class:`torch.layout`, optional): the desired layout of returned Tensor.
                Default: ``torch.strided``.
            pin_memory (bool, optional): If set, returned tensor would be allocated in
                the pinned memory. Works only for CPU tensors. Default: ``False``.

        Example::

            >>> tensor = torch.ones((2,), dtype=torch.int8)
            >>> data = [[0, 1], [2, 3]]
            >>> tensor.new_tensor(data)
            tensor([[ 0,  1],
                    [ 2,  3]], dtype=torch.int8)

        """
    @overload
    def new_tensor(self, data) -> Any:
        """
        new_tensor(data, *, dtype=None, device=None, requires_grad=False, layout=torch.strided, pin_memory=False) -> Tensor


        Returns a new Tensor with :attr:`data` as the tensor data.
        By default, the returned Tensor has the same :class:`torch.dtype` and
        :class:`torch.device` as this tensor.

        .. warning::

            :func:`new_tensor` always copies :attr:`data`. If you have a Tensor
            ``data`` and want to avoid a copy, use :func:`torch.Tensor.requires_grad_`
            or :func:`torch.Tensor.detach`.
            If you have a numpy array and want to avoid a copy, use
            :func:`torch.from_numpy`.

        .. warning::

            When data is a tensor `x`, :func:`new_tensor()` reads out 'the data' from whatever it is passed,
            and constructs a leaf variable. Therefore ``tensor.new_tensor(x)`` is equivalent to ``x.detach().clone()``
            and ``tensor.new_tensor(x, requires_grad=True)`` is equivalent to ``x.detach().clone().requires_grad_(True)``.
            The equivalents using ``detach()`` and ``clone()`` are recommended.

        Args:
            data (array_like): The returned Tensor copies :attr:`data`.

        Keyword args:
            dtype (:class:`torch.dtype`, optional): the desired type of returned tensor.
                Default: if None, same :class:`torch.dtype` as this tensor.
            device (:class:`torch.device`, optional): the desired device of returned tensor.
                Default: if None, same :class:`torch.device` as this tensor.
            requires_grad (bool, optional): If autograd should record operations on the
                returned tensor. Default: ``False``.
            layout (:class:`torch.layout`, optional): the desired layout of returned Tensor.
                Default: ``torch.strided``.
            pin_memory (bool, optional): If set, returned tensor would be allocated in
                the pinned memory. Works only for CPU tensors. Default: ``False``.

        Example::

            >>> tensor = torch.ones((2,), dtype=torch.int8)
            >>> data = [[0, 1], [2, 3]]
            >>> tensor.new_tensor(data)
            tensor([[ 0,  1],
                    [ 2,  3]], dtype=torch.int8)

        """
    def new_zeros(self, size, dtype=..., device=..., requires_grad=..., layout=..., pin_memory=...) -> Tensor:
        """
        new_zeros(size, *, dtype=None, device=None, requires_grad=False, layout=torch.strided, pin_memory=False) -> Tensor


        Returns a Tensor of size :attr:`size` filled with ``0``.
        By default, the returned Tensor has the same :class:`torch.dtype` and
        :class:`torch.device` as this tensor.

        Args:
            size (int...): a list, tuple, or :class:`torch.Size` of integers defining the
                shape of the output tensor.

        Keyword args:
            dtype (:class:`torch.dtype`, optional): the desired type of returned tensor.
                Default: if None, same :class:`torch.dtype` as this tensor.
            device (:class:`torch.device`, optional): the desired device of returned tensor.
                Default: if None, same :class:`torch.device` as this tensor.
            requires_grad (bool, optional): If autograd should record operations on the
                returned tensor. Default: ``False``.
            layout (:class:`torch.layout`, optional): the desired layout of returned Tensor.
                Default: ``torch.strided``.
            pin_memory (bool, optional): If set, returned tensor would be allocated in
                the pinned memory. Works only for CPU tensors. Default: ``False``.

        Example::

            >>> tensor = torch.tensor((), dtype=torch.float64)
            >>> tensor.new_zeros((2, 3))
            tensor([[ 0.,  0.,  0.],
                    [ 0.,  0.,  0.]], dtype=torch.float64)

        """
    def nextafter(self, other) -> Tensor:
        """
        nextafter(other) -> Tensor
        See :func:`torch.nextafter`
        """
    def nextafter_(self, other) -> Tensor:
        """
        nextafter_(other) -> Tensor
        In-place version of :meth:`~Tensor.nextafter`
        """
    def nonzero(self) -> LongTensor:
        """
        nonzero() -> LongTensor

        See :func:`torch.nonzero`
        """
    @overload
    def nonzero_static(self, input, size, fill_value=...) -> Tensor:
        """
        nonzero_static(input, *, size, fill_value=-1) -> Tensor

        Returns a 2-D tensor where each row is the index for a non-zero value.
        The returned Tensor has the same `torch.dtype` as `torch.nonzero()`.

        Args:
            input (Tensor): the input tensor to count non-zero elements.

        Keyword args:
            size (int): the size of non-zero elements expected to be included in the out
                tensor. Pad the out tensor with `fill_value` if the `size` is larger
                than total number of non-zero elements, truncate out tensor if `size`
                is smaller. The size must be a non-negative integer.
            fill_value (int): the value to fill the output tensor with when `size` is larger
                than the total number of non-zero elements. Default is `-1` to represent
                invalid index.

        Example:

            # Example 1: Padding
            >>> input_tensor = torch.tensor([[1, 0], [3, 2]])
            >>> static_size = 4
            >>> t = torch.nonzero_static(input_tensor, size=static_size)
            tensor([[  0,   0],
                    [  1,   0],
                    [  1,   1],
                    [  -1, -1]], dtype=torch.int64)

            # Example 2: Truncating
            >>> input_tensor = torch.tensor([[1, 0], [3, 2]])
            >>> static_size = 2
            >>> t = torch.nonzero_static(input_tensor, size=static_size)
            tensor([[  0,   0],
                    [  1,   0]], dtype=torch.int64)

            # Example 3: 0 size
            >>> input_tensor = torch.tensor([10])
            >>> static_size = 0
            >>> t = torch.nonzero_static(input_tensor, size=static_size)
            tensor([], size=(0, 1), dtype=torch.int64)

            # Example 4: 0 rank input
            >>> input_tensor = torch.tensor(10)
            >>> static_size = 2
            >>> t = torch.nonzero_static(input_tensor, size=static_size)
            tensor([], size=(2, 0), dtype=torch.int64)
        """
    @overload
    def nonzero_static(self, input_tensor, size=...) -> Any:
        """
        nonzero_static(input, *, size, fill_value=-1) -> Tensor

        Returns a 2-D tensor where each row is the index for a non-zero value.
        The returned Tensor has the same `torch.dtype` as `torch.nonzero()`.

        Args:
            input (Tensor): the input tensor to count non-zero elements.

        Keyword args:
            size (int): the size of non-zero elements expected to be included in the out
                tensor. Pad the out tensor with `fill_value` if the `size` is larger
                than total number of non-zero elements, truncate out tensor if `size`
                is smaller. The size must be a non-negative integer.
            fill_value (int): the value to fill the output tensor with when `size` is larger
                than the total number of non-zero elements. Default is `-1` to represent
                invalid index.

        Example:

            # Example 1: Padding
            >>> input_tensor = torch.tensor([[1, 0], [3, 2]])
            >>> static_size = 4
            >>> t = torch.nonzero_static(input_tensor, size=static_size)
            tensor([[  0,   0],
                    [  1,   0],
                    [  1,   1],
                    [  -1, -1]], dtype=torch.int64)

            # Example 2: Truncating
            >>> input_tensor = torch.tensor([[1, 0], [3, 2]])
            >>> static_size = 2
            >>> t = torch.nonzero_static(input_tensor, size=static_size)
            tensor([[  0,   0],
                    [  1,   0]], dtype=torch.int64)

            # Example 3: 0 size
            >>> input_tensor = torch.tensor([10])
            >>> static_size = 0
            >>> t = torch.nonzero_static(input_tensor, size=static_size)
            tensor([], size=(0, 1), dtype=torch.int64)

            # Example 4: 0 rank input
            >>> input_tensor = torch.tensor(10)
            >>> static_size = 2
            >>> t = torch.nonzero_static(input_tensor, size=static_size)
            tensor([], size=(2, 0), dtype=torch.int64)
        """
    @overload
    def nonzero_static(self, input_tensor, size=...) -> Any:
        """
        nonzero_static(input, *, size, fill_value=-1) -> Tensor

        Returns a 2-D tensor where each row is the index for a non-zero value.
        The returned Tensor has the same `torch.dtype` as `torch.nonzero()`.

        Args:
            input (Tensor): the input tensor to count non-zero elements.

        Keyword args:
            size (int): the size of non-zero elements expected to be included in the out
                tensor. Pad the out tensor with `fill_value` if the `size` is larger
                than total number of non-zero elements, truncate out tensor if `size`
                is smaller. The size must be a non-negative integer.
            fill_value (int): the value to fill the output tensor with when `size` is larger
                than the total number of non-zero elements. Default is `-1` to represent
                invalid index.

        Example:

            # Example 1: Padding
            >>> input_tensor = torch.tensor([[1, 0], [3, 2]])
            >>> static_size = 4
            >>> t = torch.nonzero_static(input_tensor, size=static_size)
            tensor([[  0,   0],
                    [  1,   0],
                    [  1,   1],
                    [  -1, -1]], dtype=torch.int64)

            # Example 2: Truncating
            >>> input_tensor = torch.tensor([[1, 0], [3, 2]])
            >>> static_size = 2
            >>> t = torch.nonzero_static(input_tensor, size=static_size)
            tensor([[  0,   0],
                    [  1,   0]], dtype=torch.int64)

            # Example 3: 0 size
            >>> input_tensor = torch.tensor([10])
            >>> static_size = 0
            >>> t = torch.nonzero_static(input_tensor, size=static_size)
            tensor([], size=(0, 1), dtype=torch.int64)

            # Example 4: 0 rank input
            >>> input_tensor = torch.tensor(10)
            >>> static_size = 2
            >>> t = torch.nonzero_static(input_tensor, size=static_size)
            tensor([], size=(2, 0), dtype=torch.int64)
        """
    @overload
    def nonzero_static(self, input_tensor, size=...) -> Any:
        """
        nonzero_static(input, *, size, fill_value=-1) -> Tensor

        Returns a 2-D tensor where each row is the index for a non-zero value.
        The returned Tensor has the same `torch.dtype` as `torch.nonzero()`.

        Args:
            input (Tensor): the input tensor to count non-zero elements.

        Keyword args:
            size (int): the size of non-zero elements expected to be included in the out
                tensor. Pad the out tensor with `fill_value` if the `size` is larger
                than total number of non-zero elements, truncate out tensor if `size`
                is smaller. The size must be a non-negative integer.
            fill_value (int): the value to fill the output tensor with when `size` is larger
                than the total number of non-zero elements. Default is `-1` to represent
                invalid index.

        Example:

            # Example 1: Padding
            >>> input_tensor = torch.tensor([[1, 0], [3, 2]])
            >>> static_size = 4
            >>> t = torch.nonzero_static(input_tensor, size=static_size)
            tensor([[  0,   0],
                    [  1,   0],
                    [  1,   1],
                    [  -1, -1]], dtype=torch.int64)

            # Example 2: Truncating
            >>> input_tensor = torch.tensor([[1, 0], [3, 2]])
            >>> static_size = 2
            >>> t = torch.nonzero_static(input_tensor, size=static_size)
            tensor([[  0,   0],
                    [  1,   0]], dtype=torch.int64)

            # Example 3: 0 size
            >>> input_tensor = torch.tensor([10])
            >>> static_size = 0
            >>> t = torch.nonzero_static(input_tensor, size=static_size)
            tensor([], size=(0, 1), dtype=torch.int64)

            # Example 4: 0 rank input
            >>> input_tensor = torch.tensor(10)
            >>> static_size = 2
            >>> t = torch.nonzero_static(input_tensor, size=static_size)
            tensor([], size=(2, 0), dtype=torch.int64)
        """
    @overload
    def nonzero_static(self, input_tensor, size=...) -> Any:
        """
        nonzero_static(input, *, size, fill_value=-1) -> Tensor

        Returns a 2-D tensor where each row is the index for a non-zero value.
        The returned Tensor has the same `torch.dtype` as `torch.nonzero()`.

        Args:
            input (Tensor): the input tensor to count non-zero elements.

        Keyword args:
            size (int): the size of non-zero elements expected to be included in the out
                tensor. Pad the out tensor with `fill_value` if the `size` is larger
                than total number of non-zero elements, truncate out tensor if `size`
                is smaller. The size must be a non-negative integer.
            fill_value (int): the value to fill the output tensor with when `size` is larger
                than the total number of non-zero elements. Default is `-1` to represent
                invalid index.

        Example:

            # Example 1: Padding
            >>> input_tensor = torch.tensor([[1, 0], [3, 2]])
            >>> static_size = 4
            >>> t = torch.nonzero_static(input_tensor, size=static_size)
            tensor([[  0,   0],
                    [  1,   0],
                    [  1,   1],
                    [  -1, -1]], dtype=torch.int64)

            # Example 2: Truncating
            >>> input_tensor = torch.tensor([[1, 0], [3, 2]])
            >>> static_size = 2
            >>> t = torch.nonzero_static(input_tensor, size=static_size)
            tensor([[  0,   0],
                    [  1,   0]], dtype=torch.int64)

            # Example 3: 0 size
            >>> input_tensor = torch.tensor([10])
            >>> static_size = 0
            >>> t = torch.nonzero_static(input_tensor, size=static_size)
            tensor([], size=(0, 1), dtype=torch.int64)

            # Example 4: 0 rank input
            >>> input_tensor = torch.tensor(10)
            >>> static_size = 2
            >>> t = torch.nonzero_static(input_tensor, size=static_size)
            tensor([], size=(2, 0), dtype=torch.int64)
        """
    def norm(self, p=..., dim=..., keepdim=...) -> Tensor:
        """
        norm(p=2, dim=None, keepdim=False) -> Tensor

        See :func:`torch.norm`
        """
    def normal_(self, mean=..., std=..., generator=...) -> Tensor:
        """
        normal_(mean=0, std=1, *, generator=None) -> Tensor

        Fills :attr:`self` tensor with elements samples from the normal distribution
        parameterized by :attr:`mean` and :attr:`std`.
        """
    def not_equal(self, other) -> Tensor:
        """
        not_equal(other) -> Tensor

        See :func:`torch.not_equal`.
        """
    def not_equal_(self, other) -> Tensor:
        """
        not_equal_(other) -> Tensor

        In-place version of :meth:`~Tensor.not_equal`.
        """
    def numel(self) -> int:
        """
        numel() -> int

        See :func:`torch.numel`
        """
    def numpy(self, force=...) -> numpy.ndarray:
        """
        numpy(*, force=False) -> numpy.ndarray

        Returns the tensor as a NumPy :class:`ndarray`.

        If :attr:`force` is ``False`` (the default), the conversion
        is performed only if the tensor is on the CPU, does not require grad,
        does not have its conjugate bit set, and is a dtype and layout that
        NumPy supports. The returned ndarray and the tensor will share their
        storage, so changes to the tensor will be reflected in the ndarray
        and vice versa.

        If :attr:`force` is ``True`` this is equivalent to
        calling ``t.detach().cpu().resolve_conj().resolve_neg().numpy()``.
        If the tensor isn't on the CPU or the conjugate or negative bit is set,
        the tensor won't share its storage with the returned ndarray.
        Setting :attr:`force` to ``True`` can be a useful shorthand.

        Args:
            force (bool): if ``True``, the ndarray may be a copy of the tensor
                       instead of always sharing memory, defaults to ``False``.
        """
    def orgqr(self, input2) -> Tensor:
        """
        orgqr(input2) -> Tensor

        See :func:`torch.orgqr`
        """
    def ormqr(self, input2, input3, left=..., transpose=...) -> Tensor:
        """
        ormqr(input2, input3, left=True, transpose=False) -> Tensor

        See :func:`torch.ormqr`
        """
    def outer(self, vec2) -> Tensor:
        """
        outer(vec2) -> Tensor

        See :func:`torch.outer`.
        """
    def permute(self, *dims) -> Tensor:
        """
        permute(*dims) -> Tensor

        See :func:`torch.permute`
        """
    def pin_memory(self) -> Tensor:
        """
        pin_memory() -> Tensor

        Copies the tensor to pinned memory, if it's not already pinned.
        By default, the device pinned memory on will be the current :ref:`accelerator<accelerators>`.
        """
    def pinverse(self) -> Tensor:
        """
        pinverse() -> Tensor

        See :func:`torch.pinverse`
        """
    def polygamma(self, n) -> Tensor:
        """
        polygamma(n) -> Tensor

        See :func:`torch.polygamma`
        """
    def polygamma_(self, n) -> Tensor:
        """
        polygamma_(n) -> Tensor

        In-place version of :meth:`~Tensor.polygamma`
        """
    def positive(self) -> Tensor:
        """
        positive() -> Tensor

        See :func:`torch.positive`
        """
    def pow(self, exponent) -> Tensor:
        """
        pow(exponent) -> Tensor

        See :func:`torch.pow`
        """
    def pow_(self, exponent) -> Tensor:
        """
        pow_(exponent) -> Tensor

        In-place version of :meth:`~Tensor.pow`
        """
    def prelu(self, *args, **kwargs): ...
    def prod(self, dim=..., keepdim=..., dtype=...) -> Tensor:
        """
        prod(dim=None, keepdim=False, dtype=None) -> Tensor

        See :func:`torch.prod`
        """
    def put(self, input, index, source, accumulate=...) -> Tensor:
        """
        put(input, index, source, accumulate=False) -> Tensor

        Out-of-place version of :meth:`torch.Tensor.put_`.
        `input` corresponds to `self` in :meth:`torch.Tensor.put_`.
        """
    def put_(self, index, source, accumulate=...) -> Tensor:
        """
        put_(index, source, accumulate=False) -> Tensor

        Copies the elements from :attr:`source` into the positions specified by
        :attr:`index`. For the purpose of indexing, the :attr:`self` tensor is treated as if
        it were a 1-D tensor.

        :attr:`index` and :attr:`source` need to have the same number of elements, but not necessarily
        the same shape.

        If :attr:`accumulate` is ``True``, the elements in :attr:`source` are added to
        :attr:`self`. If accumulate is ``False``, the behavior is undefined if :attr:`index`
        contain duplicate elements.

        Args:
            index (LongTensor): the indices into self
            source (Tensor): the tensor containing values to copy from
            accumulate (bool): whether to accumulate into self

        Example::

            >>> src = torch.tensor([[4, 3, 5],
            ...                     [6, 7, 8]])
            >>> src.put_(torch.tensor([1, 3]), torch.tensor([9, 10]))
            tensor([[  4,   9,   5],
                    [ 10,   7,   8]])
        """
    def q_per_channel_axis(self) -> int:
        """
        q_per_channel_axis() -> int

        Given a Tensor quantized by linear (affine) per-channel quantization,
        returns the index of dimension on which per-channel quantization is applied.
        """
    def q_per_channel_scales(self) -> Tensor:
        """
        q_per_channel_scales() -> Tensor

        Given a Tensor quantized by linear (affine) per-channel quantization,
        returns a Tensor of scales of the underlying quantizer. It has the number of
        elements that matches the corresponding dimensions (from q_per_channel_axis) of
        the tensor.
        """
    def q_per_channel_zero_points(self) -> Tensor:
        """
        q_per_channel_zero_points() -> Tensor

        Given a Tensor quantized by linear (affine) per-channel quantization,
        returns a tensor of zero_points of the underlying quantizer. It has the number of
        elements that matches the corresponding dimensions (from q_per_channel_axis) of
        the tensor.
        """
    def q_scale(self) -> float:
        """
        q_scale() -> float

        Given a Tensor quantized by linear(affine) quantization,
        returns the scale of the underlying quantizer().
        """
    def q_zero_point(self) -> int:
        """
        q_zero_point() -> int

        Given a Tensor quantized by linear(affine) quantization,
        returns the zero_point of the underlying quantizer().
        """
    def qr(self, *args, **kwargs):
        """
        qr(some=True) -> (Tensor, Tensor)

        See :func:`torch.qr`
        """
    def qscheme(self) -> torch.qscheme:
        """
        qscheme() -> torch.qscheme

        Returns the quantization scheme of a given QTensor.
        """
    def quantile(self, q, dim=..., keepdim=..., interpolation=...) -> Tensor:
        """
        quantile(q, dim=None, keepdim=False, *, interpolation='linear') -> Tensor

        See :func:`torch.quantile`
        """
    def rad2deg(self) -> Tensor:
        """
        rad2deg() -> Tensor

        See :func:`torch.rad2deg`
        """
    def rad2deg_(self) -> Tensor:
        """
        rad2deg_() -> Tensor

        In-place version of :meth:`~Tensor.rad2deg`
        """
    def random_(self, _from=..., to=..., generator=...) -> Tensor:
        """
        random_(from=0, to=None, *, generator=None) -> Tensor

        Fills :attr:`self` tensor with numbers sampled from the discrete uniform
        distribution over ``[from, to - 1]``. If not specified, the values are usually
        only bounded by :attr:`self` tensor's data type. However, for floating point
        types, if unspecified, range will be ``[0, 2^mantissa]`` to ensure that every
        value is representable. For example, `torch.tensor(1, dtype=torch.double).random_()`
        will be uniform in ``[0, 2^53]``.
        """
    def ravel(self) -> Tensor:
        """
        ravel() -> Tensor

        see :func:`torch.ravel`
        """
    def reciprocal(self) -> Tensor:
        """
        reciprocal() -> Tensor

        See :func:`torch.reciprocal`
        """
    def reciprocal_(self) -> Tensor:
        """
        reciprocal_() -> Tensor

        In-place version of :meth:`~Tensor.reciprocal`
        """
    def record_stream(self, stream) -> Any:
        """
        record_stream(stream)

        Marks the tensor as having been used by this stream.  When the tensor
        is deallocated, ensure the tensor memory is not reused for another tensor
        until all work queued on :attr:`stream` at the time of deallocation is
        complete.

        .. note::

            The caching allocator is aware of only the stream where a tensor was
            allocated. Due to the awareness, it already correctly manages the life
            cycle of tensors on only one stream. But if a tensor is used on a stream
            different from the stream of origin, the allocator might reuse the memory
            unexpectedly. Calling this method lets the allocator know which streams
            have used the tensor.

        .. warning::

            This method is most suitable for use cases where you are providing a
            function that created a tensor on a side stream, and want users to be able
            to make use of the tensor without having to think carefully about stream
            safety when making use of them.  These safety guarantees come at some
            performance and predictability cost (analogous to the tradeoff between GC
            and manual memory management), so if you are in a situation where
            you manage the full lifetime of your tensors, you may consider instead
            manually managing CUDA events so that calling this method is not necessary.
            In particular, when you call this method, on later allocations the
            allocator will poll the recorded stream to see if all operations have
            completed yet; you can potentially race with side stream computation and
            non-deterministically reuse or fail to reuse memory for an allocation.

            You can safely use tensors allocated on side streams without
            :meth:`~Tensor.record_stream`; you must manually ensure that
            any non-creation stream uses of a tensor are synced back to the creation
            stream before you deallocate the tensor.  As the CUDA caching allocator
            guarantees that the memory will only be reused with the same creation stream,
            this is sufficient to ensure that writes to future reallocations of the
            memory will be delayed until non-creation stream uses are done.
            (Counterintuitively, you may observe that on the CPU side we have already
            reallocated the tensor, even though CUDA kernels on the old tensor are
            still in progress.  This is fine, because CUDA operations on the new
            tensor will appropriately wait for the old operations to complete, as they
            are all on the same stream.)

            Concretely, this looks like this::

                with torch.cuda.stream(s0):
                    x = torch.zeros(N)

                s1.wait_stream(s0)
                with torch.cuda.stream(s1):
                    y = some_comm_op(x)

                ... some compute on s0 ...

                # synchronize creation stream s0 to side stream s1
                # before deallocating x
                s0.wait_stream(s1)
                del x

            Note that some discretion is required when deciding when to perform
            ``s0.wait_stream(s1)``.  In particular, if we were to wait immediately
            after ``some_comm_op``, there wouldn't be any point in having the side
            stream; it would be equivalent to have run ``some_comm_op`` on ``s0``.
            Instead, the synchronization must be placed at some appropriate, later
            point in time where you expect the side stream ``s1`` to have finished
            work.  This location is typically identified via profiling, e.g., using
            Chrome traces produced
            :meth:`torch.autograd.profiler.profile.export_chrome_trace`.  If you
            place the wait too early, work on s0 will block until ``s1`` has finished,
            preventing further overlapping of communication and computation.  If you
            place the wait too late, you will use more memory than is strictly
            necessary (as you are keeping ``x`` live for longer.)  For a concrete
            example of how this guidance can be applied in practice, see this post:
            `FSDP and CUDACachingAllocator
            <https://dev-discuss.pytorch.org/t/fsdp-cudacachingallocator-an-outsider-newb-perspective/1486>`_.
        """
    def refine_names(self, *args, **kwargs): ...
    def relu(self, *args, **kwargs): ...
    def relu_(self, *args, **kwargs): ...
    def remainder(self, divisor) -> Tensor:
        """
        remainder(divisor) -> Tensor

        See :func:`torch.remainder`
        """
    def remainder_(self, divisor) -> Tensor:
        """
        remainder_(divisor) -> Tensor

        In-place version of :meth:`~Tensor.remainder`
        """
    def rename(self, *args, **kwargs): ...
    def rename_(self, *args, **kwargs): ...
    def renorm(self, p, dim, maxnorm) -> Tensor:
        """
        renorm(p, dim, maxnorm) -> Tensor

        See :func:`torch.renorm`
        """
    def renorm_(self, p, dim, maxnorm) -> Tensor:
        """
        renorm_(p, dim, maxnorm) -> Tensor

        In-place version of :meth:`~Tensor.renorm`
        """
    def repeat(self, *repeats) -> Tensor:
        """
        repeat(*repeats) -> Tensor

        Repeats this tensor along the specified dimensions.

        Unlike :meth:`~Tensor.expand`, this function copies the tensor's data.

        .. warning::

            :meth:`~Tensor.repeat` behaves differently from
            `numpy.repeat <https://numpy.org/doc/stable/reference/generated/numpy.repeat.html>`_,
            but is more similar to
            `numpy.tile <https://numpy.org/doc/stable/reference/generated/numpy.tile.html>`_.
            For the operator similar to `numpy.repeat`, see :func:`torch.repeat_interleave`.

        Args:
            repeat (torch.Size, int..., tuple of int or list of int): The number of times to repeat this tensor along each dimension

        Example::

            >>> x = torch.tensor([1, 2, 3])
            >>> x.repeat(4, 2)
            tensor([[ 1,  2,  3,  1,  2,  3],
                    [ 1,  2,  3,  1,  2,  3],
                    [ 1,  2,  3,  1,  2,  3],
                    [ 1,  2,  3,  1,  2,  3]])
            >>> x.repeat(4, 2, 1).size()
            torch.Size([4, 2, 3])
        """
    def repeat_interleave(self, repeats, dim=..., output_size=...) -> Tensor:
        """
        repeat_interleave(repeats, dim=None, *, output_size=None) -> Tensor

        See :func:`torch.repeat_interleave`.
        """
    def requires_grad_(self, requires_grad=...) -> Tensor:
        """
        requires_grad_(requires_grad=True) -> Tensor

        Change if autograd should record operations on this tensor: sets this tensor's
        :attr:`requires_grad` attribute in-place. Returns this tensor.

        :func:`requires_grad_`'s main use case is to tell autograd to begin recording
        operations on a Tensor ``tensor``. If ``tensor`` has ``requires_grad=False``
        (because it was obtained through a DataLoader, or required preprocessing or
        initialization), ``tensor.requires_grad_()`` makes it so that autograd will
        begin to record operations on ``tensor``.

        Args:
            requires_grad (bool): If autograd should record operations on this tensor.
                Default: ``True``.

        Example::

            >>> # Let's say we want to preprocess some saved weights and use
            >>> # the result as new weights.
            >>> saved_weights = [0.1, 0.2, 0.3, 0.25]
            >>> loaded_weights = torch.tensor(saved_weights)
            >>> weights = preprocess(loaded_weights)  # some function
            >>> weights
            tensor([-0.5503,  0.4926, -2.1158, -0.8303])

            >>> # Now, start to record operations done to weights
            >>> weights.requires_grad_()
            >>> out = weights.pow(2).sum()
            >>> out.backward()
            >>> weights.grad
            tensor([-1.1007,  0.9853, -4.2316, -1.6606])

        """
    def reshape(self, *shape) -> Tensor:
        """
        reshape(*shape) -> Tensor

        Returns a tensor with the same data and number of elements as :attr:`self`
        but with the specified shape. This method returns a view if :attr:`shape` is
        compatible with the current shape. See :meth:`torch.Tensor.view` on when it is
        possible to return a view.

        See :func:`torch.reshape`

        Args:
            shape (tuple of ints or int...): the desired shape

        """
    @overload
    def reshape_as(self, other) -> Tensor:
        """
        reshape_as(other) -> Tensor

        Returns this tensor as the same shape as :attr:`other`.
        ``self.reshape_as(other)`` is equivalent to ``self.reshape(other.sizes())``.
        This method returns a view if ``other.sizes()`` is compatible with the current
        shape. See :meth:`torch.Tensor.view` on when it is possible to return a view.

        Please see :meth:`reshape` for more information about ``reshape``.

        Args:
            other (:class:`torch.Tensor`): The result tensor has the same shape
                as :attr:`other`.
        """
    @overload
    def reshape_as(self, other) -> Any:
        """
        reshape_as(other) -> Tensor

        Returns this tensor as the same shape as :attr:`other`.
        ``self.reshape_as(other)`` is equivalent to ``self.reshape(other.sizes())``.
        This method returns a view if ``other.sizes()`` is compatible with the current
        shape. See :meth:`torch.Tensor.view` on when it is possible to return a view.

        Please see :meth:`reshape` for more information about ``reshape``.

        Args:
            other (:class:`torch.Tensor`): The result tensor has the same shape
                as :attr:`other`.
        """
    def resize_(self, *sizes, memory_format=...) -> Tensor:
        """
        resize_(*sizes, memory_format=torch.contiguous_format) -> Tensor

        Resizes :attr:`self` tensor to the specified size. If the number of elements is
        larger than the current storage size, then the underlying storage is resized
        to fit the new number of elements. If the number of elements is smaller, the
        underlying storage is not changed. Existing elements are preserved but any new
        memory is uninitialized.

        .. warning::

            This is a low-level method. The storage is reinterpreted as C-contiguous,
            ignoring the current strides (unless the target size equals the current
            size, in which case the tensor is left unchanged). For most purposes, you
            will instead want to use :meth:`~Tensor.view()`, which checks for
            contiguity, or :meth:`~Tensor.reshape()`, which copies data if needed. To
            change the size in-place with custom strides, see :meth:`~Tensor.set_()`.

        .. note::

            If :func:`torch.use_deterministic_algorithms()` and
            :attr:`torch.utils.deterministic.fill_uninitialized_memory` are both set to
            ``True``, new elements are initialized to prevent nondeterministic behavior
            from using the result as an input to an operation. Floating point and
            complex values are set to NaN, and integer values are set to the maximum
            value.

        Args:
            sizes (torch.Size or int...): the desired size
            memory_format (:class:`torch.memory_format`, optional): the desired memory format of
                Tensor. Default: ``torch.contiguous_format``. Note that memory format of
                :attr:`self` is going to be unaffected if ``self.size()`` matches ``sizes``.

        Example::

            >>> x = torch.tensor([[1, 2], [3, 4], [5, 6]])
            >>> x.resize_(2, 2)
            tensor([[ 1,  2],
                    [ 3,  4]])
        """
    def resize_as_(self, tensor, memory_format=...) -> Tensor:
        """
        resize_as_(tensor, memory_format=torch.contiguous_format) -> Tensor

        Resizes the :attr:`self` tensor to be the same size as the specified
        :attr:`tensor`. This is equivalent to ``self.resize_(tensor.size())``.

        Args:
            memory_format (:class:`torch.memory_format`, optional): the desired memory format of
                Tensor. Default: ``torch.contiguous_format``. Note that memory format of
                :attr:`self` is going to be unaffected if ``self.size()`` matches ``tensor.size()``.

        """
    def resize_as_sparse_(self, *args, **kwargs): ...
    def resolve_conj(self) -> Tensor:
        """
        resolve_conj() -> Tensor

        See :func:`torch.resolve_conj`
        """
    def resolve_neg(self) -> Tensor:
        """
        resolve_neg() -> Tensor

        See :func:`torch.resolve_neg`
        """
    def retain_grad(self) -> None:
        """
        retain_grad() -> None

        Enables this Tensor to have their :attr:`grad` populated during
        :func:`backward`. This is a no-op for leaf tensors.
        """
    def roll(self, shifts, dims) -> Tensor:
        """
        roll(shifts, dims) -> Tensor

        See :func:`torch.roll`
        """
    def rot90(self, k, dims) -> Tensor:
        """
        rot90(k, dims) -> Tensor

        See :func:`torch.rot90`
        """
    def round(self, decimals=...) -> Tensor:
        """
        round(decimals=0) -> Tensor

        See :func:`torch.round`
        """
    def round_(self, decimals=...) -> Tensor:
        """
        round_(decimals=0) -> Tensor

        In-place version of :meth:`~Tensor.round`
        """
    def row_indices(self, *args, **kwargs): ...
    def rsqrt(self) -> Tensor:
        """
        rsqrt() -> Tensor

        See :func:`torch.rsqrt`
        """
    def rsqrt_(self) -> Tensor:
        """
        rsqrt_() -> Tensor

        In-place version of :meth:`~Tensor.rsqrt`
        """
    def scatter(self, dim, index, src) -> Tensor:
        """
        scatter(dim, index, src) -> Tensor

        Out-of-place version of :meth:`torch.Tensor.scatter_`
        """
    def scatter_(self, dim, index, src, reduce=...) -> Tensor:
        """
        scatter_(dim, index, src, *, reduce=None) -> Tensor

        Writes all values from the tensor :attr:`src` into :attr:`self` at the indices
        specified in the :attr:`index` tensor. For each value in :attr:`src`, its output
        index is specified by its index in :attr:`src` for ``dimension != dim`` and by
        the corresponding value in :attr:`index` for ``dimension = dim``.

        For a 3-D tensor, :attr:`self` is updated as::

            self[index[i][j][k]][j][k] = src[i][j][k]  # if dim == 0
            self[i][index[i][j][k]][k] = src[i][j][k]  # if dim == 1
            self[i][j][index[i][j][k]] = src[i][j][k]  # if dim == 2

        This is the reverse operation of the manner described in :meth:`~Tensor.gather`.

        :attr:`self`, :attr:`index` and :attr:`src` (if it is a Tensor) should all have
        the same number of dimensions. It is also required that
        ``index.size(d) <= src.size(d)`` for all dimensions ``d``, and that
        ``index.size(d) <= self.size(d)`` for all dimensions ``d != dim``.
        Note that ``index`` and ``src`` do not broadcast.

        Moreover, as for :meth:`~Tensor.gather`, the values of :attr:`index` must be
        between ``0`` and ``self.size(dim) - 1`` inclusive.

        .. warning::

            When indices are not unique, the behavior is non-deterministic (one of the
            values from ``src`` will be picked arbitrarily) and the gradient will be
            incorrect (it will be propagated to all locations in the source that
            correspond to the same index)!

        .. note::

            The backward pass is implemented only for ``src.shape == index.shape``.

        Additionally accepts an optional :attr:`reduce` argument that allows
        specification of an optional reduction operation, which is applied to all
        values in the tensor :attr:`src` into :attr:`self` at the indices
        specified in the :attr:`index`. For each value in :attr:`src`, the reduction
        operation is applied to an index in :attr:`self` which is specified by
        its index in :attr:`src` for ``dimension != dim`` and by the corresponding
        value in :attr:`index` for ``dimension = dim``.

        Given a 3-D tensor and reduction using the multiplication operation, :attr:`self`
        is updated as::

            self[index[i][j][k]][j][k] *= src[i][j][k]  # if dim == 0
            self[i][index[i][j][k]][k] *= src[i][j][k]  # if dim == 1
            self[i][j][index[i][j][k]] *= src[i][j][k]  # if dim == 2

        Reducing with the addition operation is the same as using
        :meth:`~torch.Tensor.scatter_add_`.

        .. warning::
            The reduce argument with Tensor ``src`` is deprecated and will be removed in
            a future PyTorch release. Please use :meth:`~torch.Tensor.scatter_reduce_`
            instead for more reduction options.

        Args:
            dim (int): the axis along which to index
            index (LongTensor): the indices of elements to scatter, can be either empty
                or of the same dimensionality as ``src``. When empty, the operation
                returns ``self`` unchanged.
            src (Tensor): the source element(s) to scatter.

        Keyword args:
            reduce (str, optional): reduction operation to apply, can be either
                ``'add'`` or ``'multiply'``.

        Example::

            >>> src = torch.arange(1, 11).reshape((2, 5))
            >>> src
            tensor([[ 1,  2,  3,  4,  5],
                    [ 6,  7,  8,  9, 10]])
            >>> index = torch.tensor([[0, 1, 2, 0]])
            >>> torch.zeros(3, 5, dtype=src.dtype).scatter_(0, index, src)
            tensor([[1, 0, 0, 4, 0],
                    [0, 2, 0, 0, 0],
                    [0, 0, 3, 0, 0]])
            >>> index = torch.tensor([[0, 1, 2], [0, 1, 4]])
            >>> torch.zeros(3, 5, dtype=src.dtype).scatter_(1, index, src)
            tensor([[1, 2, 3, 0, 0],
                    [6, 7, 0, 0, 8],
                    [0, 0, 0, 0, 0]])

            >>> torch.full((2, 4), 2.).scatter_(1, torch.tensor([[2], [3]]),
            ...            1.23, reduce='multiply')
            tensor([[2.0000, 2.0000, 2.4600, 2.0000],
                    [2.0000, 2.0000, 2.0000, 2.4600]])
            >>> torch.full((2, 4), 2.).scatter_(1, torch.tensor([[2], [3]]),
            ...            1.23, reduce='add')
            tensor([[2.0000, 2.0000, 3.2300, 2.0000],
                    [2.0000, 2.0000, 2.0000, 3.2300]])

        .. function:: scatter_(dim, index, value, *, reduce=None) -> Tensor:
           :noindex:

        Writes the value from :attr:`value` into :attr:`self` at the indices
        specified in the :attr:`index` tensor.  This operation is equivalent to the previous version,
        with the :attr:`src` tensor filled entirely with :attr:`value`.

        Args:
            dim (int): the axis along which to index
            index (LongTensor): the indices of elements to scatter, can be either empty
                or of the same dimensionality as ``src``. When empty, the operation
                returns ``self`` unchanged.
            value (Scalar): the value to scatter.

        Keyword args:
            reduce (str, optional): reduction operation to apply, can be either
                ``'add'`` or ``'multiply'``.

        Example::

            >>> index = torch.tensor([[0, 1]])
            >>> value = 2
            >>> torch.zeros(3, 5).scatter_(0, index, value)
            tensor([[2., 0., 0., 0., 0.],
                    [0., 2., 0., 0., 0.],
                    [0., 0., 0., 0., 0.]])
        """
    def scatter_add(self, dim, index, src) -> Tensor:
        """
        scatter_add(dim, index, src) -> Tensor

        Out-of-place version of :meth:`torch.Tensor.scatter_add_`
        """
    def scatter_add_(self, dim, index, src) -> Tensor:
        """
        scatter_add_(dim, index, src) -> Tensor

        Adds all values from the tensor :attr:`src` into :attr:`self` at the indices
        specified in the :attr:`index` tensor in a similar fashion as
        :meth:`~torch.Tensor.scatter_`. For each value in :attr:`src`, it is added to
        an index in :attr:`self` which is specified by its index in :attr:`src`
        for ``dimension != dim`` and by the corresponding value in :attr:`index` for
        ``dimension = dim``.

        For a 3-D tensor, :attr:`self` is updated as::

            self[index[i][j][k]][j][k] += src[i][j][k]  # if dim == 0
            self[i][index[i][j][k]][k] += src[i][j][k]  # if dim == 1
            self[i][j][index[i][j][k]] += src[i][j][k]  # if dim == 2

        :attr:`self`, :attr:`index` and :attr:`src` should have same number of
        dimensions. It is also required that ``index.size(d) <= src.size(d)`` for all
        dimensions ``d``, and that ``index.size(d) <= self.size(d)`` for all dimensions
        ``d != dim``. Note that ``index`` and ``src`` do not broadcast.

        Note:
            This operation may behave nondeterministically when given tensors on a CUDA device. See :doc:`/notes/randomness` for more information.

        .. note::

            The backward pass is implemented only for ``src.shape == index.shape``.

        Args:
            dim (int): the axis along which to index
            index (LongTensor): the indices of elements to scatter and add, can be
                either empty or of the same dimensionality as ``src``. When empty, the
                operation returns ``self`` unchanged.
            src (Tensor): the source elements to scatter and add

        Example::

            >>> src = torch.ones((2, 5))
            >>> index = torch.tensor([[0, 1, 2, 0, 0]])
            >>> torch.zeros(3, 5, dtype=src.dtype).scatter_add_(0, index, src)
            tensor([[1., 0., 0., 1., 1.],
                    [0., 1., 0., 0., 0.],
                    [0., 0., 1., 0., 0.]])
            >>> index = torch.tensor([[0, 1, 2, 0, 0], [0, 1, 2, 2, 2]])
            >>> torch.zeros(3, 5, dtype=src.dtype).scatter_add_(0, index, src)
            tensor([[2., 0., 0., 1., 1.],
                    [0., 2., 0., 0., 0.],
                    [0., 0., 2., 1., 1.]])

        """
    def scatter_reduce(self, dim, index, src, reduce, include_self=...) -> Tensor:
        """
        scatter_reduce(dim, index, src, reduce, *, include_self=True) -> Tensor

        Out-of-place version of :meth:`torch.Tensor.scatter_reduce_`
        """
    def scatter_reduce_(self, dim, index, src, reduce, include_self=...) -> Tensor:
        '''
        scatter_reduce_(dim, index, src, reduce, *, include_self=True) -> Tensor

        Reduces all values from the :attr:`src` tensor to the indices specified in
        the :attr:`index` tensor in the :attr:`self` tensor using the applied reduction
        defined via the :attr:`reduce` argument (:obj:`"sum"`, :obj:`"prod"`, :obj:`"mean"`,
        :obj:`"amax"`, :obj:`"amin"`). For each value in :attr:`src`, it is reduced to an
        index in :attr:`self` which is specified by its index in :attr:`src` for
        ``dimension != dim`` and by the corresponding value in :attr:`index` for
        ``dimension = dim``. If :obj:`include_self="True"`, the values in the :attr:`self`
        tensor are included in the reduction.

        :attr:`self`, :attr:`index` and :attr:`src` should all have
        the same number of dimensions. It is also required that
        ``index.size(d) <= src.size(d)`` for all dimensions ``d``, and that
        ``index.size(d) <= self.size(d)`` for all dimensions ``d != dim``.
        Note that ``index`` and ``src`` do not broadcast.

        For a 3-D tensor with :obj:`reduce="sum"` and :obj:`include_self=True` the
        output is given as::

            self[index[i][j][k]][j][k] += src[i][j][k]  # if dim == 0
            self[i][index[i][j][k]][k] += src[i][j][k]  # if dim == 1
            self[i][j][index[i][j][k]] += src[i][j][k]  # if dim == 2

        Note:
            This operation may behave nondeterministically when given tensors on a CUDA device. See :doc:`/notes/randomness` for more information.

        .. note::

            The backward pass is implemented only for ``src.shape == index.shape``.

        .. warning::

            This function is in beta and may change in the near future.

        Args:
            dim (int): the axis along which to index
            index (LongTensor): the indices of elements to scatter and reduce.
            src (Tensor): the source elements to scatter and reduce
            reduce (str): the reduction operation to apply for non-unique indices
                (:obj:`"sum"`, :obj:`"prod"`, :obj:`"mean"`, :obj:`"amax"`, :obj:`"amin"`)
            include_self (bool): whether elements from the :attr:`self` tensor are
                included in the reduction

        Example::

            >>> src = torch.tensor([1., 2., 3., 4., 5., 6.])
            >>> index = torch.tensor([0, 1, 0, 1, 2, 1])
            >>> input = torch.tensor([1., 2., 3., 4.])
            >>> input.scatter_reduce(0, index, src, reduce="sum")
            tensor([5., 14., 8., 4.])
            >>> input.scatter_reduce(0, index, src, reduce="sum", include_self=False)
            tensor([4., 12., 5., 4.])
            >>> input2 = torch.tensor([5., 4., 3., 2.])
            >>> input2.scatter_reduce(0, index, src, reduce="amax")
            tensor([5., 6., 5., 2.])
            >>> input2.scatter_reduce(0, index, src, reduce="amax", include_self=False)
            tensor([3., 6., 5., 2.])


        '''
    def select(self, dim, index) -> Tensor:
        """
        select(dim, index) -> Tensor

        See :func:`torch.select`
        """
    def select_scatter(self, src, dim, index) -> Tensor:
        """
        select_scatter(src, dim, index) -> Tensor

        See :func:`torch.select_scatter`
        """
    def set_(self, source=..., storage_offset=..., size=..., stride=...) -> Tensor:
        """
        set_(source=None, storage_offset=0, size=None, stride=None) -> Tensor

        Sets the underlying storage, size, and strides. If :attr:`source` is a tensor,
        :attr:`self` tensor will share the same storage and have the same size and
        strides as :attr:`source`. Changes to elements in one tensor will be reflected
        in the other.

        If :attr:`source` is a :class:`~torch.Storage`, the method sets the underlying
        storage, offset, size, and stride.

        Args:
            source (Tensor or Storage): the tensor or storage to use
            storage_offset (int, optional): the offset in the storage
            size (torch.Size, optional): the desired size. Defaults to the size of the source.
            stride (tuple, optional): the desired stride. Defaults to C-contiguous strides.
        """
    def sgn(self) -> Tensor:
        """
        sgn() -> Tensor

        See :func:`torch.sgn`
        """
    def sgn_(self) -> Tensor:
        """
        sgn_() -> Tensor

        In-place version of :meth:`~Tensor.sgn`
        """
    @overload
    def short(self, memory_format=...) -> Tensor:
        """
        short(memory_format=torch.preserve_format) -> Tensor

        ``self.short()`` is equivalent to ``self.to(torch.int16)``. See :func:`to`.

        Args:
            memory_format (:class:`torch.memory_format`, optional): the desired memory format of
                returned Tensor. Default: ``torch.preserve_format``.
        """
    @overload
    def short(self) -> Any:
        """
        short(memory_format=torch.preserve_format) -> Tensor

        ``self.short()`` is equivalent to ``self.to(torch.int16)``. See :func:`to`.

        Args:
            memory_format (:class:`torch.memory_format`, optional): the desired memory format of
                returned Tensor. Default: ``torch.preserve_format``.
        """
    def sigmoid(self) -> Tensor:
        """
        sigmoid() -> Tensor

        See :func:`torch.sigmoid`
        """
    def sigmoid_(self) -> Tensor:
        """
        sigmoid_() -> Tensor

        In-place version of :meth:`~Tensor.sigmoid`
        """
    def sign(self) -> Tensor:
        """
        sign() -> Tensor

        See :func:`torch.sign`
        """
    def sign_(self) -> Tensor:
        """
        sign_() -> Tensor

        In-place version of :meth:`~Tensor.sign`
        """
    def signbit(self) -> Tensor:
        """
        signbit() -> Tensor

        See :func:`torch.signbit`
        """
    def sin(self) -> Tensor:
        """
        sin() -> Tensor

        See :func:`torch.sin`
        """
    def sin_(self) -> Tensor:
        """
        sin_() -> Tensor

        In-place version of :meth:`~Tensor.sin`
        """
    def sinc(self) -> Tensor:
        """
        sinc() -> Tensor

        See :func:`torch.sinc`
        """
    def sinc_(self) -> Tensor:
        """
        sinc_() -> Tensor

        In-place version of :meth:`~Tensor.sinc`
        """
    def sinh(self) -> Tensor:
        """
        sinh() -> Tensor

        See :func:`torch.sinh`
        """
    def sinh_(self) -> Tensor:
        """
        sinh_() -> Tensor

        In-place version of :meth:`~Tensor.sinh`
        """
    @overload
    def size(self, dim=...) -> torch.Sizeorint:
        """
        size(dim=None) -> torch.Size or int

        Returns the size of the :attr:`self` tensor. If ``dim`` is not specified,
        the returned value is a :class:`torch.Size`, a subclass of :class:`tuple`.
        If ``dim`` is specified, returns an int holding the size of that dimension.

        Args:
          dim (int, optional): The dimension for which to retrieve the size.

        Example::

            >>> t = torch.empty(3, 4, 5)
            >>> t.size()
            torch.Size([3, 4, 5])
            >>> t.size(dim=1)
            4

        """
    @overload
    def size(self) -> Any:
        """
        size(dim=None) -> torch.Size or int

        Returns the size of the :attr:`self` tensor. If ``dim`` is not specified,
        the returned value is a :class:`torch.Size`, a subclass of :class:`tuple`.
        If ``dim`` is specified, returns an int holding the size of that dimension.

        Args:
          dim (int, optional): The dimension for which to retrieve the size.

        Example::

            >>> t = torch.empty(3, 4, 5)
            >>> t.size()
            torch.Size([3, 4, 5])
            >>> t.size(dim=1)
            4

        """
    @overload
    def size(self, dim=...) -> Any:
        """
        size(dim=None) -> torch.Size or int

        Returns the size of the :attr:`self` tensor. If ``dim`` is not specified,
        the returned value is a :class:`torch.Size`, a subclass of :class:`tuple`.
        If ``dim`` is specified, returns an int holding the size of that dimension.

        Args:
          dim (int, optional): The dimension for which to retrieve the size.

        Example::

            >>> t = torch.empty(3, 4, 5)
            >>> t.size()
            torch.Size([3, 4, 5])
            >>> t.size(dim=1)
            4

        """
    def slice_inverse(self, *args, **kwargs): ...
    def slice_scatter(self, src, dim=..., start=..., end=..., step=...) -> Tensor:
        """
        slice_scatter(src, dim=0, start=None, end=None, step=1) -> Tensor

        See :func:`torch.slice_scatter`
        """
    def slogdet(self, *args, **kwargs):
        """
        slogdet() -> (Tensor, Tensor)

        See :func:`torch.slogdet`
        """
    def smm(self, mat) -> Tensor:
        """
        smm(mat) -> Tensor

        See :func:`torch.smm`
        """
    def softmax(self, dim) -> Tensor:
        """
        softmax(dim) -> Tensor

        Alias for :func:`torch.nn.functional.softmax`.
        """
    def sort(self, *args, **kwargs):
        """
        sort(dim=-1, descending=False) -> (Tensor, LongTensor)

        See :func:`torch.sort`
        """
    def sparse_dim(self) -> int:
        """
        sparse_dim() -> int

        Return the number of sparse dimensions in a :ref:`sparse tensor <sparse-docs>` :attr:`self`.

        .. note::
          Returns ``0`` if :attr:`self` is not a sparse tensor.

        See also :meth:`Tensor.dense_dim` and :ref:`hybrid tensors <sparse-hybrid-coo-docs>`.
        """
    @overload
    def sparse_mask(self, mask) -> Tensor:
        """
        sparse_mask(mask) -> Tensor

        Returns a new :ref:`sparse tensor <sparse-docs>` with values from a
        strided tensor :attr:`self` filtered by the indices of the sparse
        tensor :attr:`mask`. The values of :attr:`mask` sparse tensor are
        ignored. :attr:`self` and :attr:`mask` tensors must have the same
        shape.

        .. note::

          The returned sparse tensor might contain duplicate values if :attr:`mask`
          is not coalesced. It is therefore advisable to pass ``mask.coalesce()``
          if such behavior is not desired.

        .. note::

          The returned sparse tensor has the same indices as the sparse tensor
          :attr:`mask`, even when the corresponding values in :attr:`self` are
          zeros.

        Args:
            mask (Tensor): a sparse tensor whose indices are used as a filter

        Example::

            >>> nse = 5
            >>> dims = (5, 5, 2, 2)
            >>> I = torch.cat([torch.randint(0, dims[0], size=(nse,)),
            ...                torch.randint(0, dims[1], size=(nse,))], 0).reshape(2, nse)
            >>> V = torch.randn(nse, dims[2], dims[3])
            >>> S = torch.sparse_coo_tensor(I, V, dims).coalesce()
            >>> D = torch.randn(dims)
            >>> D.sparse_mask(S)
            tensor(indices=tensor([[0, 0, 0, 2],
                                   [0, 1, 4, 3]]),
                   values=tensor([[[ 1.6550,  0.2397],
                                   [-0.1611, -0.0779]],

                                  [[ 0.2326, -1.0558],
                                   [ 1.4711,  1.9678]],

                                  [[-0.5138, -0.0411],
                                   [ 1.9417,  0.5158]],

                                  [[ 0.0793,  0.0036],
                                   [-0.2569, -0.1055]]]),
                   size=(5, 5, 2, 2), nnz=4, layout=torch.sparse_coo)
        """
    @overload
    def sparse_mask(self, S) -> Any:
        """
        sparse_mask(mask) -> Tensor

        Returns a new :ref:`sparse tensor <sparse-docs>` with values from a
        strided tensor :attr:`self` filtered by the indices of the sparse
        tensor :attr:`mask`. The values of :attr:`mask` sparse tensor are
        ignored. :attr:`self` and :attr:`mask` tensors must have the same
        shape.

        .. note::

          The returned sparse tensor might contain duplicate values if :attr:`mask`
          is not coalesced. It is therefore advisable to pass ``mask.coalesce()``
          if such behavior is not desired.

        .. note::

          The returned sparse tensor has the same indices as the sparse tensor
          :attr:`mask`, even when the corresponding values in :attr:`self` are
          zeros.

        Args:
            mask (Tensor): a sparse tensor whose indices are used as a filter

        Example::

            >>> nse = 5
            >>> dims = (5, 5, 2, 2)
            >>> I = torch.cat([torch.randint(0, dims[0], size=(nse,)),
            ...                torch.randint(0, dims[1], size=(nse,))], 0).reshape(2, nse)
            >>> V = torch.randn(nse, dims[2], dims[3])
            >>> S = torch.sparse_coo_tensor(I, V, dims).coalesce()
            >>> D = torch.randn(dims)
            >>> D.sparse_mask(S)
            tensor(indices=tensor([[0, 0, 0, 2],
                                   [0, 1, 4, 3]]),
                   values=tensor([[[ 1.6550,  0.2397],
                                   [-0.1611, -0.0779]],

                                  [[ 0.2326, -1.0558],
                                   [ 1.4711,  1.9678]],

                                  [[-0.5138, -0.0411],
                                   [ 1.9417,  0.5158]],

                                  [[ 0.0793,  0.0036],
                                   [-0.2569, -0.1055]]]),
                   size=(5, 5, 2, 2), nnz=4, layout=torch.sparse_coo)
        """
    def sparse_resize_(self, size, sparse_dim, dense_dim) -> Tensor:
        """
        sparse_resize_(size, sparse_dim, dense_dim) -> Tensor

        Resizes :attr:`self` :ref:`sparse tensor <sparse-docs>` to the desired
        size and the number of sparse and dense dimensions.

        .. note::
          If the number of specified elements in :attr:`self` is zero, then
          :attr:`size`, :attr:`sparse_dim`, and :attr:`dense_dim` can be any
          size and positive integers such that ``len(size) == sparse_dim +
          dense_dim``.

          If :attr:`self` specifies one or more elements, however, then each
          dimension in :attr:`size` must not be smaller than the corresponding
          dimension of :attr:`self`, :attr:`sparse_dim` must equal the number
          of sparse dimensions in :attr:`self`, and :attr:`dense_dim` must
          equal the number of dense dimensions in :attr:`self`.

        .. warning::
          Throws an error if :attr:`self` is not a sparse tensor.

        Args:
            size (torch.Size): the desired size. If :attr:`self` is non-empty
              sparse tensor, the desired size cannot be smaller than the
              original size.
            sparse_dim (int): the number of sparse dimensions
            dense_dim (int): the number of dense dimensions
        """
    def sparse_resize_and_clear_(self, size, sparse_dim, dense_dim) -> Tensor:
        """
        sparse_resize_and_clear_(size, sparse_dim, dense_dim) -> Tensor

        Removes all specified elements from a :ref:`sparse tensor
        <sparse-docs>` :attr:`self` and resizes :attr:`self` to the desired
        size and the number of sparse and dense dimensions.

        .. warning:
          Throws an error if :attr:`self` is not a sparse tensor.

        Args:
            size (torch.Size): the desired size.
            sparse_dim (int): the number of sparse dimensions
            dense_dim (int): the number of dense dimensions
        """
    def split(self, *args, **kwargs): ...
    def split_with_sizes(self, *args, **kwargs): ...
    def sqrt(self) -> Tensor:
        """
        sqrt() -> Tensor

        See :func:`torch.sqrt`
        """
    def sqrt_(self) -> Tensor:
        """
        sqrt_() -> Tensor

        In-place version of :meth:`~Tensor.sqrt`
        """
    def square(self) -> Tensor:
        """
        square() -> Tensor

        See :func:`torch.square`
        """
    def square_(self) -> Tensor:
        """
        square_() -> Tensor

        In-place version of :meth:`~Tensor.square`
        """
    def squeeze(self, dim=...) -> Tensor:
        """
        squeeze(dim=None) -> Tensor

        See :func:`torch.squeeze`
        """
    def squeeze_(self, dim=...) -> Tensor:
        """
        squeeze_(dim=None) -> Tensor

        In-place version of :meth:`~Tensor.squeeze`
        """
    def sspaddmm(self, mat1, mat2, beta=..., alpha=...) -> Tensor:
        """
        sspaddmm(mat1, mat2, *, beta=1, alpha=1) -> Tensor

        See :func:`torch.sspaddmm`
        """
    def std(self, dim=..., correction=..., keepdim=...) -> Tensor:
        """
        std(dim=None, *, correction=1, keepdim=False) -> Tensor

        See :func:`torch.std`
        """
    def stft(self, frame_length, hop, fft_size=..., return_onesided=..., window=..., 
pad_end=..., align_to_window=...) -> Tensor:
        """
        stft(frame_length, hop, fft_size=None, return_onesided=True, window=None,
         pad_end=0, align_to_window=None) -> Tensor

        See :func:`torch.stft`
        """
    def storage_offset(self) -> int:
        """
        storage_offset() -> int

        Returns :attr:`self` tensor's offset in the underlying storage in terms of
        number of storage elements (not bytes).

        Example::

            >>> x = torch.tensor([1, 2, 3, 4, 5])
            >>> x.storage_offset()
            0
            >>> x[3:].storage_offset()
            3

        """
    @overload
    def stride(self, dim) -> tupleorint:
        """
        stride(dim) -> tuple or int

        Returns the stride of :attr:`self` tensor.

        Stride is the jump necessary to go from one element to the next one in the
        specified dimension :attr:`dim`. A tuple of all strides is returned when no
        argument is passed in. Otherwise, an integer value is returned as the stride in
        the particular dimension :attr:`dim`.

        Args:
            dim (int, optional): the desired dimension in which stride is required

        Example::

            >>> x = torch.tensor([[1, 2, 3, 4, 5], [6, 7, 8, 9, 10]])
            >>> x.stride()
            (5, 1)
            >>> x.stride(0)
            5
            >>> x.stride(-1)
            1

        """
    @overload
    def stride(self) -> Any:
        """
        stride(dim) -> tuple or int

        Returns the stride of :attr:`self` tensor.

        Stride is the jump necessary to go from one element to the next one in the
        specified dimension :attr:`dim`. A tuple of all strides is returned when no
        argument is passed in. Otherwise, an integer value is returned as the stride in
        the particular dimension :attr:`dim`.

        Args:
            dim (int, optional): the desired dimension in which stride is required

        Example::

            >>> x = torch.tensor([[1, 2, 3, 4, 5], [6, 7, 8, 9, 10]])
            >>> x.stride()
            (5, 1)
            >>> x.stride(0)
            5
            >>> x.stride(-1)
            1

        """
    def sub(self, other, alpha=...) -> Tensor:
        """
        sub(other, *, alpha=1) -> Tensor

        See :func:`torch.sub`.
        """
    def sub_(self, other, alpha=...) -> Tensor:
        """
        sub_(other, *, alpha=1) -> Tensor

        In-place version of :meth:`~Tensor.sub`
        """
    def subtract(self, other, alpha=...) -> Tensor:
        """
        subtract(other, *, alpha=1) -> Tensor

        See :func:`torch.subtract`.
        """
    def subtract_(self, other, alpha=...) -> Tensor:
        """
        subtract_(other, *, alpha=1) -> Tensor

        In-place version of :meth:`~Tensor.subtract`.
        """
    def sum(self, dim=..., keepdim=..., dtype=...) -> Tensor:
        """
        sum(dim=None, keepdim=False, dtype=None) -> Tensor

        See :func:`torch.sum`
        """
    def sum_to_size(self, *size) -> Tensor:
        """
        sum_to_size(*size) -> Tensor

        Sum ``this`` tensor to :attr:`size`.
        :attr:`size` must be broadcastable to ``this`` tensor size.

        Args:
            size (int...): a sequence of integers defining the shape of the output tensor.
        """
    def svd(self, *args, **kwargs):
        """
        svd(some=True, compute_uv=True) -> (Tensor, Tensor, Tensor)

        See :func:`torch.svd`
        """
    def swapaxes(self, axis0, axis1) -> Tensor:
        """
        swapaxes(axis0, axis1) -> Tensor

        See :func:`torch.swapaxes`
        """
    def swapaxes_(self, axis0, axis1) -> Tensor:
        """
        swapaxes_(axis0, axis1) -> Tensor

        In-place version of :meth:`~Tensor.swapaxes`
        """
    def swapdims(self, dim0, dim1) -> Tensor:
        """
        swapdims(dim0, dim1) -> Tensor

        See :func:`torch.swapdims`
        """
    def swapdims_(self, dim0, dim1) -> Tensor:
        """
        swapdims_(dim0, dim1) -> Tensor

        In-place version of :meth:`~Tensor.swapdims`
        """
    def t(self) -> Tensor:
        """
        t() -> Tensor

        See :func:`torch.t`
        """
    def t_(self) -> Tensor:
        """
        t_() -> Tensor

        In-place version of :meth:`~Tensor.t`
        """
    def take(self, indices) -> Tensor:
        """
        take(indices) -> Tensor

        See :func:`torch.take`
        """
    def take_along_dim(self, indices, dim) -> Tensor:
        """
        take_along_dim(indices, dim) -> Tensor

        See :func:`torch.take_along_dim`
        """
    def tan(self) -> Tensor:
        """
        tan() -> Tensor

        See :func:`torch.tan`
        """
    def tan_(self) -> Tensor:
        """
        tan_() -> Tensor

        In-place version of :meth:`~Tensor.tan`
        """
    def tanh(self) -> Tensor:
        """
        tanh() -> Tensor

        See :func:`torch.tanh`
        """
    def tanh_(self) -> Tensor:
        """
        tanh_() -> Tensor

        In-place version of :meth:`~Tensor.tanh`
        """
    def tensor_split(self, indices_or_sections, dim=...) -> ListofTensors:
        """
        tensor_split(indices_or_sections, dim=0) -> List of Tensors

        See :func:`torch.tensor_split`
        """
    def tile(self, dims) -> Tensor:
        """
        tile(dims) -> Tensor

        See :func:`torch.tile`
        """
    @overload
    def to(self, dtype, non_blocking=..., copy=..., memory_format=...) -> Tensor:
        """
        to(*args, **kwargs) -> Tensor

        Performs Tensor dtype and/or device conversion. A :class:`torch.dtype` and :class:`torch.device` are
        inferred from the arguments of ``self.to(*args, **kwargs)``.

        .. note::

            If the ``self`` Tensor already
            has the correct :class:`torch.dtype` and :class:`torch.device`, then ``self`` is returned.
            Otherwise, the returned tensor is a copy of ``self`` with the desired
            :class:`torch.dtype` and :class:`torch.device`.

        .. note::

            If ``self`` requires gradients (``requires_grad=True``) but the target
            ``dtype`` specified is an integer type, the returned tensor will implicitly
            set ``requires_grad=False``. This is because only tensors with
            floating-point or complex dtypes can require gradients.

        Here are the ways to call ``to``:

        .. method:: to(dtype, non_blocking=False, copy=False, memory_format=torch.preserve_format) -> Tensor
           :noindex:

            Returns a Tensor with the specified :attr:`dtype`

            Args:
                memory_format (:class:`torch.memory_format`, optional): the desired memory format of
                returned Tensor. Default: ``torch.preserve_format``.

        .. note::

            According to `C++ type conversion rules <https://en.cppreference.com/w/cpp/language/implicit_conversion.html>`_,
            converting floating point value to integer type will truncate the fractional part.
            If the truncated value cannot fit into the target type (e.g., casting ``torch.inf`` to ``torch.long``),
            the behavior is undefined and the result may vary across platforms.

        .. method:: to(device=None, dtype=None, non_blocking=False, copy=False, memory_format=torch.preserve_format) -> Tensor
           :noindex:

            Returns a Tensor with the specified :attr:`device` and (optional)
            :attr:`dtype`. If :attr:`dtype` is ``None`` it is inferred to be ``self.dtype``.
            When :attr:`non_blocking` is set to ``True``, the function attempts to perform
            the conversion asynchronously with respect to the host, if possible. This
            asynchronous behavior applies to both pinned and pageable memory. However,
            caution is advised when using this feature. For more information, refer to the
            `tutorial on good usage of non_blocking and pin_memory <https://pytorch.org/tutorials/intermediate/pinmem_nonblock.html>`__.
            When :attr:`copy` is set, a new Tensor is created even when the Tensor
            already matches the desired conversion.

            Args:
                memory_format (:class:`torch.memory_format`, optional): the desired memory format of
                returned Tensor. Default: ``torch.preserve_format``.

        .. method:: to(other, non_blocking=False, copy=False) -> Tensor
           :noindex:

            Returns a Tensor with same :class:`torch.dtype` and :class:`torch.device` as
            the Tensor :attr:`other`.
            When :attr:`non_blocking` is set to ``True``, the function attempts to perform
            the conversion asynchronously with respect to the host, if possible. This
            asynchronous behavior applies to both pinned and pageable memory. However,
            caution is advised when using this feature. For more information, refer to the
            `tutorial on good usage of non_blocking and pin_memory <https://pytorch.org/tutorials/intermediate/pinmem_nonblock.html>`__.
            When :attr:`copy` is set, a new Tensor is created even when the Tensor
            already matches the desired conversion.

        Example::

            >>> tensor = torch.randn(2, 2)  # Initially dtype=float32, device=cpu
            >>> tensor.to(torch.float64)
            tensor([[-0.5044,  0.0005],
                    [ 0.3310, -0.0584]], dtype=torch.float64)

            >>> cuda0 = torch.device('cuda:0')
            >>> tensor.to(cuda0)
            tensor([[-0.5044,  0.0005],
                    [ 0.3310, -0.0584]], device='cuda:0')

            >>> tensor.to(cuda0, dtype=torch.float64)
            tensor([[-0.5044,  0.0005],
                    [ 0.3310, -0.0584]], dtype=torch.float64, device='cuda:0')

            >>> other = torch.randn((), dtype=torch.float64, device=cuda0)
            >>> tensor.to(other, non_blocking=True)
            tensor([[-0.5044,  0.0005],
                    [ 0.3310, -0.0584]], dtype=torch.float64, device='cuda:0')
        """
    @overload
    def to(self, device=..., dtype=..., non_blocking=..., copy=..., memory_format=...) -> Tensor:
        """
        to(*args, **kwargs) -> Tensor

        Performs Tensor dtype and/or device conversion. A :class:`torch.dtype` and :class:`torch.device` are
        inferred from the arguments of ``self.to(*args, **kwargs)``.

        .. note::

            If the ``self`` Tensor already
            has the correct :class:`torch.dtype` and :class:`torch.device`, then ``self`` is returned.
            Otherwise, the returned tensor is a copy of ``self`` with the desired
            :class:`torch.dtype` and :class:`torch.device`.

        .. note::

            If ``self`` requires gradients (``requires_grad=True``) but the target
            ``dtype`` specified is an integer type, the returned tensor will implicitly
            set ``requires_grad=False``. This is because only tensors with
            floating-point or complex dtypes can require gradients.

        Here are the ways to call ``to``:

        .. method:: to(dtype, non_blocking=False, copy=False, memory_format=torch.preserve_format) -> Tensor
           :noindex:

            Returns a Tensor with the specified :attr:`dtype`

            Args:
                memory_format (:class:`torch.memory_format`, optional): the desired memory format of
                returned Tensor. Default: ``torch.preserve_format``.

        .. note::

            According to `C++ type conversion rules <https://en.cppreference.com/w/cpp/language/implicit_conversion.html>`_,
            converting floating point value to integer type will truncate the fractional part.
            If the truncated value cannot fit into the target type (e.g., casting ``torch.inf`` to ``torch.long``),
            the behavior is undefined and the result may vary across platforms.

        .. method:: to(device=None, dtype=None, non_blocking=False, copy=False, memory_format=torch.preserve_format) -> Tensor
           :noindex:

            Returns a Tensor with the specified :attr:`device` and (optional)
            :attr:`dtype`. If :attr:`dtype` is ``None`` it is inferred to be ``self.dtype``.
            When :attr:`non_blocking` is set to ``True``, the function attempts to perform
            the conversion asynchronously with respect to the host, if possible. This
            asynchronous behavior applies to both pinned and pageable memory. However,
            caution is advised when using this feature. For more information, refer to the
            `tutorial on good usage of non_blocking and pin_memory <https://pytorch.org/tutorials/intermediate/pinmem_nonblock.html>`__.
            When :attr:`copy` is set, a new Tensor is created even when the Tensor
            already matches the desired conversion.

            Args:
                memory_format (:class:`torch.memory_format`, optional): the desired memory format of
                returned Tensor. Default: ``torch.preserve_format``.

        .. method:: to(other, non_blocking=False, copy=False) -> Tensor
           :noindex:

            Returns a Tensor with same :class:`torch.dtype` and :class:`torch.device` as
            the Tensor :attr:`other`.
            When :attr:`non_blocking` is set to ``True``, the function attempts to perform
            the conversion asynchronously with respect to the host, if possible. This
            asynchronous behavior applies to both pinned and pageable memory. However,
            caution is advised when using this feature. For more information, refer to the
            `tutorial on good usage of non_blocking and pin_memory <https://pytorch.org/tutorials/intermediate/pinmem_nonblock.html>`__.
            When :attr:`copy` is set, a new Tensor is created even when the Tensor
            already matches the desired conversion.

        Example::

            >>> tensor = torch.randn(2, 2)  # Initially dtype=float32, device=cpu
            >>> tensor.to(torch.float64)
            tensor([[-0.5044,  0.0005],
                    [ 0.3310, -0.0584]], dtype=torch.float64)

            >>> cuda0 = torch.device('cuda:0')
            >>> tensor.to(cuda0)
            tensor([[-0.5044,  0.0005],
                    [ 0.3310, -0.0584]], device='cuda:0')

            >>> tensor.to(cuda0, dtype=torch.float64)
            tensor([[-0.5044,  0.0005],
                    [ 0.3310, -0.0584]], dtype=torch.float64, device='cuda:0')

            >>> other = torch.randn((), dtype=torch.float64, device=cuda0)
            >>> tensor.to(other, non_blocking=True)
            tensor([[-0.5044,  0.0005],
                    [ 0.3310, -0.0584]], dtype=torch.float64, device='cuda:0')
        """
    @overload
    def to(self, other, non_blocking=..., copy=...) -> Tensor:
        """
        to(*args, **kwargs) -> Tensor

        Performs Tensor dtype and/or device conversion. A :class:`torch.dtype` and :class:`torch.device` are
        inferred from the arguments of ``self.to(*args, **kwargs)``.

        .. note::

            If the ``self`` Tensor already
            has the correct :class:`torch.dtype` and :class:`torch.device`, then ``self`` is returned.
            Otherwise, the returned tensor is a copy of ``self`` with the desired
            :class:`torch.dtype` and :class:`torch.device`.

        .. note::

            If ``self`` requires gradients (``requires_grad=True``) but the target
            ``dtype`` specified is an integer type, the returned tensor will implicitly
            set ``requires_grad=False``. This is because only tensors with
            floating-point or complex dtypes can require gradients.

        Here are the ways to call ``to``:

        .. method:: to(dtype, non_blocking=False, copy=False, memory_format=torch.preserve_format) -> Tensor
           :noindex:

            Returns a Tensor with the specified :attr:`dtype`

            Args:
                memory_format (:class:`torch.memory_format`, optional): the desired memory format of
                returned Tensor. Default: ``torch.preserve_format``.

        .. note::

            According to `C++ type conversion rules <https://en.cppreference.com/w/cpp/language/implicit_conversion.html>`_,
            converting floating point value to integer type will truncate the fractional part.
            If the truncated value cannot fit into the target type (e.g., casting ``torch.inf`` to ``torch.long``),
            the behavior is undefined and the result may vary across platforms.

        .. method:: to(device=None, dtype=None, non_blocking=False, copy=False, memory_format=torch.preserve_format) -> Tensor
           :noindex:

            Returns a Tensor with the specified :attr:`device` and (optional)
            :attr:`dtype`. If :attr:`dtype` is ``None`` it is inferred to be ``self.dtype``.
            When :attr:`non_blocking` is set to ``True``, the function attempts to perform
            the conversion asynchronously with respect to the host, if possible. This
            asynchronous behavior applies to both pinned and pageable memory. However,
            caution is advised when using this feature. For more information, refer to the
            `tutorial on good usage of non_blocking and pin_memory <https://pytorch.org/tutorials/intermediate/pinmem_nonblock.html>`__.
            When :attr:`copy` is set, a new Tensor is created even when the Tensor
            already matches the desired conversion.

            Args:
                memory_format (:class:`torch.memory_format`, optional): the desired memory format of
                returned Tensor. Default: ``torch.preserve_format``.

        .. method:: to(other, non_blocking=False, copy=False) -> Tensor
           :noindex:

            Returns a Tensor with same :class:`torch.dtype` and :class:`torch.device` as
            the Tensor :attr:`other`.
            When :attr:`non_blocking` is set to ``True``, the function attempts to perform
            the conversion asynchronously with respect to the host, if possible. This
            asynchronous behavior applies to both pinned and pageable memory. However,
            caution is advised when using this feature. For more information, refer to the
            `tutorial on good usage of non_blocking and pin_memory <https://pytorch.org/tutorials/intermediate/pinmem_nonblock.html>`__.
            When :attr:`copy` is set, a new Tensor is created even when the Tensor
            already matches the desired conversion.

        Example::

            >>> tensor = torch.randn(2, 2)  # Initially dtype=float32, device=cpu
            >>> tensor.to(torch.float64)
            tensor([[-0.5044,  0.0005],
                    [ 0.3310, -0.0584]], dtype=torch.float64)

            >>> cuda0 = torch.device('cuda:0')
            >>> tensor.to(cuda0)
            tensor([[-0.5044,  0.0005],
                    [ 0.3310, -0.0584]], device='cuda:0')

            >>> tensor.to(cuda0, dtype=torch.float64)
            tensor([[-0.5044,  0.0005],
                    [ 0.3310, -0.0584]], dtype=torch.float64, device='cuda:0')

            >>> other = torch.randn((), dtype=torch.float64, device=cuda0)
            >>> tensor.to(other, non_blocking=True)
            tensor([[-0.5044,  0.0005],
                    [ 0.3310, -0.0584]], dtype=torch.float64, device='cuda:0')
        """
    @overload
    def to(self, cuda0) -> Any:
        """
        to(*args, **kwargs) -> Tensor

        Performs Tensor dtype and/or device conversion. A :class:`torch.dtype` and :class:`torch.device` are
        inferred from the arguments of ``self.to(*args, **kwargs)``.

        .. note::

            If the ``self`` Tensor already
            has the correct :class:`torch.dtype` and :class:`torch.device`, then ``self`` is returned.
            Otherwise, the returned tensor is a copy of ``self`` with the desired
            :class:`torch.dtype` and :class:`torch.device`.

        .. note::

            If ``self`` requires gradients (``requires_grad=True``) but the target
            ``dtype`` specified is an integer type, the returned tensor will implicitly
            set ``requires_grad=False``. This is because only tensors with
            floating-point or complex dtypes can require gradients.

        Here are the ways to call ``to``:

        .. method:: to(dtype, non_blocking=False, copy=False, memory_format=torch.preserve_format) -> Tensor
           :noindex:

            Returns a Tensor with the specified :attr:`dtype`

            Args:
                memory_format (:class:`torch.memory_format`, optional): the desired memory format of
                returned Tensor. Default: ``torch.preserve_format``.

        .. note::

            According to `C++ type conversion rules <https://en.cppreference.com/w/cpp/language/implicit_conversion.html>`_,
            converting floating point value to integer type will truncate the fractional part.
            If the truncated value cannot fit into the target type (e.g., casting ``torch.inf`` to ``torch.long``),
            the behavior is undefined and the result may vary across platforms.

        .. method:: to(device=None, dtype=None, non_blocking=False, copy=False, memory_format=torch.preserve_format) -> Tensor
           :noindex:

            Returns a Tensor with the specified :attr:`device` and (optional)
            :attr:`dtype`. If :attr:`dtype` is ``None`` it is inferred to be ``self.dtype``.
            When :attr:`non_blocking` is set to ``True``, the function attempts to perform
            the conversion asynchronously with respect to the host, if possible. This
            asynchronous behavior applies to both pinned and pageable memory. However,
            caution is advised when using this feature. For more information, refer to the
            `tutorial on good usage of non_blocking and pin_memory <https://pytorch.org/tutorials/intermediate/pinmem_nonblock.html>`__.
            When :attr:`copy` is set, a new Tensor is created even when the Tensor
            already matches the desired conversion.

            Args:
                memory_format (:class:`torch.memory_format`, optional): the desired memory format of
                returned Tensor. Default: ``torch.preserve_format``.

        .. method:: to(other, non_blocking=False, copy=False) -> Tensor
           :noindex:

            Returns a Tensor with same :class:`torch.dtype` and :class:`torch.device` as
            the Tensor :attr:`other`.
            When :attr:`non_blocking` is set to ``True``, the function attempts to perform
            the conversion asynchronously with respect to the host, if possible. This
            asynchronous behavior applies to both pinned and pageable memory. However,
            caution is advised when using this feature. For more information, refer to the
            `tutorial on good usage of non_blocking and pin_memory <https://pytorch.org/tutorials/intermediate/pinmem_nonblock.html>`__.
            When :attr:`copy` is set, a new Tensor is created even when the Tensor
            already matches the desired conversion.

        Example::

            >>> tensor = torch.randn(2, 2)  # Initially dtype=float32, device=cpu
            >>> tensor.to(torch.float64)
            tensor([[-0.5044,  0.0005],
                    [ 0.3310, -0.0584]], dtype=torch.float64)

            >>> cuda0 = torch.device('cuda:0')
            >>> tensor.to(cuda0)
            tensor([[-0.5044,  0.0005],
                    [ 0.3310, -0.0584]], device='cuda:0')

            >>> tensor.to(cuda0, dtype=torch.float64)
            tensor([[-0.5044,  0.0005],
                    [ 0.3310, -0.0584]], dtype=torch.float64, device='cuda:0')

            >>> other = torch.randn((), dtype=torch.float64, device=cuda0)
            >>> tensor.to(other, non_blocking=True)
            tensor([[-0.5044,  0.0005],
                    [ 0.3310, -0.0584]], dtype=torch.float64, device='cuda:0')
        """
    @overload
    def to(self, cuda0, dtype=...) -> Any:
        """
        to(*args, **kwargs) -> Tensor

        Performs Tensor dtype and/or device conversion. A :class:`torch.dtype` and :class:`torch.device` are
        inferred from the arguments of ``self.to(*args, **kwargs)``.

        .. note::

            If the ``self`` Tensor already
            has the correct :class:`torch.dtype` and :class:`torch.device`, then ``self`` is returned.
            Otherwise, the returned tensor is a copy of ``self`` with the desired
            :class:`torch.dtype` and :class:`torch.device`.

        .. note::

            If ``self`` requires gradients (``requires_grad=True``) but the target
            ``dtype`` specified is an integer type, the returned tensor will implicitly
            set ``requires_grad=False``. This is because only tensors with
            floating-point or complex dtypes can require gradients.

        Here are the ways to call ``to``:

        .. method:: to(dtype, non_blocking=False, copy=False, memory_format=torch.preserve_format) -> Tensor
           :noindex:

            Returns a Tensor with the specified :attr:`dtype`

            Args:
                memory_format (:class:`torch.memory_format`, optional): the desired memory format of
                returned Tensor. Default: ``torch.preserve_format``.

        .. note::

            According to `C++ type conversion rules <https://en.cppreference.com/w/cpp/language/implicit_conversion.html>`_,
            converting floating point value to integer type will truncate the fractional part.
            If the truncated value cannot fit into the target type (e.g., casting ``torch.inf`` to ``torch.long``),
            the behavior is undefined and the result may vary across platforms.

        .. method:: to(device=None, dtype=None, non_blocking=False, copy=False, memory_format=torch.preserve_format) -> Tensor
           :noindex:

            Returns a Tensor with the specified :attr:`device` and (optional)
            :attr:`dtype`. If :attr:`dtype` is ``None`` it is inferred to be ``self.dtype``.
            When :attr:`non_blocking` is set to ``True``, the function attempts to perform
            the conversion asynchronously with respect to the host, if possible. This
            asynchronous behavior applies to both pinned and pageable memory. However,
            caution is advised when using this feature. For more information, refer to the
            `tutorial on good usage of non_blocking and pin_memory <https://pytorch.org/tutorials/intermediate/pinmem_nonblock.html>`__.
            When :attr:`copy` is set, a new Tensor is created even when the Tensor
            already matches the desired conversion.

            Args:
                memory_format (:class:`torch.memory_format`, optional): the desired memory format of
                returned Tensor. Default: ``torch.preserve_format``.

        .. method:: to(other, non_blocking=False, copy=False) -> Tensor
           :noindex:

            Returns a Tensor with same :class:`torch.dtype` and :class:`torch.device` as
            the Tensor :attr:`other`.
            When :attr:`non_blocking` is set to ``True``, the function attempts to perform
            the conversion asynchronously with respect to the host, if possible. This
            asynchronous behavior applies to both pinned and pageable memory. However,
            caution is advised when using this feature. For more information, refer to the
            `tutorial on good usage of non_blocking and pin_memory <https://pytorch.org/tutorials/intermediate/pinmem_nonblock.html>`__.
            When :attr:`copy` is set, a new Tensor is created even when the Tensor
            already matches the desired conversion.

        Example::

            >>> tensor = torch.randn(2, 2)  # Initially dtype=float32, device=cpu
            >>> tensor.to(torch.float64)
            tensor([[-0.5044,  0.0005],
                    [ 0.3310, -0.0584]], dtype=torch.float64)

            >>> cuda0 = torch.device('cuda:0')
            >>> tensor.to(cuda0)
            tensor([[-0.5044,  0.0005],
                    [ 0.3310, -0.0584]], device='cuda:0')

            >>> tensor.to(cuda0, dtype=torch.float64)
            tensor([[-0.5044,  0.0005],
                    [ 0.3310, -0.0584]], dtype=torch.float64, device='cuda:0')

            >>> other = torch.randn((), dtype=torch.float64, device=cuda0)
            >>> tensor.to(other, non_blocking=True)
            tensor([[-0.5044,  0.0005],
                    [ 0.3310, -0.0584]], dtype=torch.float64, device='cuda:0')
        """
    @overload
    def to(self, other, non_blocking=...) -> Any:
        """
        to(*args, **kwargs) -> Tensor

        Performs Tensor dtype and/or device conversion. A :class:`torch.dtype` and :class:`torch.device` are
        inferred from the arguments of ``self.to(*args, **kwargs)``.

        .. note::

            If the ``self`` Tensor already
            has the correct :class:`torch.dtype` and :class:`torch.device`, then ``self`` is returned.
            Otherwise, the returned tensor is a copy of ``self`` with the desired
            :class:`torch.dtype` and :class:`torch.device`.

        .. note::

            If ``self`` requires gradients (``requires_grad=True``) but the target
            ``dtype`` specified is an integer type, the returned tensor will implicitly
            set ``requires_grad=False``. This is because only tensors with
            floating-point or complex dtypes can require gradients.

        Here are the ways to call ``to``:

        .. method:: to(dtype, non_blocking=False, copy=False, memory_format=torch.preserve_format) -> Tensor
           :noindex:

            Returns a Tensor with the specified :attr:`dtype`

            Args:
                memory_format (:class:`torch.memory_format`, optional): the desired memory format of
                returned Tensor. Default: ``torch.preserve_format``.

        .. note::

            According to `C++ type conversion rules <https://en.cppreference.com/w/cpp/language/implicit_conversion.html>`_,
            converting floating point value to integer type will truncate the fractional part.
            If the truncated value cannot fit into the target type (e.g., casting ``torch.inf`` to ``torch.long``),
            the behavior is undefined and the result may vary across platforms.

        .. method:: to(device=None, dtype=None, non_blocking=False, copy=False, memory_format=torch.preserve_format) -> Tensor
           :noindex:

            Returns a Tensor with the specified :attr:`device` and (optional)
            :attr:`dtype`. If :attr:`dtype` is ``None`` it is inferred to be ``self.dtype``.
            When :attr:`non_blocking` is set to ``True``, the function attempts to perform
            the conversion asynchronously with respect to the host, if possible. This
            asynchronous behavior applies to both pinned and pageable memory. However,
            caution is advised when using this feature. For more information, refer to the
            `tutorial on good usage of non_blocking and pin_memory <https://pytorch.org/tutorials/intermediate/pinmem_nonblock.html>`__.
            When :attr:`copy` is set, a new Tensor is created even when the Tensor
            already matches the desired conversion.

            Args:
                memory_format (:class:`torch.memory_format`, optional): the desired memory format of
                returned Tensor. Default: ``torch.preserve_format``.

        .. method:: to(other, non_blocking=False, copy=False) -> Tensor
           :noindex:

            Returns a Tensor with same :class:`torch.dtype` and :class:`torch.device` as
            the Tensor :attr:`other`.
            When :attr:`non_blocking` is set to ``True``, the function attempts to perform
            the conversion asynchronously with respect to the host, if possible. This
            asynchronous behavior applies to both pinned and pageable memory. However,
            caution is advised when using this feature. For more information, refer to the
            `tutorial on good usage of non_blocking and pin_memory <https://pytorch.org/tutorials/intermediate/pinmem_nonblock.html>`__.
            When :attr:`copy` is set, a new Tensor is created even when the Tensor
            already matches the desired conversion.

        Example::

            >>> tensor = torch.randn(2, 2)  # Initially dtype=float32, device=cpu
            >>> tensor.to(torch.float64)
            tensor([[-0.5044,  0.0005],
                    [ 0.3310, -0.0584]], dtype=torch.float64)

            >>> cuda0 = torch.device('cuda:0')
            >>> tensor.to(cuda0)
            tensor([[-0.5044,  0.0005],
                    [ 0.3310, -0.0584]], device='cuda:0')

            >>> tensor.to(cuda0, dtype=torch.float64)
            tensor([[-0.5044,  0.0005],
                    [ 0.3310, -0.0584]], dtype=torch.float64, device='cuda:0')

            >>> other = torch.randn((), dtype=torch.float64, device=cuda0)
            >>> tensor.to(other, non_blocking=True)
            tensor([[-0.5044,  0.0005],
                    [ 0.3310, -0.0584]], dtype=torch.float64, device='cuda:0')
        """
    @overload
    def to(self, *args, **kwargs) -> Tensor:
        """
        to(*args, **kwargs) -> Tensor

        Performs Tensor dtype and/or device conversion. A :class:`torch.dtype` and :class:`torch.device` are
        inferred from the arguments of ``self.to(*args, **kwargs)``.

        .. note::

            If the ``self`` Tensor already
            has the correct :class:`torch.dtype` and :class:`torch.device`, then ``self`` is returned.
            Otherwise, the returned tensor is a copy of ``self`` with the desired
            :class:`torch.dtype` and :class:`torch.device`.

        .. note::

            If ``self`` requires gradients (``requires_grad=True``) but the target
            ``dtype`` specified is an integer type, the returned tensor will implicitly
            set ``requires_grad=False``. This is because only tensors with
            floating-point or complex dtypes can require gradients.

        Here are the ways to call ``to``:

        .. method:: to(dtype, non_blocking=False, copy=False, memory_format=torch.preserve_format) -> Tensor
           :noindex:

            Returns a Tensor with the specified :attr:`dtype`

            Args:
                memory_format (:class:`torch.memory_format`, optional): the desired memory format of
                returned Tensor. Default: ``torch.preserve_format``.

        .. note::

            According to `C++ type conversion rules <https://en.cppreference.com/w/cpp/language/implicit_conversion.html>`_,
            converting floating point value to integer type will truncate the fractional part.
            If the truncated value cannot fit into the target type (e.g., casting ``torch.inf`` to ``torch.long``),
            the behavior is undefined and the result may vary across platforms.

        .. method:: to(device=None, dtype=None, non_blocking=False, copy=False, memory_format=torch.preserve_format) -> Tensor
           :noindex:

            Returns a Tensor with the specified :attr:`device` and (optional)
            :attr:`dtype`. If :attr:`dtype` is ``None`` it is inferred to be ``self.dtype``.
            When :attr:`non_blocking` is set to ``True``, the function attempts to perform
            the conversion asynchronously with respect to the host, if possible. This
            asynchronous behavior applies to both pinned and pageable memory. However,
            caution is advised when using this feature. For more information, refer to the
            `tutorial on good usage of non_blocking and pin_memory <https://pytorch.org/tutorials/intermediate/pinmem_nonblock.html>`__.
            When :attr:`copy` is set, a new Tensor is created even when the Tensor
            already matches the desired conversion.

            Args:
                memory_format (:class:`torch.memory_format`, optional): the desired memory format of
                returned Tensor. Default: ``torch.preserve_format``.

        .. method:: to(other, non_blocking=False, copy=False) -> Tensor
           :noindex:

            Returns a Tensor with same :class:`torch.dtype` and :class:`torch.device` as
            the Tensor :attr:`other`.
            When :attr:`non_blocking` is set to ``True``, the function attempts to perform
            the conversion asynchronously with respect to the host, if possible. This
            asynchronous behavior applies to both pinned and pageable memory. However,
            caution is advised when using this feature. For more information, refer to the
            `tutorial on good usage of non_blocking and pin_memory <https://pytorch.org/tutorials/intermediate/pinmem_nonblock.html>`__.
            When :attr:`copy` is set, a new Tensor is created even when the Tensor
            already matches the desired conversion.

        Example::

            >>> tensor = torch.randn(2, 2)  # Initially dtype=float32, device=cpu
            >>> tensor.to(torch.float64)
            tensor([[-0.5044,  0.0005],
                    [ 0.3310, -0.0584]], dtype=torch.float64)

            >>> cuda0 = torch.device('cuda:0')
            >>> tensor.to(cuda0)
            tensor([[-0.5044,  0.0005],
                    [ 0.3310, -0.0584]], device='cuda:0')

            >>> tensor.to(cuda0, dtype=torch.float64)
            tensor([[-0.5044,  0.0005],
                    [ 0.3310, -0.0584]], dtype=torch.float64, device='cuda:0')

            >>> other = torch.randn((), dtype=torch.float64, device=cuda0)
            >>> tensor.to(other, non_blocking=True)
            tensor([[-0.5044,  0.0005],
                    [ 0.3310, -0.0584]], dtype=torch.float64, device='cuda:0')
        """
    @overload
    def to(self, *args, **kwargs) -> Any:
        """
        to(*args, **kwargs) -> Tensor

        Performs Tensor dtype and/or device conversion. A :class:`torch.dtype` and :class:`torch.device` are
        inferred from the arguments of ``self.to(*args, **kwargs)``.

        .. note::

            If the ``self`` Tensor already
            has the correct :class:`torch.dtype` and :class:`torch.device`, then ``self`` is returned.
            Otherwise, the returned tensor is a copy of ``self`` with the desired
            :class:`torch.dtype` and :class:`torch.device`.

        .. note::

            If ``self`` requires gradients (``requires_grad=True``) but the target
            ``dtype`` specified is an integer type, the returned tensor will implicitly
            set ``requires_grad=False``. This is because only tensors with
            floating-point or complex dtypes can require gradients.

        Here are the ways to call ``to``:

        .. method:: to(dtype, non_blocking=False, copy=False, memory_format=torch.preserve_format) -> Tensor
           :noindex:

            Returns a Tensor with the specified :attr:`dtype`

            Args:
                memory_format (:class:`torch.memory_format`, optional): the desired memory format of
                returned Tensor. Default: ``torch.preserve_format``.

        .. note::

            According to `C++ type conversion rules <https://en.cppreference.com/w/cpp/language/implicit_conversion.html>`_,
            converting floating point value to integer type will truncate the fractional part.
            If the truncated value cannot fit into the target type (e.g., casting ``torch.inf`` to ``torch.long``),
            the behavior is undefined and the result may vary across platforms.

        .. method:: to(device=None, dtype=None, non_blocking=False, copy=False, memory_format=torch.preserve_format) -> Tensor
           :noindex:

            Returns a Tensor with the specified :attr:`device` and (optional)
            :attr:`dtype`. If :attr:`dtype` is ``None`` it is inferred to be ``self.dtype``.
            When :attr:`non_blocking` is set to ``True``, the function attempts to perform
            the conversion asynchronously with respect to the host, if possible. This
            asynchronous behavior applies to both pinned and pageable memory. However,
            caution is advised when using this feature. For more information, refer to the
            `tutorial on good usage of non_blocking and pin_memory <https://pytorch.org/tutorials/intermediate/pinmem_nonblock.html>`__.
            When :attr:`copy` is set, a new Tensor is created even when the Tensor
            already matches the desired conversion.

            Args:
                memory_format (:class:`torch.memory_format`, optional): the desired memory format of
                returned Tensor. Default: ``torch.preserve_format``.

        .. method:: to(other, non_blocking=False, copy=False) -> Tensor
           :noindex:

            Returns a Tensor with same :class:`torch.dtype` and :class:`torch.device` as
            the Tensor :attr:`other`.
            When :attr:`non_blocking` is set to ``True``, the function attempts to perform
            the conversion asynchronously with respect to the host, if possible. This
            asynchronous behavior applies to both pinned and pageable memory. However,
            caution is advised when using this feature. For more information, refer to the
            `tutorial on good usage of non_blocking and pin_memory <https://pytorch.org/tutorials/intermediate/pinmem_nonblock.html>`__.
            When :attr:`copy` is set, a new Tensor is created even when the Tensor
            already matches the desired conversion.

        Example::

            >>> tensor = torch.randn(2, 2)  # Initially dtype=float32, device=cpu
            >>> tensor.to(torch.float64)
            tensor([[-0.5044,  0.0005],
                    [ 0.3310, -0.0584]], dtype=torch.float64)

            >>> cuda0 = torch.device('cuda:0')
            >>> tensor.to(cuda0)
            tensor([[-0.5044,  0.0005],
                    [ 0.3310, -0.0584]], device='cuda:0')

            >>> tensor.to(cuda0, dtype=torch.float64)
            tensor([[-0.5044,  0.0005],
                    [ 0.3310, -0.0584]], dtype=torch.float64, device='cuda:0')

            >>> other = torch.randn((), dtype=torch.float64, device=cuda0)
            >>> tensor.to(other, non_blocking=True)
            tensor([[-0.5044,  0.0005],
                    [ 0.3310, -0.0584]], dtype=torch.float64, device='cuda:0')
        """
    @overload
    def to_dense(self, dtype=..., masked_grad=...) -> Tensor:
        """
        to_dense(dtype=None, *, masked_grad=True) -> Tensor

        Creates a strided copy of :attr:`self` if :attr:`self` is not a strided tensor, otherwise returns :attr:`self`.

        Keyword args:
            {dtype}
            masked_grad (bool, optional): If set to ``True`` (default) and
              :attr:`self` has a sparse layout then the backward of
              :meth:`to_dense` returns ``grad.sparse_mask(self)``.

        Example::

            >>> s = torch.sparse_coo_tensor(
            ...        torch.tensor([[1, 1],
            ...                      [0, 2]]),
            ...        torch.tensor([9, 10]),
            ...        size=(3, 3))
            >>> s.to_dense()
            tensor([[ 0,  0,  0],
                    [ 9,  0, 10],
                    [ 0,  0,  0]])
        """
    @overload
    def to_dense(self) -> Any:
        """
        to_dense(dtype=None, *, masked_grad=True) -> Tensor

        Creates a strided copy of :attr:`self` if :attr:`self` is not a strided tensor, otherwise returns :attr:`self`.

        Keyword args:
            {dtype}
            masked_grad (bool, optional): If set to ``True`` (default) and
              :attr:`self` has a sparse layout then the backward of
              :meth:`to_dense` returns ``grad.sparse_mask(self)``.

        Example::

            >>> s = torch.sparse_coo_tensor(
            ...        torch.tensor([[1, 1],
            ...                      [0, 2]]),
            ...        torch.tensor([9, 10]),
            ...        size=(3, 3))
            >>> s.to_dense()
            tensor([[ 0,  0,  0],
                    [ 9,  0, 10],
                    [ 0,  0,  0]])
        """
    def to_mkldnn(self) -> Tensor:
        """
        to_mkldnn() -> Tensor
        Returns a copy of the tensor in ``torch.mkldnn`` layout.

        """
    def to_padded_tensor(self, padding, output_size=...) -> Tensor:
        """
        to_padded_tensor(padding, output_size=None) -> Tensor
        See :func:`to_padded_tensor`
        """
    @overload
    def to_sparse(self, sparseDims) -> Tensor:
        """
        to_sparse(sparseDims) -> Tensor

        Returns a sparse copy of the tensor.  PyTorch supports sparse tensors in
        :ref:`coordinate format <sparse-coo-docs>`.

        Args:
            sparseDims (int, optional): the number of sparse dimensions to include in the new sparse tensor

        Example::

            >>> d = torch.tensor([[0, 0, 0], [9, 0, 10], [0, 0, 0]])
            >>> d
            tensor([[ 0,  0,  0],
                    [ 9,  0, 10],
                    [ 0,  0,  0]])
            >>> d.to_sparse()
            tensor(indices=tensor([[1, 1],
                                   [0, 2]]),
                   values=tensor([ 9, 10]),
                   size=(3, 3), nnz=2, layout=torch.sparse_coo)
            >>> d.to_sparse(1)
            tensor(indices=tensor([[1]]),
                   values=tensor([[ 9,  0, 10]]),
                   size=(3, 3), nnz=1, layout=torch.sparse_coo)

        .. method:: to_sparse(*, layout=None, blocksize=None, dense_dim=None) -> Tensor
           :noindex:

        Returns a sparse tensor with the specified layout and blocksize.  If
        the :attr:`self` is strided, the number of dense dimensions could be
        specified, and a hybrid sparse tensor will be created, with
        `dense_dim` dense dimensions and `self.dim() - 2 - dense_dim` batch
        dimension.

        .. note:: If the :attr:`self` layout and blocksize parameters match
                  with the specified layout and blocksize, return
                  :attr:`self`. Otherwise, return a sparse tensor copy of
                  :attr:`self`.

        Args:

            layout (:class:`torch.layout`, optional): The desired sparse
              layout. One of ``torch.sparse_coo``, ``torch.sparse_csr``,
              ``torch.sparse_csc``, ``torch.sparse_bsr``, or
              ``torch.sparse_bsc``. Default: if ``None``,
              ``torch.sparse_coo``.

            blocksize (list, tuple, :class:`torch.Size`, optional): Block size
              of the resulting BSR or BSC tensor. For other layouts,
              specifying the block size that is not ``None`` will result in a
              RuntimeError exception.  A block size must be a tuple of length
              two such that its items evenly divide the two sparse dimensions.

            dense_dim (int, optional): Number of dense dimensions of the
              resulting CSR, CSC, BSR or BSC tensor.  This argument should be
              used only if :attr:`self` is a strided tensor, and must be a
              value between 0 and dimension of :attr:`self` tensor minus two.

        Example::

            >>> x = torch.tensor([[1, 0], [0, 0], [2, 3]])
            >>> x.to_sparse(layout=torch.sparse_coo)
            tensor(indices=tensor([[0, 2, 2],
                                   [0, 0, 1]]),
                   values=tensor([1, 2, 3]),
                   size=(3, 2), nnz=3, layout=torch.sparse_coo)
            >>> x.to_sparse(layout=torch.sparse_bsr, blocksize=(1, 2))
            tensor(crow_indices=tensor([0, 1, 1, 2]),
                   col_indices=tensor([0, 0]),
                   values=tensor([[[1, 0]],
                                  [[2, 3]]]), size=(3, 2), nnz=2, layout=torch.sparse_bsr)
            >>> x.to_sparse(layout=torch.sparse_bsr, blocksize=(2, 1))
            RuntimeError: Tensor size(-2) 3 needs to be divisible by blocksize[0] 2
            >>> x.to_sparse(layout=torch.sparse_csr, blocksize=(3, 1))
            RuntimeError: to_sparse for Strided to SparseCsr conversion does not use specified blocksize

            >>> x = torch.tensor([[[1], [0]], [[0], [0]], [[2], [3]]])
            >>> x.to_sparse(layout=torch.sparse_csr, dense_dim=1)
            tensor(crow_indices=tensor([0, 1, 1, 3]),
                   col_indices=tensor([0, 0, 1]),
                   values=tensor([[1],
                                  [2],
                                  [3]]), size=(3, 2, 1), nnz=3, layout=torch.sparse_csr)

        """
    @overload
    def to_sparse(self) -> Any:
        """
        to_sparse(sparseDims) -> Tensor

        Returns a sparse copy of the tensor.  PyTorch supports sparse tensors in
        :ref:`coordinate format <sparse-coo-docs>`.

        Args:
            sparseDims (int, optional): the number of sparse dimensions to include in the new sparse tensor

        Example::

            >>> d = torch.tensor([[0, 0, 0], [9, 0, 10], [0, 0, 0]])
            >>> d
            tensor([[ 0,  0,  0],
                    [ 9,  0, 10],
                    [ 0,  0,  0]])
            >>> d.to_sparse()
            tensor(indices=tensor([[1, 1],
                                   [0, 2]]),
                   values=tensor([ 9, 10]),
                   size=(3, 3), nnz=2, layout=torch.sparse_coo)
            >>> d.to_sparse(1)
            tensor(indices=tensor([[1]]),
                   values=tensor([[ 9,  0, 10]]),
                   size=(3, 3), nnz=1, layout=torch.sparse_coo)

        .. method:: to_sparse(*, layout=None, blocksize=None, dense_dim=None) -> Tensor
           :noindex:

        Returns a sparse tensor with the specified layout and blocksize.  If
        the :attr:`self` is strided, the number of dense dimensions could be
        specified, and a hybrid sparse tensor will be created, with
        `dense_dim` dense dimensions and `self.dim() - 2 - dense_dim` batch
        dimension.

        .. note:: If the :attr:`self` layout and blocksize parameters match
                  with the specified layout and blocksize, return
                  :attr:`self`. Otherwise, return a sparse tensor copy of
                  :attr:`self`.

        Args:

            layout (:class:`torch.layout`, optional): The desired sparse
              layout. One of ``torch.sparse_coo``, ``torch.sparse_csr``,
              ``torch.sparse_csc``, ``torch.sparse_bsr``, or
              ``torch.sparse_bsc``. Default: if ``None``,
              ``torch.sparse_coo``.

            blocksize (list, tuple, :class:`torch.Size`, optional): Block size
              of the resulting BSR or BSC tensor. For other layouts,
              specifying the block size that is not ``None`` will result in a
              RuntimeError exception.  A block size must be a tuple of length
              two such that its items evenly divide the two sparse dimensions.

            dense_dim (int, optional): Number of dense dimensions of the
              resulting CSR, CSC, BSR or BSC tensor.  This argument should be
              used only if :attr:`self` is a strided tensor, and must be a
              value between 0 and dimension of :attr:`self` tensor minus two.

        Example::

            >>> x = torch.tensor([[1, 0], [0, 0], [2, 3]])
            >>> x.to_sparse(layout=torch.sparse_coo)
            tensor(indices=tensor([[0, 2, 2],
                                   [0, 0, 1]]),
                   values=tensor([1, 2, 3]),
                   size=(3, 2), nnz=3, layout=torch.sparse_coo)
            >>> x.to_sparse(layout=torch.sparse_bsr, blocksize=(1, 2))
            tensor(crow_indices=tensor([0, 1, 1, 2]),
                   col_indices=tensor([0, 0]),
                   values=tensor([[[1, 0]],
                                  [[2, 3]]]), size=(3, 2), nnz=2, layout=torch.sparse_bsr)
            >>> x.to_sparse(layout=torch.sparse_bsr, blocksize=(2, 1))
            RuntimeError: Tensor size(-2) 3 needs to be divisible by blocksize[0] 2
            >>> x.to_sparse(layout=torch.sparse_csr, blocksize=(3, 1))
            RuntimeError: to_sparse for Strided to SparseCsr conversion does not use specified blocksize

            >>> x = torch.tensor([[[1], [0]], [[0], [0]], [[2], [3]]])
            >>> x.to_sparse(layout=torch.sparse_csr, dense_dim=1)
            tensor(crow_indices=tensor([0, 1, 1, 3]),
                   col_indices=tensor([0, 0, 1]),
                   values=tensor([[1],
                                  [2],
                                  [3]]), size=(3, 2, 1), nnz=3, layout=torch.sparse_csr)

        """
    @overload
    def to_sparse(self, 1, layout=..., blocksize=..., dense_dim=...) -> Tensor:
        """
        to_sparse(sparseDims) -> Tensor

        Returns a sparse copy of the tensor.  PyTorch supports sparse tensors in
        :ref:`coordinate format <sparse-coo-docs>`.

        Args:
            sparseDims (int, optional): the number of sparse dimensions to include in the new sparse tensor

        Example::

            >>> d = torch.tensor([[0, 0, 0], [9, 0, 10], [0, 0, 0]])
            >>> d
            tensor([[ 0,  0,  0],
                    [ 9,  0, 10],
                    [ 0,  0,  0]])
            >>> d.to_sparse()
            tensor(indices=tensor([[1, 1],
                                   [0, 2]]),
                   values=tensor([ 9, 10]),
                   size=(3, 3), nnz=2, layout=torch.sparse_coo)
            >>> d.to_sparse(1)
            tensor(indices=tensor([[1]]),
                   values=tensor([[ 9,  0, 10]]),
                   size=(3, 3), nnz=1, layout=torch.sparse_coo)

        .. method:: to_sparse(*, layout=None, blocksize=None, dense_dim=None) -> Tensor
           :noindex:

        Returns a sparse tensor with the specified layout and blocksize.  If
        the :attr:`self` is strided, the number of dense dimensions could be
        specified, and a hybrid sparse tensor will be created, with
        `dense_dim` dense dimensions and `self.dim() - 2 - dense_dim` batch
        dimension.

        .. note:: If the :attr:`self` layout and blocksize parameters match
                  with the specified layout and blocksize, return
                  :attr:`self`. Otherwise, return a sparse tensor copy of
                  :attr:`self`.

        Args:

            layout (:class:`torch.layout`, optional): The desired sparse
              layout. One of ``torch.sparse_coo``, ``torch.sparse_csr``,
              ``torch.sparse_csc``, ``torch.sparse_bsr``, or
              ``torch.sparse_bsc``. Default: if ``None``,
              ``torch.sparse_coo``.

            blocksize (list, tuple, :class:`torch.Size`, optional): Block size
              of the resulting BSR or BSC tensor. For other layouts,
              specifying the block size that is not ``None`` will result in a
              RuntimeError exception.  A block size must be a tuple of length
              two such that its items evenly divide the two sparse dimensions.

            dense_dim (int, optional): Number of dense dimensions of the
              resulting CSR, CSC, BSR or BSC tensor.  This argument should be
              used only if :attr:`self` is a strided tensor, and must be a
              value between 0 and dimension of :attr:`self` tensor minus two.

        Example::

            >>> x = torch.tensor([[1, 0], [0, 0], [2, 3]])
            >>> x.to_sparse(layout=torch.sparse_coo)
            tensor(indices=tensor([[0, 2, 2],
                                   [0, 0, 1]]),
                   values=tensor([1, 2, 3]),
                   size=(3, 2), nnz=3, layout=torch.sparse_coo)
            >>> x.to_sparse(layout=torch.sparse_bsr, blocksize=(1, 2))
            tensor(crow_indices=tensor([0, 1, 1, 2]),
                   col_indices=tensor([0, 0]),
                   values=tensor([[[1, 0]],
                                  [[2, 3]]]), size=(3, 2), nnz=2, layout=torch.sparse_bsr)
            >>> x.to_sparse(layout=torch.sparse_bsr, blocksize=(2, 1))
            RuntimeError: Tensor size(-2) 3 needs to be divisible by blocksize[0] 2
            >>> x.to_sparse(layout=torch.sparse_csr, blocksize=(3, 1))
            RuntimeError: to_sparse for Strided to SparseCsr conversion does not use specified blocksize

            >>> x = torch.tensor([[[1], [0]], [[0], [0]], [[2], [3]]])
            >>> x.to_sparse(layout=torch.sparse_csr, dense_dim=1)
            tensor(crow_indices=tensor([0, 1, 1, 3]),
                   col_indices=tensor([0, 0, 1]),
                   values=tensor([[1],
                                  [2],
                                  [3]]), size=(3, 2, 1), nnz=3, layout=torch.sparse_csr)

        """
    @overload
    def to_sparse(self, layout=...) -> Any:
        """
        to_sparse(sparseDims) -> Tensor

        Returns a sparse copy of the tensor.  PyTorch supports sparse tensors in
        :ref:`coordinate format <sparse-coo-docs>`.

        Args:
            sparseDims (int, optional): the number of sparse dimensions to include in the new sparse tensor

        Example::

            >>> d = torch.tensor([[0, 0, 0], [9, 0, 10], [0, 0, 0]])
            >>> d
            tensor([[ 0,  0,  0],
                    [ 9,  0, 10],
                    [ 0,  0,  0]])
            >>> d.to_sparse()
            tensor(indices=tensor([[1, 1],
                                   [0, 2]]),
                   values=tensor([ 9, 10]),
                   size=(3, 3), nnz=2, layout=torch.sparse_coo)
            >>> d.to_sparse(1)
            tensor(indices=tensor([[1]]),
                   values=tensor([[ 9,  0, 10]]),
                   size=(3, 3), nnz=1, layout=torch.sparse_coo)

        .. method:: to_sparse(*, layout=None, blocksize=None, dense_dim=None) -> Tensor
           :noindex:

        Returns a sparse tensor with the specified layout and blocksize.  If
        the :attr:`self` is strided, the number of dense dimensions could be
        specified, and a hybrid sparse tensor will be created, with
        `dense_dim` dense dimensions and `self.dim() - 2 - dense_dim` batch
        dimension.

        .. note:: If the :attr:`self` layout and blocksize parameters match
                  with the specified layout and blocksize, return
                  :attr:`self`. Otherwise, return a sparse tensor copy of
                  :attr:`self`.

        Args:

            layout (:class:`torch.layout`, optional): The desired sparse
              layout. One of ``torch.sparse_coo``, ``torch.sparse_csr``,
              ``torch.sparse_csc``, ``torch.sparse_bsr``, or
              ``torch.sparse_bsc``. Default: if ``None``,
              ``torch.sparse_coo``.

            blocksize (list, tuple, :class:`torch.Size`, optional): Block size
              of the resulting BSR or BSC tensor. For other layouts,
              specifying the block size that is not ``None`` will result in a
              RuntimeError exception.  A block size must be a tuple of length
              two such that its items evenly divide the two sparse dimensions.

            dense_dim (int, optional): Number of dense dimensions of the
              resulting CSR, CSC, BSR or BSC tensor.  This argument should be
              used only if :attr:`self` is a strided tensor, and must be a
              value between 0 and dimension of :attr:`self` tensor minus two.

        Example::

            >>> x = torch.tensor([[1, 0], [0, 0], [2, 3]])
            >>> x.to_sparse(layout=torch.sparse_coo)
            tensor(indices=tensor([[0, 2, 2],
                                   [0, 0, 1]]),
                   values=tensor([1, 2, 3]),
                   size=(3, 2), nnz=3, layout=torch.sparse_coo)
            >>> x.to_sparse(layout=torch.sparse_bsr, blocksize=(1, 2))
            tensor(crow_indices=tensor([0, 1, 1, 2]),
                   col_indices=tensor([0, 0]),
                   values=tensor([[[1, 0]],
                                  [[2, 3]]]), size=(3, 2), nnz=2, layout=torch.sparse_bsr)
            >>> x.to_sparse(layout=torch.sparse_bsr, blocksize=(2, 1))
            RuntimeError: Tensor size(-2) 3 needs to be divisible by blocksize[0] 2
            >>> x.to_sparse(layout=torch.sparse_csr, blocksize=(3, 1))
            RuntimeError: to_sparse for Strided to SparseCsr conversion does not use specified blocksize

            >>> x = torch.tensor([[[1], [0]], [[0], [0]], [[2], [3]]])
            >>> x.to_sparse(layout=torch.sparse_csr, dense_dim=1)
            tensor(crow_indices=tensor([0, 1, 1, 3]),
                   col_indices=tensor([0, 0, 1]),
                   values=tensor([[1],
                                  [2],
                                  [3]]), size=(3, 2, 1), nnz=3, layout=torch.sparse_csr)

        """
    @overload
    def to_sparse(self, layout=..., blocksize=...) -> Any:
        """
        to_sparse(sparseDims) -> Tensor

        Returns a sparse copy of the tensor.  PyTorch supports sparse tensors in
        :ref:`coordinate format <sparse-coo-docs>`.

        Args:
            sparseDims (int, optional): the number of sparse dimensions to include in the new sparse tensor

        Example::

            >>> d = torch.tensor([[0, 0, 0], [9, 0, 10], [0, 0, 0]])
            >>> d
            tensor([[ 0,  0,  0],
                    [ 9,  0, 10],
                    [ 0,  0,  0]])
            >>> d.to_sparse()
            tensor(indices=tensor([[1, 1],
                                   [0, 2]]),
                   values=tensor([ 9, 10]),
                   size=(3, 3), nnz=2, layout=torch.sparse_coo)
            >>> d.to_sparse(1)
            tensor(indices=tensor([[1]]),
                   values=tensor([[ 9,  0, 10]]),
                   size=(3, 3), nnz=1, layout=torch.sparse_coo)

        .. method:: to_sparse(*, layout=None, blocksize=None, dense_dim=None) -> Tensor
           :noindex:

        Returns a sparse tensor with the specified layout and blocksize.  If
        the :attr:`self` is strided, the number of dense dimensions could be
        specified, and a hybrid sparse tensor will be created, with
        `dense_dim` dense dimensions and `self.dim() - 2 - dense_dim` batch
        dimension.

        .. note:: If the :attr:`self` layout and blocksize parameters match
                  with the specified layout and blocksize, return
                  :attr:`self`. Otherwise, return a sparse tensor copy of
                  :attr:`self`.

        Args:

            layout (:class:`torch.layout`, optional): The desired sparse
              layout. One of ``torch.sparse_coo``, ``torch.sparse_csr``,
              ``torch.sparse_csc``, ``torch.sparse_bsr``, or
              ``torch.sparse_bsc``. Default: if ``None``,
              ``torch.sparse_coo``.

            blocksize (list, tuple, :class:`torch.Size`, optional): Block size
              of the resulting BSR or BSC tensor. For other layouts,
              specifying the block size that is not ``None`` will result in a
              RuntimeError exception.  A block size must be a tuple of length
              two such that its items evenly divide the two sparse dimensions.

            dense_dim (int, optional): Number of dense dimensions of the
              resulting CSR, CSC, BSR or BSC tensor.  This argument should be
              used only if :attr:`self` is a strided tensor, and must be a
              value between 0 and dimension of :attr:`self` tensor minus two.

        Example::

            >>> x = torch.tensor([[1, 0], [0, 0], [2, 3]])
            >>> x.to_sparse(layout=torch.sparse_coo)
            tensor(indices=tensor([[0, 2, 2],
                                   [0, 0, 1]]),
                   values=tensor([1, 2, 3]),
                   size=(3, 2), nnz=3, layout=torch.sparse_coo)
            >>> x.to_sparse(layout=torch.sparse_bsr, blocksize=(1, 2))
            tensor(crow_indices=tensor([0, 1, 1, 2]),
                   col_indices=tensor([0, 0]),
                   values=tensor([[[1, 0]],
                                  [[2, 3]]]), size=(3, 2), nnz=2, layout=torch.sparse_bsr)
            >>> x.to_sparse(layout=torch.sparse_bsr, blocksize=(2, 1))
            RuntimeError: Tensor size(-2) 3 needs to be divisible by blocksize[0] 2
            >>> x.to_sparse(layout=torch.sparse_csr, blocksize=(3, 1))
            RuntimeError: to_sparse for Strided to SparseCsr conversion does not use specified blocksize

            >>> x = torch.tensor([[[1], [0]], [[0], [0]], [[2], [3]]])
            >>> x.to_sparse(layout=torch.sparse_csr, dense_dim=1)
            tensor(crow_indices=tensor([0, 1, 1, 3]),
                   col_indices=tensor([0, 0, 1]),
                   values=tensor([[1],
                                  [2],
                                  [3]]), size=(3, 2, 1), nnz=3, layout=torch.sparse_csr)

        """
    @overload
    def to_sparse(self, layout=..., blocksize=...) -> Any:
        """
        to_sparse(sparseDims) -> Tensor

        Returns a sparse copy of the tensor.  PyTorch supports sparse tensors in
        :ref:`coordinate format <sparse-coo-docs>`.

        Args:
            sparseDims (int, optional): the number of sparse dimensions to include in the new sparse tensor

        Example::

            >>> d = torch.tensor([[0, 0, 0], [9, 0, 10], [0, 0, 0]])
            >>> d
            tensor([[ 0,  0,  0],
                    [ 9,  0, 10],
                    [ 0,  0,  0]])
            >>> d.to_sparse()
            tensor(indices=tensor([[1, 1],
                                   [0, 2]]),
                   values=tensor([ 9, 10]),
                   size=(3, 3), nnz=2, layout=torch.sparse_coo)
            >>> d.to_sparse(1)
            tensor(indices=tensor([[1]]),
                   values=tensor([[ 9,  0, 10]]),
                   size=(3, 3), nnz=1, layout=torch.sparse_coo)

        .. method:: to_sparse(*, layout=None, blocksize=None, dense_dim=None) -> Tensor
           :noindex:

        Returns a sparse tensor with the specified layout and blocksize.  If
        the :attr:`self` is strided, the number of dense dimensions could be
        specified, and a hybrid sparse tensor will be created, with
        `dense_dim` dense dimensions and `self.dim() - 2 - dense_dim` batch
        dimension.

        .. note:: If the :attr:`self` layout and blocksize parameters match
                  with the specified layout and blocksize, return
                  :attr:`self`. Otherwise, return a sparse tensor copy of
                  :attr:`self`.

        Args:

            layout (:class:`torch.layout`, optional): The desired sparse
              layout. One of ``torch.sparse_coo``, ``torch.sparse_csr``,
              ``torch.sparse_csc``, ``torch.sparse_bsr``, or
              ``torch.sparse_bsc``. Default: if ``None``,
              ``torch.sparse_coo``.

            blocksize (list, tuple, :class:`torch.Size`, optional): Block size
              of the resulting BSR or BSC tensor. For other layouts,
              specifying the block size that is not ``None`` will result in a
              RuntimeError exception.  A block size must be a tuple of length
              two such that its items evenly divide the two sparse dimensions.

            dense_dim (int, optional): Number of dense dimensions of the
              resulting CSR, CSC, BSR or BSC tensor.  This argument should be
              used only if :attr:`self` is a strided tensor, and must be a
              value between 0 and dimension of :attr:`self` tensor minus two.

        Example::

            >>> x = torch.tensor([[1, 0], [0, 0], [2, 3]])
            >>> x.to_sparse(layout=torch.sparse_coo)
            tensor(indices=tensor([[0, 2, 2],
                                   [0, 0, 1]]),
                   values=tensor([1, 2, 3]),
                   size=(3, 2), nnz=3, layout=torch.sparse_coo)
            >>> x.to_sparse(layout=torch.sparse_bsr, blocksize=(1, 2))
            tensor(crow_indices=tensor([0, 1, 1, 2]),
                   col_indices=tensor([0, 0]),
                   values=tensor([[[1, 0]],
                                  [[2, 3]]]), size=(3, 2), nnz=2, layout=torch.sparse_bsr)
            >>> x.to_sparse(layout=torch.sparse_bsr, blocksize=(2, 1))
            RuntimeError: Tensor size(-2) 3 needs to be divisible by blocksize[0] 2
            >>> x.to_sparse(layout=torch.sparse_csr, blocksize=(3, 1))
            RuntimeError: to_sparse for Strided to SparseCsr conversion does not use specified blocksize

            >>> x = torch.tensor([[[1], [0]], [[0], [0]], [[2], [3]]])
            >>> x.to_sparse(layout=torch.sparse_csr, dense_dim=1)
            tensor(crow_indices=tensor([0, 1, 1, 3]),
                   col_indices=tensor([0, 0, 1]),
                   values=tensor([[1],
                                  [2],
                                  [3]]), size=(3, 2, 1), nnz=3, layout=torch.sparse_csr)

        """
    @overload
    def to_sparse(self, layout=..., blocksize=...) -> Any:
        """
        to_sparse(sparseDims) -> Tensor

        Returns a sparse copy of the tensor.  PyTorch supports sparse tensors in
        :ref:`coordinate format <sparse-coo-docs>`.

        Args:
            sparseDims (int, optional): the number of sparse dimensions to include in the new sparse tensor

        Example::

            >>> d = torch.tensor([[0, 0, 0], [9, 0, 10], [0, 0, 0]])
            >>> d
            tensor([[ 0,  0,  0],
                    [ 9,  0, 10],
                    [ 0,  0,  0]])
            >>> d.to_sparse()
            tensor(indices=tensor([[1, 1],
                                   [0, 2]]),
                   values=tensor([ 9, 10]),
                   size=(3, 3), nnz=2, layout=torch.sparse_coo)
            >>> d.to_sparse(1)
            tensor(indices=tensor([[1]]),
                   values=tensor([[ 9,  0, 10]]),
                   size=(3, 3), nnz=1, layout=torch.sparse_coo)

        .. method:: to_sparse(*, layout=None, blocksize=None, dense_dim=None) -> Tensor
           :noindex:

        Returns a sparse tensor with the specified layout and blocksize.  If
        the :attr:`self` is strided, the number of dense dimensions could be
        specified, and a hybrid sparse tensor will be created, with
        `dense_dim` dense dimensions and `self.dim() - 2 - dense_dim` batch
        dimension.

        .. note:: If the :attr:`self` layout and blocksize parameters match
                  with the specified layout and blocksize, return
                  :attr:`self`. Otherwise, return a sparse tensor copy of
                  :attr:`self`.

        Args:

            layout (:class:`torch.layout`, optional): The desired sparse
              layout. One of ``torch.sparse_coo``, ``torch.sparse_csr``,
              ``torch.sparse_csc``, ``torch.sparse_bsr``, or
              ``torch.sparse_bsc``. Default: if ``None``,
              ``torch.sparse_coo``.

            blocksize (list, tuple, :class:`torch.Size`, optional): Block size
              of the resulting BSR or BSC tensor. For other layouts,
              specifying the block size that is not ``None`` will result in a
              RuntimeError exception.  A block size must be a tuple of length
              two such that its items evenly divide the two sparse dimensions.

            dense_dim (int, optional): Number of dense dimensions of the
              resulting CSR, CSC, BSR or BSC tensor.  This argument should be
              used only if :attr:`self` is a strided tensor, and must be a
              value between 0 and dimension of :attr:`self` tensor minus two.

        Example::

            >>> x = torch.tensor([[1, 0], [0, 0], [2, 3]])
            >>> x.to_sparse(layout=torch.sparse_coo)
            tensor(indices=tensor([[0, 2, 2],
                                   [0, 0, 1]]),
                   values=tensor([1, 2, 3]),
                   size=(3, 2), nnz=3, layout=torch.sparse_coo)
            >>> x.to_sparse(layout=torch.sparse_bsr, blocksize=(1, 2))
            tensor(crow_indices=tensor([0, 1, 1, 2]),
                   col_indices=tensor([0, 0]),
                   values=tensor([[[1, 0]],
                                  [[2, 3]]]), size=(3, 2), nnz=2, layout=torch.sparse_bsr)
            >>> x.to_sparse(layout=torch.sparse_bsr, blocksize=(2, 1))
            RuntimeError: Tensor size(-2) 3 needs to be divisible by blocksize[0] 2
            >>> x.to_sparse(layout=torch.sparse_csr, blocksize=(3, 1))
            RuntimeError: to_sparse for Strided to SparseCsr conversion does not use specified blocksize

            >>> x = torch.tensor([[[1], [0]], [[0], [0]], [[2], [3]]])
            >>> x.to_sparse(layout=torch.sparse_csr, dense_dim=1)
            tensor(crow_indices=tensor([0, 1, 1, 3]),
                   col_indices=tensor([0, 0, 1]),
                   values=tensor([[1],
                                  [2],
                                  [3]]), size=(3, 2, 1), nnz=3, layout=torch.sparse_csr)

        """
    @overload
    def to_sparse(self, layout=..., dense_dim=...) -> Any:
        """
        to_sparse(sparseDims) -> Tensor

        Returns a sparse copy of the tensor.  PyTorch supports sparse tensors in
        :ref:`coordinate format <sparse-coo-docs>`.

        Args:
            sparseDims (int, optional): the number of sparse dimensions to include in the new sparse tensor

        Example::

            >>> d = torch.tensor([[0, 0, 0], [9, 0, 10], [0, 0, 0]])
            >>> d
            tensor([[ 0,  0,  0],
                    [ 9,  0, 10],
                    [ 0,  0,  0]])
            >>> d.to_sparse()
            tensor(indices=tensor([[1, 1],
                                   [0, 2]]),
                   values=tensor([ 9, 10]),
                   size=(3, 3), nnz=2, layout=torch.sparse_coo)
            >>> d.to_sparse(1)
            tensor(indices=tensor([[1]]),
                   values=tensor([[ 9,  0, 10]]),
                   size=(3, 3), nnz=1, layout=torch.sparse_coo)

        .. method:: to_sparse(*, layout=None, blocksize=None, dense_dim=None) -> Tensor
           :noindex:

        Returns a sparse tensor with the specified layout and blocksize.  If
        the :attr:`self` is strided, the number of dense dimensions could be
        specified, and a hybrid sparse tensor will be created, with
        `dense_dim` dense dimensions and `self.dim() - 2 - dense_dim` batch
        dimension.

        .. note:: If the :attr:`self` layout and blocksize parameters match
                  with the specified layout and blocksize, return
                  :attr:`self`. Otherwise, return a sparse tensor copy of
                  :attr:`self`.

        Args:

            layout (:class:`torch.layout`, optional): The desired sparse
              layout. One of ``torch.sparse_coo``, ``torch.sparse_csr``,
              ``torch.sparse_csc``, ``torch.sparse_bsr``, or
              ``torch.sparse_bsc``. Default: if ``None``,
              ``torch.sparse_coo``.

            blocksize (list, tuple, :class:`torch.Size`, optional): Block size
              of the resulting BSR or BSC tensor. For other layouts,
              specifying the block size that is not ``None`` will result in a
              RuntimeError exception.  A block size must be a tuple of length
              two such that its items evenly divide the two sparse dimensions.

            dense_dim (int, optional): Number of dense dimensions of the
              resulting CSR, CSC, BSR or BSC tensor.  This argument should be
              used only if :attr:`self` is a strided tensor, and must be a
              value between 0 and dimension of :attr:`self` tensor minus two.

        Example::

            >>> x = torch.tensor([[1, 0], [0, 0], [2, 3]])
            >>> x.to_sparse(layout=torch.sparse_coo)
            tensor(indices=tensor([[0, 2, 2],
                                   [0, 0, 1]]),
                   values=tensor([1, 2, 3]),
                   size=(3, 2), nnz=3, layout=torch.sparse_coo)
            >>> x.to_sparse(layout=torch.sparse_bsr, blocksize=(1, 2))
            tensor(crow_indices=tensor([0, 1, 1, 2]),
                   col_indices=tensor([0, 0]),
                   values=tensor([[[1, 0]],
                                  [[2, 3]]]), size=(3, 2), nnz=2, layout=torch.sparse_bsr)
            >>> x.to_sparse(layout=torch.sparse_bsr, blocksize=(2, 1))
            RuntimeError: Tensor size(-2) 3 needs to be divisible by blocksize[0] 2
            >>> x.to_sparse(layout=torch.sparse_csr, blocksize=(3, 1))
            RuntimeError: to_sparse for Strided to SparseCsr conversion does not use specified blocksize

            >>> x = torch.tensor([[[1], [0]], [[0], [0]], [[2], [3]]])
            >>> x.to_sparse(layout=torch.sparse_csr, dense_dim=1)
            tensor(crow_indices=tensor([0, 1, 1, 3]),
                   col_indices=tensor([0, 0, 1]),
                   values=tensor([[1],
                                  [2],
                                  [3]]), size=(3, 2, 1), nnz=3, layout=torch.sparse_csr)

        """
    def to_sparse_bsc(self, blocksize, dense_dim) -> Tensor:
        """
        to_sparse_bsc(blocksize, dense_dim) -> Tensor

        Convert a tensor to a block sparse column (BSC) storage format of
        given blocksize.  If the :attr:`self` is strided, then the number of
        dense dimensions could be specified, and a hybrid BSC tensor will be
        created, with `dense_dim` dense dimensions and `self.dim() - 2 -
        dense_dim` batch dimension.

        Args:

            blocksize (list, tuple, :class:`torch.Size`, optional): Block size
              of the resulting BSC tensor. A block size must be a tuple of
              length two such that its items evenly divide the two sparse
              dimensions.

            dense_dim (int, optional): Number of dense dimensions of the
              resulting BSC tensor.  This argument should be used only if
              :attr:`self` is a strided tensor, and must be a value between 0
              and dimension of :attr:`self` tensor minus two.

        Example::

            >>> dense = torch.randn(10, 10)
            >>> sparse = dense.to_sparse_csr()
            >>> sparse_bsc = sparse.to_sparse_bsc((5, 5))
            >>> sparse_bsc.row_indices()
            tensor([0, 1, 0, 1])

            >>> dense = torch.zeros(4, 3, 1)
            >>> dense[0:2, 0] = dense[0:2, 2] = dense[2:4, 1] = 1
            >>> dense.to_sparse_bsc((2, 1), 1)
            tensor(ccol_indices=tensor([0, 1, 2, 3]),
                   row_indices=tensor([0, 1, 0]),
                   values=tensor([[[[1.]],

                                   [[1.]]],


                                  [[[1.]],

                                   [[1.]]],


                                  [[[1.]],

                                   [[1.]]]]), size=(4, 3, 1), nnz=3,
                   layout=torch.sparse_bsc)

        """
    def to_sparse_bsr(self, blocksize, dense_dim) -> Tensor:
        """
        to_sparse_bsr(blocksize, dense_dim) -> Tensor

        Convert a tensor to a block sparse row (BSR) storage format of given
        blocksize.  If the :attr:`self` is strided, then the number of dense
        dimensions could be specified, and a hybrid BSR tensor will be
        created, with `dense_dim` dense dimensions and `self.dim() - 2 -
        dense_dim` batch dimension.

        Args:

            blocksize (list, tuple, :class:`torch.Size`, optional): Block size
              of the resulting BSR tensor. A block size must be a tuple of
              length two such that its items evenly divide the two sparse
              dimensions.

            dense_dim (int, optional): Number of dense dimensions of the
              resulting BSR tensor.  This argument should be used only if
              :attr:`self` is a strided tensor, and must be a value between 0
              and dimension of :attr:`self` tensor minus two.

        Example::

            >>> dense = torch.randn(10, 10)
            >>> sparse = dense.to_sparse_csr()
            >>> sparse_bsr = sparse.to_sparse_bsr((5, 5))
            >>> sparse_bsr.col_indices()
            tensor([0, 1, 0, 1])

            >>> dense = torch.zeros(4, 3, 1)
            >>> dense[0:2, 0] = dense[0:2, 2] = dense[2:4, 1] = 1
            >>> dense.to_sparse_bsr((2, 1), 1)
            tensor(crow_indices=tensor([0, 2, 3]),
                   col_indices=tensor([0, 2, 1]),
                   values=tensor([[[[1.]],

                                   [[1.]]],


                                  [[[1.]],

                                   [[1.]]],


                                  [[[1.]],

                                   [[1.]]]]), size=(4, 3, 1), nnz=3,
                   layout=torch.sparse_bsr)

        """
    @overload
    def to_sparse_csc(self) -> Tensor:
        """
        to_sparse_csc() -> Tensor

        Convert a tensor to compressed column storage (CSC) format.  Except
        for strided tensors, only works with 2D tensors.  If the :attr:`self`
        is strided, then the number of dense dimensions could be specified,
        and a hybrid CSC tensor will be created, with `dense_dim` dense
        dimensions and `self.dim() - 2 - dense_dim` batch dimension.

        Args:

            dense_dim (int, optional): Number of dense dimensions of the
              resulting CSC tensor.  This argument should be used only if
              :attr:`self` is a strided tensor, and must be a value between 0
              and dimension of :attr:`self` tensor minus two.

        Example::

            >>> dense = torch.randn(5, 5)
            >>> sparse = dense.to_sparse_csc()
            >>> sparse._nnz()
            25

            >>> dense = torch.zeros(3, 3, 1, 1)
            >>> dense[0, 0] = dense[1, 2] = dense[2, 1] = 1
            >>> dense.to_sparse_csc(dense_dim=2)
            tensor(ccol_indices=tensor([0, 1, 2, 3]),
                   row_indices=tensor([0, 2, 1]),
                   values=tensor([[[1.]],

                                  [[1.]],

                                  [[1.]]]), size=(3, 3, 1, 1), nnz=3,
                   layout=torch.sparse_csc)

        """
    @overload
    def to_sparse_csc(self) -> Any:
        """
        to_sparse_csc() -> Tensor

        Convert a tensor to compressed column storage (CSC) format.  Except
        for strided tensors, only works with 2D tensors.  If the :attr:`self`
        is strided, then the number of dense dimensions could be specified,
        and a hybrid CSC tensor will be created, with `dense_dim` dense
        dimensions and `self.dim() - 2 - dense_dim` batch dimension.

        Args:

            dense_dim (int, optional): Number of dense dimensions of the
              resulting CSC tensor.  This argument should be used only if
              :attr:`self` is a strided tensor, and must be a value between 0
              and dimension of :attr:`self` tensor minus two.

        Example::

            >>> dense = torch.randn(5, 5)
            >>> sparse = dense.to_sparse_csc()
            >>> sparse._nnz()
            25

            >>> dense = torch.zeros(3, 3, 1, 1)
            >>> dense[0, 0] = dense[1, 2] = dense[2, 1] = 1
            >>> dense.to_sparse_csc(dense_dim=2)
            tensor(ccol_indices=tensor([0, 1, 2, 3]),
                   row_indices=tensor([0, 2, 1]),
                   values=tensor([[[1.]],

                                  [[1.]],

                                  [[1.]]]), size=(3, 3, 1, 1), nnz=3,
                   layout=torch.sparse_csc)

        """
    @overload
    def to_sparse_csc(self, dense_dim=...) -> Any:
        """
        to_sparse_csc() -> Tensor

        Convert a tensor to compressed column storage (CSC) format.  Except
        for strided tensors, only works with 2D tensors.  If the :attr:`self`
        is strided, then the number of dense dimensions could be specified,
        and a hybrid CSC tensor will be created, with `dense_dim` dense
        dimensions and `self.dim() - 2 - dense_dim` batch dimension.

        Args:

            dense_dim (int, optional): Number of dense dimensions of the
              resulting CSC tensor.  This argument should be used only if
              :attr:`self` is a strided tensor, and must be a value between 0
              and dimension of :attr:`self` tensor minus two.

        Example::

            >>> dense = torch.randn(5, 5)
            >>> sparse = dense.to_sparse_csc()
            >>> sparse._nnz()
            25

            >>> dense = torch.zeros(3, 3, 1, 1)
            >>> dense[0, 0] = dense[1, 2] = dense[2, 1] = 1
            >>> dense.to_sparse_csc(dense_dim=2)
            tensor(ccol_indices=tensor([0, 1, 2, 3]),
                   row_indices=tensor([0, 2, 1]),
                   values=tensor([[[1.]],

                                  [[1.]],

                                  [[1.]]]), size=(3, 3, 1, 1), nnz=3,
                   layout=torch.sparse_csc)

        """
    @overload
    def to_sparse_csr(self, dense_dim=...) -> Tensor:
        """
        to_sparse_csr(dense_dim=None) -> Tensor

        Convert a tensor to compressed row storage format (CSR).  Except for
        strided tensors, only works with 2D tensors.  If the :attr:`self` is
        strided, then the number of dense dimensions could be specified, and a
        hybrid CSR tensor will be created, with `dense_dim` dense dimensions
        and `self.dim() - 2 - dense_dim` batch dimension.

        Args:

            dense_dim (int, optional): Number of dense dimensions of the
              resulting CSR tensor.  This argument should be used only if
              :attr:`self` is a strided tensor, and must be a value between 0
              and dimension of :attr:`self` tensor minus two.

        Example::

            >>> dense = torch.randn(5, 5)
            >>> sparse = dense.to_sparse_csr()
            >>> sparse._nnz()
            25

            >>> dense = torch.zeros(3, 3, 1, 1)
            >>> dense[0, 0] = dense[1, 2] = dense[2, 1] = 1
            >>> dense.to_sparse_csr(dense_dim=2)
            tensor(crow_indices=tensor([0, 1, 2, 3]),
                   col_indices=tensor([0, 2, 1]),
                   values=tensor([[[1.]],

                                  [[1.]],

                                  [[1.]]]), size=(3, 3, 1, 1), nnz=3,
                   layout=torch.sparse_csr)

        """
    @overload
    def to_sparse_csr(self) -> Any:
        """
        to_sparse_csr(dense_dim=None) -> Tensor

        Convert a tensor to compressed row storage format (CSR).  Except for
        strided tensors, only works with 2D tensors.  If the :attr:`self` is
        strided, then the number of dense dimensions could be specified, and a
        hybrid CSR tensor will be created, with `dense_dim` dense dimensions
        and `self.dim() - 2 - dense_dim` batch dimension.

        Args:

            dense_dim (int, optional): Number of dense dimensions of the
              resulting CSR tensor.  This argument should be used only if
              :attr:`self` is a strided tensor, and must be a value between 0
              and dimension of :attr:`self` tensor minus two.

        Example::

            >>> dense = torch.randn(5, 5)
            >>> sparse = dense.to_sparse_csr()
            >>> sparse._nnz()
            25

            >>> dense = torch.zeros(3, 3, 1, 1)
            >>> dense[0, 0] = dense[1, 2] = dense[2, 1] = 1
            >>> dense.to_sparse_csr(dense_dim=2)
            tensor(crow_indices=tensor([0, 1, 2, 3]),
                   col_indices=tensor([0, 2, 1]),
                   values=tensor([[[1.]],

                                  [[1.]],

                                  [[1.]]]), size=(3, 3, 1, 1), nnz=3,
                   layout=torch.sparse_csr)

        """
    @overload
    def to_sparse_csr(self, dense_dim=...) -> Any:
        """
        to_sparse_csr(dense_dim=None) -> Tensor

        Convert a tensor to compressed row storage format (CSR).  Except for
        strided tensors, only works with 2D tensors.  If the :attr:`self` is
        strided, then the number of dense dimensions could be specified, and a
        hybrid CSR tensor will be created, with `dense_dim` dense dimensions
        and `self.dim() - 2 - dense_dim` batch dimension.

        Args:

            dense_dim (int, optional): Number of dense dimensions of the
              resulting CSR tensor.  This argument should be used only if
              :attr:`self` is a strided tensor, and must be a value between 0
              and dimension of :attr:`self` tensor minus two.

        Example::

            >>> dense = torch.randn(5, 5)
            >>> sparse = dense.to_sparse_csr()
            >>> sparse._nnz()
            25

            >>> dense = torch.zeros(3, 3, 1, 1)
            >>> dense[0, 0] = dense[1, 2] = dense[2, 1] = 1
            >>> dense.to_sparse_csr(dense_dim=2)
            tensor(crow_indices=tensor([0, 1, 2, 3]),
                   col_indices=tensor([0, 2, 1]),
                   values=tensor([[[1.]],

                                  [[1.]],

                                  [[1.]]]), size=(3, 3, 1, 1), nnz=3,
                   layout=torch.sparse_csr)

        """
    @overload
    def tolist(self) -> listornumber:
        """
        tolist() -> list or number

        Returns the tensor as a (nested) list. For scalars, a standard
        Python number is returned, just like with :meth:`~Tensor.item`.
        Tensors are automatically moved to the CPU first if necessary.

        This operation is not differentiable.

        Examples::

            >>> a = torch.randn(2, 2)
            >>> a.tolist()
            [[0.012766935862600803, 0.5415473580360413],
             [-0.08909505605697632, 0.7729271650314331]]
            >>> a[0,0].tolist()
            0.012766935862600803
        """
    @overload
    def tolist(self) -> Any:
        """
        tolist() -> list or number

        Returns the tensor as a (nested) list. For scalars, a standard
        Python number is returned, just like with :meth:`~Tensor.item`.
        Tensors are automatically moved to the CPU first if necessary.

        This operation is not differentiable.

        Examples::

            >>> a = torch.randn(2, 2)
            >>> a.tolist()
            [[0.012766935862600803, 0.5415473580360413],
             [-0.08909505605697632, 0.7729271650314331]]
            >>> a[0,0].tolist()
            0.012766935862600803
        """
    @overload
    def tolist(self) -> Any:
        """
        tolist() -> list or number

        Returns the tensor as a (nested) list. For scalars, a standard
        Python number is returned, just like with :meth:`~Tensor.item`.
        Tensors are automatically moved to the CPU first if necessary.

        This operation is not differentiable.

        Examples::

            >>> a = torch.randn(2, 2)
            >>> a.tolist()
            [[0.012766935862600803, 0.5415473580360413],
             [-0.08909505605697632, 0.7729271650314331]]
            >>> a[0,0].tolist()
            0.012766935862600803
        """
    def topk(self, *args, **kwargs):
        """
        topk(k, dim=None, largest=True, sorted=True) -> (Tensor, LongTensor)

        See :func:`torch.topk`
        """
    def trace(self) -> Tensor:
        """
        trace() -> Tensor

        See :func:`torch.trace`
        """
    def transpose(self, dim0, dim1) -> Tensor:
        """
        transpose(dim0, dim1) -> Tensor

        See :func:`torch.transpose`
        """
    def transpose_(self, dim0, dim1) -> Tensor:
        """
        transpose_(dim0, dim1) -> Tensor

        In-place version of :meth:`~Tensor.transpose`
        """
    def triangular_solve(self, *args, **kwargs):
        """
        triangular_solve(A, upper=True, transpose=False, unitriangular=False) -> (Tensor, Tensor)

        See :func:`torch.triangular_solve`
        """
    def tril(self, diagonal=...) -> Tensor:
        """
        tril(diagonal=0) -> Tensor

        See :func:`torch.tril`
        """
    def tril_(self, diagonal=...) -> Tensor:
        """
        tril_(diagonal=0) -> Tensor

        In-place version of :meth:`~Tensor.tril`
        """
    def triu(self, diagonal=...) -> Tensor:
        """
        triu(diagonal=0) -> Tensor

        See :func:`torch.triu`
        """
    def triu_(self, diagonal=...) -> Tensor:
        """
        triu_(diagonal=0) -> Tensor

        In-place version of :meth:`~Tensor.triu`
        """
    def true_divide(self, value) -> Tensor:
        """
        true_divide(value) -> Tensor

        See :func:`torch.true_divide`
        """
    def true_divide_(self, value) -> Tensor:
        """
        true_divide_(value) -> Tensor

        In-place version of :meth:`~Tensor.true_divide_`
        """
    def trunc(self) -> Tensor:
        """
        trunc() -> Tensor

        See :func:`torch.trunc`
        """
    def trunc_(self) -> Tensor:
        """
        trunc_() -> Tensor

        In-place version of :meth:`~Tensor.trunc`
        """
    def type(self, dtype=..., non_blocking=..., **kwargs) -> strorTensor:
        """
        type(dtype=None, non_blocking=False, **kwargs) -> str or Tensor
        Returns the type if `dtype` is not provided, else casts this object to
        the specified type.

        If this is already of the correct type, no copy is performed and the
        original object is returned.

        Args:
            dtype (dtype or string): The desired type
            non_blocking (bool): If ``True``, and the source is in pinned memory
                and destination is on the GPU or vice versa, the copy is performed
                asynchronously with respect to the host. Otherwise, the argument
                has no effect.
            **kwargs: For compatibility, may contain the key ``async`` in place of
                the ``non_blocking`` argument. The ``async`` arg is deprecated.
        """
    def type_as(self, tensor) -> Tensor:
        """
        type_as(tensor) -> Tensor

        Returns this tensor cast to the type of the given tensor.

        This is a no-op if the tensor is already of the correct type. This is
        equivalent to ``self.type(tensor.type())``

        Args:
            tensor (Tensor): the tensor which has the desired type
        """
    def unbind(self, dim=...) -> seq:
        """
        unbind(dim=0) -> seq

        See :func:`torch.unbind`
        """
    def unflatten(self, *args, **kwargs): ...
    def unfold(self, dimension, size, step) -> Tensor:
        """
        unfold(dimension, size, step) -> Tensor

        Returns a view of the original tensor which contains all slices of size :attr:`size` from
        :attr:`self` tensor in the dimension :attr:`dimension`.

        Step between two slices is given by :attr:`step`.

        If `sizedim` is the size of dimension :attr:`dimension` for :attr:`self`, the size of
        dimension :attr:`dimension` in the returned tensor will be
        `(sizedim - size) / step + 1`.

        An additional dimension of size :attr:`size` is appended in the returned tensor.

        Args:
            dimension (int): dimension in which unfolding happens
            size (int): the size of each slice that is unfolded
            step (int): the step between each slice

        Example::

            >>> x = torch.arange(1., 8)
            >>> x
            tensor([ 1.,  2.,  3.,  4.,  5.,  6.,  7.])
            >>> x.unfold(0, 2, 1)
            tensor([[ 1.,  2.],
                    [ 2.,  3.],
                    [ 3.,  4.],
                    [ 4.,  5.],
                    [ 5.,  6.],
                    [ 6.,  7.]])
            >>> x.unfold(0, 2, 2)
            tensor([[ 1.,  2.],
                    [ 3.,  4.],
                    [ 5.,  6.]])
        """
    def uniform_(self, _from=..., to=..., generator=...) -> Tensor:
        """
        uniform_(from=0, to=1, *, generator=None) -> Tensor

        Fills :attr:`self` tensor with numbers sampled from the continuous uniform
        distribution:

        .. math::
            f(x) = \\dfrac{1}{\\text{to} - \\text{from}}
        """
    def unsafe_chunk(self, chunks, dim=...) -> ListofTensors:
        """
        unsafe_chunk(chunks, dim=0) -> List of Tensors

        See :func:`torch.unsafe_chunk`
        """
    def unsafe_split(self, split_size, dim=...) -> ListofTensors:
        """
        unsafe_split(split_size, dim=0) -> List of Tensors

        See :func:`torch.unsafe_split`
        """
    def unsafe_split_with_sizes(self, *args, **kwargs): ...
    def unsqueeze(self, dim) -> Tensor:
        """
        unsqueeze(dim) -> Tensor

        See :func:`torch.unsqueeze`
        """
    def unsqueeze_(self, dim) -> Tensor:
        """
        unsqueeze_(dim) -> Tensor

        In-place version of :meth:`~Tensor.unsqueeze`
        """
    def untyped_storage(self) -> torch.UntypedStorage:
        """
        untyped_storage() -> torch.UntypedStorage

        Returns the underlying :class:`UntypedStorage`.
        """
    def values(self) -> Tensor:
        """
        values() -> Tensor

        Return the values tensor of a :ref:`sparse COO tensor <sparse-coo-docs>`.

        .. warning::
          Throws an error if :attr:`self` is not a sparse COO tensor.

        See also :meth:`Tensor.indices`.

        .. note::
          This method can only be called on a coalesced sparse tensor. See
          :meth:`Tensor.coalesce` for details.
        """
    def var(self, dim=..., correction=..., keepdim=...) -> Tensor:
        """
        var(dim=None, *, correction=1, keepdim=False) -> Tensor

        See :func:`torch.var`
        """
    def vdot(self, other) -> Tensor:
        """
        vdot(other) -> Tensor

        See :func:`torch.vdot`
        """
    def view(self, *shape) -> Tensor:
        """
        view(*shape) -> Tensor

        Returns a new tensor with the same data as the :attr:`self` tensor but of a
        different :attr:`shape`.

        The returned tensor shares the same data and must have the same number
        of elements, but may have a different size. For a tensor to be viewed, the new
        view size must be compatible with its original size and stride, i.e., each new
        view dimension must either be a subspace of an original dimension, or only span
        across original dimensions :math:`d, d+1, \\dots, d+k` that satisfy the following
        contiguity-like condition that :math:`\\forall i = d, \\dots, d+k-1`,

        .. math::

          \\text{stride}[i] = \\text{stride}[i+1] \\times \\text{size}[i+1]

        Otherwise, it will not be possible to view :attr:`self` tensor as :attr:`shape`
        without copying it (e.g., via :meth:`contiguous`). When it is unclear whether a
        :meth:`view` can be performed, it is advisable to use :meth:`reshape`, which
        returns a view if the shapes are compatible, and copies (equivalent to calling
        :meth:`contiguous`) otherwise.

        Args:
            shape (torch.Size or int...): the desired size

        Example::

            >>> x = torch.randn(4, 4)
            >>> x.size()
            torch.Size([4, 4])
            >>> y = x.view(16)
            >>> y.size()
            torch.Size([16])
            >>> z = x.view(-1, 8)  # the size -1 is inferred from other dimensions
            >>> z.size()
            torch.Size([2, 8])

            >>> a = torch.randn(1, 2, 3, 4)
            >>> a.size()
            torch.Size([1, 2, 3, 4])
            >>> b = a.transpose(1, 2)  # Swaps 2nd and 3rd dimension
            >>> b.size()
            torch.Size([1, 3, 2, 4])
            >>> c = a.view(1, 3, 2, 4)  # Does not change tensor layout in memory
            >>> c.size()
            torch.Size([1, 3, 2, 4])
            >>> torch.equal(b, c)
            False


        .. method:: view(dtype) -> Tensor
           :noindex:

        Returns a new tensor with the same data as the :attr:`self` tensor but of a
        different :attr:`dtype`.

        If the element size of :attr:`dtype` is different than that of ``self.dtype``,
        then the size of the last dimension of the output will be scaled
        proportionally.  For instance, if :attr:`dtype` element size is twice that of
        ``self.dtype``, then each pair of elements in the last dimension of
        :attr:`self` will be combined, and the size of the last dimension of the output
        will be half that of :attr:`self`. If :attr:`dtype` element size is half that
        of ``self.dtype``, then each element in the last dimension of :attr:`self` will
        be split in two, and the size of the last dimension of the output will be
        double that of :attr:`self`. For this to be possible, the following conditions
        must be true:

            * ``self.dim()`` must be greater than 0.
            * ``self.stride(-1)`` must be 1.

        Additionally, if the element size of :attr:`dtype` is greater than that of
        ``self.dtype``, the following conditions must be true as well:

            * ``self.size(-1)`` must be divisible by the ratio between the element
              sizes of the dtypes.
            * ``self.storage_offset()`` must be divisible by the ratio between the
              element sizes of the dtypes.
            * The strides of all dimensions, except the last dimension, must be
              divisible by the ratio between the element sizes of the dtypes.

        If any of the above conditions are not met, an error is thrown.

        .. warning::

            This overload is not supported by TorchScript, and using it in a Torchscript
            program will cause undefined behavior.


        Args:
            dtype (:class:`torch.dtype`): the desired dtype

        Example::

            >>> x = torch.randn(4, 4)
            >>> x
            tensor([[ 0.9482, -0.0310,  1.4999, -0.5316],
                    [-0.1520,  0.7472,  0.5617, -0.8649],
                    [-2.4724, -0.0334, -0.2976, -0.8499],
                    [-0.2109,  1.9913, -0.9607, -0.6123]])
            >>> x.dtype
            torch.float32

            >>> y = x.view(torch.int32)
            >>> y
            tensor([[ 1064483442, -1124191867,  1069546515, -1089989247],
                    [-1105482831,  1061112040,  1057999968, -1084397505],
                    [-1071760287, -1123489973, -1097310419, -1084649136],
                    [-1101533110,  1073668768, -1082790149, -1088634448]],
                dtype=torch.int32)
            >>> y[0, 0] = 1000000000
            >>> x
            tensor([[ 0.0047, -0.0310,  1.4999, -0.5316],
                    [-0.1520,  0.7472,  0.5617, -0.8649],
                    [-2.4724, -0.0334, -0.2976, -0.8499],
                    [-0.2109,  1.9913, -0.9607, -0.6123]])

            >>> x.view(torch.cfloat)
            tensor([[ 0.0047-0.0310j,  1.4999-0.5316j],
                    [-0.1520+0.7472j,  0.5617-0.8649j],
                    [-2.4724-0.0334j, -0.2976-0.8499j],
                    [-0.2109+1.9913j, -0.9607-0.6123j]])
            >>> x.view(torch.cfloat).size()
            torch.Size([4, 2])

            >>> x.view(torch.uint8)
            tensor([[  0, 202, 154,  59, 182, 243, 253, 188, 185, 252, 191,  63, 240,  22,
                       8, 191],
                    [227, 165,  27, 190, 128,  72,  63,  63, 146, 203,  15,  63,  22, 106,
                      93, 191],
                    [205,  59,  30, 192, 112, 206,   8, 189,   7,  95, 152, 190,  12, 147,
                      89, 191],
                    [ 43, 246,  87, 190, 235, 226, 254,  63, 111, 240, 117, 191, 177, 191,
                      28, 191]], dtype=torch.uint8)
            >>> x.view(torch.uint8).size()
            torch.Size([4, 16])
        """
    @overload
    def view_as(self, other) -> Tensor:
        """
        view_as(other) -> Tensor

        View this tensor as the same size as :attr:`other`.
        ``self.view_as(other)`` is equivalent to ``self.view(other.size())``.

        Please see :meth:`~Tensor.view` for more information about ``view``.

        Args:
            other (:class:`torch.Tensor`): The result tensor has the same size
                as :attr:`other`.
        """
    @overload
    def view_as(self, other) -> Any:
        """
        view_as(other) -> Tensor

        View this tensor as the same size as :attr:`other`.
        ``self.view_as(other)`` is equivalent to ``self.view(other.size())``.

        Please see :meth:`~Tensor.view` for more information about ``view``.

        Args:
            other (:class:`torch.Tensor`): The result tensor has the same size
                as :attr:`other`.
        """
    def vsplit(self, split_size_or_sections) -> ListofTensors:
        """
        vsplit(split_size_or_sections) -> List of Tensors

        See :func:`torch.vsplit`
        """
    def where(self, condition, y) -> Tensor:
        """
        where(condition, y) -> Tensor

        ``self.where(condition, y)`` is equivalent to ``torch.where(condition, self, y)``.
        See :func:`torch.where`
        """
    def xlogy(self, other) -> Tensor:
        """
        xlogy(other) -> Tensor

        See :func:`torch.xlogy`
        """
    def xlogy_(self, other) -> Tensor:
        """
        xlogy_(other) -> Tensor

        In-place version of :meth:`~Tensor.xlogy`
        """
    def xpu(self, device=..., non_blocking=..., memory_format=...) -> Tensor:
        """
        xpu(device=None, non_blocking=False, memory_format=torch.preserve_format) -> Tensor

        Returns a copy of this object in XPU memory.

        If this object is already in XPU memory and on the correct device,
        then no copy is performed and the original object is returned.

        Args:
            device (:class:`torch.device`): The destination XPU device.
                Defaults to the current XPU device.
            non_blocking (bool): If ``True`` and the source is in pinned memory,
                the copy will be asynchronous with respect to the host.
                Otherwise, the argument has no effect. Default: ``False``.
            memory_format (:class:`torch.memory_format`, optional): the desired memory format of
                returned Tensor. Default: ``torch.preserve_format``.
        """
    def zero_(self) -> Tensor:
        """
        zero_() -> Tensor

        Fills :attr:`self` tensor with zeros.
        """
    def __add__(self, other): ...
    def __and__(self, other): ...
    def __bool__(self) -> bool: ...
    def __complex__(self) -> complex: ...
    def __delitem__(self, other) -> None:
        """Delete self[key]."""
    def __div__(self, *args, **kwargs): ...
    def __eq__(self, other: object) -> bool: ...
    def __float__(self) -> float: ...
    def __floordiv__(self, other): ...
    def __ge__(self, other: object) -> bool: ...
    def __getitem__(self, index):
        """Return self[key]."""
    def __gt__(self, other: object) -> bool: ...
    def __iadd__(self, other): ...
    def __iand__(self, other): ...
    def __idiv__(self, *args, **kwargs): ...
    def __ifloordiv__(self, other): ...
    def __ilshift__(self, other): ...
    def __imod__(self, other): ...
    def __imul__(self, other): ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __invert__(self): ...
    def __ior__(self, other): ...
    def __irshift__(self, other): ...
    def __isub__(self, other): ...
    def __ixor__(self, other): ...
    def __le__(self, other: object) -> bool: ...
    def __len__(self) -> int:
        """Return len(self)."""
    def __long__(self, *args, **kwargs): ...
    def __lshift__(self, other): ...
    def __lt__(self, other: object) -> bool: ...
    def __matmul__(self, *args, **kwargs): ...
    def __mod__(self, other): ...
    def __mul__(self, other): ...
    def __ne__(self, other: object) -> bool: ...
    def __nonzero__(self, *args, **kwargs): ...
    def __or__(self, other): ...
    def __radd__(self, other): ...
    def __rand__(self, other): ...
    def __rmul__(self, other): ...
    def __ror__(self, other): ...
    def __rshift__(self, other): ...
    def __rxor__(self, other): ...
    def __setitem__(self, index, object) -> None:
        """Set self[key] to value."""
    def __sub__(self, other): ...
    def __truediv__(self, other): ...
    def __xor__(self, other): ...

class _AliasInfo:
    def __init__(self, arg0: bool, arg1: set[str], arg2: set[str]) -> None:
        """__init__(self: torch._C._AliasInfo, arg0: bool, arg1: set[str], arg2: set[str]) -> None"""
    def _pybind11_conduit_v1_(self, *args, **kwargs): ...
    @property
    def after_set(self) -> set[str]:
        """(arg0: torch._C._AliasInfo) -> set[str]"""
    @property
    def before_set(self) -> set[str]:
        """(arg0: torch._C._AliasInfo) -> set[str]"""
    @property
    def is_write(self) -> bool:
        """(arg0: torch._C._AliasInfo) -> bool"""

class _AutoDispatchBelowADInplaceOrView:
    def __init__(self) -> None:
        """__init__(self: torch._C._AutoDispatchBelowADInplaceOrView) -> None"""
    def _pybind11_conduit_v1_(self, *args, **kwargs): ...
    def __enter__(self) -> None:
        """__enter__(self: torch._C._AutoDispatchBelowADInplaceOrView) -> None"""
    def __exit__(self, arg0: object, arg1: object, arg2: object) -> None:
        """__exit__(self: torch._C._AutoDispatchBelowADInplaceOrView, arg0: object, arg1: object, arg2: object) -> None"""

class _AutoDispatchBelowAutograd:
    def __init__(self) -> None:
        """__init__(self: torch._C._AutoDispatchBelowAutograd) -> None"""
    def _pybind11_conduit_v1_(self, *args, **kwargs): ...
    def __enter__(self) -> None:
        """__enter__(self: torch._C._AutoDispatchBelowAutograd) -> None"""
    def __exit__(self, arg0: object, arg1: object, arg2: object) -> None:
        """__exit__(self: torch._C._AutoDispatchBelowAutograd, arg0: object, arg1: object, arg2: object) -> None"""

class _Await:
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def _pybind11_conduit_v1_(self, *args, **kwargs): ...
    def args(self) -> tuple:
        """args(self: torch._C._Await) -> tuple"""
    def fn(self) -> Callable:
        """fn(self: torch._C._Await) -> Callable"""
    def is_nowait(self) -> bool:
        """is_nowait(self: torch._C._Await) -> bool"""
    def type(self, *args, **kwargs):
        """type(self: torch._C._Await) -> c10::Type"""
    def wait(self) -> object:
        """wait(self: torch._C._Await) -> object"""
    def __getattr__(self, arg0: str) -> object:
        """__getattr__(self: torch._C._Await, arg0: str) -> object"""

class _BatchNormBackend:
    """Members:

      Native

      Cudnn

      Miopen"""
    __members__: ClassVar[dict] = ...  # read-only
    Cudnn: ClassVar[_BatchNormBackend] = ...
    Miopen: ClassVar[_BatchNormBackend] = ...
    Native: ClassVar[_BatchNormBackend] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None:
        """__init__(self: torch._C._BatchNormBackend, value: int) -> None"""
    def _pybind11_conduit_v1_(self, *args, **kwargs): ...
    def __eq__(self, other: object) -> bool:
        """__eq__(self: object, other: object) -> bool"""
    def __hash__(self) -> int:
        """__hash__(self: object) -> int"""
    def __index__(self) -> int:
        """__index__(self: torch._C._BatchNormBackend) -> int"""
    def __int__(self) -> int:
        """__int__(self: torch._C._BatchNormBackend) -> int"""
    def __ne__(self, other: object) -> bool:
        """__ne__(self: object, other: object) -> bool"""
    @property
    def name(self) -> str:
        """name(self: object) -> str

        name(self: object) -> str
        """
    @property
    def value(self) -> int:
        """(arg0: torch._C._BatchNormBackend) -> int"""

class _BlasBackend:
    """Members:

      Default

      Cublas

      Cublaslt

      Ck"""
    __members__: ClassVar[dict] = ...  # read-only
    Ck: ClassVar[_BlasBackend] = ...
    Cublas: ClassVar[_BlasBackend] = ...
    Cublaslt: ClassVar[_BlasBackend] = ...
    Default: ClassVar[_BlasBackend] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None:
        """__init__(self: torch._C._BlasBackend, value: int) -> None"""
    def _pybind11_conduit_v1_(self, *args, **kwargs): ...
    def __eq__(self, other: object) -> bool:
        """__eq__(self: object, other: object) -> bool"""
    def __hash__(self) -> int:
        """__hash__(self: object) -> int"""
    def __index__(self) -> int:
        """__index__(self: torch._C._BlasBackend) -> int"""
    def __int__(self) -> int:
        """__int__(self: torch._C._BlasBackend) -> int"""
    def __ne__(self, other: object) -> bool:
        """__ne__(self: object, other: object) -> bool"""
    @property
    def name(self) -> str:
        """name(self: object) -> str

        name(self: object) -> str
        """
    @property
    def value(self) -> int:
        """(arg0: torch._C._BlasBackend) -> int"""

class _ConvBackend:
    """Members:

      CudaDepthwise2d

      CudaDepthwise3d

      Cudnn

      CudnnTranspose

      Empty

      Miopen

      MiopenDepthwise

      MiopenTranspose

      Mkldnn

      MkldnnEmpty

      NnpackSpatial

      Overrideable

      Slow2d

      Slow3d

      SlowDilated2d

      SlowDilated3d

      SlowTranspose2d

      SlowTranspose3d

      Winograd3x3Depthwise

      Xnnpack2d

      Mps

      MpsTranspose,"""
    __members__: ClassVar[dict] = ...  # read-only
    CudaDepthwise2d: ClassVar[_ConvBackend] = ...
    CudaDepthwise3d: ClassVar[_ConvBackend] = ...
    Cudnn: ClassVar[_ConvBackend] = ...
    CudnnTranspose: ClassVar[_ConvBackend] = ...
    Empty: ClassVar[_ConvBackend] = ...
    Miopen: ClassVar[_ConvBackend] = ...
    MiopenDepthwise: ClassVar[_ConvBackend] = ...
    MiopenTranspose: ClassVar[_ConvBackend] = ...
    Mkldnn: ClassVar[_ConvBackend] = ...
    MkldnnEmpty: ClassVar[_ConvBackend] = ...
    Mps: ClassVar[_ConvBackend] = ...
    MpsTranspose,: ClassVar[_ConvBackend] = ...
    NnpackSpatial: ClassVar[_ConvBackend] = ...
    Overrideable: ClassVar[_ConvBackend] = ...
    Slow2d: ClassVar[_ConvBackend] = ...
    Slow3d: ClassVar[_ConvBackend] = ...
    SlowDilated2d: ClassVar[_ConvBackend] = ...
    SlowDilated3d: ClassVar[_ConvBackend] = ...
    SlowTranspose2d: ClassVar[_ConvBackend] = ...
    SlowTranspose3d: ClassVar[_ConvBackend] = ...
    Winograd3x3Depthwise: ClassVar[_ConvBackend] = ...
    Xnnpack2d: ClassVar[_ConvBackend] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None:
        """__init__(self: torch._C._ConvBackend, value: int) -> None"""
    def _pybind11_conduit_v1_(self, *args, **kwargs): ...
    def __eq__(self, other: object) -> bool:
        """__eq__(self: object, other: object) -> bool"""
    def __hash__(self) -> int:
        """__hash__(self: object) -> int"""
    def __index__(self) -> int:
        """__index__(self: torch._C._ConvBackend) -> int"""
    def __int__(self) -> int:
        """__int__(self: torch._C._ConvBackend) -> int"""
    def __ne__(self, other: object) -> bool:
        """__ne__(self: object, other: object) -> bool"""
    @property
    def name(self) -> str:
        """name(self: object) -> str

        name(self: object) -> str
        """
    @property
    def value(self) -> int:
        """(arg0: torch._C._ConvBackend) -> int"""

class _DisableAutocast:
    def __init__(self) -> None:
        """__init__(self: torch._C._DisableAutocast) -> None"""
    def _pybind11_conduit_v1_(self, *args, **kwargs): ...
    def __enter__(self) -> None:
        """__enter__(self: torch._C._DisableAutocast) -> None"""
    def __exit__(self, arg0: object, arg1: object, arg2: object) -> None:
        """__exit__(self: torch._C._DisableAutocast, arg0: object, arg1: object, arg2: object) -> None"""

class _DisableFuncTorch:
    def __init__(self) -> None:
        """__init__(self: torch._C._DisableFuncTorch) -> None"""
    def _pybind11_conduit_v1_(self, *args, **kwargs): ...
    def __enter__(self) -> None:
        """__enter__(self: torch._C._DisableFuncTorch) -> None"""
    def __exit__(self, arg0: object, arg1: object, arg2: object) -> None:
        """__exit__(self: torch._C._DisableFuncTorch, arg0: object, arg1: object, arg2: object) -> None"""

class _DisablePythonDispatcher:
    def __init__(self) -> None:
        """__init__(self: torch._C._DisablePythonDispatcher) -> None"""
    def _pybind11_conduit_v1_(self, *args, **kwargs): ...
    def __enter__(self) -> None:
        """__enter__(self: torch._C._DisablePythonDispatcher) -> None"""
    def __exit__(self, arg0: object, arg1: object, arg2: object) -> None:
        """__exit__(self: torch._C._DisablePythonDispatcher, arg0: object, arg1: object, arg2: object) -> None"""

class _DisableTorchDispatch:
    def __init__(self) -> None:
        """__init__(self: torch._C._DisableTorchDispatch) -> None"""
    def _pybind11_conduit_v1_(self, *args, **kwargs): ...
    def __enter__(self) -> None:
        """__enter__(self: torch._C._DisableTorchDispatch) -> None"""
    def __exit__(self, arg0: object, arg1: object, arg2: object) -> None:
        """__exit__(self: torch._C._DisableTorchDispatch, arg0: object, arg1: object, arg2: object) -> None"""

class _DispatchModule:
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def _pybind11_conduit_v1_(self, *args, **kwargs): ...
    def def_(self, schema: str, alias: str = ...) -> object:
        """def_(self: object, schema: str, alias: str = '') -> object"""
    def def_legacy(self, schema: str) -> object:
        """def_legacy(self: object, schema: str) -> object"""
    def def_name_t_t(self, name: str, dispatch: str = ..., debug: str = ...) -> object:
        """def_name_t_t(self: object, name: str, dispatch: str = '', debug: str = 'default_def_name_t_t') -> object"""
    def def_schema_t_t(self, name: str, dispatch: str = ..., alias: str = ..., debug: str = ...) -> object:
        """def_schema_t_t(self: object, name: str, dispatch: str = '', alias: str = '', debug: str = 'default_def_schema_t_t') -> object"""
    def define(self, schema: str, alias_analysis: str = ..., tags: list[Tag] = ...) -> str:
        """define(self: object, schema: str, alias_analysis: str = '', tags: list[torch._C.Tag] = []) -> str"""
    def fallback(self, dispatch, func: object, with_keyset: bool = ...) -> None:
        """fallback(self: object, dispatch: c10::DispatchKey, func: object, with_keyset: bool = False) -> None"""
    def fallback_fallthrough(self, dispatch: str = ...) -> object:
        """fallback_fallthrough(self: object, dispatch: str = '') -> object"""
    def impl(self, name: str, dispatch, func: object, with_keyset: bool = ...) -> None:
        """impl(self: object, name: str, dispatch: c10::DispatchKey, func: object, with_keyset: bool = False) -> None"""
    def impl_t_t(self, name: str, dispatch: str = ..., debug: str = ...) -> object:
        """impl_t_t(self: object, name: str, dispatch: str = '', debug: str = 'impl_t_t') -> object"""
    def impl_with_aoti_compile(self, ns: str, op_name_with_overload: str, dispatch) -> None:
        """impl_with_aoti_compile(self: object, ns: str, op_name_with_overload: str, dispatch: c10::DispatchKey) -> None"""
    def reset(self) -> None:
        """reset(self: object) -> None"""

class _DispatchOperatorHandle:
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def _pybind11_conduit_v1_(self, *args, **kwargs): ...
    def debug(self) -> str:
        """debug(self: torch._C._DispatchOperatorHandle) -> str"""
    def redispatch_boxed(self, arg0, *args, **kwargs) -> object:
        """redispatch_boxed(self: object, arg0: c10::DispatchKeySet, *args, **kwargs) -> object"""
    def schema(self) -> FunctionSchema:
        """schema(self: torch._C._DispatchOperatorHandle) -> torch._C.FunctionSchema"""

class _EnablePreDispatch:
    def __init__(self) -> None:
        """__init__(self: torch._C._EnablePreDispatch) -> None"""
    def _pybind11_conduit_v1_(self, *args, **kwargs): ...
    def __enter__(self) -> None:
        """__enter__(self: torch._C._EnablePreDispatch) -> None"""
    def __exit__(self, arg0: object, arg1: object, arg2: object) -> None:
        """__exit__(self: torch._C._EnablePreDispatch, arg0: object, arg1: object, arg2: object) -> None"""

class _EnablePythonDispatcher:
    def __init__(self) -> None:
        """__init__(self: torch._C._EnablePythonDispatcher) -> None"""
    def _pybind11_conduit_v1_(self, *args, **kwargs): ...
    def __enter__(self) -> None:
        """__enter__(self: torch._C._EnablePythonDispatcher) -> None"""
    def __exit__(self, arg0: object, arg1: object, arg2: object) -> None:
        """__exit__(self: torch._C._EnablePythonDispatcher, arg0: object, arg1: object, arg2: object) -> None"""

class _EnableTorchFunction:
    def __init__(self) -> None:
        """__init__(self: torch._C._EnableTorchFunction) -> None"""
    def _pybind11_conduit_v1_(self, *args, **kwargs): ...
    def __enter__(self) -> None:
        """__enter__(self: torch._C._EnableTorchFunction) -> None"""
    def __exit__(self, arg0: object, arg1: object, arg2: object) -> None:
        """__exit__(self: torch._C._EnableTorchFunction, arg0: object, arg1: object, arg2: object) -> None"""

class _ExcludeDispatchKeyGuard:
    def __init__(self, arg0: DispatchKeySet) -> None:
        """__init__(self: torch._C._ExcludeDispatchKeyGuard, arg0: torch._C.DispatchKeySet) -> None"""
    def _pybind11_conduit_v1_(self, *args, **kwargs): ...
    def __enter__(self) -> None:
        """__enter__(self: torch._C._ExcludeDispatchKeyGuard) -> None"""
    def __exit__(self, arg0: object, arg1: object, arg2: object) -> None:
        """__exit__(self: torch._C._ExcludeDispatchKeyGuard, arg0: object, arg1: object, arg2: object) -> None"""

class _ForceDispatchKeyGuard:
    def __init__(self, arg0: DispatchKeySet, arg1: DispatchKeySet) -> None:
        """__init__(self: torch._C._ForceDispatchKeyGuard, arg0: torch._C.DispatchKeySet, arg1: torch._C.DispatchKeySet) -> None"""
    def _pybind11_conduit_v1_(self, *args, **kwargs): ...
    def __enter__(self) -> None:
        """__enter__(self: torch._C._ForceDispatchKeyGuard) -> None"""
    def __exit__(self, arg0: object, arg1: object, arg2: object) -> None:
        """__exit__(self: torch._C._ForceDispatchKeyGuard, arg0: object, arg1: object, arg2: object) -> None"""

class _FunctionBase:
    _compiled_autograd_backward_state: Incomplete
    _input_metadata: Incomplete
    _materialize_non_diff_grads: Incomplete
    _raw_saved_tensors: Incomplete
    dirty_tensors: Incomplete
    materialize_grads: Incomplete
    metadata: Incomplete
    needs_input_grad: Incomplete
    next_functions: Incomplete
    non_differentiable: Incomplete
    requires_grad: Incomplete
    saved_for_forward: Incomplete
    saved_tensors: Incomplete
    saved_variables: Incomplete
    to_save: Incomplete
    @classmethod
    def __init__(cls, *args, **kwargs) -> None:
        """Create and return a new object.  See help(type) for accurate signature."""
    def _get_compiled_autograd_symints(self, *args, **kwargs): ...
    def _register_hook_dict(self, *args, **kwargs): ...
    def _sequence_nr(self, *args, **kwargs): ...
    def _set_sequence_nr(self, *args, **kwargs): ...
    @classmethod
    def apply(cls, *args, **kwargs): ...
    def maybe_clear_saved_tensors(self, *args, **kwargs): ...
    def name(self, *args, **kwargs): ...
    def register_hook(self, *args, **kwargs): ...
    def register_prehook(self, *args, **kwargs): ...

class _GeneratorType(torch.Type):
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def _pybind11_conduit_v1_(self, *args, **kwargs): ...
    @staticmethod
    def get() -> _GeneratorType:
        """get() -> torch._C._GeneratorType"""

class _ImperativeEngine:
    @classmethod
    def __init__(cls, *args, **kwargs) -> None:
        """Create and return a new object.  See help(type) for accurate signature."""
    def is_checkpoint_valid(self, *args, **kwargs): ...
    def queue_callback(self, *args, **kwargs): ...
    def run_backward(self, *args, **kwargs): ...

class _IncludeDispatchKeyGuard:
    def __init__(self, arg0: DispatchKey) -> None:
        """__init__(self: torch._C._IncludeDispatchKeyGuard, arg0: torch._C.DispatchKey) -> None"""
    def _pybind11_conduit_v1_(self, *args, **kwargs): ...
    def __enter__(self) -> None:
        """__enter__(self: torch._C._IncludeDispatchKeyGuard) -> None"""
    def __exit__(self, arg0: object, arg1: object, arg2: object) -> None:
        """__exit__(self: torch._C._IncludeDispatchKeyGuard, arg0: object, arg1: object, arg2: object) -> None"""

class _InferenceMode:
    def __init__(self, arg0: bool) -> None:
        """__init__(self: torch._C._InferenceMode, arg0: bool) -> None"""
    def _pybind11_conduit_v1_(self, *args, **kwargs): ...
    def __enter__(self) -> None:
        """__enter__(self: torch._C._InferenceMode) -> None"""
    def __exit__(self, arg0: object, arg1: object, arg2: object) -> None:
        """__exit__(self: torch._C._InferenceMode, arg0: object, arg1: object, arg2: object) -> None"""

class _LegacyVariableBase:
    @classmethod
    def __init__(cls, *args, **kwargs) -> None:
        """Create and return a new object.  See help(type) for accurate signature."""

class _LinAlgError(RuntimeError):
    '''Error raised by torch.linalg function when the cause of error is a numerical inconsistency in the data.
     For example, you can the torch.linalg.inv function will raise torch.linalg.LinAlgError when it finds that a matrix is not invertible.
 
    Example:
     >>> # xdoctest: +REQUIRES(env:TORCH_DOCKTEST_LAPACK)
     >>> matrix = torch.eye(3, 3)
     >>> matrix[-1, -1] = 0
     >>> matrix
         tensor([[1., 0., 0.],
                 [0., 1., 0.],
                 [0., 0., 0.]])
     >>> torch.linalg.inv(matrix)
     Traceback (most recent call last):
     File "<stdin>", line 1, in <module>
     torch._C._LinAlgError: torch.linalg.inv: The diagonal element 3 is zero, the inversion
     could not be completed because the input matrix is singular.'''

class _LinalgBackend:
    """Members:

      Default

      Cusolver

      Magma"""
    __members__: ClassVar[dict] = ...  # read-only
    Cusolver: ClassVar[_LinalgBackend] = ...
    Default: ClassVar[_LinalgBackend] = ...
    Magma: ClassVar[_LinalgBackend] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None:
        """__init__(self: torch._C._LinalgBackend, value: int) -> None"""
    def _pybind11_conduit_v1_(self, *args, **kwargs): ...
    def __eq__(self, other: object) -> bool:
        """__eq__(self: object, other: object) -> bool"""
    def __hash__(self) -> int:
        """__hash__(self: object) -> int"""
    def __index__(self) -> int:
        """__index__(self: torch._C._LinalgBackend) -> int"""
    def __int__(self) -> int:
        """__int__(self: torch._C._LinalgBackend) -> int"""
    def __ne__(self, other: object) -> bool:
        """__ne__(self: object, other: object) -> bool"""
    @property
    def name(self) -> str:
        """name(self: object) -> str

        name(self: object) -> str
        """
    @property
    def value(self) -> int:
        """(arg0: torch._C._LinalgBackend) -> int"""

class _MobileOptimizerType:
    """Members:

      CONV_BN_FUSION

      INSERT_FOLD_PREPACK_OPS

      REMOVE_DROPOUT

      FUSE_ADD_RELU

      HOIST_CONV_PACKED_PARAMS

      VULKAN_AUTOMATIC_GPU_TRANSFER"""
    __members__: ClassVar[dict] = ...  # read-only
    CONV_BN_FUSION: ClassVar[_MobileOptimizerType] = ...
    FUSE_ADD_RELU: ClassVar[_MobileOptimizerType] = ...
    HOIST_CONV_PACKED_PARAMS: ClassVar[_MobileOptimizerType] = ...
    INSERT_FOLD_PREPACK_OPS: ClassVar[_MobileOptimizerType] = ...
    REMOVE_DROPOUT: ClassVar[_MobileOptimizerType] = ...
    VULKAN_AUTOMATIC_GPU_TRANSFER: ClassVar[_MobileOptimizerType] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None:
        """__init__(self: torch._C._MobileOptimizerType, value: int) -> None"""
    def _pybind11_conduit_v1_(self, *args, **kwargs): ...
    def __eq__(self, other: object) -> bool:
        """__eq__(self: object, other: object) -> bool"""
    def __hash__(self) -> int:
        """__hash__(self: object) -> int"""
    def __index__(self) -> int:
        """__index__(self: torch._C._MobileOptimizerType) -> int"""
    def __int__(self) -> int:
        """__int__(self: torch._C._MobileOptimizerType) -> int"""
    def __ne__(self, other: object) -> bool:
        """__ne__(self: object, other: object) -> bool"""
    @property
    def name(self) -> str:
        """name(self: object) -> str

        name(self: object) -> str
        """
    @property
    def value(self) -> int:
        """(arg0: torch._C._MobileOptimizerType) -> int"""

class _NodeBase:
    _args: Incomplete
    _erased: Incomplete
    _input_nodes: Incomplete
    _kwargs: Incomplete
    _next: Incomplete
    _prev: Incomplete
    _repr_fn: Incomplete
    _sort_key: Incomplete
    graph: Incomplete
    meta: Incomplete
    name: Incomplete
    op: Incomplete
    target: Incomplete
    type: Incomplete
    users: Incomplete
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def _update_args_kwargs(self, *args, **kwargs):
        """Internal method: do not call directly."""

class _NodeIter:
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def __iter__(self):
        """Implement iter(self)."""
    def __next__(self):
        """Implement next(self)."""

class _PreserveDispatchKeyGuard:
    def __init__(self) -> None:
        """__init__(self: torch._C._PreserveDispatchKeyGuard) -> None"""
    def _pybind11_conduit_v1_(self, *args, **kwargs): ...
    def __enter__(self) -> None:
        """__enter__(self: torch._C._PreserveDispatchKeyGuard) -> None"""
    def __exit__(self, arg0: object, arg1: object, arg2: object) -> None:
        """__exit__(self: torch._C._PreserveDispatchKeyGuard, arg0: object, arg1: object, arg2: object) -> None"""

class _ROCmFABackend:
    """Members:

      Default

      AOTriton

      Ck"""
    __members__: ClassVar[dict] = ...  # read-only
    AOTriton: ClassVar[_ROCmFABackend] = ...
    Ck: ClassVar[_ROCmFABackend] = ...
    Default: ClassVar[_ROCmFABackend] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None:
        """__init__(self: torch._C._ROCmFABackend, value: int) -> None"""
    def _pybind11_conduit_v1_(self, *args, **kwargs): ...
    def __eq__(self, other: object) -> bool:
        """__eq__(self: object, other: object) -> bool"""
    def __hash__(self) -> int:
        """__hash__(self: object) -> int"""
    def __index__(self) -> int:
        """__index__(self: torch._C._ROCmFABackend) -> int"""
    def __int__(self) -> int:
        """__int__(self: torch._C._ROCmFABackend) -> int"""
    def __ne__(self, other: object) -> bool:
        """__ne__(self: object, other: object) -> bool"""
    @property
    def name(self) -> str:
        """name(self: object) -> str

        name(self: object) -> str
        """
    @property
    def value(self) -> int:
        """(arg0: torch._C._ROCmFABackend) -> int"""

class _RestorePythonTLSSnapshot:
    def __init__(self) -> None:
        """__init__(self: torch._C._RestorePythonTLSSnapshot) -> None"""
    def _pybind11_conduit_v1_(self, *args, **kwargs): ...
    def __enter__(self) -> None:
        """__enter__(self: torch._C._RestorePythonTLSSnapshot) -> None"""
    def __exit__(self, arg0: object, arg1: object, arg2: object) -> None:
        """__exit__(self: torch._C._RestorePythonTLSSnapshot, arg0: object, arg1: object, arg2: object) -> None"""

class _SchemaArgType:
    """Members:

      input

      output"""
    __members__: ClassVar[dict] = ...  # read-only
    __entries: ClassVar[dict] = ...
    input: ClassVar[_SchemaArgType] = ...
    output: ClassVar[_SchemaArgType] = ...
    def __init__(self, value: int) -> None:
        """__init__(self: torch._C._SchemaArgType, value: int) -> None"""
    def _pybind11_conduit_v1_(self, *args, **kwargs): ...
    def __eq__(self, other: object) -> bool:
        """__eq__(self: object, other: object) -> bool"""
    def __hash__(self) -> int:
        """__hash__(self: object) -> int"""
    def __index__(self) -> int:
        """__index__(self: torch._C._SchemaArgType) -> int"""
    def __int__(self) -> int:
        """__int__(self: torch._C._SchemaArgType) -> int"""
    def __ne__(self, other: object) -> bool:
        """__ne__(self: object, other: object) -> bool"""
    @property
    def name(self) -> str:
        """name(self: object) -> str

        name(self: object) -> str
        """
    @property
    def value(self) -> int:
        """(arg0: torch._C._SchemaArgType) -> int"""

class _SchemaArgument:
    index: int
    type: _SchemaArgType
    def __init__(self, arg0: _SchemaArgType, arg1: int) -> None:
        """__init__(self: torch._C._SchemaArgument, arg0: torch._C._SchemaArgType, arg1: int) -> None"""
    def _pybind11_conduit_v1_(self, *args, **kwargs): ...

class _SchemaInfo:
    def __init__(self, arg0) -> None:
        """__init__(self: torch._C._SchemaInfo, arg0: c10::FunctionSchema) -> None"""
    def _pybind11_conduit_v1_(self, *args, **kwargs): ...
    def add_argument_value(self, arg0: str, arg1: object) -> None:
        """add_argument_value(self: torch._C._SchemaInfo, arg0: str, arg1: object) -> None"""
    def add_argument_values(self, arg0: dict) -> None:
        """add_argument_values(self: torch._C._SchemaInfo, arg0: dict) -> None"""
    def has_argument(self, arg0: str) -> bool:
        """has_argument(self: torch._C._SchemaInfo, arg0: str) -> bool"""
    @overload
    def is_mutable(self) -> bool:
        """is_mutable(*args, **kwargs)
        Overloaded function.

        1. is_mutable(self: torch._C._SchemaInfo) -> bool

        2. is_mutable(self: torch._C._SchemaInfo, arg0: torch._C._SchemaArgument) -> bool

        3. is_mutable(self: torch._C._SchemaInfo, arg0: str) -> bool
        """
    @overload
    def is_mutable(self, arg0: _SchemaArgument) -> bool:
        """is_mutable(*args, **kwargs)
        Overloaded function.

        1. is_mutable(self: torch._C._SchemaInfo) -> bool

        2. is_mutable(self: torch._C._SchemaInfo, arg0: torch._C._SchemaArgument) -> bool

        3. is_mutable(self: torch._C._SchemaInfo, arg0: str) -> bool
        """
    @overload
    def is_mutable(self, arg0: str) -> bool:
        """is_mutable(*args, **kwargs)
        Overloaded function.

        1. is_mutable(self: torch._C._SchemaInfo) -> bool

        2. is_mutable(self: torch._C._SchemaInfo, arg0: torch._C._SchemaArgument) -> bool

        3. is_mutable(self: torch._C._SchemaInfo, arg0: str) -> bool
        """
    def may_alias(self, arg0: _SchemaArgument, arg1: _SchemaArgument) -> bool:
        """may_alias(self: torch._C._SchemaInfo, arg0: torch._C._SchemaArgument, arg1: torch._C._SchemaArgument) -> bool"""
    def may_contain_alias(self, arg0: _SchemaArgument, arg1: _SchemaArgument) -> bool:
        """may_contain_alias(self: torch._C._SchemaInfo, arg0: torch._C._SchemaArgument, arg1: torch._C._SchemaArgument) -> bool"""

class _SetExcludeDispatchKeyGuard:
    def __init__(self, arg0: DispatchKey, arg1: bool) -> None:
        """__init__(self: torch._C._SetExcludeDispatchKeyGuard, arg0: torch._C.DispatchKey, arg1: bool) -> None"""
    def _pybind11_conduit_v1_(self, *args, **kwargs): ...
    def __enter__(self) -> None:
        """__enter__(self: torch._C._SetExcludeDispatchKeyGuard) -> None"""
    def __exit__(self, arg0: object, arg1: object, arg2: object) -> None:
        """__exit__(self: torch._C._SetExcludeDispatchKeyGuard, arg0: object, arg1: object, arg2: object) -> None"""

class _ShapeComputeGraphMapping:
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def _pybind11_conduit_v1_(self, *args, **kwargs): ...
    def graph_output_to_symbolic_shape_dim(self) -> dict[Value, int]:
        """graph_output_to_symbolic_shape_dim(self: torch._C._ShapeComputeGraphMapping) -> dict[torch._C.Value, int]"""
    def partial_eval_shape_graph(self) -> Graph:
        """partial_eval_shape_graph(self: torch._C._ShapeComputeGraphMapping) -> torch._C.Graph"""

class _StorageMeta(type):
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""

class _SymNode:
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def _graph_repr(self) -> str:
        """_graph_repr(self: torch._C._SymNode) -> str"""
    def _pybind11_conduit_v1_(self, *args, **kwargs): ...
    def add(self, arg0: _SymNode) -> _SymNode:
        """add(self: torch._C._SymNode, arg0: torch._C._SymNode) -> torch._C._SymNode"""
    def bool_(self) -> bool:
        """bool_(self: torch._C._SymNode) -> bool"""
    def ceil(self) -> _SymNode:
        """ceil(self: torch._C._SymNode) -> torch._C._SymNode"""
    def clone(self) -> _SymNode:
        """clone(self: torch._C._SymNode) -> torch._C._SymNode"""
    def eq(self, arg0: _SymNode) -> _SymNode:
        """eq(self: torch._C._SymNode, arg0: torch._C._SymNode) -> torch._C._SymNode"""
    def expect_size(self, arg0: str, arg1: int) -> bool:
        """expect_size(self: torch._C._SymNode, arg0: str, arg1: int) -> bool"""
    def expect_true(self, arg0: str, arg1: int) -> bool:
        """expect_true(self: torch._C._SymNode, arg0: str, arg1: int) -> bool"""
    def float_pow(self, arg0: _SymNode) -> _SymNode:
        """float_pow(self: torch._C._SymNode, arg0: torch._C._SymNode) -> torch._C._SymNode"""
    def float_truediv(self, arg0: _SymNode) -> _SymNode:
        """float_truediv(self: torch._C._SymNode, arg0: torch._C._SymNode) -> torch._C._SymNode"""
    def floor(self) -> _SymNode:
        """floor(self: torch._C._SymNode) -> torch._C._SymNode"""
    def floordiv(self, arg0: _SymNode) -> _SymNode:
        """floordiv(self: torch._C._SymNode, arg0: torch._C._SymNode) -> torch._C._SymNode"""
    def ge(self, arg0: _SymNode) -> _SymNode:
        """ge(self: torch._C._SymNode, arg0: torch._C._SymNode) -> torch._C._SymNode"""
    def gt(self, arg0: _SymNode) -> _SymNode:
        """gt(self: torch._C._SymNode, arg0: torch._C._SymNode) -> torch._C._SymNode"""
    def guard_bool(self, arg0: str, arg1: int) -> bool:
        """guard_bool(self: torch._C._SymNode, arg0: str, arg1: int) -> bool"""
    def guard_float(self, arg0: str, arg1: int) -> float:
        """guard_float(self: torch._C._SymNode, arg0: str, arg1: int) -> float"""
    def guard_int(self, arg0: str, arg1: int) -> int:
        """guard_int(self: torch._C._SymNode, arg0: str, arg1: int) -> int"""
    def guard_or_false(self, arg0: str, arg1: int) -> bool:
        """guard_or_false(self: torch._C._SymNode, arg0: str, arg1: int) -> bool"""
    def guard_or_true(self, arg0: str, arg1: int) -> bool:
        """guard_or_true(self: torch._C._SymNode, arg0: str, arg1: int) -> bool"""
    def guard_size_oblivious(self, arg0: str, arg1: int) -> bool:
        """guard_size_oblivious(self: torch._C._SymNode, arg0: str, arg1: int) -> bool"""
    def has_hint(self) -> bool:
        """has_hint(self: torch._C._SymNode) -> bool"""
    def int_(self) -> int:
        """int_(self: torch._C._SymNode) -> int"""
    def int_floordiv(self, arg0: _SymNode) -> _SymNode:
        """int_floordiv(self: torch._C._SymNode, arg0: torch._C._SymNode) -> torch._C._SymNode"""
    def int_truediv(self, arg0: _SymNode) -> _SymNode:
        """int_truediv(self: torch._C._SymNode, arg0: torch._C._SymNode) -> torch._C._SymNode"""
    def is_bool(self) -> bool:
        """is_bool(self: torch._C._SymNode) -> bool"""
    def is_channels_last_contiguous_2d(self, arg0: list[SymNode], arg1: list[SymNode]) -> _SymNode:
        """is_channels_last_contiguous_2d(self: torch._C._SymNode, arg0: List[SymNode], arg1: List[SymNode]) -> torch._C._SymNode"""
    def is_channels_last_contiguous_3d(self, arg0: list[SymNode], arg1: list[SymNode]) -> _SymNode:
        """is_channels_last_contiguous_3d(self: torch._C._SymNode, arg0: List[SymNode], arg1: List[SymNode]) -> torch._C._SymNode"""
    def is_channels_last_strides_2d(self, arg0: list[SymNode], arg1: list[SymNode]) -> _SymNode:
        """is_channels_last_strides_2d(self: torch._C._SymNode, arg0: List[SymNode], arg1: List[SymNode]) -> torch._C._SymNode"""
    def is_channels_last_strides_3d(self, arg0: list[SymNode], arg1: list[SymNode]) -> _SymNode:
        """is_channels_last_strides_3d(self: torch._C._SymNode, arg0: List[SymNode], arg1: List[SymNode]) -> torch._C._SymNode"""
    def is_constant(self) -> bool:
        """is_constant(self: torch._C._SymNode) -> bool"""
    def is_contiguous(self, arg0: list[SymNode], arg1: list[SymNode]) -> _SymNode:
        """is_contiguous(self: torch._C._SymNode, arg0: List[SymNode], arg1: List[SymNode]) -> torch._C._SymNode"""
    def is_float(self) -> bool:
        """is_float(self: torch._C._SymNode) -> bool"""
    def is_int(self) -> bool:
        """is_int(self: torch._C._SymNode) -> bool"""
    def is_nested_int(self) -> bool:
        """is_nested_int(self: torch._C._SymNode) -> bool"""
    def is_non_overlapping_and_dense(self, arg0: list[SymNode], arg1: list[SymNode]) -> _SymNode:
        """is_non_overlapping_and_dense(self: torch._C._SymNode, arg0: List[SymNode], arg1: List[SymNode]) -> torch._C._SymNode"""
    def is_symbolic(self) -> bool:
        """is_symbolic(self: torch._C._SymNode) -> bool"""
    def le(self, arg0: _SymNode) -> _SymNode:
        """le(self: torch._C._SymNode, arg0: torch._C._SymNode) -> torch._C._SymNode"""
    def lt(self, arg0: _SymNode) -> _SymNode:
        """lt(self: torch._C._SymNode, arg0: torch._C._SymNode) -> torch._C._SymNode"""
    def mod(self, arg0: _SymNode) -> _SymNode:
        """mod(self: torch._C._SymNode, arg0: torch._C._SymNode) -> torch._C._SymNode"""
    def mul(self, arg0: _SymNode) -> _SymNode:
        """mul(self: torch._C._SymNode, arg0: torch._C._SymNode) -> torch._C._SymNode"""
    def ne(self, arg0: _SymNode) -> _SymNode:
        """ne(self: torch._C._SymNode, arg0: torch._C._SymNode) -> torch._C._SymNode"""
    def neg(self) -> _SymNode:
        """neg(self: torch._C._SymNode) -> torch._C._SymNode"""
    def nested_int(self) -> int | None:
        """nested_int(self: torch._C._SymNode) -> Optional[int]"""
    def nested_int_coeff(self) -> int | None:
        """nested_int_coeff(self: torch._C._SymNode) -> Optional[int]"""
    def pow(self, arg0: _SymNode) -> _SymNode:
        """pow(self: torch._C._SymNode, arg0: torch._C._SymNode) -> torch._C._SymNode"""
    def pow_by_natural(self, arg0: _SymNode) -> _SymNode:
        """pow_by_natural(self: torch._C._SymNode, arg0: torch._C._SymNode) -> torch._C._SymNode"""
    def sub(self, arg0: _SymNode) -> _SymNode:
        """sub(self: torch._C._SymNode, arg0: torch._C._SymNode) -> torch._C._SymNode"""
    def sym_and(self, arg0: _SymNode) -> _SymNode:
        """sym_and(self: torch._C._SymNode, arg0: torch._C._SymNode) -> torch._C._SymNode"""
    def sym_float(self) -> _SymNode:
        """sym_float(self: torch._C._SymNode) -> torch._C._SymNode"""
    def sym_max(self, arg0: _SymNode) -> _SymNode:
        """sym_max(self: torch._C._SymNode, arg0: torch._C._SymNode) -> torch._C._SymNode"""
    def sym_min(self, arg0: _SymNode) -> _SymNode:
        """sym_min(self: torch._C._SymNode, arg0: torch._C._SymNode) -> torch._C._SymNode"""
    def sym_not(self) -> _SymNode:
        """sym_not(self: torch._C._SymNode) -> torch._C._SymNode"""
    def sym_or(self, arg0: _SymNode) -> _SymNode:
        """sym_or(self: torch._C._SymNode, arg0: torch._C._SymNode) -> torch._C._SymNode"""
    def truediv(self, arg0: _SymNode) -> _SymNode:
        """truediv(self: torch._C._SymNode, arg0: torch._C._SymNode) -> torch._C._SymNode"""
    def wrap_bool(self, arg0: bool) -> _SymNode:
        """wrap_bool(self: torch._C._SymNode, arg0: bool) -> torch._C._SymNode"""
    def wrap_float(self, arg0: float) -> _SymNode:
        """wrap_float(self: torch._C._SymNode, arg0: float) -> torch._C._SymNode"""
    def wrap_int(self, arg0: int) -> _SymNode:
        """wrap_int(self: torch._C._SymNode, arg0: int) -> torch._C._SymNode"""
    def __deepcopy__(self, arg0: object) -> _SymNode:
        """__deepcopy__(self: torch._C._SymNode, arg0: object) -> torch._C._SymNode"""

class _TensorBase:
    H: Incomplete
    T: Incomplete
    _backward_hooks: Incomplete
    _base: Incomplete
    _cdata: Incomplete
    _grad: Incomplete
    _grad_fn: Incomplete
    _has_symbolic_sizes_strides: Incomplete
    _post_accumulate_grad_hooks: Incomplete
    _python_dispatch: Incomplete
    _version: Incomplete
    data: Incomplete
    device: Incomplete
    dtype: Incomplete
    grad: Incomplete
    grad_fn: Incomplete
    imag: Incomplete
    is_cpu: Incomplete
    is_cuda: Incomplete
    is_ipu: Incomplete
    is_leaf: Incomplete
    is_maia: Incomplete
    is_meta: Incomplete
    is_mkldnn: Incomplete
    is_mps: Incomplete
    is_mtia: Incomplete
    is_nested: Incomplete
    is_quantized: Incomplete
    is_sparse: Incomplete
    is_sparse_csr: Incomplete
    is_vulkan: Incomplete
    is_xla: Incomplete
    is_xpu: Incomplete
    itemsize: Incomplete
    layout: Incomplete
    mH: Incomplete
    mT: Incomplete
    name: Incomplete
    names: Incomplete
    nbytes: Incomplete
    ndim: Incomplete
    output_nr: Incomplete
    real: Incomplete
    requires_grad: Incomplete
    retains_grad: Incomplete
    shape: torch.Size
    volatile: Incomplete
    @classmethod
    def __init__(cls, *args, **kwargs) -> None:
        """Create and return a new object.  See help(type) for accurate signature."""
    def _addmm_activation(self, *args, **kwargs): ...
    def _autocast_to_full_precision(self, *args, **kwargs): ...
    def _autocast_to_reduced_precision(self, *args, **kwargs): ...
    def _coalesced_(self, *args, **kwargs): ...
    def _conj(self, *args, **kwargs): ...
    def _conj_physical(self, *args, **kwargs): ...
    def _dimI(self, *args, **kwargs): ...
    def _dimV(self, *args, **kwargs): ...
    def _fix_weakref(self, *args, **kwargs): ...
    def _indices(self, *args, **kwargs): ...
    def _is_all_true(self, *args, **kwargs): ...
    def _is_any_true(self, *args, **kwargs): ...
    def _is_view(self, *args, **kwargs): ...
    def _is_zerotensor(self, *args, **kwargs): ...
    def _lazy_clone(self, *args, **kwargs): ...
    @staticmethod
    def _make_subclass(*args, **kwargs): ...
    @staticmethod
    def _make_wrapper_subclass(*args, **kwargs): ...
    def _neg_view(self, *args, **kwargs): ...
    def _nested_tensor_size(self, *args, **kwargs): ...
    def _nested_tensor_storage_offsets(self, *args, **kwargs): ...
    def _nested_tensor_strides(self, *args, **kwargs): ...
    def _nnz(self, *args, **kwargs): ...
    def _rev_view_func_unsafe(self, *args, **kwargs): ...
    def _sparse_mask_projection(self, *args, **kwargs): ...
    def _to_dense(self, *args, **kwargs): ...
    def _to_sparse(self, *args, **kwargs): ...
    def _to_sparse_bsc(self, *args, **kwargs): ...
    def _to_sparse_bsr(self, *args, **kwargs): ...
    def _to_sparse_csc(self, *args, **kwargs): ...
    def _to_sparse_csr(self, *args, **kwargs): ...
    def _use_count(self, *args, **kwargs): ...
    def _values(self, *args, **kwargs): ...
    def _view_func(self, *args, **kwargs): ...
    def _view_func_unsafe(self, *args, **kwargs): ...
    def abs(self) -> Tensor:
        """
        abs() -> Tensor

        See :func:`torch.abs`
        """
    def abs_(self) -> Tensor:
        """
        abs_() -> Tensor

        In-place version of :meth:`~Tensor.abs`
        """
    def absolute(self) -> Tensor:
        """
        absolute() -> Tensor

        Alias for :func:`abs`
        """
    def absolute_(self) -> Tensor:
        """
        absolute_() -> Tensor

        In-place version of :meth:`~Tensor.absolute`
        Alias for :func:`abs_`
        """
    def acos(self) -> Tensor:
        """
        acos() -> Tensor

        See :func:`torch.acos`
        """
    def acos_(self) -> Tensor:
        """
        acos_() -> Tensor

        In-place version of :meth:`~Tensor.acos`
        """
    def acosh(self) -> Tensor:
        """
        acosh() -> Tensor

        See :func:`torch.acosh`
        """
    def acosh_(self) -> Tensor:
        """
        acosh_() -> Tensor

        In-place version of :meth:`~Tensor.acosh`
        """
    def add(self, other, alpha=...) -> Tensor:
        """
        add(other, *, alpha=1) -> Tensor

        Add a scalar or tensor to :attr:`self` tensor. If both :attr:`alpha`
        and :attr:`other` are specified, each element of :attr:`other` is scaled by
        :attr:`alpha` before being used.

        When :attr:`other` is a tensor, the shape of :attr:`other` must be
        :ref:`broadcastable <broadcasting-semantics>` with the shape of the underlying
        tensor

        See :func:`torch.add`
        """
    def add_(self, other, alpha=...) -> Tensor:
        """
        add_(other, *, alpha=1) -> Tensor

        In-place version of :meth:`~Tensor.add`
        """
    def addbmm(self, batch1, batch2, beta=..., alpha=...) -> Tensor:
        """
        addbmm(batch1, batch2, *, beta=1, alpha=1) -> Tensor

        See :func:`torch.addbmm`
        """
    def addbmm_(self, batch1, batch2, beta=..., alpha=...) -> Tensor:
        """
        addbmm_(batch1, batch2, *, beta=1, alpha=1) -> Tensor

        In-place version of :meth:`~Tensor.addbmm`
        """
    def addcdiv(self, tensor1, tensor2, value=...) -> Tensor:
        """
        addcdiv(tensor1, tensor2, *, value=1) -> Tensor

        See :func:`torch.addcdiv`
        """
    def addcdiv_(self, tensor1, tensor2, value=...) -> Tensor:
        """
        addcdiv_(tensor1, tensor2, *, value=1) -> Tensor

        In-place version of :meth:`~Tensor.addcdiv`
        """
    def addcmul(self, tensor1, tensor2, value=...) -> Tensor:
        """
        addcmul(tensor1, tensor2, *, value=1) -> Tensor

        See :func:`torch.addcmul`
        """
    def addcmul_(self, tensor1, tensor2, value=...) -> Tensor:
        """
        addcmul_(tensor1, tensor2, *, value=1) -> Tensor

        In-place version of :meth:`~Tensor.addcmul`
        """
    def addmm(self, mat1, mat2, beta=..., alpha=...) -> Tensor:
        """
        addmm(mat1, mat2, *, beta=1, alpha=1) -> Tensor

        See :func:`torch.addmm`
        """
    def addmm_(self, mat1, mat2, beta=..., alpha=...) -> Tensor:
        """
        addmm_(mat1, mat2, *, beta=1, alpha=1) -> Tensor

        In-place version of :meth:`~Tensor.addmm`
        """
    def addmv(self, mat, vec, beta=..., alpha=...) -> Tensor:
        """
        addmv(mat, vec, *, beta=1, alpha=1) -> Tensor

        See :func:`torch.addmv`
        """
    def addmv_(self, mat, vec, beta=..., alpha=...) -> Tensor:
        """
        addmv_(mat, vec, *, beta=1, alpha=1) -> Tensor

        In-place version of :meth:`~Tensor.addmv`
        """
    def addr(self, vec1, vec2, beta=..., alpha=...) -> Tensor:
        """
        addr(vec1, vec2, *, beta=1, alpha=1) -> Tensor

        See :func:`torch.addr`
        """
    def addr_(self, vec1, vec2, beta=..., alpha=...) -> Tensor:
        """
        addr_(vec1, vec2, *, beta=1, alpha=1) -> Tensor

        In-place version of :meth:`~Tensor.addr`
        """
    def adjoint(self) -> Tensor:
        """
        adjoint() -> Tensor

        Alias for :func:`adjoint`
        """
    @overload
    def align_as(self, other) -> Tensor:
        """
        align_as(other) -> Tensor

        Permutes the dimensions of the :attr:`self` tensor to match the dimension order
        in the :attr:`other` tensor, adding size-one dims for any new names.

        This operation is useful for explicit broadcasting by names (see examples).

        All of the dims of :attr:`self` must be named in order to use this method.
        The resulting tensor is a view on the original tensor.

        All dimension names of :attr:`self` must be present in ``other.names``.
        :attr:`other` may contain named dimensions that are not in ``self.names``;
        the output tensor has a size-one dimension for each of those new names.

        To align a tensor to a specific order, use :meth:`~Tensor.align_to`.

        Examples::

            # Example 1: Applying a mask
            >>> mask = torch.randint(2, [127, 128], dtype=torch.bool).refine_names('W', 'H')
            >>> imgs = torch.randn(32, 128, 127, 3, names=('N', 'H', 'W', 'C'))
            >>> imgs.masked_fill_(mask.align_as(imgs), 0)


            # Example 2: Applying a per-channel-scale
            >>> def scale_channels(input, scale):
            >>>    scale = scale.refine_names('C')
            >>>    return input * scale.align_as(input)

            >>> num_channels = 3
            >>> scale = torch.randn(num_channels, names=('C',))
            >>> imgs = torch.rand(32, 128, 128, num_channels, names=('N', 'H', 'W', 'C'))
            >>> more_imgs = torch.rand(32, num_channels, 128, 128, names=('N', 'C', 'H', 'W'))
            >>> videos = torch.randn(3, num_channels, 128, 128, 128, names=('N', 'C', 'H', 'W', 'D'))

            # scale_channels is agnostic to the dimension order of the input
            >>> scale_channels(imgs, scale)
            >>> scale_channels(more_imgs, scale)
            >>> scale_channels(videos, scale)

        .. warning::
            The named tensor API is experimental and subject to change.

        """
    @overload
    def align_as(self, imgs) -> Any:
        """
        align_as(other) -> Tensor

        Permutes the dimensions of the :attr:`self` tensor to match the dimension order
        in the :attr:`other` tensor, adding size-one dims for any new names.

        This operation is useful for explicit broadcasting by names (see examples).

        All of the dims of :attr:`self` must be named in order to use this method.
        The resulting tensor is a view on the original tensor.

        All dimension names of :attr:`self` must be present in ``other.names``.
        :attr:`other` may contain named dimensions that are not in ``self.names``;
        the output tensor has a size-one dimension for each of those new names.

        To align a tensor to a specific order, use :meth:`~Tensor.align_to`.

        Examples::

            # Example 1: Applying a mask
            >>> mask = torch.randint(2, [127, 128], dtype=torch.bool).refine_names('W', 'H')
            >>> imgs = torch.randn(32, 128, 127, 3, names=('N', 'H', 'W', 'C'))
            >>> imgs.masked_fill_(mask.align_as(imgs), 0)


            # Example 2: Applying a per-channel-scale
            >>> def scale_channels(input, scale):
            >>>    scale = scale.refine_names('C')
            >>>    return input * scale.align_as(input)

            >>> num_channels = 3
            >>> scale = torch.randn(num_channels, names=('C',))
            >>> imgs = torch.rand(32, 128, 128, num_channels, names=('N', 'H', 'W', 'C'))
            >>> more_imgs = torch.rand(32, num_channels, 128, 128, names=('N', 'C', 'H', 'W'))
            >>> videos = torch.randn(3, num_channels, 128, 128, 128, names=('N', 'C', 'H', 'W', 'D'))

            # scale_channels is agnostic to the dimension order of the input
            >>> scale_channels(imgs, scale)
            >>> scale_channels(more_imgs, scale)
            >>> scale_channels(videos, scale)

        .. warning::
            The named tensor API is experimental and subject to change.

        """
    @overload
    def align_as(self, input) -> Any:
        """
        align_as(other) -> Tensor

        Permutes the dimensions of the :attr:`self` tensor to match the dimension order
        in the :attr:`other` tensor, adding size-one dims for any new names.

        This operation is useful for explicit broadcasting by names (see examples).

        All of the dims of :attr:`self` must be named in order to use this method.
        The resulting tensor is a view on the original tensor.

        All dimension names of :attr:`self` must be present in ``other.names``.
        :attr:`other` may contain named dimensions that are not in ``self.names``;
        the output tensor has a size-one dimension for each of those new names.

        To align a tensor to a specific order, use :meth:`~Tensor.align_to`.

        Examples::

            # Example 1: Applying a mask
            >>> mask = torch.randint(2, [127, 128], dtype=torch.bool).refine_names('W', 'H')
            >>> imgs = torch.randn(32, 128, 127, 3, names=('N', 'H', 'W', 'C'))
            >>> imgs.masked_fill_(mask.align_as(imgs), 0)


            # Example 2: Applying a per-channel-scale
            >>> def scale_channels(input, scale):
            >>>    scale = scale.refine_names('C')
            >>>    return input * scale.align_as(input)

            >>> num_channels = 3
            >>> scale = torch.randn(num_channels, names=('C',))
            >>> imgs = torch.rand(32, 128, 128, num_channels, names=('N', 'H', 'W', 'C'))
            >>> more_imgs = torch.rand(32, num_channels, 128, 128, names=('N', 'C', 'H', 'W'))
            >>> videos = torch.randn(3, num_channels, 128, 128, 128, names=('N', 'C', 'H', 'W', 'D'))

            # scale_channels is agnostic to the dimension order of the input
            >>> scale_channels(imgs, scale)
            >>> scale_channels(more_imgs, scale)
            >>> scale_channels(videos, scale)

        .. warning::
            The named tensor API is experimental and subject to change.

        """
    def align_to(self, *args, **kwargs): ...
    def all(self, dim=..., keepdim=...) -> Tensor:
        """
        all(dim=None, keepdim=False) -> Tensor

        See :func:`torch.all`
        """
    def allclose(self, other, rtol=..., atol=..., equal_nan=...) -> Tensor:
        """
        allclose(other, rtol=1e-05, atol=1e-08, equal_nan=False) -> Tensor

        See :func:`torch.allclose`
        """
    def amax(self, dim=..., keepdim=...) -> Tensor:
        """
        amax(dim=None, keepdim=False) -> Tensor

        See :func:`torch.amax`
        """
    def amin(self, dim=..., keepdim=...) -> Tensor:
        """
        amin(dim=None, keepdim=False) -> Tensor

        See :func:`torch.amin`
        """
    def aminmax(self, *args, **kwargs):
        """
        aminmax(*, dim=None, keepdim=False) -> (Tensor min, Tensor max)

        See :func:`torch.aminmax`
        """
    def angle(self) -> Tensor:
        """
        angle() -> Tensor

        See :func:`torch.angle`
        """
    def any(self, dim=..., keepdim=...) -> Tensor:
        """
        any(dim=None, keepdim=False) -> Tensor

        See :func:`torch.any`
        """
    def apply_(self, callable) -> Tensor:
        """
        apply_(callable) -> Tensor

        Applies the function :attr:`callable` to each element in the tensor, replacing
        each element with the value returned by :attr:`callable`.

        .. note::

            This function only works with CPU tensors and should not be used in code
            sections that require high performance.
        """
    def arccos(self) -> Tensor:
        """
        arccos() -> Tensor

        See :func:`torch.arccos`
        """
    def arccos_(self) -> Tensor:
        """
        arccos_() -> Tensor

        In-place version of :meth:`~Tensor.arccos`
        """
    def arccosh(self, *args, **kwargs):
        """
        acosh() -> Tensor

        See :func:`torch.arccosh`
        """
    def arccosh_(self, *args, **kwargs):
        """
        acosh_() -> Tensor

        In-place version of :meth:`~Tensor.arccosh`
        """
    def arcsin(self) -> Tensor:
        """
        arcsin() -> Tensor

        See :func:`torch.arcsin`
        """
    def arcsin_(self) -> Tensor:
        """
        arcsin_() -> Tensor

        In-place version of :meth:`~Tensor.arcsin`
        """
    def arcsinh(self) -> Tensor:
        """
        arcsinh() -> Tensor

        See :func:`torch.arcsinh`
        """
    def arcsinh_(self) -> Tensor:
        """
        arcsinh_() -> Tensor

        In-place version of :meth:`~Tensor.arcsinh`
        """
    def arctan(self) -> Tensor:
        """
        arctan() -> Tensor

        See :func:`torch.arctan`
        """
    def arctan2(self, other) -> Tensor:
        """
        arctan2(other) -> Tensor

        See :func:`torch.arctan2`
        """
    def arctan2_(self, *args, **kwargs):
        """
        atan2_(other) -> Tensor

        In-place version of :meth:`~Tensor.arctan2`
        """
    def arctan_(self) -> Tensor:
        """
        arctan_() -> Tensor

        In-place version of :meth:`~Tensor.arctan`
        """
    def arctanh(self) -> Tensor:
        """
        arctanh() -> Tensor

        See :func:`torch.arctanh`
        """
    def arctanh_(self, other) -> Tensor:
        """
        arctanh_(other) -> Tensor

        In-place version of :meth:`~Tensor.arctanh`
        """
    def argmax(self, dim=..., keepdim=...) -> LongTensor:
        """
        argmax(dim=None, keepdim=False) -> LongTensor

        See :func:`torch.argmax`
        """
    def argmin(self, dim=..., keepdim=...) -> LongTensor:
        """
        argmin(dim=None, keepdim=False) -> LongTensor

        See :func:`torch.argmin`
        """
    def argsort(self, dim=..., descending=...) -> LongTensor:
        """
        argsort(dim=-1, descending=False) -> LongTensor

        See :func:`torch.argsort`
        """
    def argwhere(self) -> Tensor:
        """
        argwhere() -> Tensor

        See :func:`torch.argwhere`
        """
    def as_strided(self, size, stride, storage_offset=...) -> Tensor:
        """
        as_strided(size, stride, storage_offset=None) -> Tensor

        See :func:`torch.as_strided`
        """
    def as_strided_(self, size, stride, storage_offset=...) -> Tensor:
        """
        as_strided_(size, stride, storage_offset=None) -> Tensor

        In-place version of :meth:`~Tensor.as_strided`
        """
    def as_strided_scatter(self, src, size, stride, storage_offset=...) -> Tensor:
        """
        as_strided_scatter(src, size, stride, storage_offset=None) -> Tensor

        See :func:`torch.as_strided_scatter`
        """
    @classmethod
    def as_subclass(cls) -> Tensor:
        """
        as_subclass(cls) -> Tensor

        Makes a ``cls`` instance with the same data pointer as ``self``. Changes
        in the output mirror changes in ``self``, and the output stays attached
        to the autograd graph. ``cls`` must be a subclass of ``Tensor``.
        """
    def asin(self) -> Tensor:
        """
        asin() -> Tensor

        See :func:`torch.asin`
        """
    def asin_(self) -> Tensor:
        """
        asin_() -> Tensor

        In-place version of :meth:`~Tensor.asin`
        """
    def asinh(self) -> Tensor:
        """
        asinh() -> Tensor

        See :func:`torch.asinh`
        """
    def asinh_(self) -> Tensor:
        """
        asinh_() -> Tensor

        In-place version of :meth:`~Tensor.asinh`
        """
    def atan(self) -> Tensor:
        """
        atan() -> Tensor

        See :func:`torch.atan`
        """
    def atan2(self, other) -> Tensor:
        """
        atan2(other) -> Tensor

        See :func:`torch.atan2`
        """
    def atan2_(self, other) -> Tensor:
        """
        atan2_(other) -> Tensor

        In-place version of :meth:`~Tensor.atan2`
        """
    def atan_(self) -> Tensor:
        """
        atan_() -> Tensor

        In-place version of :meth:`~Tensor.atan`
        """
    def atanh(self) -> Tensor:
        """
        atanh() -> Tensor

        See :func:`torch.atanh`
        """
    def atanh_(self, other) -> Tensor:
        """
        atanh_(other) -> Tensor

        In-place version of :meth:`~Tensor.atanh`
        """
    def baddbmm(self, batch1, batch2, beta=..., alpha=...) -> Tensor:
        """
        baddbmm(batch1, batch2, *, beta=1, alpha=1) -> Tensor

        See :func:`torch.baddbmm`
        """
    def baddbmm_(self, batch1, batch2, beta=..., alpha=...) -> Tensor:
        """
        baddbmm_(batch1, batch2, *, beta=1, alpha=1) -> Tensor

        In-place version of :meth:`~Tensor.baddbmm`
        """
    def bernoulli(self, generator=...) -> Tensor:
        """
        bernoulli(*, generator=None) -> Tensor

        Returns a result tensor where each :math:`\\texttt{result[i]}` is independently
        sampled from :math:`\\text{Bernoulli}(\\texttt{self[i]})`. :attr:`self` must have
        floating point ``dtype``, and the result will have the same ``dtype``.

        See :func:`torch.bernoulli`
        """
    def bernoulli_(self, p=..., generator=...) -> Tensor:
        """
        bernoulli_(p=0.5, *, generator=None) -> Tensor

        Fills each location of :attr:`self` with an independent sample from
        :math:`\\text{Bernoulli}(\\texttt{p})`. :attr:`self` can have integral
        ``dtype``.

        :attr:`p` should either be a scalar or tensor containing probabilities to be
        used for drawing the binary random number.

        If it is a tensor, the :math:`\\text{i}^{th}` element of :attr:`self` tensor
        will be set to a value sampled from
        :math:`\\text{Bernoulli}(\\texttt{p\\_tensor[i]})`. In this case `p` must have
        floating point ``dtype``.

        See also :meth:`~Tensor.bernoulli` and :func:`torch.bernoulli`
        """
    @overload
    def bfloat16(self, memory_format=...) -> Tensor:
        """
        bfloat16(memory_format=torch.preserve_format) -> Tensor
        ``self.bfloat16()`` is equivalent to ``self.to(torch.bfloat16)``. See :func:`to`.

        Args:
            memory_format (:class:`torch.memory_format`, optional): the desired memory format of
                returned Tensor. Default: ``torch.preserve_format``.
        """
    @overload
    def bfloat16(self) -> Any:
        """
        bfloat16(memory_format=torch.preserve_format) -> Tensor
        ``self.bfloat16()`` is equivalent to ``self.to(torch.bfloat16)``. See :func:`to`.

        Args:
            memory_format (:class:`torch.memory_format`, optional): the desired memory format of
                returned Tensor. Default: ``torch.preserve_format``.
        """
    def bincount(self, weights=..., minlength=...) -> Tensor:
        """
        bincount(weights=None, minlength=0) -> Tensor

        See :func:`torch.bincount`
        """
    def bitwise_and(self) -> Tensor:
        """
        bitwise_and() -> Tensor

        See :func:`torch.bitwise_and`
        """
    def bitwise_and_(self) -> Tensor:
        """
        bitwise_and_() -> Tensor

        In-place version of :meth:`~Tensor.bitwise_and`
        """
    def bitwise_left_shift(self, other) -> Tensor:
        """
        bitwise_left_shift(other) -> Tensor

        See :func:`torch.bitwise_left_shift`
        """
    def bitwise_left_shift_(self, other) -> Tensor:
        """
        bitwise_left_shift_(other) -> Tensor

        In-place version of :meth:`~Tensor.bitwise_left_shift`
        """
    def bitwise_not(self) -> Tensor:
        """
        bitwise_not() -> Tensor

        See :func:`torch.bitwise_not`
        """
    def bitwise_not_(self) -> Tensor:
        """
        bitwise_not_() -> Tensor

        In-place version of :meth:`~Tensor.bitwise_not`
        """
    def bitwise_or(self) -> Tensor:
        """
        bitwise_or() -> Tensor

        See :func:`torch.bitwise_or`
        """
    def bitwise_or_(self) -> Tensor:
        """
        bitwise_or_() -> Tensor

        In-place version of :meth:`~Tensor.bitwise_or`
        """
    def bitwise_right_shift(self, other) -> Tensor:
        """
        bitwise_right_shift(other) -> Tensor

        See :func:`torch.bitwise_right_shift`
        """
    def bitwise_right_shift_(self, other) -> Tensor:
        """
        bitwise_right_shift_(other) -> Tensor

        In-place version of :meth:`~Tensor.bitwise_right_shift`
        """
    def bitwise_xor(self) -> Tensor:
        """
        bitwise_xor() -> Tensor

        See :func:`torch.bitwise_xor`
        """
    def bitwise_xor_(self) -> Tensor:
        """
        bitwise_xor_() -> Tensor

        In-place version of :meth:`~Tensor.bitwise_xor`
        """
    def bmm(self, batch2) -> Tensor:
        """
        bmm(batch2) -> Tensor

        See :func:`torch.bmm`
        """
    @overload
    def bool(self, memory_format=...) -> Tensor:
        """
        bool(memory_format=torch.preserve_format) -> Tensor

        ``self.bool()`` is equivalent to ``self.to(torch.bool)``. See :func:`to`.

        Args:
            memory_format (:class:`torch.memory_format`, optional): the desired memory format of
                returned Tensor. Default: ``torch.preserve_format``.
        """
    @overload
    def bool(self) -> Any:
        """
        bool(memory_format=torch.preserve_format) -> Tensor

        ``self.bool()`` is equivalent to ``self.to(torch.bool)``. See :func:`to`.

        Args:
            memory_format (:class:`torch.memory_format`, optional): the desired memory format of
                returned Tensor. Default: ``torch.preserve_format``.
        """
    def broadcast_to(self, shape) -> Tensor:
        """
        broadcast_to(shape) -> Tensor

        See :func:`torch.broadcast_to`.
        """
    @overload
    def byte(self, memory_format=...) -> Tensor:
        """
        byte(memory_format=torch.preserve_format) -> Tensor

        ``self.byte()`` is equivalent to ``self.to(torch.uint8)``. See :func:`to`.

        Args:
            memory_format (:class:`torch.memory_format`, optional): the desired memory format of
                returned Tensor. Default: ``torch.preserve_format``.
        """
    @overload
    def byte(self) -> Any:
        """
        byte(memory_format=torch.preserve_format) -> Tensor

        ``self.byte()`` is equivalent to ``self.to(torch.uint8)``. See :func:`to`.

        Args:
            memory_format (:class:`torch.memory_format`, optional): the desired memory format of
                returned Tensor. Default: ``torch.preserve_format``.
        """
    def cauchy_(self, median=..., sigma=..., generator=...) -> Tensor:
        """
        cauchy_(median=0, sigma=1, *, generator=None) -> Tensor

        Fills the tensor with numbers drawn from the Cauchy distribution:

        .. math::

            f(x) = \\dfrac{1}{\\pi} \\dfrac{\\sigma}{(x - \\text{median})^2 + \\sigma^2}

        .. note::
          Sigma (:math:`\\sigma`) is used to denote the scale parameter in Cauchy distribution.
        """
    def ccol_indices(self, *args, **kwargs): ...
    @overload
    def cdouble(self, memory_format=...) -> Tensor:
        """
        cdouble(memory_format=torch.preserve_format) -> Tensor

        ``self.cdouble()`` is equivalent to ``self.to(torch.complex128)``. See :func:`to`.

        Args:
            memory_format (:class:`torch.memory_format`, optional): the desired memory format of
                returned Tensor. Default: ``torch.preserve_format``.
        """
    @overload
    def cdouble(self) -> Any:
        """
        cdouble(memory_format=torch.preserve_format) -> Tensor

        ``self.cdouble()`` is equivalent to ``self.to(torch.complex128)``. See :func:`to`.

        Args:
            memory_format (:class:`torch.memory_format`, optional): the desired memory format of
                returned Tensor. Default: ``torch.preserve_format``.
        """
    def ceil(self) -> Tensor:
        """
        ceil() -> Tensor

        See :func:`torch.ceil`
        """
    def ceil_(self) -> Tensor:
        """
        ceil_() -> Tensor

        In-place version of :meth:`~Tensor.ceil`
        """
    @overload
    def cfloat(self, memory_format=...) -> Tensor:
        """
        cfloat(memory_format=torch.preserve_format) -> Tensor

        ``self.cfloat()`` is equivalent to ``self.to(torch.complex64)``. See :func:`to`.

        Args:
            memory_format (:class:`torch.memory_format`, optional): the desired memory format of
                returned Tensor. Default: ``torch.preserve_format``.
        """
    @overload
    def cfloat(self) -> Any:
        """
        cfloat(memory_format=torch.preserve_format) -> Tensor

        ``self.cfloat()`` is equivalent to ``self.to(torch.complex64)``. See :func:`to`.

        Args:
            memory_format (:class:`torch.memory_format`, optional): the desired memory format of
                returned Tensor. Default: ``torch.preserve_format``.
        """
    @overload
    def chalf(self, memory_format=...) -> Tensor:
        """
        chalf(memory_format=torch.preserve_format) -> Tensor

        ``self.chalf()`` is equivalent to ``self.to(torch.complex32)``. See :func:`to`.

        Args:
             memory_format (:class:`torch.memory_format`, optional): the desired memory format of
                returned Tensor. Default: ``torch.preserve_format``.
 """
    @overload
    def chalf(self) -> Any:
        """
        chalf(memory_format=torch.preserve_format) -> Tensor

        ``self.chalf()`` is equivalent to ``self.to(torch.complex32)``. See :func:`to`.

        Args:
             memory_format (:class:`torch.memory_format`, optional): the desired memory format of
                returned Tensor. Default: ``torch.preserve_format``.
 """
    @overload
    def char(self, memory_format=...) -> Tensor:
        """
        char(memory_format=torch.preserve_format) -> Tensor

        ``self.char()`` is equivalent to ``self.to(torch.int8)``. See :func:`to`.

        Args:
            memory_format (:class:`torch.memory_format`, optional): the desired memory format of
                returned Tensor. Default: ``torch.preserve_format``.
        """
    @overload
    def char(self) -> Any:
        """
        char(memory_format=torch.preserve_format) -> Tensor

        ``self.char()`` is equivalent to ``self.to(torch.int8)``. See :func:`to`.

        Args:
            memory_format (:class:`torch.memory_format`, optional): the desired memory format of
                returned Tensor. Default: ``torch.preserve_format``.
        """
    def cholesky(self, upper=...) -> Tensor:
        """
        cholesky(upper=False) -> Tensor

        See :func:`torch.cholesky`
        """
    def cholesky_inverse(self, upper=...) -> Tensor:
        """
        cholesky_inverse(upper=False) -> Tensor

        See :func:`torch.cholesky_inverse`
        """
    def cholesky_solve(self, input2, upper=...) -> Tensor:
        """
        cholesky_solve(input2, upper=False) -> Tensor

        See :func:`torch.cholesky_solve`
        """
    def chunk(self, chunks, dim=...) -> ListofTensors:
        """
        chunk(chunks, dim=0) -> List of Tensors

        See :func:`torch.chunk`
        """
    def clamp(self, min=..., max=...) -> Tensor:
        """
        clamp(min=None, max=None) -> Tensor

        See :func:`torch.clamp`
        """
    def clamp_(self, min=..., max=...) -> Tensor:
        """
        clamp_(min=None, max=None) -> Tensor

        In-place version of :meth:`~Tensor.clamp`
        """
    def clamp_max(self, *args, **kwargs): ...
    def clamp_max_(self, *args, **kwargs): ...
    def clamp_min(self, *args, **kwargs): ...
    def clamp_min_(self, *args, **kwargs): ...
    def clip(self, min=..., max=...) -> Tensor:
        """
        clip(min=None, max=None) -> Tensor

        Alias for :meth:`~Tensor.clamp`.
        """
    def clip_(self, min=..., max=...) -> Tensor:
        """
        clip_(min=None, max=None) -> Tensor

        Alias for :meth:`~Tensor.clamp_`.
        """
    def clone(self, memory_format=...) -> Tensor:
        """
        clone(*, memory_format=torch.preserve_format) -> Tensor

        See :func:`torch.clone`
        """
    def coalesce(self) -> Tensor:
        """
        coalesce() -> Tensor

        Returns a coalesced copy of :attr:`self` if :attr:`self` is an
        :ref:`uncoalesced tensor <sparse-uncoalesced-coo-docs>`.

        Returns :attr:`self` if :attr:`self` is a coalesced tensor.

        .. warning::
          Throws an error if :attr:`self` is not a sparse COO tensor.
        """
    @overload
    def col_indices(self) -> IntTensor:
        """
        col_indices() -> IntTensor

        Returns the tensor containing the column indices of the :attr:`self`
        tensor when :attr:`self` is a sparse CSR tensor of layout ``sparse_csr``.
        The ``col_indices`` tensor is strictly of shape (:attr:`self`.nnz())
        and of type ``int32`` or ``int64``.  When using MKL routines such as sparse
        matrix multiplication, it is necessary to use ``int32`` indexing in order
        to avoid downcasting and potentially losing information.

        Example::

            >>> csr = torch.eye(5,5).to_sparse_csr()
            >>> csr.col_indices()
            tensor([0, 1, 2, 3, 4], dtype=torch.int32)

        """
    @overload
    def col_indices(self) -> Any:
        """
        col_indices() -> IntTensor

        Returns the tensor containing the column indices of the :attr:`self`
        tensor when :attr:`self` is a sparse CSR tensor of layout ``sparse_csr``.
        The ``col_indices`` tensor is strictly of shape (:attr:`self`.nnz())
        and of type ``int32`` or ``int64``.  When using MKL routines such as sparse
        matrix multiplication, it is necessary to use ``int32`` indexing in order
        to avoid downcasting and potentially losing information.

        Example::

            >>> csr = torch.eye(5,5).to_sparse_csr()
            >>> csr.col_indices()
            tensor([0, 1, 2, 3, 4], dtype=torch.int32)

        """
    def conj(self) -> Tensor:
        """
        conj() -> Tensor

        See :func:`torch.conj`
        """
    def conj_physical(self) -> Tensor:
        """
        conj_physical() -> Tensor

        See :func:`torch.conj_physical`
        """
    def conj_physical_(self) -> Tensor:
        """
        conj_physical_() -> Tensor

        In-place version of :meth:`~Tensor.conj_physical`
        """
    def contiguous(self, memory_format=...) -> Tensor:
        """
        contiguous(memory_format=torch.contiguous_format) -> Tensor

        Returns a contiguous in memory tensor containing the same data as :attr:`self` tensor. If
        :attr:`self` tensor is already in the specified memory format, this function returns the
        :attr:`self` tensor.

        Args:
            memory_format (:class:`torch.memory_format`, optional): the desired memory format of
                returned Tensor. Default: ``torch.contiguous_format``.
        """
    def copy_(self, src, non_blocking=...) -> Tensor:
        """
        copy_(src, non_blocking=False) -> Tensor

        Copies the elements from :attr:`src` into :attr:`self` tensor and returns
        :attr:`self`.

        The :attr:`src` tensor must be :ref:`broadcastable <broadcasting-semantics>`
        with the :attr:`self` tensor. It may be of a different data type or reside on a
        different device.

        Args:
            src (Tensor): the source tensor to copy from
            non_blocking (bool): if ``True`` and this copy is between CPU and GPU,
                the copy may occur asynchronously with respect to the host. For other
                cases, this argument has no effect.
        """
    def copysign(self, other) -> Tensor:
        """
        copysign(other) -> Tensor

        See :func:`torch.copysign`
        """
    def copysign_(self, other) -> Tensor:
        """
        copysign_(other) -> Tensor

        In-place version of :meth:`~Tensor.copysign`
        """
    def corrcoef(self) -> Tensor:
        """
        corrcoef() -> Tensor

        See :func:`torch.corrcoef`
        """
    def cos(self) -> Tensor:
        """
        cos() -> Tensor

        See :func:`torch.cos`
        """
    def cos_(self) -> Tensor:
        """
        cos_() -> Tensor

        In-place version of :meth:`~Tensor.cos`
        """
    def cosh(self) -> Tensor:
        """
        cosh() -> Tensor

        See :func:`torch.cosh`
        """
    def cosh_(self) -> Tensor:
        """
        cosh_() -> Tensor

        In-place version of :meth:`~Tensor.cosh`
        """
    def count_nonzero(self, dim=...) -> Tensor:
        """
        count_nonzero(dim=None) -> Tensor

        See :func:`torch.count_nonzero`
        """
    def cov(self, correction=..., fweights=..., aweights=...) -> Tensor:
        """
        cov(*, correction=1, fweights=None, aweights=None) -> Tensor

        See :func:`torch.cov`
        """
    def cpu(self, memory_format=...) -> Tensor:
        """
        cpu(memory_format=torch.preserve_format) -> Tensor

        Returns a copy of this object in CPU memory.

        If this object is already in CPU memory,
        then no copy is performed and the original object is returned.

        Args:
            memory_format (:class:`torch.memory_format`, optional): the desired memory format of
                returned Tensor. Default: ``torch.preserve_format``.

        """
    def cross(self, other, dim=...) -> Tensor:
        """
        cross(other, dim=None) -> Tensor

        See :func:`torch.cross`
        """
    @overload
    def crow_indices(self) -> IntTensor:
        """
        crow_indices() -> IntTensor

        Returns the tensor containing the compressed row indices of the :attr:`self`
        tensor when :attr:`self` is a sparse CSR tensor of layout ``sparse_csr``.
        The ``crow_indices`` tensor is strictly of shape (:attr:`self`.size(0) + 1)
        and of type ``int32`` or ``int64``. When using MKL routines such as sparse
        matrix multiplication, it is necessary to use ``int32`` indexing in order
        to avoid downcasting and potentially losing information.

        Example::

            >>> csr = torch.eye(5,5).to_sparse_csr()
            >>> csr.crow_indices()
            tensor([0, 1, 2, 3, 4, 5], dtype=torch.int32)

        """
    @overload
    def crow_indices(self) -> Any:
        """
        crow_indices() -> IntTensor

        Returns the tensor containing the compressed row indices of the :attr:`self`
        tensor when :attr:`self` is a sparse CSR tensor of layout ``sparse_csr``.
        The ``crow_indices`` tensor is strictly of shape (:attr:`self`.size(0) + 1)
        and of type ``int32`` or ``int64``. When using MKL routines such as sparse
        matrix multiplication, it is necessary to use ``int32`` indexing in order
        to avoid downcasting and potentially losing information.

        Example::

            >>> csr = torch.eye(5,5).to_sparse_csr()
            >>> csr.crow_indices()
            tensor([0, 1, 2, 3, 4, 5], dtype=torch.int32)

        """
    def cuda(self, device=..., non_blocking=..., memory_format=...) -> Tensor:
        """
        cuda(device=None, non_blocking=False, memory_format=torch.preserve_format) -> Tensor

        Returns a copy of this object in CUDA memory.

        If this object is already in CUDA memory and on the correct device,
        then no copy is performed and the original object is returned.

        Args:
            device (:class:`torch.device`): The destination GPU device.
                Defaults to the current CUDA device.
            non_blocking (bool): If ``True`` and the source is in pinned memory,
                the copy will be asynchronous with respect to the host.
                Otherwise, the argument has no effect. Default: ``False``.
            memory_format (:class:`torch.memory_format`, optional): the desired memory format of
                returned Tensor. Default: ``torch.preserve_format``.
        """
    def cummax(self, *args, **kwargs):
        """
        cummax(dim) -> (Tensor, Tensor)

        See :func:`torch.cummax`
        """
    def cummin(self, *args, **kwargs):
        """
        cummin(dim) -> (Tensor, Tensor)

        See :func:`torch.cummin`
        """
    def cumprod(self, dim, dtype=...) -> Tensor:
        """
        cumprod(dim, dtype=None) -> Tensor

        See :func:`torch.cumprod`
        """
    def cumprod_(self, dim, dtype=...) -> Tensor:
        """
        cumprod_(dim, dtype=None) -> Tensor

        In-place version of :meth:`~Tensor.cumprod`
        """
    def cumsum(self, dim, dtype=...) -> Tensor:
        """
        cumsum(dim, dtype=None) -> Tensor

        See :func:`torch.cumsum`
        """
    def cumsum_(self, dim, dtype=...) -> Tensor:
        """
        cumsum_(dim, dtype=None) -> Tensor

        In-place version of :meth:`~Tensor.cumsum`
        """
    def data_ptr(self) -> int:
        """
        data_ptr() -> int

        Returns the address of the first element of :attr:`self` tensor.
        """
    def deg2rad(self) -> Tensor:
        """
        deg2rad() -> Tensor

        See :func:`torch.deg2rad`
        """
    def deg2rad_(self) -> Tensor:
        """
        deg2rad_() -> Tensor

        In-place version of :meth:`~Tensor.deg2rad`
        """
    def dense_dim(self) -> int:
        """
        dense_dim() -> int

        Return the number of dense dimensions in a :ref:`sparse tensor <sparse-docs>` :attr:`self`.

        .. note::
          Returns ``len(self.shape)`` if :attr:`self` is not a sparse tensor.

        See also :meth:`Tensor.sparse_dim` and :ref:`hybrid tensors <sparse-hybrid-coo-docs>`.
        """
    def dequantize(self) -> Tensor:
        """
        dequantize() -> Tensor

        Given a quantized Tensor, dequantize it and return the dequantized float Tensor.
        """
    def det(self) -> Tensor:
        """
        det() -> Tensor

        See :func:`torch.det`
        """
    def detach(self, *args, **kwargs):
        """
            Returns a new Tensor, detached from the current graph.

            The result will never require gradient.

            This method also affects forward mode AD gradients and the result will never
            have forward mode AD gradients.

            .. note::

              Returned Tensor shares the same storage with the original one.
              In-place modifications on either of them will be seen, and may trigger
              errors in correctness checks.
    """
    def detach_(self, *args, **kwargs):
        """
            Detaches the Tensor from the graph that created it, making it a leaf.
            Views cannot be detached in-place.

            This method also affects forward mode AD gradients and the result will never
            have forward mode AD gradients.
    """
    def diag(self, diagonal=...) -> Tensor:
        """
        diag(diagonal=0) -> Tensor

        See :func:`torch.diag`
        """
    def diag_embed(self, offset=..., dim1=..., dim2=...) -> Tensor:
        """
        diag_embed(offset=0, dim1=-2, dim2=-1) -> Tensor

        See :func:`torch.diag_embed`
        """
    def diagflat(self, offset=...) -> Tensor:
        """
        diagflat(offset=0) -> Tensor

        See :func:`torch.diagflat`
        """
    def diagonal(self, offset=..., dim1=..., dim2=...) -> Tensor:
        """
        diagonal(offset=0, dim1=0, dim2=1) -> Tensor

        See :func:`torch.diagonal`
        """
    def diagonal_scatter(self, src, offset=..., dim1=..., dim2=...) -> Tensor:
        """
        diagonal_scatter(src, offset=0, dim1=0, dim2=1) -> Tensor

        See :func:`torch.diagonal_scatter`
        """
    def diff(self, n=..., dim=..., prepend=..., append=...) -> Tensor:
        """
        diff(n=1, dim=-1, prepend=None, append=None) -> Tensor

        See :func:`torch.diff`
        """
    def digamma(self) -> Tensor:
        """
        digamma() -> Tensor

        See :func:`torch.digamma`
        """
    def digamma_(self) -> Tensor:
        """
        digamma_() -> Tensor

        In-place version of :meth:`~Tensor.digamma`
        """
    def dim(self) -> int:
        """
        dim() -> int

        Returns the number of dimensions of :attr:`self` tensor.
        """
    def dist(self, other, p=...) -> Tensor:
        """
        dist(other, p=2) -> Tensor

        See :func:`torch.dist`
        """
    def div(self, value, rounding_mode=...) -> Tensor:
        """
        div(value, *, rounding_mode=None) -> Tensor

        See :func:`torch.div`
        """
    def div_(self, value, rounding_mode=...) -> Tensor:
        """
        div_(value, *, rounding_mode=None) -> Tensor

        In-place version of :meth:`~Tensor.div`
        """
    def divide(self, value, rounding_mode=...) -> Tensor:
        """
        divide(value, *, rounding_mode=None) -> Tensor

        See :func:`torch.divide`
        """
    def divide_(self, value, rounding_mode=...) -> Tensor:
        """
        divide_(value, *, rounding_mode=None) -> Tensor

        In-place version of :meth:`~Tensor.divide`
        """
    def dot(self, other) -> Tensor:
        """
        dot(other) -> Tensor

        See :func:`torch.dot`
        """
    @overload
    def double(self, memory_format=...) -> Tensor:
        """
        double(memory_format=torch.preserve_format) -> Tensor

        ``self.double()`` is equivalent to ``self.to(torch.float64)``. See :func:`to`.

        Args:
            memory_format (:class:`torch.memory_format`, optional): the desired memory format of
                returned Tensor. Default: ``torch.preserve_format``.
        """
    @overload
    def double(self) -> Any:
        """
        double(memory_format=torch.preserve_format) -> Tensor

        ``self.double()`` is equivalent to ``self.to(torch.float64)``. See :func:`to`.

        Args:
            memory_format (:class:`torch.memory_format`, optional): the desired memory format of
                returned Tensor. Default: ``torch.preserve_format``.
        """
    def dsplit(self, split_size_or_sections) -> ListofTensors:
        """
        dsplit(split_size_or_sections) -> List of Tensors

        See :func:`torch.dsplit`
        """
    @overload
    def element_size(self) -> int:
        """
        element_size() -> int

        Returns the size in bytes of an individual element.

        Example::

            >>> torch.tensor([]).element_size()
            4
            >>> torch.tensor([], dtype=torch.uint8).element_size()
            1

        """
    @overload
    def element_size(self) -> Any:
        """
        element_size() -> int

        Returns the size in bytes of an individual element.

        Example::

            >>> torch.tensor([]).element_size()
            4
            >>> torch.tensor([], dtype=torch.uint8).element_size()
            1

        """
    @overload
    def element_size(self) -> Any:
        """
        element_size() -> int

        Returns the size in bytes of an individual element.

        Example::

            >>> torch.tensor([]).element_size()
            4
            >>> torch.tensor([], dtype=torch.uint8).element_size()
            1

        """
    def eq(self, other) -> Tensor:
        """
        eq(other) -> Tensor

        See :func:`torch.eq`
        """
    def eq_(self, other) -> Tensor:
        """
        eq_(other) -> Tensor

        In-place version of :meth:`~Tensor.eq`
        """
    def equal(self, other) -> bool:
        """
        equal(other) -> bool

        See :func:`torch.equal`
        """
    def erf(self) -> Tensor:
        """
        erf() -> Tensor

        See :func:`torch.erf`
        """
    def erf_(self) -> Tensor:
        """
        erf_() -> Tensor

        In-place version of :meth:`~Tensor.erf`
        """
    def erfc(self) -> Tensor:
        """
        erfc() -> Tensor

        See :func:`torch.erfc`
        """
    def erfc_(self) -> Tensor:
        """
        erfc_() -> Tensor

        In-place version of :meth:`~Tensor.erfc`
        """
    def erfinv(self) -> Tensor:
        """
        erfinv() -> Tensor

        See :func:`torch.erfinv`
        """
    def erfinv_(self) -> Tensor:
        """
        erfinv_() -> Tensor

        In-place version of :meth:`~Tensor.erfinv`
        """
    def exp(self) -> Tensor:
        """
        exp() -> Tensor

        See :func:`torch.exp`
        """
    def exp2(self) -> Tensor:
        """
        exp2() -> Tensor

        See :func:`torch.exp2`
        """
    def exp2_(self) -> Tensor:
        """
        exp2_() -> Tensor

        In-place version of :meth:`~Tensor.exp2`
        """
    def exp_(self) -> Tensor:
        """
        exp_() -> Tensor

        In-place version of :meth:`~Tensor.exp`
        """
    def expand(self, *sizes) -> Tensor:
        """
        expand(*sizes) -> Tensor

        Returns a new view of the :attr:`self` tensor with singleton dimensions expanded
        to a larger size.

        Passing -1 as the size for a dimension means not changing the size of
        that dimension.

        Tensor can be also expanded to a larger number of dimensions, and the
        new ones will be appended at the front. For the new dimensions, the
        size cannot be set to -1.

        Expanding a tensor does not allocate new memory, but only creates a
        new view on the existing tensor where a dimension of size one is
        expanded to a larger size by setting the ``stride`` to 0. Any dimension
        of size 1 can be expanded to an arbitrary value without allocating new
        memory.

        Args:
            *sizes (torch.Size or int...): the desired expanded size

        .. warning::

            More than one element of an expanded tensor may refer to a single
            memory location. As a result, in-place operations (especially ones that
            are vectorized) may result in incorrect behavior. If you need to write
            to the tensors, please clone them first.

        Example::

            >>> x = torch.tensor([[1], [2], [3]])
            >>> x.size()
            torch.Size([3, 1])
            >>> x.expand(3, 4)
            tensor([[ 1,  1,  1,  1],
                    [ 2,  2,  2,  2],
                    [ 3,  3,  3,  3]])
            >>> x.expand(-1, 4)   # -1 means not changing the size of that dimension
            tensor([[ 1,  1,  1,  1],
                    [ 2,  2,  2,  2],
                    [ 3,  3,  3,  3]])
        """
    @overload
    def expand_as(self, other) -> Tensor:
        """
        expand_as(other) -> Tensor

        Expand this tensor to the same size as :attr:`other`.
        ``self.expand_as(other)`` is equivalent to ``self.expand(other.size())``.

        Please see :meth:`~Tensor.expand` for more information about ``expand``.

        Args:
            other (:class:`torch.Tensor`): The result tensor has the same size
                as :attr:`other`.
        """
    @overload
    def expand_as(self, other) -> Any:
        """
        expand_as(other) -> Tensor

        Expand this tensor to the same size as :attr:`other`.
        ``self.expand_as(other)`` is equivalent to ``self.expand(other.size())``.

        Please see :meth:`~Tensor.expand` for more information about ``expand``.

        Args:
            other (:class:`torch.Tensor`): The result tensor has the same size
                as :attr:`other`.
        """
    def expm1(self) -> Tensor:
        """
        expm1() -> Tensor

        See :func:`torch.expm1`
        """
    def expm1_(self) -> Tensor:
        """
        expm1_() -> Tensor

        In-place version of :meth:`~Tensor.expm1`
        """
    def exponential_(self, lambd=..., generator=...) -> Tensor:
        """
        exponential_(lambd=1, *, generator=None) -> Tensor

        Fills :attr:`self` tensor with elements drawn from the PDF (probability density function):

        .. math::

            f(x) = \\lambda e^{-\\lambda x}, x > 0

        .. note::
          In probability theory, exponential distribution is supported on interval [0, :math:`\\inf`) (i.e., :math:`x >= 0`)
          implying that zero can be sampled from the exponential distribution.
          However, :func:`torch.Tensor.exponential_` does not sample zero,
          which means that its actual support is the interval (0, :math:`\\inf`).

          Note that :func:`torch.distributions.exponential.Exponential` is supported on the interval [0, :math:`\\inf`) and can sample zero.
        """
    def fill_(self, value) -> Tensor:
        """
        fill_(value) -> Tensor

        Fills :attr:`self` tensor with the specified value.
        """
    def fill_diagonal_(self, fill_value, wrap=...) -> Tensor:
        """
        fill_diagonal_(fill_value, wrap=False) -> Tensor

        Fill the main diagonal of a tensor that has at least 2-dimensions.
        When dims>2, all dimensions of input must be of equal length.
        This function modifies the input tensor in-place, and returns the input tensor.

        Arguments:
            fill_value (Scalar): the fill value
            wrap (bool): the diagonal 'wrapped' after N columns for tall matrices.

        Example::

            >>> a = torch.zeros(3, 3)
            >>> a.fill_diagonal_(5)
            tensor([[5., 0., 0.],
                    [0., 5., 0.],
                    [0., 0., 5.]])
            >>> b = torch.zeros(7, 3)
            >>> b.fill_diagonal_(5)
            tensor([[5., 0., 0.],
                    [0., 5., 0.],
                    [0., 0., 5.],
                    [0., 0., 0.],
                    [0., 0., 0.],
                    [0., 0., 0.],
                    [0., 0., 0.]])
            >>> c = torch.zeros(7, 3)
            >>> c.fill_diagonal_(5, wrap=True)
            tensor([[5., 0., 0.],
                    [0., 5., 0.],
                    [0., 0., 5.],
                    [0., 0., 0.],
                    [5., 0., 0.],
                    [0., 5., 0.],
                    [0., 0., 5.]])

        """
    def fix(self) -> Tensor:
        """
        fix() -> Tensor

        See :func:`torch.fix`.
        """
    def fix_(self) -> Tensor:
        """
        fix_() -> Tensor

        In-place version of :meth:`~Tensor.fix`
        """
    def flatten(self, start_dim=..., end_dim=...) -> Tensor:
        """
        flatten(start_dim=0, end_dim=-1) -> Tensor

        See :func:`torch.flatten`
        """
    def flip(self, dims) -> Tensor:
        """
        flip(dims) -> Tensor

        See :func:`torch.flip`
        """
    def fliplr(self) -> Tensor:
        """
        fliplr() -> Tensor

        See :func:`torch.fliplr`
        """
    def flipud(self) -> Tensor:
        """
        flipud() -> Tensor

        See :func:`torch.flipud`
        """
    @overload
    def float(self, memory_format=...) -> Tensor:
        """
        float(memory_format=torch.preserve_format) -> Tensor

        ``self.float()`` is equivalent to ``self.to(torch.float32)``. See :func:`to`.

        Args:
            memory_format (:class:`torch.memory_format`, optional): the desired memory format of
                returned Tensor. Default: ``torch.preserve_format``.
        """
    @overload
    def float(self) -> Any:
        """
        float(memory_format=torch.preserve_format) -> Tensor

        ``self.float()`` is equivalent to ``self.to(torch.float32)``. See :func:`to`.

        Args:
            memory_format (:class:`torch.memory_format`, optional): the desired memory format of
                returned Tensor. Default: ``torch.preserve_format``.
        """
    def float_power(self, exponent) -> Tensor:
        """
        float_power(exponent) -> Tensor

        See :func:`torch.float_power`
        """
    def float_power_(self, exponent) -> Tensor:
        """
        float_power_(exponent) -> Tensor

        In-place version of :meth:`~Tensor.float_power`
        """
    def floor(self) -> Tensor:
        """
        floor() -> Tensor

        See :func:`torch.floor`
        """
    def floor_(self) -> Tensor:
        """
        floor_() -> Tensor

        In-place version of :meth:`~Tensor.floor`
        """
    def floor_divide(self, value) -> Tensor:
        """
        floor_divide(value) -> Tensor

        See :func:`torch.floor_divide`
        """
    def floor_divide_(self, value) -> Tensor:
        """
        floor_divide_(value) -> Tensor

        In-place version of :meth:`~Tensor.floor_divide`
        """
    def fmax(self, other) -> Tensor:
        """
        fmax(other) -> Tensor

        See :func:`torch.fmax`
        """
    def fmin(self, other) -> Tensor:
        """
        fmin(other) -> Tensor

        See :func:`torch.fmin`
        """
    def fmod(self, divisor) -> Tensor:
        """
        fmod(divisor) -> Tensor

        See :func:`torch.fmod`
        """
    def fmod_(self, divisor) -> Tensor:
        """
        fmod_(divisor) -> Tensor

        In-place version of :meth:`~Tensor.fmod`
        """
    def frac(self) -> Tensor:
        """
        frac() -> Tensor

        See :func:`torch.frac`
        """
    def frac_(self) -> Tensor:
        """
        frac_() -> Tensor

        In-place version of :meth:`~Tensor.frac`
        """
    def frexp(self, *args, **kwargs):
        """
        frexp(input) -> (Tensor mantissa, Tensor exponent)

        See :func:`torch.frexp`
        """
    def gather(self, dim, index) -> Tensor:
        """
        gather(dim, index) -> Tensor

        See :func:`torch.gather`
        """
    def gcd(self, other) -> Tensor:
        """
        gcd(other) -> Tensor

        See :func:`torch.gcd`
        """
    def gcd_(self, other) -> Tensor:
        """
        gcd_(other) -> Tensor

        In-place version of :meth:`~Tensor.gcd`
        """
    def ge(self, other) -> Tensor:
        """
        ge(other) -> Tensor

        See :func:`torch.ge`.
        """
    def ge_(self, other) -> Tensor:
        """
        ge_(other) -> Tensor

        In-place version of :meth:`~Tensor.ge`.
        """
    def geometric_(self, p, generator=...) -> Tensor:
        """
        geometric_(p, *, generator=None) -> Tensor

        Fills :attr:`self` tensor with elements drawn from the geometric distribution:

        .. math::

            P(X=k) = (1 - p)^{k - 1} p, k = 1, 2, ...

        .. note::
          :func:`torch.Tensor.geometric_` `k`-th trial is the first success hence draws samples in :math:`\\{1, 2, \\ldots\\}`, whereas
          :func:`torch.distributions.geometric.Geometric` :math:`(k+1)`-th trial is the first success
          hence draws samples in :math:`\\{0, 1, \\ldots\\}`.
        """
    def geqrf(self, *args, **kwargs):
        """
        geqrf() -> (Tensor, Tensor)

        See :func:`torch.geqrf`
        """
    def ger(self, vec2) -> Tensor:
        """
        ger(vec2) -> Tensor

        See :func:`torch.ger`
        """
    @overload
    def get_device(self) -> Any:
        """
        get_device() -> Device ordinal (Integer)

        For CUDA tensors, this function returns the device ordinal of the GPU on which the tensor resides.
        For CPU tensors, this function returns `-1`.

        Example::

            >>> x = torch.randn(3, 4, 5, device='cuda:0')
            >>> x.get_device()
            0
            >>> x.cpu().get_device()
            -1
        """
    @overload
    def get_device(self) -> Any:
        """
        get_device() -> Device ordinal (Integer)

        For CUDA tensors, this function returns the device ordinal of the GPU on which the tensor resides.
        For CPU tensors, this function returns `-1`.

        Example::

            >>> x = torch.randn(3, 4, 5, device='cuda:0')
            >>> x.get_device()
            0
            >>> x.cpu().get_device()
            -1
        """
    def greater(self, other) -> Tensor:
        """
        greater(other) -> Tensor

        See :func:`torch.greater`.
        """
    def greater_(self, other) -> Tensor:
        """
        greater_(other) -> Tensor

        In-place version of :meth:`~Tensor.greater`.
        """
    def greater_equal(self, other) -> Tensor:
        """
        greater_equal(other) -> Tensor

        See :func:`torch.greater_equal`.
        """
    def greater_equal_(self, other) -> Tensor:
        """
        greater_equal_(other) -> Tensor

        In-place version of :meth:`~Tensor.greater_equal`.
        """
    def gt(self, other) -> Tensor:
        """
        gt(other) -> Tensor

        See :func:`torch.gt`.
        """
    def gt_(self, other) -> Tensor:
        """
        gt_(other) -> Tensor

        In-place version of :meth:`~Tensor.gt`.
        """
    @overload
    def half(self, memory_format=...) -> Tensor:
        """
        half(memory_format=torch.preserve_format) -> Tensor

        ``self.half()`` is equivalent to ``self.to(torch.float16)``. See :func:`to`.

        Args:
            memory_format (:class:`torch.memory_format`, optional): the desired memory format of
                returned Tensor. Default: ``torch.preserve_format``.
        """
    @overload
    def half(self) -> Any:
        """
        half(memory_format=torch.preserve_format) -> Tensor

        ``self.half()`` is equivalent to ``self.to(torch.float16)``. See :func:`to`.

        Args:
            memory_format (:class:`torch.memory_format`, optional): the desired memory format of
                returned Tensor. Default: ``torch.preserve_format``.
        """
    def hardshrink(self, lambd=...) -> Tensor:
        """
        hardshrink(lambd=0.5) -> Tensor

        See :func:`torch.nn.functional.hardshrink`
        """
    def has_names(self, *args, **kwargs):
        """
        Is ``True`` if any of this tensor's dimensions are named. Otherwise, is ``False``.
        """
    def heaviside(self, values) -> Tensor:
        """
        heaviside(values) -> Tensor

        See :func:`torch.heaviside`
        """
    def heaviside_(self, values) -> Tensor:
        """
        heaviside_(values) -> Tensor

        In-place version of :meth:`~Tensor.heaviside`
        """
    def histc(self, bins=..., min=..., max=...) -> Tensor:
        """
        histc(bins=100, min=0, max=0) -> Tensor

        See :func:`torch.histc`
        """
    def histogram(self, *args, **kwargs):
        """
        histogram(input, bins, *, range=None, weight=None, density=False) -> (Tensor, Tensor)

        See :func:`torch.histogram`
        """
    def hsplit(self, split_size_or_sections) -> ListofTensors:
        """
        hsplit(split_size_or_sections) -> List of Tensors

        See :func:`torch.hsplit`
        """
    def hypot(self, other) -> Tensor:
        """
        hypot(other) -> Tensor

        See :func:`torch.hypot`
        """
    def hypot_(self, other) -> Tensor:
        """
        hypot_(other) -> Tensor

        In-place version of :meth:`~Tensor.hypot`
        """
    def i0(self) -> Tensor:
        """
        i0() -> Tensor

        See :func:`torch.i0`
        """
    def i0_(self) -> Tensor:
        """
        i0_() -> Tensor

        In-place version of :meth:`~Tensor.i0`
        """
    def igamma(self, other) -> Tensor:
        """
        igamma(other) -> Tensor

        See :func:`torch.igamma`
        """
    def igamma_(self, other) -> Tensor:
        """
        igamma_(other) -> Tensor

        In-place version of :meth:`~Tensor.igamma`
        """
    def igammac(self, other) -> Tensor:
        """
        igammac(other) -> Tensor
        See :func:`torch.igammac`
        """
    def igammac_(self, other) -> Tensor:
        """
        igammac_(other) -> Tensor
        In-place version of :meth:`~Tensor.igammac`
        """
    def index_add(self, dim, index, source, alpha=...) -> Tensor:
        """
        index_add(dim, index, source, *, alpha=1) -> Tensor

        Out-of-place version of :meth:`torch.Tensor.index_add_`.
        """
    def index_add_(self, dim, index, source, alpha=...) -> Tensor:
        """
        index_add_(dim, index, source, *, alpha=1) -> Tensor

        Accumulate the elements of :attr:`alpha` times ``source`` into the :attr:`self`
        tensor by adding to the indices in the order given in :attr:`index`. For example,
        if ``dim == 0``, ``index[i] == j``, and ``alpha=-1``, then the ``i``\\ th row of
        ``source`` is subtracted from the ``j``\\ th row of :attr:`self`.

        The :attr:`dim`\\ th dimension of ``source`` must have the same size as the
        length of :attr:`index` (which must be a vector), and all other dimensions must
        match :attr:`self`, or an error will be raised.

        For a 3-D tensor the output is given as::

            self[index[i], :, :] += alpha * src[i, :, :]  # if dim == 0
            self[:, index[i], :] += alpha * src[:, i, :]  # if dim == 1
            self[:, :, index[i]] += alpha * src[:, :, i]  # if dim == 2

        Note:
            This operation may behave nondeterministically when given tensors on a CUDA device. See :doc:`/notes/randomness` for more information.

        Args:
            dim (int): dimension along which to index
            index (Tensor): indices of ``source`` to select from,
                    should have dtype either `torch.int64` or `torch.int32`
            source (Tensor): the tensor containing values to add

        Keyword args:
            alpha (Number): the scalar multiplier for ``source``

        Example::

            >>> x = torch.ones(5, 3)
            >>> t = torch.tensor([[1, 2, 3], [4, 5, 6], [7, 8, 9]], dtype=torch.float)
            >>> index = torch.tensor([0, 4, 2])
            >>> x.index_add_(0, index, t)
            tensor([[  2.,   3.,   4.],
                    [  1.,   1.,   1.],
                    [  8.,   9.,  10.],
                    [  1.,   1.,   1.],
                    [  5.,   6.,   7.]])
            >>> x.index_add_(0, index, t, alpha=-1)
            tensor([[  1.,   1.,   1.],
                    [  1.,   1.,   1.],
                    [  1.,   1.,   1.],
                    [  1.,   1.,   1.],
                    [  1.,   1.,   1.]])
        """
    def index_copy(self, dim, index, tensor2) -> Tensor:
        """
        index_copy(dim, index, tensor2) -> Tensor

        Out-of-place version of :meth:`torch.Tensor.index_copy_`.
        """
    def index_copy_(self, dim, index, tensor) -> Tensor:
        """
        index_copy_(dim, index, tensor) -> Tensor

        Copies the elements of :attr:`tensor` into the :attr:`self` tensor by selecting
        the indices in the order given in :attr:`index`. For example, if ``dim == 0``
        and ``index[i] == j``, then the ``i``\\ th row of :attr:`tensor` is copied to the
        ``j``\\ th row of :attr:`self`.

        The :attr:`dim`\\ th dimension of :attr:`tensor` must have the same size as the
        length of :attr:`index` (which must be a vector), and all other dimensions must
        match :attr:`self`, or an error will be raised.

        .. note::
            If :attr:`index` contains duplicate entries, multiple elements from
            :attr:`tensor` will be copied to the same index of :attr:`self`. The result
            is nondeterministic since it depends on which copy occurs last.

        Args:
            dim (int): dimension along which to index
            index (LongTensor): indices of :attr:`tensor` to select from
            tensor (Tensor): the tensor containing values to copy

        Example::

            >>> x = torch.zeros(5, 3)
            >>> t = torch.tensor([[1, 2, 3], [4, 5, 6], [7, 8, 9]], dtype=torch.float)
            >>> index = torch.tensor([0, 4, 2])
            >>> x.index_copy_(0, index, t)
            tensor([[ 1.,  2.,  3.],
                    [ 0.,  0.,  0.],
                    [ 7.,  8.,  9.],
                    [ 0.,  0.,  0.],
                    [ 4.,  5.,  6.]])
        """
    def index_fill(self, dim, index, value) -> Tensor:
        """
        index_fill(dim, index, value) -> Tensor

        Out-of-place version of :meth:`torch.Tensor.index_fill_`.
        """
    def index_fill_(self, dim, index, value) -> Tensor:
        """
        index_fill_(dim, index, value) -> Tensor

        Fills the elements of the :attr:`self` tensor with value :attr:`value` by
        selecting the indices in the order given in :attr:`index`.

        Args:
            dim (int): dimension along which to index
            index (LongTensor): indices of :attr:`self` tensor to fill in
            value (float): the value to fill with

        Example::

            >>> x = torch.tensor([[1, 2, 3], [4, 5, 6], [7, 8, 9]], dtype=torch.float)
            >>> index = torch.tensor([0, 2])
            >>> x.index_fill_(1, index, -1)
            tensor([[-1.,  2., -1.],
                    [-1.,  5., -1.],
                    [-1.,  8., -1.]])
        """
    def index_put(self, indices, values, accumulate=...) -> Tensor:
        """
        index_put(indices, values, accumulate=False) -> Tensor

        Out-place version of :meth:`~Tensor.index_put_`.
        """
    @overload
    def index_put_(self, indices, values, accumulate=...) -> Tensor:
        """
        index_put_(indices, values, accumulate=False) -> Tensor

        Puts values from the tensor :attr:`values` into the tensor :attr:`self` using
        the indices specified in :attr:`indices` (which is a tuple of Tensors). The
        expression ``tensor.index_put_(indices, values)`` is equivalent to
        ``tensor[indices] = values``. Returns :attr:`self`.

        If :attr:`accumulate` is ``True``, the elements in :attr:`values` are added to
        :attr:`self`. If accumulate is ``False``, the behavior is undefined if indices
        contain duplicate elements.

        Args:
            indices (tuple of LongTensor): tensors used to index into `self`.
            values (Tensor): tensor of same dtype as `self`.
            accumulate (bool): whether to accumulate into self
        """
    @overload
    def index_put_(self, indices, values) -> Any:
        """
        index_put_(indices, values, accumulate=False) -> Tensor

        Puts values from the tensor :attr:`values` into the tensor :attr:`self` using
        the indices specified in :attr:`indices` (which is a tuple of Tensors). The
        expression ``tensor.index_put_(indices, values)`` is equivalent to
        ``tensor[indices] = values``. Returns :attr:`self`.

        If :attr:`accumulate` is ``True``, the elements in :attr:`values` are added to
        :attr:`self`. If accumulate is ``False``, the behavior is undefined if indices
        contain duplicate elements.

        Args:
            indices (tuple of LongTensor): tensors used to index into `self`.
            values (Tensor): tensor of same dtype as `self`.
            accumulate (bool): whether to accumulate into self
        """
    def index_reduce(self, *args, **kwargs): ...
    def index_reduce_(self, dim, index, source, reduce, include_self=...) -> Tensor:
        '''
        index_reduce_(dim, index, source, reduce, *, include_self=True) -> Tensor

        Accumulate the elements of ``source`` into the :attr:`self`
        tensor by accumulating to the indices in the order given in :attr:`index`
        using the reduction given by the ``reduce`` argument. For example, if ``dim == 0``,
        ``index[i] == j``, ``reduce == prod`` and ``include_self == True`` then the ``i``\\ th
        row of ``source`` is multiplied by the ``j``\\ th row of :attr:`self`. If
        :obj:`include_self="True"`, the values in the :attr:`self` tensor are included
        in the reduction, otherwise, rows in the :attr:`self` tensor that are accumulated
        to are treated as if they were filled with the reduction identites.

        The :attr:`dim`\\ th dimension of ``source`` must have the same size as the
        length of :attr:`index` (which must be a vector), and all other dimensions must
        match :attr:`self`, or an error will be raised.

        For a 3-D tensor with :obj:`reduce="prod"` and :obj:`include_self=True` the
        output is given as::

            self[index[i], :, :] *= src[i, :, :]  # if dim == 0
            self[:, index[i], :] *= src[:, i, :]  # if dim == 1
            self[:, :, index[i]] *= src[:, :, i]  # if dim == 2

        Note:
            This operation may behave nondeterministically when given tensors on a CUDA device. See :doc:`/notes/randomness` for more information.

        .. note::

            This function only supports floating point tensors.

        .. warning::

            This function is in beta and may change in the near future.

        Args:
            dim (int): dimension along which to index
            index (Tensor): indices of ``source`` to select from,
                should have dtype either `torch.int64` or `torch.int32`
            source (FloatTensor): the tensor containing values to accumulate
            reduce (str): the reduction operation to apply
                (:obj:`"prod"`, :obj:`"mean"`, :obj:`"amax"`, :obj:`"amin"`)

        Keyword args:
            include_self (bool): whether the elements from the ``self`` tensor are
                included in the reduction

        Example::

            >>> x = torch.empty(5, 3).fill_(2)
            >>> t = torch.tensor([[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12]], dtype=torch.float)
            >>> index = torch.tensor([0, 4, 2, 0])
            >>> x.index_reduce_(0, index, t, \'prod\')
            tensor([[20., 44., 72.],
                    [ 2.,  2.,  2.],
                    [14., 16., 18.],
                    [ 2.,  2.,  2.],
                    [ 8., 10., 12.]])
            >>> x = torch.empty(5, 3).fill_(2)
            >>> x.index_reduce_(0, index, t, \'prod\', include_self=False)
            tensor([[10., 22., 36.],
                    [ 2.,  2.,  2.],
                    [ 7.,  8.,  9.],
                    [ 2.,  2.,  2.],
                    [ 4.,  5.,  6.]])
        '''
    def index_select(self, dim, index) -> Tensor:
        """
        index_select(dim, index) -> Tensor

        See :func:`torch.index_select`
        """
    def indices(self) -> Tensor:
        """
        indices() -> Tensor

        Return the indices tensor of a :ref:`sparse COO tensor <sparse-coo-docs>`.

        .. warning::
          Throws an error if :attr:`self` is not a sparse COO tensor.

        See also :meth:`Tensor.values`.

        .. note::
          This method can only be called on a coalesced sparse tensor. See
          :meth:`Tensor.coalesce` for details.
        """
    def inner(self, other) -> Tensor:
        """
        inner(other) -> Tensor

        See :func:`torch.inner`.
        """
    @overload
    def int(self, memory_format=...) -> Tensor:
        """
        int(memory_format=torch.preserve_format) -> Tensor

        ``self.int()`` is equivalent to ``self.to(torch.int32)``. See :func:`to`.

        Args:
            memory_format (:class:`torch.memory_format`, optional): the desired memory format of
                returned Tensor. Default: ``torch.preserve_format``.
        """
    @overload
    def int(self) -> Any:
        """
        int(memory_format=torch.preserve_format) -> Tensor

        ``self.int()`` is equivalent to ``self.to(torch.int32)``. See :func:`to`.

        Args:
            memory_format (:class:`torch.memory_format`, optional): the desired memory format of
                returned Tensor. Default: ``torch.preserve_format``.
        """
    @overload
    def int_repr(self) -> Tensor:
        """
        int_repr() -> Tensor

        Given a quantized Tensor,
        ``self.int_repr()`` returns a CPU Tensor with uint8_t as data type that stores the
        underlying uint8_t values of the given Tensor.
        """
    @overload
    def int_repr(self) -> Any:
        """
        int_repr() -> Tensor

        Given a quantized Tensor,
        ``self.int_repr()`` returns a CPU Tensor with uint8_t as data type that stores the
        underlying uint8_t values of the given Tensor.
        """
    def inverse(self) -> Tensor:
        """
        inverse() -> Tensor

        See :func:`torch.inverse`
        """
    def ipu(self, device=..., non_blocking=..., memory_format=...) -> Tensor:
        """
        ipu(device=None, non_blocking=False, memory_format=torch.preserve_format) -> Tensor

        Returns a copy of this object in IPU memory.

        If this object is already in IPU memory and on the correct device,
        then no copy is performed and the original object is returned.

        Args:
            device (:class:`torch.device`): The destination IPU device.
                Defaults to the current IPU device.
            non_blocking (bool): If ``True`` and the source is in pinned memory,
                the copy will be asynchronous with respect to the host.
                Otherwise, the argument has no effect. Default: ``False``.
            memory_format (:class:`torch.memory_format`, optional): the desired memory format of
                returned Tensor. Default: ``torch.preserve_format``.
        """
    def is_coalesced(self) -> bool:
        """
        is_coalesced() -> bool

        Returns ``True`` if :attr:`self` is a :ref:`sparse COO tensor
        <sparse-coo-docs>` that is coalesced, ``False`` otherwise.

        .. warning::
          Throws an error if :attr:`self` is not a sparse COO tensor.

        See :meth:`coalesce` and :ref:`uncoalesced tensors <sparse-uncoalesced-coo-docs>`.
        """
    def is_complex(self) -> bool:
        """
        is_complex() -> bool

        Returns True if the data type of :attr:`self` is a complex data type.
        """
    def is_conj(self) -> bool:
        """
        is_conj() -> bool

        Returns True if the conjugate bit of :attr:`self` is set to true.
        """
    def is_contiguous(self, memory_format=...) -> bool:
        """
        is_contiguous(memory_format=torch.contiguous_format) -> bool

        Returns True if :attr:`self` tensor is contiguous in memory in the order specified
        by memory format.

        Args:
            memory_format (:class:`torch.memory_format`, optional): Specifies memory allocation
                order. Default: ``torch.contiguous_format``.
        """
    def is_distributed(self, *args, **kwargs): ...
    def is_floating_point(self) -> bool:
        """
        is_floating_point() -> bool

        Returns True if the data type of :attr:`self` is a floating point data type.
        """
    def is_inference(self) -> bool:
        """
        is_inference() -> bool

        See :func:`torch.is_inference`
        """
    def is_neg(self) -> bool:
        """
        is_neg() -> bool

        Returns True if the negative bit of :attr:`self` is set to true.
        """
    def is_nonzero(self, *args, **kwargs): ...
    def is_pinned(self, *args, **kwargs):
        """
        Returns true if this tensor resides in pinned memory.
        By default, the device pinned memory on will be the current :ref:`accelerator<accelerators>`.
        """
    def is_same_size(self, *args, **kwargs): ...
    def is_set_to(self, tensor) -> bool:
        """
        is_set_to(tensor) -> bool

        Returns True if both tensors are pointing to the exact same memory (same
        storage, offset, size and stride).
        """
    def is_signed(self) -> bool:
        """
        is_signed() -> bool

        Returns True if the data type of :attr:`self` is a signed data type.
        """
    def isclose(self, other, rtol=..., atol=..., equal_nan=...) -> Tensor:
        """
        isclose(other, rtol=1e-05, atol=1e-08, equal_nan=False) -> Tensor

        See :func:`torch.isclose`
        """
    def isfinite(self) -> Tensor:
        """
        isfinite() -> Tensor

        See :func:`torch.isfinite`
        """
    def isinf(self) -> Tensor:
        """
        isinf() -> Tensor

        See :func:`torch.isinf`
        """
    def isnan(self) -> Tensor:
        """
        isnan() -> Tensor

        See :func:`torch.isnan`
        """
    def isneginf(self) -> Tensor:
        """
        isneginf() -> Tensor

        See :func:`torch.isneginf`
        """
    def isposinf(self) -> Tensor:
        """
        isposinf() -> Tensor

        See :func:`torch.isposinf`
        """
    def isreal(self) -> Tensor:
        """
        isreal() -> Tensor

        See :func:`torch.isreal`
        """
    def istft(self, n_fft, hop_length=..., win_length=..., window=..., 
center=..., normalized=..., onesided=..., length=...) -> Tensor:
        """
        istft(n_fft, hop_length=None, win_length=None, window=None,
         center=True, normalized=False, onesided=True, length=None) -> Tensor

        See :func:`torch.istft`
        """
    @overload
    def item(self) -> number:
        """
        item() -> number

        Returns the value of this tensor as a standard Python number. This only works
        for tensors with one element. For other cases, see :meth:`~Tensor.tolist`.

        This operation is not differentiable.

        Example::

            >>> x = torch.tensor([1.0])
            >>> x.item()
            1.0

        """
    @overload
    def item(self) -> Any:
        """
        item() -> number

        Returns the value of this tensor as a standard Python number. This only works
        for tensors with one element. For other cases, see :meth:`~Tensor.tolist`.

        This operation is not differentiable.

        Example::

            >>> x = torch.tensor([1.0])
            >>> x.item()
            1.0

        """
    def kron(self, other) -> Tensor:
        """
        kron(other) -> Tensor

        See :func:`torch.kron`
        """
    def kthvalue(self, *args, **kwargs):
        """
        kthvalue(k, dim=None, keepdim=False) -> (Tensor, LongTensor)

        See :func:`torch.kthvalue`
        """
    def lcm(self, other) -> Tensor:
        """
        lcm(other) -> Tensor

        See :func:`torch.lcm`
        """
    def lcm_(self, other) -> Tensor:
        """
        lcm_(other) -> Tensor

        In-place version of :meth:`~Tensor.lcm`
        """
    def ldexp(self, other) -> Tensor:
        """
        ldexp(other) -> Tensor

        See :func:`torch.ldexp`
        """
    def ldexp_(self, other) -> Tensor:
        """
        ldexp_(other) -> Tensor

        In-place version of :meth:`~Tensor.ldexp`
        """
    def le(self, other) -> Tensor:
        """
        le(other) -> Tensor

        See :func:`torch.le`.
        """
    def le_(self, other) -> Tensor:
        """
        le_(other) -> Tensor

        In-place version of :meth:`~Tensor.le`.
        """
    def lerp(self, end, weight) -> Tensor:
        """
        lerp(end, weight) -> Tensor

        See :func:`torch.lerp`
        """
    def lerp_(self, end, weight) -> Tensor:
        """
        lerp_(end, weight) -> Tensor

        In-place version of :meth:`~Tensor.lerp`
        """
    def less(self, *args, **kwargs):
        """
        lt(other) -> Tensor

        See :func:`torch.less`.
        """
    def less_(self, other) -> Tensor:
        """
        less_(other) -> Tensor

        In-place version of :meth:`~Tensor.less`.
        """
    def less_equal(self, other) -> Tensor:
        """
        less_equal(other) -> Tensor

        See :func:`torch.less_equal`.
        """
    def less_equal_(self, other) -> Tensor:
        """
        less_equal_(other) -> Tensor

        In-place version of :meth:`~Tensor.less_equal`.
        """
    def lgamma(self) -> Tensor:
        """
        lgamma() -> Tensor

        See :func:`torch.lgamma`
        """
    def lgamma_(self) -> Tensor:
        """
        lgamma_() -> Tensor

        In-place version of :meth:`~Tensor.lgamma`
        """
    def log(self) -> Tensor:
        """
        log() -> Tensor

        See :func:`torch.log`
        """
    def log10(self) -> Tensor:
        """
        log10() -> Tensor

        See :func:`torch.log10`
        """
    def log10_(self) -> Tensor:
        """
        log10_() -> Tensor

        In-place version of :meth:`~Tensor.log10`
        """
    def log1p(self) -> Tensor:
        """
        log1p() -> Tensor

        See :func:`torch.log1p`
        """
    def log1p_(self) -> Tensor:
        """
        log1p_() -> Tensor

        In-place version of :meth:`~Tensor.log1p`
        """
    def log2(self) -> Tensor:
        """
        log2() -> Tensor

        See :func:`torch.log2`
        """
    def log2_(self) -> Tensor:
        """
        log2_() -> Tensor

        In-place version of :meth:`~Tensor.log2`
        """
    def log_(self) -> Tensor:
        """
        log_() -> Tensor

        In-place version of :meth:`~Tensor.log`
        """
    def log_normal_(self, mean=..., std=..., generator=...) -> Any:
        """
        log_normal_(mean=1, std=2, *, generator=None)

        Fills :attr:`self` tensor with numbers samples from the log-normal distribution
        parameterized by the given mean :math:`\\mu` and standard deviation
        :math:`\\sigma`. Note that :attr:`mean` and :attr:`std` are the mean and
        standard deviation of the underlying normal distribution, and not of the
        returned distribution:

        .. math::

            f(x) = \\dfrac{1}{x \\sigma \\sqrt{2\\pi}}\\ e^{-\\frac{(\\ln x - \\mu)^2}{2\\sigma^2}}
        """
    def log_softmax(self, *args, **kwargs): ...
    def logaddexp(self, other) -> Tensor:
        """
        logaddexp(other) -> Tensor

        See :func:`torch.logaddexp`
        """
    def logaddexp2(self, other) -> Tensor:
        """
        logaddexp2(other) -> Tensor

        See :func:`torch.logaddexp2`
        """
    def logcumsumexp(self, dim) -> Tensor:
        """
        logcumsumexp(dim) -> Tensor

        See :func:`torch.logcumsumexp`
        """
    def logdet(self) -> Tensor:
        """
        logdet() -> Tensor

        See :func:`torch.logdet`
        """
    def logical_and(self) -> Tensor:
        """
        logical_and() -> Tensor

        See :func:`torch.logical_and`
        """
    def logical_and_(self) -> Tensor:
        """
        logical_and_() -> Tensor

        In-place version of :meth:`~Tensor.logical_and`
        """
    def logical_not(self) -> Tensor:
        """
        logical_not() -> Tensor

        See :func:`torch.logical_not`
        """
    def logical_not_(self) -> Tensor:
        """
        logical_not_() -> Tensor

        In-place version of :meth:`~Tensor.logical_not`
        """
    def logical_or(self) -> Tensor:
        """
        logical_or() -> Tensor

        See :func:`torch.logical_or`
        """
    def logical_or_(self) -> Tensor:
        """
        logical_or_() -> Tensor

        In-place version of :meth:`~Tensor.logical_or`
        """
    def logical_xor(self) -> Tensor:
        """
        logical_xor() -> Tensor

        See :func:`torch.logical_xor`
        """
    def logical_xor_(self) -> Tensor:
        """
        logical_xor_() -> Tensor

        In-place version of :meth:`~Tensor.logical_xor`
        """
    def logit(self) -> Tensor:
        """
        logit() -> Tensor

        See :func:`torch.logit`
        """
    def logit_(self) -> Tensor:
        """
        logit_() -> Tensor

        In-place version of :meth:`~Tensor.logit`
        """
    def logsumexp(self, dim, keepdim=...) -> Tensor:
        """
        logsumexp(dim, keepdim=False) -> Tensor

        See :func:`torch.logsumexp`
        """
    @overload
    def long(self, memory_format=...) -> Tensor:
        """
        long(memory_format=torch.preserve_format) -> Tensor

        ``self.long()`` is equivalent to ``self.to(torch.int64)``. See :func:`to`.

        Args:
            memory_format (:class:`torch.memory_format`, optional): the desired memory format of
                returned Tensor. Default: ``torch.preserve_format``.
        """
    @overload
    def long(self) -> Any:
        """
        long(memory_format=torch.preserve_format) -> Tensor

        ``self.long()`` is equivalent to ``self.to(torch.int64)``. See :func:`to`.

        Args:
            memory_format (:class:`torch.memory_format`, optional): the desired memory format of
                returned Tensor. Default: ``torch.preserve_format``.
        """
    def lt(self, other) -> Tensor:
        """
        lt(other) -> Tensor

        See :func:`torch.lt`.
        """
    def lt_(self, other) -> Tensor:
        """
        lt_(other) -> Tensor

        In-place version of :meth:`~Tensor.lt`.
        """
    def lu_solve(self, LU_data, LU_pivots) -> Tensor:
        """
        lu_solve(LU_data, LU_pivots) -> Tensor

        See :func:`torch.lu_solve`
        """
    def map2_(self, *args, **kwargs): ...
    def map_(self, tensor, callable) -> Any:
        """
        map_(tensor, callable)

        Applies :attr:`callable` for each element in :attr:`self` tensor and the given
        :attr:`tensor` and stores the results in :attr:`self` tensor. :attr:`self` tensor and
        the given :attr:`tensor` must be :ref:`broadcastable <broadcasting-semantics>`.

        The :attr:`callable` should have the signature::

            def callable(a, b) -> number
        """
    def masked_fill(self, mask, value) -> Tensor:
        """
        masked_fill(mask, value) -> Tensor

        Out-of-place version of :meth:`torch.Tensor.masked_fill_`
        """
    def masked_fill_(self, mask, value) -> Any:
        """
        masked_fill_(mask, value)

        Fills elements of :attr:`self` tensor with :attr:`value` where :attr:`mask` is
        True. The shape of :attr:`mask` must be
        :ref:`broadcastable <broadcasting-semantics>` with the shape of the underlying
        tensor.

        Args:
            mask (BoolTensor): the boolean mask
            value (float): the value to fill in with
        """
    @overload
    def masked_scatter(self, mask, tensor) -> Tensor:
        """
        masked_scatter(mask, tensor) -> Tensor

        Out-of-place version of :meth:`torch.Tensor.masked_scatter_`

        .. note::

            The inputs :attr:`self` and :attr:`mask`
            :ref:`broadcast <broadcasting-semantics>`.

        Example:

            >>> self = torch.tensor([0, 0, 0, 0, 0])
            >>> mask = torch.tensor(
            ...     [[0, 0, 0, 1, 1], [1, 1, 0, 1, 1]],
            ...     dtype=torch.bool,
            ... )
            >>> source = torch.tensor([[0, 1, 2, 3, 4], [5, 6, 7, 8, 9]])
            >>> self.masked_scatter(mask, source)
            tensor([[0, 0, 0, 0, 1],
                    [2, 3, 0, 4, 5]])

        """
    @overload
    def masked_scatter(self, mask, source) -> Any:
        """
        masked_scatter(mask, tensor) -> Tensor

        Out-of-place version of :meth:`torch.Tensor.masked_scatter_`

        .. note::

            The inputs :attr:`self` and :attr:`mask`
            :ref:`broadcast <broadcasting-semantics>`.

        Example:

            >>> self = torch.tensor([0, 0, 0, 0, 0])
            >>> mask = torch.tensor(
            ...     [[0, 0, 0, 1, 1], [1, 1, 0, 1, 1]],
            ...     dtype=torch.bool,
            ... )
            >>> source = torch.tensor([[0, 1, 2, 3, 4], [5, 6, 7, 8, 9]])
            >>> self.masked_scatter(mask, source)
            tensor([[0, 0, 0, 0, 1],
                    [2, 3, 0, 4, 5]])

        """
    @overload
    def masked_scatter_(self, mask, source) -> Any:
        """
        masked_scatter_(mask, source)

        Copies elements from :attr:`source` into :attr:`self` tensor at positions where
        the :attr:`mask` is True. Elements from :attr:`source` are copied into :attr:`self`
        starting at position 0 of :attr:`source` and continuing in order one-by-one for each
        occurrence of :attr:`mask` being True.
        The shape of :attr:`mask` must be :ref:`broadcastable <broadcasting-semantics>`
        with the shape of the underlying tensor. The :attr:`source` should have at least
        as many elements as the number of ones in :attr:`mask`.

        Args:
            mask (BoolTensor): the boolean mask
            source (Tensor): the tensor to copy from

        .. note::

            The :attr:`mask` operates on the :attr:`self` tensor, not on the given
            :attr:`source` tensor.

        Example:

            >>> self = torch.tensor([[0, 0, 0, 0, 0], [0, 0, 0, 0, 0]])
            >>> mask = torch.tensor(
            ...     [[0, 0, 0, 1, 1], [1, 1, 0, 1, 1]],
            ...     dtype=torch.bool,
            ... )
            >>> source = torch.tensor([[0, 1, 2, 3, 4], [5, 6, 7, 8, 9]])
            >>> self.masked_scatter_(mask, source)
            tensor([[0, 0, 0, 0, 1],
                    [2, 3, 0, 4, 5]])

        """
    @overload
    def masked_scatter_(self, mask, source) -> Any:
        """
        masked_scatter_(mask, source)

        Copies elements from :attr:`source` into :attr:`self` tensor at positions where
        the :attr:`mask` is True. Elements from :attr:`source` are copied into :attr:`self`
        starting at position 0 of :attr:`source` and continuing in order one-by-one for each
        occurrence of :attr:`mask` being True.
        The shape of :attr:`mask` must be :ref:`broadcastable <broadcasting-semantics>`
        with the shape of the underlying tensor. The :attr:`source` should have at least
        as many elements as the number of ones in :attr:`mask`.

        Args:
            mask (BoolTensor): the boolean mask
            source (Tensor): the tensor to copy from

        .. note::

            The :attr:`mask` operates on the :attr:`self` tensor, not on the given
            :attr:`source` tensor.

        Example:

            >>> self = torch.tensor([[0, 0, 0, 0, 0], [0, 0, 0, 0, 0]])
            >>> mask = torch.tensor(
            ...     [[0, 0, 0, 1, 1], [1, 1, 0, 1, 1]],
            ...     dtype=torch.bool,
            ... )
            >>> source = torch.tensor([[0, 1, 2, 3, 4], [5, 6, 7, 8, 9]])
            >>> self.masked_scatter_(mask, source)
            tensor([[0, 0, 0, 0, 1],
                    [2, 3, 0, 4, 5]])

        """
    def masked_select(self, mask) -> Tensor:
        """
        masked_select(mask) -> Tensor

        See :func:`torch.masked_select`
        """
    def matmul(self, tensor2) -> Tensor:
        """
        matmul(tensor2) -> Tensor

        See :func:`torch.matmul`
        """
    def matrix_exp(self) -> Tensor:
        """
        matrix_exp() -> Tensor

        See :func:`torch.matrix_exp`
        """
    def matrix_power(self, n) -> Tensor:
        """
        matrix_power(n) -> Tensor

        .. note:: :meth:`~Tensor.matrix_power` is deprecated, use :func:`torch.linalg.matrix_power` instead.

        Alias for :func:`torch.linalg.matrix_power`
        """
    def max(self, *args, **kwargs):
        """
        max(dim=None, keepdim=False) -> Tensor or (Tensor, Tensor)

        See :func:`torch.max`
        """
    def maximum(self, other) -> Tensor:
        """
        maximum(other) -> Tensor

        See :func:`torch.maximum`
        """
    def mean(self, dim=..., keepdim=..., dtype=...) -> Tensor:
        """
        mean(dim=None, keepdim=False, *, dtype=None) -> Tensor

        See :func:`torch.mean`
        """
    def median(self, *args, **kwargs):
        """
        median(dim=None, keepdim=False) -> (Tensor, LongTensor)

        See :func:`torch.median`
        """
    def min(self, *args, **kwargs):
        """
        min(dim=None, keepdim=False) -> Tensor or (Tensor, Tensor)

        See :func:`torch.min`
        """
    def minimum(self, other) -> Tensor:
        """
        minimum(other) -> Tensor

        See :func:`torch.minimum`
        """
    def mm(self, mat2) -> Tensor:
        """
        mm(mat2) -> Tensor

        See :func:`torch.mm`
        """
    def mode(self, *args, **kwargs):
        """
        mode(dim=None, keepdim=False) -> (Tensor, LongTensor)

        See :func:`torch.mode`
        """
    def moveaxis(self, source, destination) -> Tensor:
        """
        moveaxis(source, destination) -> Tensor

        See :func:`torch.moveaxis`
        """
    def movedim(self, source, destination) -> Tensor:
        """
        movedim(source, destination) -> Tensor

        See :func:`torch.movedim`
        """
    def msort(self) -> Tensor:
        """
        msort() -> Tensor

        See :func:`torch.msort`
        """
    def mtia(self, device=..., non_blocking=..., memory_format=...) -> Tensor:
        """
        mtia(device=None, non_blocking=False, memory_format=torch.preserve_format) -> Tensor

        Returns a copy of this object in MTIA memory.

        If this object is already in MTIA memory and on the correct device,
        then no copy is performed and the original object is returned.

        Args:
            device (:class:`torch.device`): The destination MTIA device.
                Defaults to the current MTIA device.
            non_blocking (bool): If ``True`` and the source is in pinned memory,
                the copy will be asynchronous with respect to the host.
                Otherwise, the argument has no effect. Default: ``False``.
            memory_format (:class:`torch.memory_format`, optional): the desired memory format of
                returned Tensor. Default: ``torch.preserve_format``.
        """
    def mul(self, value) -> Tensor:
        """
        mul(value) -> Tensor

        See :func:`torch.mul`.
        """
    def mul_(self, value) -> Tensor:
        """
        mul_(value) -> Tensor

        In-place version of :meth:`~Tensor.mul`.
        """
    def multinomial(self, num_samples, replacement=..., generator=...) -> Tensor:
        """
        multinomial(num_samples, replacement=False, *, generator=None) -> Tensor

        See :func:`torch.multinomial`
        """
    def multiply(self, value) -> Tensor:
        """
        multiply(value) -> Tensor

        See :func:`torch.multiply`.
        """
    def multiply_(self, value) -> Tensor:
        """
        multiply_(value) -> Tensor

        In-place version of :meth:`~Tensor.multiply`.
        """
    def mv(self, vec) -> Tensor:
        """
        mv(vec) -> Tensor

        See :func:`torch.mv`
        """
    def mvlgamma(self, p) -> Tensor:
        """
        mvlgamma(p) -> Tensor

        See :func:`torch.mvlgamma`
        """
    def mvlgamma_(self, p) -> Tensor:
        """
        mvlgamma_(p) -> Tensor

        In-place version of :meth:`~Tensor.mvlgamma`
        """
    def nan_to_num(self, nan=..., posinf=..., neginf=...) -> Tensor:
        """
        nan_to_num(nan=0.0, posinf=None, neginf=None) -> Tensor

        See :func:`torch.nan_to_num`.
        """
    def nan_to_num_(self, nan=..., posinf=..., neginf=...) -> Tensor:
        """
        nan_to_num_(nan=0.0, posinf=None, neginf=None) -> Tensor

        In-place version of :meth:`~Tensor.nan_to_num`.
        """
    def nanmean(self, dim=..., keepdim=..., dtype=...) -> Tensor:
        """
        nanmean(dim=None, keepdim=False, *, dtype=None) -> Tensor

        See :func:`torch.nanmean`
        """
    def nanmedian(self, *args, **kwargs):
        """
        nanmedian(dim=None, keepdim=False) -> (Tensor, LongTensor)

        See :func:`torch.nanmedian`
        """
    def nanquantile(self, q, dim=..., keepdim=..., interpolation=...) -> Tensor:
        """
        nanquantile(q, dim=None, keepdim=False, *, interpolation='linear') -> Tensor

        See :func:`torch.nanquantile`
        """
    def nansum(self, dim=..., keepdim=..., dtype=...) -> Tensor:
        """
        nansum(dim=None, keepdim=False, dtype=None) -> Tensor

        See :func:`torch.nansum`
        """
    def narrow(self, dimension, start, length) -> Tensor:
        """
        narrow(dimension, start, length) -> Tensor

        See :func:`torch.narrow`.
        """
    def narrow_copy(self, dimension, start, length) -> Tensor:
        """
        narrow_copy(dimension, start, length) -> Tensor

        See :func:`torch.narrow_copy`.
        """
    def ndimension(self) -> int:
        """
        ndimension() -> int

        Alias for :meth:`~Tensor.dim()`
        """
    def ne(self, other) -> Tensor:
        """
        ne(other) -> Tensor

        See :func:`torch.ne`.
        """
    def ne_(self, other) -> Tensor:
        """
        ne_(other) -> Tensor

        In-place version of :meth:`~Tensor.ne`.
        """
    def neg(self) -> Tensor:
        """
        neg() -> Tensor

        See :func:`torch.neg`
        """
    def neg_(self) -> Tensor:
        """
        neg_() -> Tensor

        In-place version of :meth:`~Tensor.neg`
        """
    def negative(self) -> Tensor:
        """
        negative() -> Tensor

        See :func:`torch.negative`
        """
    def negative_(self) -> Tensor:
        """
        negative_() -> Tensor

        In-place version of :meth:`~Tensor.negative`
        """
    def nelement(self) -> int:
        """
        nelement() -> int

        Alias for :meth:`~Tensor.numel`
        """
    def new(self, *args, **kwargs): ...
    def new_empty(self, size, dtype=..., device=..., requires_grad=..., layout=..., pin_memory=...) -> Tensor:
        """
        new_empty(size, *, dtype=None, device=None, requires_grad=False, layout=torch.strided, pin_memory=False) -> Tensor


        Returns a Tensor of size :attr:`size` filled with uninitialized data.
        By default, the returned Tensor has the same :class:`torch.dtype` and
        :class:`torch.device` as this tensor.

        Args:
            size (int...): a list, tuple, or :class:`torch.Size` of integers defining the
                shape of the output tensor.

        Keyword args:
            dtype (:class:`torch.dtype`, optional): the desired type of returned tensor.
                Default: if None, same :class:`torch.dtype` as this tensor.
            device (:class:`torch.device`, optional): the desired device of returned tensor.
                Default: if None, same :class:`torch.device` as this tensor.
            requires_grad (bool, optional): If autograd should record operations on the
                returned tensor. Default: ``False``.
            layout (:class:`torch.layout`, optional): the desired layout of returned Tensor.
                Default: ``torch.strided``.
            pin_memory (bool, optional): If set, returned tensor would be allocated in
                the pinned memory. Works only for CPU tensors. Default: ``False``.

        Example::

            >>> tensor = torch.ones(())
            >>> tensor.new_empty((2, 3))
            tensor([[ 5.8182e-18,  4.5765e-41, -1.0545e+30],
                    [ 3.0949e-41,  4.4842e-44,  0.0000e+00]])

        """
    def new_empty_strided(self, size, stride, dtype=..., device=..., requires_grad=..., layout=..., pin_memory=...) -> Tensor:
        """
        new_empty_strided(size, stride, dtype=None, device=None, requires_grad=False, layout=torch.strided, pin_memory=False) -> Tensor


        Returns a Tensor of size :attr:`size` and strides :attr:`stride` filled with
        uninitialized data. By default, the returned Tensor has the same
        :class:`torch.dtype` and :class:`torch.device` as this tensor.

        Args:
            size (int...): a list, tuple, or :class:`torch.Size` of integers defining the
                shape of the output tensor.

        Keyword args:
            dtype (:class:`torch.dtype`, optional): the desired type of returned tensor.
                Default: if None, same :class:`torch.dtype` as this tensor.
            device (:class:`torch.device`, optional): the desired device of returned tensor.
                Default: if None, same :class:`torch.device` as this tensor.
            requires_grad (bool, optional): If autograd should record operations on the
                returned tensor. Default: ``False``.
            layout (:class:`torch.layout`, optional): the desired layout of returned Tensor.
                Default: ``torch.strided``.
            pin_memory (bool, optional): If set, returned tensor would be allocated in
                the pinned memory. Works only for CPU tensors. Default: ``False``.

        Example::

            >>> tensor = torch.ones(())
            >>> tensor.new_empty_strided((2, 3), (3, 1))
            tensor([[ 5.8182e-18,  4.5765e-41, -1.0545e+30],
                    [ 3.0949e-41,  4.4842e-44,  0.0000e+00]])

        """
    def new_full(self, size, fill_value, dtype=..., device=..., requires_grad=..., layout=..., pin_memory=...) -> Tensor:
        """
        new_full(size, fill_value, *, dtype=None, device=None, requires_grad=False, layout=torch.strided, pin_memory=False) -> Tensor


        Returns a Tensor of size :attr:`size` filled with :attr:`fill_value`.
        By default, the returned Tensor has the same :class:`torch.dtype` and
        :class:`torch.device` as this tensor.

        Args:
            fill_value (scalar): the number to fill the output tensor with.

        Keyword args:
            dtype (:class:`torch.dtype`, optional): the desired type of returned tensor.
                Default: if None, same :class:`torch.dtype` as this tensor.
            device (:class:`torch.device`, optional): the desired device of returned tensor.
                Default: if None, same :class:`torch.device` as this tensor.
            requires_grad (bool, optional): If autograd should record operations on the
                returned tensor. Default: ``False``.
            layout (:class:`torch.layout`, optional): the desired layout of returned Tensor.
                Default: ``torch.strided``.
            pin_memory (bool, optional): If set, returned tensor would be allocated in
                the pinned memory. Works only for CPU tensors. Default: ``False``.

        Example::

            >>> tensor = torch.ones((2,), dtype=torch.float64)
            >>> tensor.new_full((3, 4), 3.141592)
            tensor([[ 3.1416,  3.1416,  3.1416,  3.1416],
                    [ 3.1416,  3.1416,  3.1416,  3.1416],
                    [ 3.1416,  3.1416,  3.1416,  3.1416]], dtype=torch.float64)

        """
    def new_ones(self, size, dtype=..., device=..., requires_grad=..., layout=..., pin_memory=...) -> Tensor:
        """
        new_ones(size, *, dtype=None, device=None, requires_grad=False, layout=torch.strided, pin_memory=False) -> Tensor


        Returns a Tensor of size :attr:`size` filled with ``1``.
        By default, the returned Tensor has the same :class:`torch.dtype` and
        :class:`torch.device` as this tensor.

        Args:
            size (int...): a list, tuple, or :class:`torch.Size` of integers defining the
                shape of the output tensor.

        Keyword args:
            dtype (:class:`torch.dtype`, optional): the desired type of returned tensor.
                Default: if None, same :class:`torch.dtype` as this tensor.
            device (:class:`torch.device`, optional): the desired device of returned tensor.
                Default: if None, same :class:`torch.device` as this tensor.
            requires_grad (bool, optional): If autograd should record operations on the
                returned tensor. Default: ``False``.
            layout (:class:`torch.layout`, optional): the desired layout of returned Tensor.
                Default: ``torch.strided``.
            pin_memory (bool, optional): If set, returned tensor would be allocated in
                the pinned memory. Works only for CPU tensors. Default: ``False``.

        Example::

            >>> tensor = torch.tensor((), dtype=torch.int32)
            >>> tensor.new_ones((2, 3))
            tensor([[ 1,  1,  1],
                    [ 1,  1,  1]], dtype=torch.int32)

        """
    @overload
    def new_tensor(self, data, dtype=..., device=..., requires_grad=..., layout=..., pin_memory=...) -> Tensor:
        """
        new_tensor(data, *, dtype=None, device=None, requires_grad=False, layout=torch.strided, pin_memory=False) -> Tensor


        Returns a new Tensor with :attr:`data` as the tensor data.
        By default, the returned Tensor has the same :class:`torch.dtype` and
        :class:`torch.device` as this tensor.

        .. warning::

            :func:`new_tensor` always copies :attr:`data`. If you have a Tensor
            ``data`` and want to avoid a copy, use :func:`torch.Tensor.requires_grad_`
            or :func:`torch.Tensor.detach`.
            If you have a numpy array and want to avoid a copy, use
            :func:`torch.from_numpy`.

        .. warning::

            When data is a tensor `x`, :func:`new_tensor()` reads out 'the data' from whatever it is passed,
            and constructs a leaf variable. Therefore ``tensor.new_tensor(x)`` is equivalent to ``x.detach().clone()``
            and ``tensor.new_tensor(x, requires_grad=True)`` is equivalent to ``x.detach().clone().requires_grad_(True)``.
            The equivalents using ``detach()`` and ``clone()`` are recommended.

        Args:
            data (array_like): The returned Tensor copies :attr:`data`.

        Keyword args:
            dtype (:class:`torch.dtype`, optional): the desired type of returned tensor.
                Default: if None, same :class:`torch.dtype` as this tensor.
            device (:class:`torch.device`, optional): the desired device of returned tensor.
                Default: if None, same :class:`torch.device` as this tensor.
            requires_grad (bool, optional): If autograd should record operations on the
                returned tensor. Default: ``False``.
            layout (:class:`torch.layout`, optional): the desired layout of returned Tensor.
                Default: ``torch.strided``.
            pin_memory (bool, optional): If set, returned tensor would be allocated in
                the pinned memory. Works only for CPU tensors. Default: ``False``.

        Example::

            >>> tensor = torch.ones((2,), dtype=torch.int8)
            >>> data = [[0, 1], [2, 3]]
            >>> tensor.new_tensor(data)
            tensor([[ 0,  1],
                    [ 2,  3]], dtype=torch.int8)

        """
    @overload
    def new_tensor(self) -> Any:
        """
        new_tensor(data, *, dtype=None, device=None, requires_grad=False, layout=torch.strided, pin_memory=False) -> Tensor


        Returns a new Tensor with :attr:`data` as the tensor data.
        By default, the returned Tensor has the same :class:`torch.dtype` and
        :class:`torch.device` as this tensor.

        .. warning::

            :func:`new_tensor` always copies :attr:`data`. If you have a Tensor
            ``data`` and want to avoid a copy, use :func:`torch.Tensor.requires_grad_`
            or :func:`torch.Tensor.detach`.
            If you have a numpy array and want to avoid a copy, use
            :func:`torch.from_numpy`.

        .. warning::

            When data is a tensor `x`, :func:`new_tensor()` reads out 'the data' from whatever it is passed,
            and constructs a leaf variable. Therefore ``tensor.new_tensor(x)`` is equivalent to ``x.detach().clone()``
            and ``tensor.new_tensor(x, requires_grad=True)`` is equivalent to ``x.detach().clone().requires_grad_(True)``.
            The equivalents using ``detach()`` and ``clone()`` are recommended.

        Args:
            data (array_like): The returned Tensor copies :attr:`data`.

        Keyword args:
            dtype (:class:`torch.dtype`, optional): the desired type of returned tensor.
                Default: if None, same :class:`torch.dtype` as this tensor.
            device (:class:`torch.device`, optional): the desired device of returned tensor.
                Default: if None, same :class:`torch.device` as this tensor.
            requires_grad (bool, optional): If autograd should record operations on the
                returned tensor. Default: ``False``.
            layout (:class:`torch.layout`, optional): the desired layout of returned Tensor.
                Default: ``torch.strided``.
            pin_memory (bool, optional): If set, returned tensor would be allocated in
                the pinned memory. Works only for CPU tensors. Default: ``False``.

        Example::

            >>> tensor = torch.ones((2,), dtype=torch.int8)
            >>> data = [[0, 1], [2, 3]]
            >>> tensor.new_tensor(data)
            tensor([[ 0,  1],
                    [ 2,  3]], dtype=torch.int8)

        """
    @overload
    def new_tensor(self, x) -> Any:
        """
        new_tensor(data, *, dtype=None, device=None, requires_grad=False, layout=torch.strided, pin_memory=False) -> Tensor


        Returns a new Tensor with :attr:`data` as the tensor data.
        By default, the returned Tensor has the same :class:`torch.dtype` and
        :class:`torch.device` as this tensor.

        .. warning::

            :func:`new_tensor` always copies :attr:`data`. If you have a Tensor
            ``data`` and want to avoid a copy, use :func:`torch.Tensor.requires_grad_`
            or :func:`torch.Tensor.detach`.
            If you have a numpy array and want to avoid a copy, use
            :func:`torch.from_numpy`.

        .. warning::

            When data is a tensor `x`, :func:`new_tensor()` reads out 'the data' from whatever it is passed,
            and constructs a leaf variable. Therefore ``tensor.new_tensor(x)`` is equivalent to ``x.detach().clone()``
            and ``tensor.new_tensor(x, requires_grad=True)`` is equivalent to ``x.detach().clone().requires_grad_(True)``.
            The equivalents using ``detach()`` and ``clone()`` are recommended.

        Args:
            data (array_like): The returned Tensor copies :attr:`data`.

        Keyword args:
            dtype (:class:`torch.dtype`, optional): the desired type of returned tensor.
                Default: if None, same :class:`torch.dtype` as this tensor.
            device (:class:`torch.device`, optional): the desired device of returned tensor.
                Default: if None, same :class:`torch.device` as this tensor.
            requires_grad (bool, optional): If autograd should record operations on the
                returned tensor. Default: ``False``.
            layout (:class:`torch.layout`, optional): the desired layout of returned Tensor.
                Default: ``torch.strided``.
            pin_memory (bool, optional): If set, returned tensor would be allocated in
                the pinned memory. Works only for CPU tensors. Default: ``False``.

        Example::

            >>> tensor = torch.ones((2,), dtype=torch.int8)
            >>> data = [[0, 1], [2, 3]]
            >>> tensor.new_tensor(data)
            tensor([[ 0,  1],
                    [ 2,  3]], dtype=torch.int8)

        """
    @overload
    def new_tensor(self, x, requires_grad=...) -> Any:
        """
        new_tensor(data, *, dtype=None, device=None, requires_grad=False, layout=torch.strided, pin_memory=False) -> Tensor


        Returns a new Tensor with :attr:`data` as the tensor data.
        By default, the returned Tensor has the same :class:`torch.dtype` and
        :class:`torch.device` as this tensor.

        .. warning::

            :func:`new_tensor` always copies :attr:`data`. If you have a Tensor
            ``data`` and want to avoid a copy, use :func:`torch.Tensor.requires_grad_`
            or :func:`torch.Tensor.detach`.
            If you have a numpy array and want to avoid a copy, use
            :func:`torch.from_numpy`.

        .. warning::

            When data is a tensor `x`, :func:`new_tensor()` reads out 'the data' from whatever it is passed,
            and constructs a leaf variable. Therefore ``tensor.new_tensor(x)`` is equivalent to ``x.detach().clone()``
            and ``tensor.new_tensor(x, requires_grad=True)`` is equivalent to ``x.detach().clone().requires_grad_(True)``.
            The equivalents using ``detach()`` and ``clone()`` are recommended.

        Args:
            data (array_like): The returned Tensor copies :attr:`data`.

        Keyword args:
            dtype (:class:`torch.dtype`, optional): the desired type of returned tensor.
                Default: if None, same :class:`torch.dtype` as this tensor.
            device (:class:`torch.device`, optional): the desired device of returned tensor.
                Default: if None, same :class:`torch.device` as this tensor.
            requires_grad (bool, optional): If autograd should record operations on the
                returned tensor. Default: ``False``.
            layout (:class:`torch.layout`, optional): the desired layout of returned Tensor.
                Default: ``torch.strided``.
            pin_memory (bool, optional): If set, returned tensor would be allocated in
                the pinned memory. Works only for CPU tensors. Default: ``False``.

        Example::

            >>> tensor = torch.ones((2,), dtype=torch.int8)
            >>> data = [[0, 1], [2, 3]]
            >>> tensor.new_tensor(data)
            tensor([[ 0,  1],
                    [ 2,  3]], dtype=torch.int8)

        """
    @overload
    def new_tensor(self, data) -> Any:
        """
        new_tensor(data, *, dtype=None, device=None, requires_grad=False, layout=torch.strided, pin_memory=False) -> Tensor


        Returns a new Tensor with :attr:`data` as the tensor data.
        By default, the returned Tensor has the same :class:`torch.dtype` and
        :class:`torch.device` as this tensor.

        .. warning::

            :func:`new_tensor` always copies :attr:`data`. If you have a Tensor
            ``data`` and want to avoid a copy, use :func:`torch.Tensor.requires_grad_`
            or :func:`torch.Tensor.detach`.
            If you have a numpy array and want to avoid a copy, use
            :func:`torch.from_numpy`.

        .. warning::

            When data is a tensor `x`, :func:`new_tensor()` reads out 'the data' from whatever it is passed,
            and constructs a leaf variable. Therefore ``tensor.new_tensor(x)`` is equivalent to ``x.detach().clone()``
            and ``tensor.new_tensor(x, requires_grad=True)`` is equivalent to ``x.detach().clone().requires_grad_(True)``.
            The equivalents using ``detach()`` and ``clone()`` are recommended.

        Args:
            data (array_like): The returned Tensor copies :attr:`data`.

        Keyword args:
            dtype (:class:`torch.dtype`, optional): the desired type of returned tensor.
                Default: if None, same :class:`torch.dtype` as this tensor.
            device (:class:`torch.device`, optional): the desired device of returned tensor.
                Default: if None, same :class:`torch.device` as this tensor.
            requires_grad (bool, optional): If autograd should record operations on the
                returned tensor. Default: ``False``.
            layout (:class:`torch.layout`, optional): the desired layout of returned Tensor.
                Default: ``torch.strided``.
            pin_memory (bool, optional): If set, returned tensor would be allocated in
                the pinned memory. Works only for CPU tensors. Default: ``False``.

        Example::

            >>> tensor = torch.ones((2,), dtype=torch.int8)
            >>> data = [[0, 1], [2, 3]]
            >>> tensor.new_tensor(data)
            tensor([[ 0,  1],
                    [ 2,  3]], dtype=torch.int8)

        """
    def new_zeros(self, size, dtype=..., device=..., requires_grad=..., layout=..., pin_memory=...) -> Tensor:
        """
        new_zeros(size, *, dtype=None, device=None, requires_grad=False, layout=torch.strided, pin_memory=False) -> Tensor


        Returns a Tensor of size :attr:`size` filled with ``0``.
        By default, the returned Tensor has the same :class:`torch.dtype` and
        :class:`torch.device` as this tensor.

        Args:
            size (int...): a list, tuple, or :class:`torch.Size` of integers defining the
                shape of the output tensor.

        Keyword args:
            dtype (:class:`torch.dtype`, optional): the desired type of returned tensor.
                Default: if None, same :class:`torch.dtype` as this tensor.
            device (:class:`torch.device`, optional): the desired device of returned tensor.
                Default: if None, same :class:`torch.device` as this tensor.
            requires_grad (bool, optional): If autograd should record operations on the
                returned tensor. Default: ``False``.
            layout (:class:`torch.layout`, optional): the desired layout of returned Tensor.
                Default: ``torch.strided``.
            pin_memory (bool, optional): If set, returned tensor would be allocated in
                the pinned memory. Works only for CPU tensors. Default: ``False``.

        Example::

            >>> tensor = torch.tensor((), dtype=torch.float64)
            >>> tensor.new_zeros((2, 3))
            tensor([[ 0.,  0.,  0.],
                    [ 0.,  0.,  0.]], dtype=torch.float64)

        """
    def nextafter(self, other) -> Tensor:
        """
        nextafter(other) -> Tensor
        See :func:`torch.nextafter`
        """
    def nextafter_(self, other) -> Tensor:
        """
        nextafter_(other) -> Tensor
        In-place version of :meth:`~Tensor.nextafter`
        """
    def nonzero(self) -> LongTensor:
        """
        nonzero() -> LongTensor

        See :func:`torch.nonzero`
        """
    @overload
    def nonzero_static(self, input, size, fill_value=...) -> Tensor:
        """
        nonzero_static(input, *, size, fill_value=-1) -> Tensor

        Returns a 2-D tensor where each row is the index for a non-zero value.
        The returned Tensor has the same `torch.dtype` as `torch.nonzero()`.

        Args:
            input (Tensor): the input tensor to count non-zero elements.

        Keyword args:
            size (int): the size of non-zero elements expected to be included in the out
                tensor. Pad the out tensor with `fill_value` if the `size` is larger
                than total number of non-zero elements, truncate out tensor if `size`
                is smaller. The size must be a non-negative integer.
            fill_value (int): the value to fill the output tensor with when `size` is larger
                than the total number of non-zero elements. Default is `-1` to represent
                invalid index.

        Example:

            # Example 1: Padding
            >>> input_tensor = torch.tensor([[1, 0], [3, 2]])
            >>> static_size = 4
            >>> t = torch.nonzero_static(input_tensor, size=static_size)
            tensor([[  0,   0],
                    [  1,   0],
                    [  1,   1],
                    [  -1, -1]], dtype=torch.int64)

            # Example 2: Truncating
            >>> input_tensor = torch.tensor([[1, 0], [3, 2]])
            >>> static_size = 2
            >>> t = torch.nonzero_static(input_tensor, size=static_size)
            tensor([[  0,   0],
                    [  1,   0]], dtype=torch.int64)

            # Example 3: 0 size
            >>> input_tensor = torch.tensor([10])
            >>> static_size = 0
            >>> t = torch.nonzero_static(input_tensor, size=static_size)
            tensor([], size=(0, 1), dtype=torch.int64)

            # Example 4: 0 rank input
            >>> input_tensor = torch.tensor(10)
            >>> static_size = 2
            >>> t = torch.nonzero_static(input_tensor, size=static_size)
            tensor([], size=(2, 0), dtype=torch.int64)
        """
    @overload
    def nonzero_static(self, input_tensor, size=...) -> Any:
        """
        nonzero_static(input, *, size, fill_value=-1) -> Tensor

        Returns a 2-D tensor where each row is the index for a non-zero value.
        The returned Tensor has the same `torch.dtype` as `torch.nonzero()`.

        Args:
            input (Tensor): the input tensor to count non-zero elements.

        Keyword args:
            size (int): the size of non-zero elements expected to be included in the out
                tensor. Pad the out tensor with `fill_value` if the `size` is larger
                than total number of non-zero elements, truncate out tensor if `size`
                is smaller. The size must be a non-negative integer.
            fill_value (int): the value to fill the output tensor with when `size` is larger
                than the total number of non-zero elements. Default is `-1` to represent
                invalid index.

        Example:

            # Example 1: Padding
            >>> input_tensor = torch.tensor([[1, 0], [3, 2]])
            >>> static_size = 4
            >>> t = torch.nonzero_static(input_tensor, size=static_size)
            tensor([[  0,   0],
                    [  1,   0],
                    [  1,   1],
                    [  -1, -1]], dtype=torch.int64)

            # Example 2: Truncating
            >>> input_tensor = torch.tensor([[1, 0], [3, 2]])
            >>> static_size = 2
            >>> t = torch.nonzero_static(input_tensor, size=static_size)
            tensor([[  0,   0],
                    [  1,   0]], dtype=torch.int64)

            # Example 3: 0 size
            >>> input_tensor = torch.tensor([10])
            >>> static_size = 0
            >>> t = torch.nonzero_static(input_tensor, size=static_size)
            tensor([], size=(0, 1), dtype=torch.int64)

            # Example 4: 0 rank input
            >>> input_tensor = torch.tensor(10)
            >>> static_size = 2
            >>> t = torch.nonzero_static(input_tensor, size=static_size)
            tensor([], size=(2, 0), dtype=torch.int64)
        """
    @overload
    def nonzero_static(self, input_tensor, size=...) -> Any:
        """
        nonzero_static(input, *, size, fill_value=-1) -> Tensor

        Returns a 2-D tensor where each row is the index for a non-zero value.
        The returned Tensor has the same `torch.dtype` as `torch.nonzero()`.

        Args:
            input (Tensor): the input tensor to count non-zero elements.

        Keyword args:
            size (int): the size of non-zero elements expected to be included in the out
                tensor. Pad the out tensor with `fill_value` if the `size` is larger
                than total number of non-zero elements, truncate out tensor if `size`
                is smaller. The size must be a non-negative integer.
            fill_value (int): the value to fill the output tensor with when `size` is larger
                than the total number of non-zero elements. Default is `-1` to represent
                invalid index.

        Example:

            # Example 1: Padding
            >>> input_tensor = torch.tensor([[1, 0], [3, 2]])
            >>> static_size = 4
            >>> t = torch.nonzero_static(input_tensor, size=static_size)
            tensor([[  0,   0],
                    [  1,   0],
                    [  1,   1],
                    [  -1, -1]], dtype=torch.int64)

            # Example 2: Truncating
            >>> input_tensor = torch.tensor([[1, 0], [3, 2]])
            >>> static_size = 2
            >>> t = torch.nonzero_static(input_tensor, size=static_size)
            tensor([[  0,   0],
                    [  1,   0]], dtype=torch.int64)

            # Example 3: 0 size
            >>> input_tensor = torch.tensor([10])
            >>> static_size = 0
            >>> t = torch.nonzero_static(input_tensor, size=static_size)
            tensor([], size=(0, 1), dtype=torch.int64)

            # Example 4: 0 rank input
            >>> input_tensor = torch.tensor(10)
            >>> static_size = 2
            >>> t = torch.nonzero_static(input_tensor, size=static_size)
            tensor([], size=(2, 0), dtype=torch.int64)
        """
    @overload
    def nonzero_static(self, input_tensor, size=...) -> Any:
        """
        nonzero_static(input, *, size, fill_value=-1) -> Tensor

        Returns a 2-D tensor where each row is the index for a non-zero value.
        The returned Tensor has the same `torch.dtype` as `torch.nonzero()`.

        Args:
            input (Tensor): the input tensor to count non-zero elements.

        Keyword args:
            size (int): the size of non-zero elements expected to be included in the out
                tensor. Pad the out tensor with `fill_value` if the `size` is larger
                than total number of non-zero elements, truncate out tensor if `size`
                is smaller. The size must be a non-negative integer.
            fill_value (int): the value to fill the output tensor with when `size` is larger
                than the total number of non-zero elements. Default is `-1` to represent
                invalid index.

        Example:

            # Example 1: Padding
            >>> input_tensor = torch.tensor([[1, 0], [3, 2]])
            >>> static_size = 4
            >>> t = torch.nonzero_static(input_tensor, size=static_size)
            tensor([[  0,   0],
                    [  1,   0],
                    [  1,   1],
                    [  -1, -1]], dtype=torch.int64)

            # Example 2: Truncating
            >>> input_tensor = torch.tensor([[1, 0], [3, 2]])
            >>> static_size = 2
            >>> t = torch.nonzero_static(input_tensor, size=static_size)
            tensor([[  0,   0],
                    [  1,   0]], dtype=torch.int64)

            # Example 3: 0 size
            >>> input_tensor = torch.tensor([10])
            >>> static_size = 0
            >>> t = torch.nonzero_static(input_tensor, size=static_size)
            tensor([], size=(0, 1), dtype=torch.int64)

            # Example 4: 0 rank input
            >>> input_tensor = torch.tensor(10)
            >>> static_size = 2
            >>> t = torch.nonzero_static(input_tensor, size=static_size)
            tensor([], size=(2, 0), dtype=torch.int64)
        """
    @overload
    def nonzero_static(self, input_tensor, size=...) -> Any:
        """
        nonzero_static(input, *, size, fill_value=-1) -> Tensor

        Returns a 2-D tensor where each row is the index for a non-zero value.
        The returned Tensor has the same `torch.dtype` as `torch.nonzero()`.

        Args:
            input (Tensor): the input tensor to count non-zero elements.

        Keyword args:
            size (int): the size of non-zero elements expected to be included in the out
                tensor. Pad the out tensor with `fill_value` if the `size` is larger
                than total number of non-zero elements, truncate out tensor if `size`
                is smaller. The size must be a non-negative integer.
            fill_value (int): the value to fill the output tensor with when `size` is larger
                than the total number of non-zero elements. Default is `-1` to represent
                invalid index.

        Example:

            # Example 1: Padding
            >>> input_tensor = torch.tensor([[1, 0], [3, 2]])
            >>> static_size = 4
            >>> t = torch.nonzero_static(input_tensor, size=static_size)
            tensor([[  0,   0],
                    [  1,   0],
                    [  1,   1],
                    [  -1, -1]], dtype=torch.int64)

            # Example 2: Truncating
            >>> input_tensor = torch.tensor([[1, 0], [3, 2]])
            >>> static_size = 2
            >>> t = torch.nonzero_static(input_tensor, size=static_size)
            tensor([[  0,   0],
                    [  1,   0]], dtype=torch.int64)

            # Example 3: 0 size
            >>> input_tensor = torch.tensor([10])
            >>> static_size = 0
            >>> t = torch.nonzero_static(input_tensor, size=static_size)
            tensor([], size=(0, 1), dtype=torch.int64)

            # Example 4: 0 rank input
            >>> input_tensor = torch.tensor(10)
            >>> static_size = 2
            >>> t = torch.nonzero_static(input_tensor, size=static_size)
            tensor([], size=(2, 0), dtype=torch.int64)
        """
    def norm(self, p=..., dim=..., keepdim=...) -> Tensor:
        """
        norm(p=2, dim=None, keepdim=False) -> Tensor

        See :func:`torch.norm`
        """
    def normal_(self, mean=..., std=..., generator=...) -> Tensor:
        """
        normal_(mean=0, std=1, *, generator=None) -> Tensor

        Fills :attr:`self` tensor with elements samples from the normal distribution
        parameterized by :attr:`mean` and :attr:`std`.
        """
    def not_equal(self, other) -> Tensor:
        """
        not_equal(other) -> Tensor

        See :func:`torch.not_equal`.
        """
    def not_equal_(self, other) -> Tensor:
        """
        not_equal_(other) -> Tensor

        In-place version of :meth:`~Tensor.not_equal`.
        """
    def numel(self) -> int:
        """
        numel() -> int

        See :func:`torch.numel`
        """
    def numpy(self, force=...) -> numpy.ndarray:
        """
        numpy(*, force=False) -> numpy.ndarray

        Returns the tensor as a NumPy :class:`ndarray`.

        If :attr:`force` is ``False`` (the default), the conversion
        is performed only if the tensor is on the CPU, does not require grad,
        does not have its conjugate bit set, and is a dtype and layout that
        NumPy supports. The returned ndarray and the tensor will share their
        storage, so changes to the tensor will be reflected in the ndarray
        and vice versa.

        If :attr:`force` is ``True`` this is equivalent to
        calling ``t.detach().cpu().resolve_conj().resolve_neg().numpy()``.
        If the tensor isn't on the CPU or the conjugate or negative bit is set,
        the tensor won't share its storage with the returned ndarray.
        Setting :attr:`force` to ``True`` can be a useful shorthand.

        Args:
            force (bool): if ``True``, the ndarray may be a copy of the tensor
                       instead of always sharing memory, defaults to ``False``.
        """
    def orgqr(self, input2) -> Tensor:
        """
        orgqr(input2) -> Tensor

        See :func:`torch.orgqr`
        """
    def ormqr(self, input2, input3, left=..., transpose=...) -> Tensor:
        """
        ormqr(input2, input3, left=True, transpose=False) -> Tensor

        See :func:`torch.ormqr`
        """
    def outer(self, vec2) -> Tensor:
        """
        outer(vec2) -> Tensor

        See :func:`torch.outer`.
        """
    def permute(self, *dims) -> Tensor:
        """
        permute(*dims) -> Tensor

        See :func:`torch.permute`
        """
    def pin_memory(self) -> Tensor:
        """
        pin_memory() -> Tensor

        Copies the tensor to pinned memory, if it's not already pinned.
        By default, the device pinned memory on will be the current :ref:`accelerator<accelerators>`.
        """
    def pinverse(self) -> Tensor:
        """
        pinverse() -> Tensor

        See :func:`torch.pinverse`
        """
    def polygamma(self, n) -> Tensor:
        """
        polygamma(n) -> Tensor

        See :func:`torch.polygamma`
        """
    def polygamma_(self, n) -> Tensor:
        """
        polygamma_(n) -> Tensor

        In-place version of :meth:`~Tensor.polygamma`
        """
    def positive(self) -> Tensor:
        """
        positive() -> Tensor

        See :func:`torch.positive`
        """
    def pow(self, exponent) -> Tensor:
        """
        pow(exponent) -> Tensor

        See :func:`torch.pow`
        """
    def pow_(self, exponent) -> Tensor:
        """
        pow_(exponent) -> Tensor

        In-place version of :meth:`~Tensor.pow`
        """
    def prelu(self, *args, **kwargs): ...
    def prod(self, dim=..., keepdim=..., dtype=...) -> Tensor:
        """
        prod(dim=None, keepdim=False, dtype=None) -> Tensor

        See :func:`torch.prod`
        """
    def put(self, input, index, source, accumulate=...) -> Tensor:
        """
        put(input, index, source, accumulate=False) -> Tensor

        Out-of-place version of :meth:`torch.Tensor.put_`.
        `input` corresponds to `self` in :meth:`torch.Tensor.put_`.
        """
    def put_(self, index, source, accumulate=...) -> Tensor:
        """
        put_(index, source, accumulate=False) -> Tensor

        Copies the elements from :attr:`source` into the positions specified by
        :attr:`index`. For the purpose of indexing, the :attr:`self` tensor is treated as if
        it were a 1-D tensor.

        :attr:`index` and :attr:`source` need to have the same number of elements, but not necessarily
        the same shape.

        If :attr:`accumulate` is ``True``, the elements in :attr:`source` are added to
        :attr:`self`. If accumulate is ``False``, the behavior is undefined if :attr:`index`
        contain duplicate elements.

        Args:
            index (LongTensor): the indices into self
            source (Tensor): the tensor containing values to copy from
            accumulate (bool): whether to accumulate into self

        Example::

            >>> src = torch.tensor([[4, 3, 5],
            ...                     [6, 7, 8]])
            >>> src.put_(torch.tensor([1, 3]), torch.tensor([9, 10]))
            tensor([[  4,   9,   5],
                    [ 10,   7,   8]])
        """
    def q_per_channel_axis(self) -> int:
        """
        q_per_channel_axis() -> int

        Given a Tensor quantized by linear (affine) per-channel quantization,
        returns the index of dimension on which per-channel quantization is applied.
        """
    def q_per_channel_scales(self) -> Tensor:
        """
        q_per_channel_scales() -> Tensor

        Given a Tensor quantized by linear (affine) per-channel quantization,
        returns a Tensor of scales of the underlying quantizer. It has the number of
        elements that matches the corresponding dimensions (from q_per_channel_axis) of
        the tensor.
        """
    def q_per_channel_zero_points(self) -> Tensor:
        """
        q_per_channel_zero_points() -> Tensor

        Given a Tensor quantized by linear (affine) per-channel quantization,
        returns a tensor of zero_points of the underlying quantizer. It has the number of
        elements that matches the corresponding dimensions (from q_per_channel_axis) of
        the tensor.
        """
    def q_scale(self) -> float:
        """
        q_scale() -> float

        Given a Tensor quantized by linear(affine) quantization,
        returns the scale of the underlying quantizer().
        """
    def q_zero_point(self) -> int:
        """
        q_zero_point() -> int

        Given a Tensor quantized by linear(affine) quantization,
        returns the zero_point of the underlying quantizer().
        """
    def qr(self, *args, **kwargs):
        """
        qr(some=True) -> (Tensor, Tensor)

        See :func:`torch.qr`
        """
    def qscheme(self) -> torch.qscheme:
        """
        qscheme() -> torch.qscheme

        Returns the quantization scheme of a given QTensor.
        """
    def quantile(self, q, dim=..., keepdim=..., interpolation=...) -> Tensor:
        """
        quantile(q, dim=None, keepdim=False, *, interpolation='linear') -> Tensor

        See :func:`torch.quantile`
        """
    def rad2deg(self) -> Tensor:
        """
        rad2deg() -> Tensor

        See :func:`torch.rad2deg`
        """
    def rad2deg_(self) -> Tensor:
        """
        rad2deg_() -> Tensor

        In-place version of :meth:`~Tensor.rad2deg`
        """
    def random_(self, _from=..., to=..., generator=...) -> Tensor:
        """
        random_(from=0, to=None, *, generator=None) -> Tensor

        Fills :attr:`self` tensor with numbers sampled from the discrete uniform
        distribution over ``[from, to - 1]``. If not specified, the values are usually
        only bounded by :attr:`self` tensor's data type. However, for floating point
        types, if unspecified, range will be ``[0, 2^mantissa]`` to ensure that every
        value is representable. For example, `torch.tensor(1, dtype=torch.double).random_()`
        will be uniform in ``[0, 2^53]``.
        """
    def ravel(self) -> Tensor:
        """
        ravel() -> Tensor

        see :func:`torch.ravel`
        """
    def reciprocal(self) -> Tensor:
        """
        reciprocal() -> Tensor

        See :func:`torch.reciprocal`
        """
    def reciprocal_(self) -> Tensor:
        """
        reciprocal_() -> Tensor

        In-place version of :meth:`~Tensor.reciprocal`
        """
    def record_stream(self, stream) -> Any:
        """
        record_stream(stream)

        Marks the tensor as having been used by this stream.  When the tensor
        is deallocated, ensure the tensor memory is not reused for another tensor
        until all work queued on :attr:`stream` at the time of deallocation is
        complete.

        .. note::

            The caching allocator is aware of only the stream where a tensor was
            allocated. Due to the awareness, it already correctly manages the life
            cycle of tensors on only one stream. But if a tensor is used on a stream
            different from the stream of origin, the allocator might reuse the memory
            unexpectedly. Calling this method lets the allocator know which streams
            have used the tensor.

        .. warning::

            This method is most suitable for use cases where you are providing a
            function that created a tensor on a side stream, and want users to be able
            to make use of the tensor without having to think carefully about stream
            safety when making use of them.  These safety guarantees come at some
            performance and predictability cost (analogous to the tradeoff between GC
            and manual memory management), so if you are in a situation where
            you manage the full lifetime of your tensors, you may consider instead
            manually managing CUDA events so that calling this method is not necessary.
            In particular, when you call this method, on later allocations the
            allocator will poll the recorded stream to see if all operations have
            completed yet; you can potentially race with side stream computation and
            non-deterministically reuse or fail to reuse memory for an allocation.

            You can safely use tensors allocated on side streams without
            :meth:`~Tensor.record_stream`; you must manually ensure that
            any non-creation stream uses of a tensor are synced back to the creation
            stream before you deallocate the tensor.  As the CUDA caching allocator
            guarantees that the memory will only be reused with the same creation stream,
            this is sufficient to ensure that writes to future reallocations of the
            memory will be delayed until non-creation stream uses are done.
            (Counterintuitively, you may observe that on the CPU side we have already
            reallocated the tensor, even though CUDA kernels on the old tensor are
            still in progress.  This is fine, because CUDA operations on the new
            tensor will appropriately wait for the old operations to complete, as they
            are all on the same stream.)

            Concretely, this looks like this::

                with torch.cuda.stream(s0):
                    x = torch.zeros(N)

                s1.wait_stream(s0)
                with torch.cuda.stream(s1):
                    y = some_comm_op(x)

                ... some compute on s0 ...

                # synchronize creation stream s0 to side stream s1
                # before deallocating x
                s0.wait_stream(s1)
                del x

            Note that some discretion is required when deciding when to perform
            ``s0.wait_stream(s1)``.  In particular, if we were to wait immediately
            after ``some_comm_op``, there wouldn't be any point in having the side
            stream; it would be equivalent to have run ``some_comm_op`` on ``s0``.
            Instead, the synchronization must be placed at some appropriate, later
            point in time where you expect the side stream ``s1`` to have finished
            work.  This location is typically identified via profiling, e.g., using
            Chrome traces produced
            :meth:`torch.autograd.profiler.profile.export_chrome_trace`.  If you
            place the wait too early, work on s0 will block until ``s1`` has finished,
            preventing further overlapping of communication and computation.  If you
            place the wait too late, you will use more memory than is strictly
            necessary (as you are keeping ``x`` live for longer.)  For a concrete
            example of how this guidance can be applied in practice, see this post:
            `FSDP and CUDACachingAllocator
            <https://dev-discuss.pytorch.org/t/fsdp-cudacachingallocator-an-outsider-newb-perspective/1486>`_.
        """
    def refine_names(self, *args, **kwargs): ...
    def relu(self, *args, **kwargs): ...
    def relu_(self, *args, **kwargs): ...
    def remainder(self, divisor) -> Tensor:
        """
        remainder(divisor) -> Tensor

        See :func:`torch.remainder`
        """
    def remainder_(self, divisor) -> Tensor:
        """
        remainder_(divisor) -> Tensor

        In-place version of :meth:`~Tensor.remainder`
        """
    def rename(self, *args, **kwargs): ...
    def rename_(self, *args, **kwargs): ...
    def renorm(self, p, dim, maxnorm) -> Tensor:
        """
        renorm(p, dim, maxnorm) -> Tensor

        See :func:`torch.renorm`
        """
    def renorm_(self, p, dim, maxnorm) -> Tensor:
        """
        renorm_(p, dim, maxnorm) -> Tensor

        In-place version of :meth:`~Tensor.renorm`
        """
    def repeat(self, *repeats) -> Tensor:
        """
        repeat(*repeats) -> Tensor

        Repeats this tensor along the specified dimensions.

        Unlike :meth:`~Tensor.expand`, this function copies the tensor's data.

        .. warning::

            :meth:`~Tensor.repeat` behaves differently from
            `numpy.repeat <https://numpy.org/doc/stable/reference/generated/numpy.repeat.html>`_,
            but is more similar to
            `numpy.tile <https://numpy.org/doc/stable/reference/generated/numpy.tile.html>`_.
            For the operator similar to `numpy.repeat`, see :func:`torch.repeat_interleave`.

        Args:
            repeat (torch.Size, int..., tuple of int or list of int): The number of times to repeat this tensor along each dimension

        Example::

            >>> x = torch.tensor([1, 2, 3])
            >>> x.repeat(4, 2)
            tensor([[ 1,  2,  3,  1,  2,  3],
                    [ 1,  2,  3,  1,  2,  3],
                    [ 1,  2,  3,  1,  2,  3],
                    [ 1,  2,  3,  1,  2,  3]])
            >>> x.repeat(4, 2, 1).size()
            torch.Size([4, 2, 3])
        """
    def repeat_interleave(self, repeats, dim=..., output_size=...) -> Tensor:
        """
        repeat_interleave(repeats, dim=None, *, output_size=None) -> Tensor

        See :func:`torch.repeat_interleave`.
        """
    def requires_grad_(self, requires_grad=...) -> Tensor:
        """
        requires_grad_(requires_grad=True) -> Tensor

        Change if autograd should record operations on this tensor: sets this tensor's
        :attr:`requires_grad` attribute in-place. Returns this tensor.

        :func:`requires_grad_`'s main use case is to tell autograd to begin recording
        operations on a Tensor ``tensor``. If ``tensor`` has ``requires_grad=False``
        (because it was obtained through a DataLoader, or required preprocessing or
        initialization), ``tensor.requires_grad_()`` makes it so that autograd will
        begin to record operations on ``tensor``.

        Args:
            requires_grad (bool): If autograd should record operations on this tensor.
                Default: ``True``.

        Example::

            >>> # Let's say we want to preprocess some saved weights and use
            >>> # the result as new weights.
            >>> saved_weights = [0.1, 0.2, 0.3, 0.25]
            >>> loaded_weights = torch.tensor(saved_weights)
            >>> weights = preprocess(loaded_weights)  # some function
            >>> weights
            tensor([-0.5503,  0.4926, -2.1158, -0.8303])

            >>> # Now, start to record operations done to weights
            >>> weights.requires_grad_()
            >>> out = weights.pow(2).sum()
            >>> out.backward()
            >>> weights.grad
            tensor([-1.1007,  0.9853, -4.2316, -1.6606])

        """
    def reshape(self, *shape) -> Tensor:
        """
        reshape(*shape) -> Tensor

        Returns a tensor with the same data and number of elements as :attr:`self`
        but with the specified shape. This method returns a view if :attr:`shape` is
        compatible with the current shape. See :meth:`torch.Tensor.view` on when it is
        possible to return a view.

        See :func:`torch.reshape`

        Args:
            shape (tuple of ints or int...): the desired shape

        """
    @overload
    def reshape_as(self, other) -> Tensor:
        """
        reshape_as(other) -> Tensor

        Returns this tensor as the same shape as :attr:`other`.
        ``self.reshape_as(other)`` is equivalent to ``self.reshape(other.sizes())``.
        This method returns a view if ``other.sizes()`` is compatible with the current
        shape. See :meth:`torch.Tensor.view` on when it is possible to return a view.

        Please see :meth:`reshape` for more information about ``reshape``.

        Args:
            other (:class:`torch.Tensor`): The result tensor has the same shape
                as :attr:`other`.
        """
    @overload
    def reshape_as(self, other) -> Any:
        """
        reshape_as(other) -> Tensor

        Returns this tensor as the same shape as :attr:`other`.
        ``self.reshape_as(other)`` is equivalent to ``self.reshape(other.sizes())``.
        This method returns a view if ``other.sizes()`` is compatible with the current
        shape. See :meth:`torch.Tensor.view` on when it is possible to return a view.

        Please see :meth:`reshape` for more information about ``reshape``.

        Args:
            other (:class:`torch.Tensor`): The result tensor has the same shape
                as :attr:`other`.
        """
    def resize_(self, *sizes, memory_format=...) -> Tensor:
        """
        resize_(*sizes, memory_format=torch.contiguous_format) -> Tensor

        Resizes :attr:`self` tensor to the specified size. If the number of elements is
        larger than the current storage size, then the underlying storage is resized
        to fit the new number of elements. If the number of elements is smaller, the
        underlying storage is not changed. Existing elements are preserved but any new
        memory is uninitialized.

        .. warning::

            This is a low-level method. The storage is reinterpreted as C-contiguous,
            ignoring the current strides (unless the target size equals the current
            size, in which case the tensor is left unchanged). For most purposes, you
            will instead want to use :meth:`~Tensor.view()`, which checks for
            contiguity, or :meth:`~Tensor.reshape()`, which copies data if needed. To
            change the size in-place with custom strides, see :meth:`~Tensor.set_()`.

        .. note::

            If :func:`torch.use_deterministic_algorithms()` and
            :attr:`torch.utils.deterministic.fill_uninitialized_memory` are both set to
            ``True``, new elements are initialized to prevent nondeterministic behavior
            from using the result as an input to an operation. Floating point and
            complex values are set to NaN, and integer values are set to the maximum
            value.

        Args:
            sizes (torch.Size or int...): the desired size
            memory_format (:class:`torch.memory_format`, optional): the desired memory format of
                Tensor. Default: ``torch.contiguous_format``. Note that memory format of
                :attr:`self` is going to be unaffected if ``self.size()`` matches ``sizes``.

        Example::

            >>> x = torch.tensor([[1, 2], [3, 4], [5, 6]])
            >>> x.resize_(2, 2)
            tensor([[ 1,  2],
                    [ 3,  4]])
        """
    def resize_as_(self, tensor, memory_format=...) -> Tensor:
        """
        resize_as_(tensor, memory_format=torch.contiguous_format) -> Tensor

        Resizes the :attr:`self` tensor to be the same size as the specified
        :attr:`tensor`. This is equivalent to ``self.resize_(tensor.size())``.

        Args:
            memory_format (:class:`torch.memory_format`, optional): the desired memory format of
                Tensor. Default: ``torch.contiguous_format``. Note that memory format of
                :attr:`self` is going to be unaffected if ``self.size()`` matches ``tensor.size()``.

        """
    def resize_as_sparse_(self, *args, **kwargs): ...
    def resolve_conj(self) -> Tensor:
        """
        resolve_conj() -> Tensor

        See :func:`torch.resolve_conj`
        """
    def resolve_neg(self) -> Tensor:
        """
        resolve_neg() -> Tensor

        See :func:`torch.resolve_neg`
        """
    def retain_grad(self) -> None:
        """
        retain_grad() -> None

        Enables this Tensor to have their :attr:`grad` populated during
        :func:`backward`. This is a no-op for leaf tensors.
        """
    def roll(self, shifts, dims) -> Tensor:
        """
        roll(shifts, dims) -> Tensor

        See :func:`torch.roll`
        """
    def rot90(self, k, dims) -> Tensor:
        """
        rot90(k, dims) -> Tensor

        See :func:`torch.rot90`
        """
    def round(self, decimals=...) -> Tensor:
        """
        round(decimals=0) -> Tensor

        See :func:`torch.round`
        """
    def round_(self, decimals=...) -> Tensor:
        """
        round_(decimals=0) -> Tensor

        In-place version of :meth:`~Tensor.round`
        """
    def row_indices(self, *args, **kwargs): ...
    def rsqrt(self) -> Tensor:
        """
        rsqrt() -> Tensor

        See :func:`torch.rsqrt`
        """
    def rsqrt_(self) -> Tensor:
        """
        rsqrt_() -> Tensor

        In-place version of :meth:`~Tensor.rsqrt`
        """
    def scatter(self, dim, index, src) -> Tensor:
        """
        scatter(dim, index, src) -> Tensor

        Out-of-place version of :meth:`torch.Tensor.scatter_`
        """
    def scatter_(self, dim, index, src, reduce=...) -> Tensor:
        """
        scatter_(dim, index, src, *, reduce=None) -> Tensor

        Writes all values from the tensor :attr:`src` into :attr:`self` at the indices
        specified in the :attr:`index` tensor. For each value in :attr:`src`, its output
        index is specified by its index in :attr:`src` for ``dimension != dim`` and by
        the corresponding value in :attr:`index` for ``dimension = dim``.

        For a 3-D tensor, :attr:`self` is updated as::

            self[index[i][j][k]][j][k] = src[i][j][k]  # if dim == 0
            self[i][index[i][j][k]][k] = src[i][j][k]  # if dim == 1
            self[i][j][index[i][j][k]] = src[i][j][k]  # if dim == 2

        This is the reverse operation of the manner described in :meth:`~Tensor.gather`.

        :attr:`self`, :attr:`index` and :attr:`src` (if it is a Tensor) should all have
        the same number of dimensions. It is also required that
        ``index.size(d) <= src.size(d)`` for all dimensions ``d``, and that
        ``index.size(d) <= self.size(d)`` for all dimensions ``d != dim``.
        Note that ``index`` and ``src`` do not broadcast.

        Moreover, as for :meth:`~Tensor.gather`, the values of :attr:`index` must be
        between ``0`` and ``self.size(dim) - 1`` inclusive.

        .. warning::

            When indices are not unique, the behavior is non-deterministic (one of the
            values from ``src`` will be picked arbitrarily) and the gradient will be
            incorrect (it will be propagated to all locations in the source that
            correspond to the same index)!

        .. note::

            The backward pass is implemented only for ``src.shape == index.shape``.

        Additionally accepts an optional :attr:`reduce` argument that allows
        specification of an optional reduction operation, which is applied to all
        values in the tensor :attr:`src` into :attr:`self` at the indices
        specified in the :attr:`index`. For each value in :attr:`src`, the reduction
        operation is applied to an index in :attr:`self` which is specified by
        its index in :attr:`src` for ``dimension != dim`` and by the corresponding
        value in :attr:`index` for ``dimension = dim``.

        Given a 3-D tensor and reduction using the multiplication operation, :attr:`self`
        is updated as::

            self[index[i][j][k]][j][k] *= src[i][j][k]  # if dim == 0
            self[i][index[i][j][k]][k] *= src[i][j][k]  # if dim == 1
            self[i][j][index[i][j][k]] *= src[i][j][k]  # if dim == 2

        Reducing with the addition operation is the same as using
        :meth:`~torch.Tensor.scatter_add_`.

        .. warning::
            The reduce argument with Tensor ``src`` is deprecated and will be removed in
            a future PyTorch release. Please use :meth:`~torch.Tensor.scatter_reduce_`
            instead for more reduction options.

        Args:
            dim (int): the axis along which to index
            index (LongTensor): the indices of elements to scatter, can be either empty
                or of the same dimensionality as ``src``. When empty, the operation
                returns ``self`` unchanged.
            src (Tensor): the source element(s) to scatter.

        Keyword args:
            reduce (str, optional): reduction operation to apply, can be either
                ``'add'`` or ``'multiply'``.

        Example::

            >>> src = torch.arange(1, 11).reshape((2, 5))
            >>> src
            tensor([[ 1,  2,  3,  4,  5],
                    [ 6,  7,  8,  9, 10]])
            >>> index = torch.tensor([[0, 1, 2, 0]])
            >>> torch.zeros(3, 5, dtype=src.dtype).scatter_(0, index, src)
            tensor([[1, 0, 0, 4, 0],
                    [0, 2, 0, 0, 0],
                    [0, 0, 3, 0, 0]])
            >>> index = torch.tensor([[0, 1, 2], [0, 1, 4]])
            >>> torch.zeros(3, 5, dtype=src.dtype).scatter_(1, index, src)
            tensor([[1, 2, 3, 0, 0],
                    [6, 7, 0, 0, 8],
                    [0, 0, 0, 0, 0]])

            >>> torch.full((2, 4), 2.).scatter_(1, torch.tensor([[2], [3]]),
            ...            1.23, reduce='multiply')
            tensor([[2.0000, 2.0000, 2.4600, 2.0000],
                    [2.0000, 2.0000, 2.0000, 2.4600]])
            >>> torch.full((2, 4), 2.).scatter_(1, torch.tensor([[2], [3]]),
            ...            1.23, reduce='add')
            tensor([[2.0000, 2.0000, 3.2300, 2.0000],
                    [2.0000, 2.0000, 2.0000, 3.2300]])

        .. function:: scatter_(dim, index, value, *, reduce=None) -> Tensor:
           :noindex:

        Writes the value from :attr:`value` into :attr:`self` at the indices
        specified in the :attr:`index` tensor.  This operation is equivalent to the previous version,
        with the :attr:`src` tensor filled entirely with :attr:`value`.

        Args:
            dim (int): the axis along which to index
            index (LongTensor): the indices of elements to scatter, can be either empty
                or of the same dimensionality as ``src``. When empty, the operation
                returns ``self`` unchanged.
            value (Scalar): the value to scatter.

        Keyword args:
            reduce (str, optional): reduction operation to apply, can be either
                ``'add'`` or ``'multiply'``.

        Example::

            >>> index = torch.tensor([[0, 1]])
            >>> value = 2
            >>> torch.zeros(3, 5).scatter_(0, index, value)
            tensor([[2., 0., 0., 0., 0.],
                    [0., 2., 0., 0., 0.],
                    [0., 0., 0., 0., 0.]])
        """
    def scatter_add(self, dim, index, src) -> Tensor:
        """
        scatter_add(dim, index, src) -> Tensor

        Out-of-place version of :meth:`torch.Tensor.scatter_add_`
        """
    def scatter_add_(self, dim, index, src) -> Tensor:
        """
        scatter_add_(dim, index, src) -> Tensor

        Adds all values from the tensor :attr:`src` into :attr:`self` at the indices
        specified in the :attr:`index` tensor in a similar fashion as
        :meth:`~torch.Tensor.scatter_`. For each value in :attr:`src`, it is added to
        an index in :attr:`self` which is specified by its index in :attr:`src`
        for ``dimension != dim`` and by the corresponding value in :attr:`index` for
        ``dimension = dim``.

        For a 3-D tensor, :attr:`self` is updated as::

            self[index[i][j][k]][j][k] += src[i][j][k]  # if dim == 0
            self[i][index[i][j][k]][k] += src[i][j][k]  # if dim == 1
            self[i][j][index[i][j][k]] += src[i][j][k]  # if dim == 2

        :attr:`self`, :attr:`index` and :attr:`src` should have same number of
        dimensions. It is also required that ``index.size(d) <= src.size(d)`` for all
        dimensions ``d``, and that ``index.size(d) <= self.size(d)`` for all dimensions
        ``d != dim``. Note that ``index`` and ``src`` do not broadcast.

        Note:
            This operation may behave nondeterministically when given tensors on a CUDA device. See :doc:`/notes/randomness` for more information.

        .. note::

            The backward pass is implemented only for ``src.shape == index.shape``.

        Args:
            dim (int): the axis along which to index
            index (LongTensor): the indices of elements to scatter and add, can be
                either empty or of the same dimensionality as ``src``. When empty, the
                operation returns ``self`` unchanged.
            src (Tensor): the source elements to scatter and add

        Example::

            >>> src = torch.ones((2, 5))
            >>> index = torch.tensor([[0, 1, 2, 0, 0]])
            >>> torch.zeros(3, 5, dtype=src.dtype).scatter_add_(0, index, src)
            tensor([[1., 0., 0., 1., 1.],
                    [0., 1., 0., 0., 0.],
                    [0., 0., 1., 0., 0.]])
            >>> index = torch.tensor([[0, 1, 2, 0, 0], [0, 1, 2, 2, 2]])
            >>> torch.zeros(3, 5, dtype=src.dtype).scatter_add_(0, index, src)
            tensor([[2., 0., 0., 1., 1.],
                    [0., 2., 0., 0., 0.],
                    [0., 0., 2., 1., 1.]])

        """
    def scatter_reduce(self, dim, index, src, reduce, include_self=...) -> Tensor:
        """
        scatter_reduce(dim, index, src, reduce, *, include_self=True) -> Tensor

        Out-of-place version of :meth:`torch.Tensor.scatter_reduce_`
        """
    def scatter_reduce_(self, dim, index, src, reduce, include_self=...) -> Tensor:
        '''
        scatter_reduce_(dim, index, src, reduce, *, include_self=True) -> Tensor

        Reduces all values from the :attr:`src` tensor to the indices specified in
        the :attr:`index` tensor in the :attr:`self` tensor using the applied reduction
        defined via the :attr:`reduce` argument (:obj:`"sum"`, :obj:`"prod"`, :obj:`"mean"`,
        :obj:`"amax"`, :obj:`"amin"`). For each value in :attr:`src`, it is reduced to an
        index in :attr:`self` which is specified by its index in :attr:`src` for
        ``dimension != dim`` and by the corresponding value in :attr:`index` for
        ``dimension = dim``. If :obj:`include_self="True"`, the values in the :attr:`self`
        tensor are included in the reduction.

        :attr:`self`, :attr:`index` and :attr:`src` should all have
        the same number of dimensions. It is also required that
        ``index.size(d) <= src.size(d)`` for all dimensions ``d``, and that
        ``index.size(d) <= self.size(d)`` for all dimensions ``d != dim``.
        Note that ``index`` and ``src`` do not broadcast.

        For a 3-D tensor with :obj:`reduce="sum"` and :obj:`include_self=True` the
        output is given as::

            self[index[i][j][k]][j][k] += src[i][j][k]  # if dim == 0
            self[i][index[i][j][k]][k] += src[i][j][k]  # if dim == 1
            self[i][j][index[i][j][k]] += src[i][j][k]  # if dim == 2

        Note:
            This operation may behave nondeterministically when given tensors on a CUDA device. See :doc:`/notes/randomness` for more information.

        .. note::

            The backward pass is implemented only for ``src.shape == index.shape``.

        .. warning::

            This function is in beta and may change in the near future.

        Args:
            dim (int): the axis along which to index
            index (LongTensor): the indices of elements to scatter and reduce.
            src (Tensor): the source elements to scatter and reduce
            reduce (str): the reduction operation to apply for non-unique indices
                (:obj:`"sum"`, :obj:`"prod"`, :obj:`"mean"`, :obj:`"amax"`, :obj:`"amin"`)
            include_self (bool): whether elements from the :attr:`self` tensor are
                included in the reduction

        Example::

            >>> src = torch.tensor([1., 2., 3., 4., 5., 6.])
            >>> index = torch.tensor([0, 1, 0, 1, 2, 1])
            >>> input = torch.tensor([1., 2., 3., 4.])
            >>> input.scatter_reduce(0, index, src, reduce="sum")
            tensor([5., 14., 8., 4.])
            >>> input.scatter_reduce(0, index, src, reduce="sum", include_self=False)
            tensor([4., 12., 5., 4.])
            >>> input2 = torch.tensor([5., 4., 3., 2.])
            >>> input2.scatter_reduce(0, index, src, reduce="amax")
            tensor([5., 6., 5., 2.])
            >>> input2.scatter_reduce(0, index, src, reduce="amax", include_self=False)
            tensor([3., 6., 5., 2.])


        '''
    def select(self, dim, index) -> Tensor:
        """
        select(dim, index) -> Tensor

        See :func:`torch.select`
        """
    def select_scatter(self, src, dim, index) -> Tensor:
        """
        select_scatter(src, dim, index) -> Tensor

        See :func:`torch.select_scatter`
        """
    def set_(self, source=..., storage_offset=..., size=..., stride=...) -> Tensor:
        """
        set_(source=None, storage_offset=0, size=None, stride=None) -> Tensor

        Sets the underlying storage, size, and strides. If :attr:`source` is a tensor,
        :attr:`self` tensor will share the same storage and have the same size and
        strides as :attr:`source`. Changes to elements in one tensor will be reflected
        in the other.

        If :attr:`source` is a :class:`~torch.Storage`, the method sets the underlying
        storage, offset, size, and stride.

        Args:
            source (Tensor or Storage): the tensor or storage to use
            storage_offset (int, optional): the offset in the storage
            size (torch.Size, optional): the desired size. Defaults to the size of the source.
            stride (tuple, optional): the desired stride. Defaults to C-contiguous strides.
        """
    def sgn(self) -> Tensor:
        """
        sgn() -> Tensor

        See :func:`torch.sgn`
        """
    def sgn_(self) -> Tensor:
        """
        sgn_() -> Tensor

        In-place version of :meth:`~Tensor.sgn`
        """
    @overload
    def short(self, memory_format=...) -> Tensor:
        """
        short(memory_format=torch.preserve_format) -> Tensor

        ``self.short()`` is equivalent to ``self.to(torch.int16)``. See :func:`to`.

        Args:
            memory_format (:class:`torch.memory_format`, optional): the desired memory format of
                returned Tensor. Default: ``torch.preserve_format``.
        """
    @overload
    def short(self) -> Any:
        """
        short(memory_format=torch.preserve_format) -> Tensor

        ``self.short()`` is equivalent to ``self.to(torch.int16)``. See :func:`to`.

        Args:
            memory_format (:class:`torch.memory_format`, optional): the desired memory format of
                returned Tensor. Default: ``torch.preserve_format``.
        """
    def sigmoid(self) -> Tensor:
        """
        sigmoid() -> Tensor

        See :func:`torch.sigmoid`
        """
    def sigmoid_(self) -> Tensor:
        """
        sigmoid_() -> Tensor

        In-place version of :meth:`~Tensor.sigmoid`
        """
    def sign(self) -> Tensor:
        """
        sign() -> Tensor

        See :func:`torch.sign`
        """
    def sign_(self) -> Tensor:
        """
        sign_() -> Tensor

        In-place version of :meth:`~Tensor.sign`
        """
    def signbit(self) -> Tensor:
        """
        signbit() -> Tensor

        See :func:`torch.signbit`
        """
    def sin(self) -> Tensor:
        """
        sin() -> Tensor

        See :func:`torch.sin`
        """
    def sin_(self) -> Tensor:
        """
        sin_() -> Tensor

        In-place version of :meth:`~Tensor.sin`
        """
    def sinc(self) -> Tensor:
        """
        sinc() -> Tensor

        See :func:`torch.sinc`
        """
    def sinc_(self) -> Tensor:
        """
        sinc_() -> Tensor

        In-place version of :meth:`~Tensor.sinc`
        """
    def sinh(self) -> Tensor:
        """
        sinh() -> Tensor

        See :func:`torch.sinh`
        """
    def sinh_(self) -> Tensor:
        """
        sinh_() -> Tensor

        In-place version of :meth:`~Tensor.sinh`
        """
    @overload
    def size(self, dim=...) -> torch.Sizeorint:
        """
        size(dim=None) -> torch.Size or int

        Returns the size of the :attr:`self` tensor. If ``dim`` is not specified,
        the returned value is a :class:`torch.Size`, a subclass of :class:`tuple`.
        If ``dim`` is specified, returns an int holding the size of that dimension.

        Args:
          dim (int, optional): The dimension for which to retrieve the size.

        Example::

            >>> t = torch.empty(3, 4, 5)
            >>> t.size()
            torch.Size([3, 4, 5])
            >>> t.size(dim=1)
            4

        """
    @overload
    def size(self) -> Any:
        """
        size(dim=None) -> torch.Size or int

        Returns the size of the :attr:`self` tensor. If ``dim`` is not specified,
        the returned value is a :class:`torch.Size`, a subclass of :class:`tuple`.
        If ``dim`` is specified, returns an int holding the size of that dimension.

        Args:
          dim (int, optional): The dimension for which to retrieve the size.

        Example::

            >>> t = torch.empty(3, 4, 5)
            >>> t.size()
            torch.Size([3, 4, 5])
            >>> t.size(dim=1)
            4

        """
    @overload
    def size(self, dim=...) -> Any:
        """
        size(dim=None) -> torch.Size or int

        Returns the size of the :attr:`self` tensor. If ``dim`` is not specified,
        the returned value is a :class:`torch.Size`, a subclass of :class:`tuple`.
        If ``dim`` is specified, returns an int holding the size of that dimension.

        Args:
          dim (int, optional): The dimension for which to retrieve the size.

        Example::

            >>> t = torch.empty(3, 4, 5)
            >>> t.size()
            torch.Size([3, 4, 5])
            >>> t.size(dim=1)
            4

        """
    def slice_inverse(self, *args, **kwargs): ...
    def slice_scatter(self, src, dim=..., start=..., end=..., step=...) -> Tensor:
        """
        slice_scatter(src, dim=0, start=None, end=None, step=1) -> Tensor

        See :func:`torch.slice_scatter`
        """
    def slogdet(self, *args, **kwargs):
        """
        slogdet() -> (Tensor, Tensor)

        See :func:`torch.slogdet`
        """
    def smm(self, mat) -> Tensor:
        """
        smm(mat) -> Tensor

        See :func:`torch.smm`
        """
    def softmax(self, dim) -> Tensor:
        """
        softmax(dim) -> Tensor

        Alias for :func:`torch.nn.functional.softmax`.
        """
    def sort(self, *args, **kwargs):
        """
        sort(dim=-1, descending=False) -> (Tensor, LongTensor)

        See :func:`torch.sort`
        """
    def sparse_dim(self) -> int:
        """
        sparse_dim() -> int

        Return the number of sparse dimensions in a :ref:`sparse tensor <sparse-docs>` :attr:`self`.

        .. note::
          Returns ``0`` if :attr:`self` is not a sparse tensor.

        See also :meth:`Tensor.dense_dim` and :ref:`hybrid tensors <sparse-hybrid-coo-docs>`.
        """
    @overload
    def sparse_mask(self, mask) -> Tensor:
        """
        sparse_mask(mask) -> Tensor

        Returns a new :ref:`sparse tensor <sparse-docs>` with values from a
        strided tensor :attr:`self` filtered by the indices of the sparse
        tensor :attr:`mask`. The values of :attr:`mask` sparse tensor are
        ignored. :attr:`self` and :attr:`mask` tensors must have the same
        shape.

        .. note::

          The returned sparse tensor might contain duplicate values if :attr:`mask`
          is not coalesced. It is therefore advisable to pass ``mask.coalesce()``
          if such behavior is not desired.

        .. note::

          The returned sparse tensor has the same indices as the sparse tensor
          :attr:`mask`, even when the corresponding values in :attr:`self` are
          zeros.

        Args:
            mask (Tensor): a sparse tensor whose indices are used as a filter

        Example::

            >>> nse = 5
            >>> dims = (5, 5, 2, 2)
            >>> I = torch.cat([torch.randint(0, dims[0], size=(nse,)),
            ...                torch.randint(0, dims[1], size=(nse,))], 0).reshape(2, nse)
            >>> V = torch.randn(nse, dims[2], dims[3])
            >>> S = torch.sparse_coo_tensor(I, V, dims).coalesce()
            >>> D = torch.randn(dims)
            >>> D.sparse_mask(S)
            tensor(indices=tensor([[0, 0, 0, 2],
                                   [0, 1, 4, 3]]),
                   values=tensor([[[ 1.6550,  0.2397],
                                   [-0.1611, -0.0779]],

                                  [[ 0.2326, -1.0558],
                                   [ 1.4711,  1.9678]],

                                  [[-0.5138, -0.0411],
                                   [ 1.9417,  0.5158]],

                                  [[ 0.0793,  0.0036],
                                   [-0.2569, -0.1055]]]),
                   size=(5, 5, 2, 2), nnz=4, layout=torch.sparse_coo)
        """
    @overload
    def sparse_mask(self, S) -> Any:
        """
        sparse_mask(mask) -> Tensor

        Returns a new :ref:`sparse tensor <sparse-docs>` with values from a
        strided tensor :attr:`self` filtered by the indices of the sparse
        tensor :attr:`mask`. The values of :attr:`mask` sparse tensor are
        ignored. :attr:`self` and :attr:`mask` tensors must have the same
        shape.

        .. note::

          The returned sparse tensor might contain duplicate values if :attr:`mask`
          is not coalesced. It is therefore advisable to pass ``mask.coalesce()``
          if such behavior is not desired.

        .. note::

          The returned sparse tensor has the same indices as the sparse tensor
          :attr:`mask`, even when the corresponding values in :attr:`self` are
          zeros.

        Args:
            mask (Tensor): a sparse tensor whose indices are used as a filter

        Example::

            >>> nse = 5
            >>> dims = (5, 5, 2, 2)
            >>> I = torch.cat([torch.randint(0, dims[0], size=(nse,)),
            ...                torch.randint(0, dims[1], size=(nse,))], 0).reshape(2, nse)
            >>> V = torch.randn(nse, dims[2], dims[3])
            >>> S = torch.sparse_coo_tensor(I, V, dims).coalesce()
            >>> D = torch.randn(dims)
            >>> D.sparse_mask(S)
            tensor(indices=tensor([[0, 0, 0, 2],
                                   [0, 1, 4, 3]]),
                   values=tensor([[[ 1.6550,  0.2397],
                                   [-0.1611, -0.0779]],

                                  [[ 0.2326, -1.0558],
                                   [ 1.4711,  1.9678]],

                                  [[-0.5138, -0.0411],
                                   [ 1.9417,  0.5158]],

                                  [[ 0.0793,  0.0036],
                                   [-0.2569, -0.1055]]]),
                   size=(5, 5, 2, 2), nnz=4, layout=torch.sparse_coo)
        """
    def sparse_resize_(self, size, sparse_dim, dense_dim) -> Tensor:
        """
        sparse_resize_(size, sparse_dim, dense_dim) -> Tensor

        Resizes :attr:`self` :ref:`sparse tensor <sparse-docs>` to the desired
        size and the number of sparse and dense dimensions.

        .. note::
          If the number of specified elements in :attr:`self` is zero, then
          :attr:`size`, :attr:`sparse_dim`, and :attr:`dense_dim` can be any
          size and positive integers such that ``len(size) == sparse_dim +
          dense_dim``.

          If :attr:`self` specifies one or more elements, however, then each
          dimension in :attr:`size` must not be smaller than the corresponding
          dimension of :attr:`self`, :attr:`sparse_dim` must equal the number
          of sparse dimensions in :attr:`self`, and :attr:`dense_dim` must
          equal the number of dense dimensions in :attr:`self`.

        .. warning::
          Throws an error if :attr:`self` is not a sparse tensor.

        Args:
            size (torch.Size): the desired size. If :attr:`self` is non-empty
              sparse tensor, the desired size cannot be smaller than the
              original size.
            sparse_dim (int): the number of sparse dimensions
            dense_dim (int): the number of dense dimensions
        """
    def sparse_resize_and_clear_(self, size, sparse_dim, dense_dim) -> Tensor:
        """
        sparse_resize_and_clear_(size, sparse_dim, dense_dim) -> Tensor

        Removes all specified elements from a :ref:`sparse tensor
        <sparse-docs>` :attr:`self` and resizes :attr:`self` to the desired
        size and the number of sparse and dense dimensions.

        .. warning:
          Throws an error if :attr:`self` is not a sparse tensor.

        Args:
            size (torch.Size): the desired size.
            sparse_dim (int): the number of sparse dimensions
            dense_dim (int): the number of dense dimensions
        """
    def split(self, *args, **kwargs): ...
    def split_with_sizes(self, *args, **kwargs): ...
    def sqrt(self) -> Tensor:
        """
        sqrt() -> Tensor

        See :func:`torch.sqrt`
        """
    def sqrt_(self) -> Tensor:
        """
        sqrt_() -> Tensor

        In-place version of :meth:`~Tensor.sqrt`
        """
    def square(self) -> Tensor:
        """
        square() -> Tensor

        See :func:`torch.square`
        """
    def square_(self) -> Tensor:
        """
        square_() -> Tensor

        In-place version of :meth:`~Tensor.square`
        """
    def squeeze(self, dim=...) -> Tensor:
        """
        squeeze(dim=None) -> Tensor

        See :func:`torch.squeeze`
        """
    def squeeze_(self, dim=...) -> Tensor:
        """
        squeeze_(dim=None) -> Tensor

        In-place version of :meth:`~Tensor.squeeze`
        """
    def sspaddmm(self, mat1, mat2, beta=..., alpha=...) -> Tensor:
        """
        sspaddmm(mat1, mat2, *, beta=1, alpha=1) -> Tensor

        See :func:`torch.sspaddmm`
        """
    def std(self, dim=..., correction=..., keepdim=...) -> Tensor:
        """
        std(dim=None, *, correction=1, keepdim=False) -> Tensor

        See :func:`torch.std`
        """
    def stft(self, frame_length, hop, fft_size=..., return_onesided=..., window=..., 
pad_end=..., align_to_window=...) -> Tensor:
        """
        stft(frame_length, hop, fft_size=None, return_onesided=True, window=None,
         pad_end=0, align_to_window=None) -> Tensor

        See :func:`torch.stft`
        """
    def storage_offset(self) -> int:
        """
        storage_offset() -> int

        Returns :attr:`self` tensor's offset in the underlying storage in terms of
        number of storage elements (not bytes).

        Example::

            >>> x = torch.tensor([1, 2, 3, 4, 5])
            >>> x.storage_offset()
            0
            >>> x[3:].storage_offset()
            3

        """
    @overload
    def stride(self, dim) -> tupleorint:
        """
        stride(dim) -> tuple or int

        Returns the stride of :attr:`self` tensor.

        Stride is the jump necessary to go from one element to the next one in the
        specified dimension :attr:`dim`. A tuple of all strides is returned when no
        argument is passed in. Otherwise, an integer value is returned as the stride in
        the particular dimension :attr:`dim`.

        Args:
            dim (int, optional): the desired dimension in which stride is required

        Example::

            >>> x = torch.tensor([[1, 2, 3, 4, 5], [6, 7, 8, 9, 10]])
            >>> x.stride()
            (5, 1)
            >>> x.stride(0)
            5
            >>> x.stride(-1)
            1

        """
    @overload
    def stride(self) -> Any:
        """
        stride(dim) -> tuple or int

        Returns the stride of :attr:`self` tensor.

        Stride is the jump necessary to go from one element to the next one in the
        specified dimension :attr:`dim`. A tuple of all strides is returned when no
        argument is passed in. Otherwise, an integer value is returned as the stride in
        the particular dimension :attr:`dim`.

        Args:
            dim (int, optional): the desired dimension in which stride is required

        Example::

            >>> x = torch.tensor([[1, 2, 3, 4, 5], [6, 7, 8, 9, 10]])
            >>> x.stride()
            (5, 1)
            >>> x.stride(0)
            5
            >>> x.stride(-1)
            1

        """
    def sub(self, other, alpha=...) -> Tensor:
        """
        sub(other, *, alpha=1) -> Tensor

        See :func:`torch.sub`.
        """
    def sub_(self, other, alpha=...) -> Tensor:
        """
        sub_(other, *, alpha=1) -> Tensor

        In-place version of :meth:`~Tensor.sub`
        """
    def subtract(self, other, alpha=...) -> Tensor:
        """
        subtract(other, *, alpha=1) -> Tensor

        See :func:`torch.subtract`.
        """
    def subtract_(self, other, alpha=...) -> Tensor:
        """
        subtract_(other, *, alpha=1) -> Tensor

        In-place version of :meth:`~Tensor.subtract`.
        """
    def sum(self, dim=..., keepdim=..., dtype=...) -> Tensor:
        """
        sum(dim=None, keepdim=False, dtype=None) -> Tensor

        See :func:`torch.sum`
        """
    def sum_to_size(self, *size) -> Tensor:
        """
        sum_to_size(*size) -> Tensor

        Sum ``this`` tensor to :attr:`size`.
        :attr:`size` must be broadcastable to ``this`` tensor size.

        Args:
            size (int...): a sequence of integers defining the shape of the output tensor.
        """
    def svd(self, *args, **kwargs):
        """
        svd(some=True, compute_uv=True) -> (Tensor, Tensor, Tensor)

        See :func:`torch.svd`
        """
    def swapaxes(self, axis0, axis1) -> Tensor:
        """
        swapaxes(axis0, axis1) -> Tensor

        See :func:`torch.swapaxes`
        """
    def swapaxes_(self, axis0, axis1) -> Tensor:
        """
        swapaxes_(axis0, axis1) -> Tensor

        In-place version of :meth:`~Tensor.swapaxes`
        """
    def swapdims(self, dim0, dim1) -> Tensor:
        """
        swapdims(dim0, dim1) -> Tensor

        See :func:`torch.swapdims`
        """
    def swapdims_(self, dim0, dim1) -> Tensor:
        """
        swapdims_(dim0, dim1) -> Tensor

        In-place version of :meth:`~Tensor.swapdims`
        """
    def t(self) -> Tensor:
        """
        t() -> Tensor

        See :func:`torch.t`
        """
    def t_(self) -> Tensor:
        """
        t_() -> Tensor

        In-place version of :meth:`~Tensor.t`
        """
    def take(self, indices) -> Tensor:
        """
        take(indices) -> Tensor

        See :func:`torch.take`
        """
    def take_along_dim(self, indices, dim) -> Tensor:
        """
        take_along_dim(indices, dim) -> Tensor

        See :func:`torch.take_along_dim`
        """
    def tan(self) -> Tensor:
        """
        tan() -> Tensor

        See :func:`torch.tan`
        """
    def tan_(self) -> Tensor:
        """
        tan_() -> Tensor

        In-place version of :meth:`~Tensor.tan`
        """
    def tanh(self) -> Tensor:
        """
        tanh() -> Tensor

        See :func:`torch.tanh`
        """
    def tanh_(self) -> Tensor:
        """
        tanh_() -> Tensor

        In-place version of :meth:`~Tensor.tanh`
        """
    def tensor_split(self, indices_or_sections, dim=...) -> ListofTensors:
        """
        tensor_split(indices_or_sections, dim=0) -> List of Tensors

        See :func:`torch.tensor_split`
        """
    def tile(self, dims) -> Tensor:
        """
        tile(dims) -> Tensor

        See :func:`torch.tile`
        """
    @overload
    def to(self, dtype, non_blocking=..., copy=..., memory_format=...) -> Tensor:
        """
        to(*args, **kwargs) -> Tensor

        Performs Tensor dtype and/or device conversion. A :class:`torch.dtype` and :class:`torch.device` are
        inferred from the arguments of ``self.to(*args, **kwargs)``.

        .. note::

            If the ``self`` Tensor already
            has the correct :class:`torch.dtype` and :class:`torch.device`, then ``self`` is returned.
            Otherwise, the returned tensor is a copy of ``self`` with the desired
            :class:`torch.dtype` and :class:`torch.device`.

        .. note::

            If ``self`` requires gradients (``requires_grad=True``) but the target
            ``dtype`` specified is an integer type, the returned tensor will implicitly
            set ``requires_grad=False``. This is because only tensors with
            floating-point or complex dtypes can require gradients.

        Here are the ways to call ``to``:

        .. method:: to(dtype, non_blocking=False, copy=False, memory_format=torch.preserve_format) -> Tensor
           :noindex:

            Returns a Tensor with the specified :attr:`dtype`

            Args:
                memory_format (:class:`torch.memory_format`, optional): the desired memory format of
                returned Tensor. Default: ``torch.preserve_format``.

        .. note::

            According to `C++ type conversion rules <https://en.cppreference.com/w/cpp/language/implicit_conversion.html>`_,
            converting floating point value to integer type will truncate the fractional part.
            If the truncated value cannot fit into the target type (e.g., casting ``torch.inf`` to ``torch.long``),
            the behavior is undefined and the result may vary across platforms.

        .. method:: to(device=None, dtype=None, non_blocking=False, copy=False, memory_format=torch.preserve_format) -> Tensor
           :noindex:

            Returns a Tensor with the specified :attr:`device` and (optional)
            :attr:`dtype`. If :attr:`dtype` is ``None`` it is inferred to be ``self.dtype``.
            When :attr:`non_blocking` is set to ``True``, the function attempts to perform
            the conversion asynchronously with respect to the host, if possible. This
            asynchronous behavior applies to both pinned and pageable memory. However,
            caution is advised when using this feature. For more information, refer to the
            `tutorial on good usage of non_blocking and pin_memory <https://pytorch.org/tutorials/intermediate/pinmem_nonblock.html>`__.
            When :attr:`copy` is set, a new Tensor is created even when the Tensor
            already matches the desired conversion.

            Args:
                memory_format (:class:`torch.memory_format`, optional): the desired memory format of
                returned Tensor. Default: ``torch.preserve_format``.

        .. method:: to(other, non_blocking=False, copy=False) -> Tensor
           :noindex:

            Returns a Tensor with same :class:`torch.dtype` and :class:`torch.device` as
            the Tensor :attr:`other`.
            When :attr:`non_blocking` is set to ``True``, the function attempts to perform
            the conversion asynchronously with respect to the host, if possible. This
            asynchronous behavior applies to both pinned and pageable memory. However,
            caution is advised when using this feature. For more information, refer to the
            `tutorial on good usage of non_blocking and pin_memory <https://pytorch.org/tutorials/intermediate/pinmem_nonblock.html>`__.
            When :attr:`copy` is set, a new Tensor is created even when the Tensor
            already matches the desired conversion.

        Example::

            >>> tensor = torch.randn(2, 2)  # Initially dtype=float32, device=cpu
            >>> tensor.to(torch.float64)
            tensor([[-0.5044,  0.0005],
                    [ 0.3310, -0.0584]], dtype=torch.float64)

            >>> cuda0 = torch.device('cuda:0')
            >>> tensor.to(cuda0)
            tensor([[-0.5044,  0.0005],
                    [ 0.3310, -0.0584]], device='cuda:0')

            >>> tensor.to(cuda0, dtype=torch.float64)
            tensor([[-0.5044,  0.0005],
                    [ 0.3310, -0.0584]], dtype=torch.float64, device='cuda:0')

            >>> other = torch.randn((), dtype=torch.float64, device=cuda0)
            >>> tensor.to(other, non_blocking=True)
            tensor([[-0.5044,  0.0005],
                    [ 0.3310, -0.0584]], dtype=torch.float64, device='cuda:0')
        """
    @overload
    def to(self, device=..., dtype=..., non_blocking=..., copy=..., memory_format=...) -> Tensor:
        """
        to(*args, **kwargs) -> Tensor

        Performs Tensor dtype and/or device conversion. A :class:`torch.dtype` and :class:`torch.device` are
        inferred from the arguments of ``self.to(*args, **kwargs)``.

        .. note::

            If the ``self`` Tensor already
            has the correct :class:`torch.dtype` and :class:`torch.device`, then ``self`` is returned.
            Otherwise, the returned tensor is a copy of ``self`` with the desired
            :class:`torch.dtype` and :class:`torch.device`.

        .. note::

            If ``self`` requires gradients (``requires_grad=True``) but the target
            ``dtype`` specified is an integer type, the returned tensor will implicitly
            set ``requires_grad=False``. This is because only tensors with
            floating-point or complex dtypes can require gradients.

        Here are the ways to call ``to``:

        .. method:: to(dtype, non_blocking=False, copy=False, memory_format=torch.preserve_format) -> Tensor
           :noindex:

            Returns a Tensor with the specified :attr:`dtype`

            Args:
                memory_format (:class:`torch.memory_format`, optional): the desired memory format of
                returned Tensor. Default: ``torch.preserve_format``.

        .. note::

            According to `C++ type conversion rules <https://en.cppreference.com/w/cpp/language/implicit_conversion.html>`_,
            converting floating point value to integer type will truncate the fractional part.
            If the truncated value cannot fit into the target type (e.g., casting ``torch.inf`` to ``torch.long``),
            the behavior is undefined and the result may vary across platforms.

        .. method:: to(device=None, dtype=None, non_blocking=False, copy=False, memory_format=torch.preserve_format) -> Tensor
           :noindex:

            Returns a Tensor with the specified :attr:`device` and (optional)
            :attr:`dtype`. If :attr:`dtype` is ``None`` it is inferred to be ``self.dtype``.
            When :attr:`non_blocking` is set to ``True``, the function attempts to perform
            the conversion asynchronously with respect to the host, if possible. This
            asynchronous behavior applies to both pinned and pageable memory. However,
            caution is advised when using this feature. For more information, refer to the
            `tutorial on good usage of non_blocking and pin_memory <https://pytorch.org/tutorials/intermediate/pinmem_nonblock.html>`__.
            When :attr:`copy` is set, a new Tensor is created even when the Tensor
            already matches the desired conversion.

            Args:
                memory_format (:class:`torch.memory_format`, optional): the desired memory format of
                returned Tensor. Default: ``torch.preserve_format``.

        .. method:: to(other, non_blocking=False, copy=False) -> Tensor
           :noindex:

            Returns a Tensor with same :class:`torch.dtype` and :class:`torch.device` as
            the Tensor :attr:`other`.
            When :attr:`non_blocking` is set to ``True``, the function attempts to perform
            the conversion asynchronously with respect to the host, if possible. This
            asynchronous behavior applies to both pinned and pageable memory. However,
            caution is advised when using this feature. For more information, refer to the
            `tutorial on good usage of non_blocking and pin_memory <https://pytorch.org/tutorials/intermediate/pinmem_nonblock.html>`__.
            When :attr:`copy` is set, a new Tensor is created even when the Tensor
            already matches the desired conversion.

        Example::

            >>> tensor = torch.randn(2, 2)  # Initially dtype=float32, device=cpu
            >>> tensor.to(torch.float64)
            tensor([[-0.5044,  0.0005],
                    [ 0.3310, -0.0584]], dtype=torch.float64)

            >>> cuda0 = torch.device('cuda:0')
            >>> tensor.to(cuda0)
            tensor([[-0.5044,  0.0005],
                    [ 0.3310, -0.0584]], device='cuda:0')

            >>> tensor.to(cuda0, dtype=torch.float64)
            tensor([[-0.5044,  0.0005],
                    [ 0.3310, -0.0584]], dtype=torch.float64, device='cuda:0')

            >>> other = torch.randn((), dtype=torch.float64, device=cuda0)
            >>> tensor.to(other, non_blocking=True)
            tensor([[-0.5044,  0.0005],
                    [ 0.3310, -0.0584]], dtype=torch.float64, device='cuda:0')
        """
    @overload
    def to(self, other, non_blocking=..., copy=...) -> Tensor:
        """
        to(*args, **kwargs) -> Tensor

        Performs Tensor dtype and/or device conversion. A :class:`torch.dtype` and :class:`torch.device` are
        inferred from the arguments of ``self.to(*args, **kwargs)``.

        .. note::

            If the ``self`` Tensor already
            has the correct :class:`torch.dtype` and :class:`torch.device`, then ``self`` is returned.
            Otherwise, the returned tensor is a copy of ``self`` with the desired
            :class:`torch.dtype` and :class:`torch.device`.

        .. note::

            If ``self`` requires gradients (``requires_grad=True``) but the target
            ``dtype`` specified is an integer type, the returned tensor will implicitly
            set ``requires_grad=False``. This is because only tensors with
            floating-point or complex dtypes can require gradients.

        Here are the ways to call ``to``:

        .. method:: to(dtype, non_blocking=False, copy=False, memory_format=torch.preserve_format) -> Tensor
           :noindex:

            Returns a Tensor with the specified :attr:`dtype`

            Args:
                memory_format (:class:`torch.memory_format`, optional): the desired memory format of
                returned Tensor. Default: ``torch.preserve_format``.

        .. note::

            According to `C++ type conversion rules <https://en.cppreference.com/w/cpp/language/implicit_conversion.html>`_,
            converting floating point value to integer type will truncate the fractional part.
            If the truncated value cannot fit into the target type (e.g., casting ``torch.inf`` to ``torch.long``),
            the behavior is undefined and the result may vary across platforms.

        .. method:: to(device=None, dtype=None, non_blocking=False, copy=False, memory_format=torch.preserve_format) -> Tensor
           :noindex:

            Returns a Tensor with the specified :attr:`device` and (optional)
            :attr:`dtype`. If :attr:`dtype` is ``None`` it is inferred to be ``self.dtype``.
            When :attr:`non_blocking` is set to ``True``, the function attempts to perform
            the conversion asynchronously with respect to the host, if possible. This
            asynchronous behavior applies to both pinned and pageable memory. However,
            caution is advised when using this feature. For more information, refer to the
            `tutorial on good usage of non_blocking and pin_memory <https://pytorch.org/tutorials/intermediate/pinmem_nonblock.html>`__.
            When :attr:`copy` is set, a new Tensor is created even when the Tensor
            already matches the desired conversion.

            Args:
                memory_format (:class:`torch.memory_format`, optional): the desired memory format of
                returned Tensor. Default: ``torch.preserve_format``.

        .. method:: to(other, non_blocking=False, copy=False) -> Tensor
           :noindex:

            Returns a Tensor with same :class:`torch.dtype` and :class:`torch.device` as
            the Tensor :attr:`other`.
            When :attr:`non_blocking` is set to ``True``, the function attempts to perform
            the conversion asynchronously with respect to the host, if possible. This
            asynchronous behavior applies to both pinned and pageable memory. However,
            caution is advised when using this feature. For more information, refer to the
            `tutorial on good usage of non_blocking and pin_memory <https://pytorch.org/tutorials/intermediate/pinmem_nonblock.html>`__.
            When :attr:`copy` is set, a new Tensor is created even when the Tensor
            already matches the desired conversion.

        Example::

            >>> tensor = torch.randn(2, 2)  # Initially dtype=float32, device=cpu
            >>> tensor.to(torch.float64)
            tensor([[-0.5044,  0.0005],
                    [ 0.3310, -0.0584]], dtype=torch.float64)

            >>> cuda0 = torch.device('cuda:0')
            >>> tensor.to(cuda0)
            tensor([[-0.5044,  0.0005],
                    [ 0.3310, -0.0584]], device='cuda:0')

            >>> tensor.to(cuda0, dtype=torch.float64)
            tensor([[-0.5044,  0.0005],
                    [ 0.3310, -0.0584]], dtype=torch.float64, device='cuda:0')

            >>> other = torch.randn((), dtype=torch.float64, device=cuda0)
            >>> tensor.to(other, non_blocking=True)
            tensor([[-0.5044,  0.0005],
                    [ 0.3310, -0.0584]], dtype=torch.float64, device='cuda:0')
        """
    @overload
    def to(self, cuda0) -> Any:
        """
        to(*args, **kwargs) -> Tensor

        Performs Tensor dtype and/or device conversion. A :class:`torch.dtype` and :class:`torch.device` are
        inferred from the arguments of ``self.to(*args, **kwargs)``.

        .. note::

            If the ``self`` Tensor already
            has the correct :class:`torch.dtype` and :class:`torch.device`, then ``self`` is returned.
            Otherwise, the returned tensor is a copy of ``self`` with the desired
            :class:`torch.dtype` and :class:`torch.device`.

        .. note::

            If ``self`` requires gradients (``requires_grad=True``) but the target
            ``dtype`` specified is an integer type, the returned tensor will implicitly
            set ``requires_grad=False``. This is because only tensors with
            floating-point or complex dtypes can require gradients.

        Here are the ways to call ``to``:

        .. method:: to(dtype, non_blocking=False, copy=False, memory_format=torch.preserve_format) -> Tensor
           :noindex:

            Returns a Tensor with the specified :attr:`dtype`

            Args:
                memory_format (:class:`torch.memory_format`, optional): the desired memory format of
                returned Tensor. Default: ``torch.preserve_format``.

        .. note::

            According to `C++ type conversion rules <https://en.cppreference.com/w/cpp/language/implicit_conversion.html>`_,
            converting floating point value to integer type will truncate the fractional part.
            If the truncated value cannot fit into the target type (e.g., casting ``torch.inf`` to ``torch.long``),
            the behavior is undefined and the result may vary across platforms.

        .. method:: to(device=None, dtype=None, non_blocking=False, copy=False, memory_format=torch.preserve_format) -> Tensor
           :noindex:

            Returns a Tensor with the specified :attr:`device` and (optional)
            :attr:`dtype`. If :attr:`dtype` is ``None`` it is inferred to be ``self.dtype``.
            When :attr:`non_blocking` is set to ``True``, the function attempts to perform
            the conversion asynchronously with respect to the host, if possible. This
            asynchronous behavior applies to both pinned and pageable memory. However,
            caution is advised when using this feature. For more information, refer to the
            `tutorial on good usage of non_blocking and pin_memory <https://pytorch.org/tutorials/intermediate/pinmem_nonblock.html>`__.
            When :attr:`copy` is set, a new Tensor is created even when the Tensor
            already matches the desired conversion.

            Args:
                memory_format (:class:`torch.memory_format`, optional): the desired memory format of
                returned Tensor. Default: ``torch.preserve_format``.

        .. method:: to(other, non_blocking=False, copy=False) -> Tensor
           :noindex:

            Returns a Tensor with same :class:`torch.dtype` and :class:`torch.device` as
            the Tensor :attr:`other`.
            When :attr:`non_blocking` is set to ``True``, the function attempts to perform
            the conversion asynchronously with respect to the host, if possible. This
            asynchronous behavior applies to both pinned and pageable memory. However,
            caution is advised when using this feature. For more information, refer to the
            `tutorial on good usage of non_blocking and pin_memory <https://pytorch.org/tutorials/intermediate/pinmem_nonblock.html>`__.
            When :attr:`copy` is set, a new Tensor is created even when the Tensor
            already matches the desired conversion.

        Example::

            >>> tensor = torch.randn(2, 2)  # Initially dtype=float32, device=cpu
            >>> tensor.to(torch.float64)
            tensor([[-0.5044,  0.0005],
                    [ 0.3310, -0.0584]], dtype=torch.float64)

            >>> cuda0 = torch.device('cuda:0')
            >>> tensor.to(cuda0)
            tensor([[-0.5044,  0.0005],
                    [ 0.3310, -0.0584]], device='cuda:0')

            >>> tensor.to(cuda0, dtype=torch.float64)
            tensor([[-0.5044,  0.0005],
                    [ 0.3310, -0.0584]], dtype=torch.float64, device='cuda:0')

            >>> other = torch.randn((), dtype=torch.float64, device=cuda0)
            >>> tensor.to(other, non_blocking=True)
            tensor([[-0.5044,  0.0005],
                    [ 0.3310, -0.0584]], dtype=torch.float64, device='cuda:0')
        """
    @overload
    def to(self, cuda0, dtype=...) -> Any:
        """
        to(*args, **kwargs) -> Tensor

        Performs Tensor dtype and/or device conversion. A :class:`torch.dtype` and :class:`torch.device` are
        inferred from the arguments of ``self.to(*args, **kwargs)``.

        .. note::

            If the ``self`` Tensor already
            has the correct :class:`torch.dtype` and :class:`torch.device`, then ``self`` is returned.
            Otherwise, the returned tensor is a copy of ``self`` with the desired
            :class:`torch.dtype` and :class:`torch.device`.

        .. note::

            If ``self`` requires gradients (``requires_grad=True``) but the target
            ``dtype`` specified is an integer type, the returned tensor will implicitly
            set ``requires_grad=False``. This is because only tensors with
            floating-point or complex dtypes can require gradients.

        Here are the ways to call ``to``:

        .. method:: to(dtype, non_blocking=False, copy=False, memory_format=torch.preserve_format) -> Tensor
           :noindex:

            Returns a Tensor with the specified :attr:`dtype`

            Args:
                memory_format (:class:`torch.memory_format`, optional): the desired memory format of
                returned Tensor. Default: ``torch.preserve_format``.

        .. note::

            According to `C++ type conversion rules <https://en.cppreference.com/w/cpp/language/implicit_conversion.html>`_,
            converting floating point value to integer type will truncate the fractional part.
            If the truncated value cannot fit into the target type (e.g., casting ``torch.inf`` to ``torch.long``),
            the behavior is undefined and the result may vary across platforms.

        .. method:: to(device=None, dtype=None, non_blocking=False, copy=False, memory_format=torch.preserve_format) -> Tensor
           :noindex:

            Returns a Tensor with the specified :attr:`device` and (optional)
            :attr:`dtype`. If :attr:`dtype` is ``None`` it is inferred to be ``self.dtype``.
            When :attr:`non_blocking` is set to ``True``, the function attempts to perform
            the conversion asynchronously with respect to the host, if possible. This
            asynchronous behavior applies to both pinned and pageable memory. However,
            caution is advised when using this feature. For more information, refer to the
            `tutorial on good usage of non_blocking and pin_memory <https://pytorch.org/tutorials/intermediate/pinmem_nonblock.html>`__.
            When :attr:`copy` is set, a new Tensor is created even when the Tensor
            already matches the desired conversion.

            Args:
                memory_format (:class:`torch.memory_format`, optional): the desired memory format of
                returned Tensor. Default: ``torch.preserve_format``.

        .. method:: to(other, non_blocking=False, copy=False) -> Tensor
           :noindex:

            Returns a Tensor with same :class:`torch.dtype` and :class:`torch.device` as
            the Tensor :attr:`other`.
            When :attr:`non_blocking` is set to ``True``, the function attempts to perform
            the conversion asynchronously with respect to the host, if possible. This
            asynchronous behavior applies to both pinned and pageable memory. However,
            caution is advised when using this feature. For more information, refer to the
            `tutorial on good usage of non_blocking and pin_memory <https://pytorch.org/tutorials/intermediate/pinmem_nonblock.html>`__.
            When :attr:`copy` is set, a new Tensor is created even when the Tensor
            already matches the desired conversion.

        Example::

            >>> tensor = torch.randn(2, 2)  # Initially dtype=float32, device=cpu
            >>> tensor.to(torch.float64)
            tensor([[-0.5044,  0.0005],
                    [ 0.3310, -0.0584]], dtype=torch.float64)

            >>> cuda0 = torch.device('cuda:0')
            >>> tensor.to(cuda0)
            tensor([[-0.5044,  0.0005],
                    [ 0.3310, -0.0584]], device='cuda:0')

            >>> tensor.to(cuda0, dtype=torch.float64)
            tensor([[-0.5044,  0.0005],
                    [ 0.3310, -0.0584]], dtype=torch.float64, device='cuda:0')

            >>> other = torch.randn((), dtype=torch.float64, device=cuda0)
            >>> tensor.to(other, non_blocking=True)
            tensor([[-0.5044,  0.0005],
                    [ 0.3310, -0.0584]], dtype=torch.float64, device='cuda:0')
        """
    @overload
    def to(self, other, non_blocking=...) -> Any:
        """
        to(*args, **kwargs) -> Tensor

        Performs Tensor dtype and/or device conversion. A :class:`torch.dtype` and :class:`torch.device` are
        inferred from the arguments of ``self.to(*args, **kwargs)``.

        .. note::

            If the ``self`` Tensor already
            has the correct :class:`torch.dtype` and :class:`torch.device`, then ``self`` is returned.
            Otherwise, the returned tensor is a copy of ``self`` with the desired
            :class:`torch.dtype` and :class:`torch.device`.

        .. note::

            If ``self`` requires gradients (``requires_grad=True``) but the target
            ``dtype`` specified is an integer type, the returned tensor will implicitly
            set ``requires_grad=False``. This is because only tensors with
            floating-point or complex dtypes can require gradients.

        Here are the ways to call ``to``:

        .. method:: to(dtype, non_blocking=False, copy=False, memory_format=torch.preserve_format) -> Tensor
           :noindex:

            Returns a Tensor with the specified :attr:`dtype`

            Args:
                memory_format (:class:`torch.memory_format`, optional): the desired memory format of
                returned Tensor. Default: ``torch.preserve_format``.

        .. note::

            According to `C++ type conversion rules <https://en.cppreference.com/w/cpp/language/implicit_conversion.html>`_,
            converting floating point value to integer type will truncate the fractional part.
            If the truncated value cannot fit into the target type (e.g., casting ``torch.inf`` to ``torch.long``),
            the behavior is undefined and the result may vary across platforms.

        .. method:: to(device=None, dtype=None, non_blocking=False, copy=False, memory_format=torch.preserve_format) -> Tensor
           :noindex:

            Returns a Tensor with the specified :attr:`device` and (optional)
            :attr:`dtype`. If :attr:`dtype` is ``None`` it is inferred to be ``self.dtype``.
            When :attr:`non_blocking` is set to ``True``, the function attempts to perform
            the conversion asynchronously with respect to the host, if possible. This
            asynchronous behavior applies to both pinned and pageable memory. However,
            caution is advised when using this feature. For more information, refer to the
            `tutorial on good usage of non_blocking and pin_memory <https://pytorch.org/tutorials/intermediate/pinmem_nonblock.html>`__.
            When :attr:`copy` is set, a new Tensor is created even when the Tensor
            already matches the desired conversion.

            Args:
                memory_format (:class:`torch.memory_format`, optional): the desired memory format of
                returned Tensor. Default: ``torch.preserve_format``.

        .. method:: to(other, non_blocking=False, copy=False) -> Tensor
           :noindex:

            Returns a Tensor with same :class:`torch.dtype` and :class:`torch.device` as
            the Tensor :attr:`other`.
            When :attr:`non_blocking` is set to ``True``, the function attempts to perform
            the conversion asynchronously with respect to the host, if possible. This
            asynchronous behavior applies to both pinned and pageable memory. However,
            caution is advised when using this feature. For more information, refer to the
            `tutorial on good usage of non_blocking and pin_memory <https://pytorch.org/tutorials/intermediate/pinmem_nonblock.html>`__.
            When :attr:`copy` is set, a new Tensor is created even when the Tensor
            already matches the desired conversion.

        Example::

            >>> tensor = torch.randn(2, 2)  # Initially dtype=float32, device=cpu
            >>> tensor.to(torch.float64)
            tensor([[-0.5044,  0.0005],
                    [ 0.3310, -0.0584]], dtype=torch.float64)

            >>> cuda0 = torch.device('cuda:0')
            >>> tensor.to(cuda0)
            tensor([[-0.5044,  0.0005],
                    [ 0.3310, -0.0584]], device='cuda:0')

            >>> tensor.to(cuda0, dtype=torch.float64)
            tensor([[-0.5044,  0.0005],
                    [ 0.3310, -0.0584]], dtype=torch.float64, device='cuda:0')

            >>> other = torch.randn((), dtype=torch.float64, device=cuda0)
            >>> tensor.to(other, non_blocking=True)
            tensor([[-0.5044,  0.0005],
                    [ 0.3310, -0.0584]], dtype=torch.float64, device='cuda:0')
        """
    @overload
    def to(self, *args, **kwargs) -> Tensor:
        """
        to(*args, **kwargs) -> Tensor

        Performs Tensor dtype and/or device conversion. A :class:`torch.dtype` and :class:`torch.device` are
        inferred from the arguments of ``self.to(*args, **kwargs)``.

        .. note::

            If the ``self`` Tensor already
            has the correct :class:`torch.dtype` and :class:`torch.device`, then ``self`` is returned.
            Otherwise, the returned tensor is a copy of ``self`` with the desired
            :class:`torch.dtype` and :class:`torch.device`.

        .. note::

            If ``self`` requires gradients (``requires_grad=True``) but the target
            ``dtype`` specified is an integer type, the returned tensor will implicitly
            set ``requires_grad=False``. This is because only tensors with
            floating-point or complex dtypes can require gradients.

        Here are the ways to call ``to``:

        .. method:: to(dtype, non_blocking=False, copy=False, memory_format=torch.preserve_format) -> Tensor
           :noindex:

            Returns a Tensor with the specified :attr:`dtype`

            Args:
                memory_format (:class:`torch.memory_format`, optional): the desired memory format of
                returned Tensor. Default: ``torch.preserve_format``.

        .. note::

            According to `C++ type conversion rules <https://en.cppreference.com/w/cpp/language/implicit_conversion.html>`_,
            converting floating point value to integer type will truncate the fractional part.
            If the truncated value cannot fit into the target type (e.g., casting ``torch.inf`` to ``torch.long``),
            the behavior is undefined and the result may vary across platforms.

        .. method:: to(device=None, dtype=None, non_blocking=False, copy=False, memory_format=torch.preserve_format) -> Tensor
           :noindex:

            Returns a Tensor with the specified :attr:`device` and (optional)
            :attr:`dtype`. If :attr:`dtype` is ``None`` it is inferred to be ``self.dtype``.
            When :attr:`non_blocking` is set to ``True``, the function attempts to perform
            the conversion asynchronously with respect to the host, if possible. This
            asynchronous behavior applies to both pinned and pageable memory. However,
            caution is advised when using this feature. For more information, refer to the
            `tutorial on good usage of non_blocking and pin_memory <https://pytorch.org/tutorials/intermediate/pinmem_nonblock.html>`__.
            When :attr:`copy` is set, a new Tensor is created even when the Tensor
            already matches the desired conversion.

            Args:
                memory_format (:class:`torch.memory_format`, optional): the desired memory format of
                returned Tensor. Default: ``torch.preserve_format``.

        .. method:: to(other, non_blocking=False, copy=False) -> Tensor
           :noindex:

            Returns a Tensor with same :class:`torch.dtype` and :class:`torch.device` as
            the Tensor :attr:`other`.
            When :attr:`non_blocking` is set to ``True``, the function attempts to perform
            the conversion asynchronously with respect to the host, if possible. This
            asynchronous behavior applies to both pinned and pageable memory. However,
            caution is advised when using this feature. For more information, refer to the
            `tutorial on good usage of non_blocking and pin_memory <https://pytorch.org/tutorials/intermediate/pinmem_nonblock.html>`__.
            When :attr:`copy` is set, a new Tensor is created even when the Tensor
            already matches the desired conversion.

        Example::

            >>> tensor = torch.randn(2, 2)  # Initially dtype=float32, device=cpu
            >>> tensor.to(torch.float64)
            tensor([[-0.5044,  0.0005],
                    [ 0.3310, -0.0584]], dtype=torch.float64)

            >>> cuda0 = torch.device('cuda:0')
            >>> tensor.to(cuda0)
            tensor([[-0.5044,  0.0005],
                    [ 0.3310, -0.0584]], device='cuda:0')

            >>> tensor.to(cuda0, dtype=torch.float64)
            tensor([[-0.5044,  0.0005],
                    [ 0.3310, -0.0584]], dtype=torch.float64, device='cuda:0')

            >>> other = torch.randn((), dtype=torch.float64, device=cuda0)
            >>> tensor.to(other, non_blocking=True)
            tensor([[-0.5044,  0.0005],
                    [ 0.3310, -0.0584]], dtype=torch.float64, device='cuda:0')
        """
    @overload
    def to(self, *args, **kwargs) -> Any:
        """
        to(*args, **kwargs) -> Tensor

        Performs Tensor dtype and/or device conversion. A :class:`torch.dtype` and :class:`torch.device` are
        inferred from the arguments of ``self.to(*args, **kwargs)``.

        .. note::

            If the ``self`` Tensor already
            has the correct :class:`torch.dtype` and :class:`torch.device`, then ``self`` is returned.
            Otherwise, the returned tensor is a copy of ``self`` with the desired
            :class:`torch.dtype` and :class:`torch.device`.

        .. note::

            If ``self`` requires gradients (``requires_grad=True``) but the target
            ``dtype`` specified is an integer type, the returned tensor will implicitly
            set ``requires_grad=False``. This is because only tensors with
            floating-point or complex dtypes can require gradients.

        Here are the ways to call ``to``:

        .. method:: to(dtype, non_blocking=False, copy=False, memory_format=torch.preserve_format) -> Tensor
           :noindex:

            Returns a Tensor with the specified :attr:`dtype`

            Args:
                memory_format (:class:`torch.memory_format`, optional): the desired memory format of
                returned Tensor. Default: ``torch.preserve_format``.

        .. note::

            According to `C++ type conversion rules <https://en.cppreference.com/w/cpp/language/implicit_conversion.html>`_,
            converting floating point value to integer type will truncate the fractional part.
            If the truncated value cannot fit into the target type (e.g., casting ``torch.inf`` to ``torch.long``),
            the behavior is undefined and the result may vary across platforms.

        .. method:: to(device=None, dtype=None, non_blocking=False, copy=False, memory_format=torch.preserve_format) -> Tensor
           :noindex:

            Returns a Tensor with the specified :attr:`device` and (optional)
            :attr:`dtype`. If :attr:`dtype` is ``None`` it is inferred to be ``self.dtype``.
            When :attr:`non_blocking` is set to ``True``, the function attempts to perform
            the conversion asynchronously with respect to the host, if possible. This
            asynchronous behavior applies to both pinned and pageable memory. However,
            caution is advised when using this feature. For more information, refer to the
            `tutorial on good usage of non_blocking and pin_memory <https://pytorch.org/tutorials/intermediate/pinmem_nonblock.html>`__.
            When :attr:`copy` is set, a new Tensor is created even when the Tensor
            already matches the desired conversion.

            Args:
                memory_format (:class:`torch.memory_format`, optional): the desired memory format of
                returned Tensor. Default: ``torch.preserve_format``.

        .. method:: to(other, non_blocking=False, copy=False) -> Tensor
           :noindex:

            Returns a Tensor with same :class:`torch.dtype` and :class:`torch.device` as
            the Tensor :attr:`other`.
            When :attr:`non_blocking` is set to ``True``, the function attempts to perform
            the conversion asynchronously with respect to the host, if possible. This
            asynchronous behavior applies to both pinned and pageable memory. However,
            caution is advised when using this feature. For more information, refer to the
            `tutorial on good usage of non_blocking and pin_memory <https://pytorch.org/tutorials/intermediate/pinmem_nonblock.html>`__.
            When :attr:`copy` is set, a new Tensor is created even when the Tensor
            already matches the desired conversion.

        Example::

            >>> tensor = torch.randn(2, 2)  # Initially dtype=float32, device=cpu
            >>> tensor.to(torch.float64)
            tensor([[-0.5044,  0.0005],
                    [ 0.3310, -0.0584]], dtype=torch.float64)

            >>> cuda0 = torch.device('cuda:0')
            >>> tensor.to(cuda0)
            tensor([[-0.5044,  0.0005],
                    [ 0.3310, -0.0584]], device='cuda:0')

            >>> tensor.to(cuda0, dtype=torch.float64)
            tensor([[-0.5044,  0.0005],
                    [ 0.3310, -0.0584]], dtype=torch.float64, device='cuda:0')

            >>> other = torch.randn((), dtype=torch.float64, device=cuda0)
            >>> tensor.to(other, non_blocking=True)
            tensor([[-0.5044,  0.0005],
                    [ 0.3310, -0.0584]], dtype=torch.float64, device='cuda:0')
        """
    @overload
    def to_dense(self, dtype=..., masked_grad=...) -> Tensor:
        """
        to_dense(dtype=None, *, masked_grad=True) -> Tensor

        Creates a strided copy of :attr:`self` if :attr:`self` is not a strided tensor, otherwise returns :attr:`self`.

        Keyword args:
            {dtype}
            masked_grad (bool, optional): If set to ``True`` (default) and
              :attr:`self` has a sparse layout then the backward of
              :meth:`to_dense` returns ``grad.sparse_mask(self)``.

        Example::

            >>> s = torch.sparse_coo_tensor(
            ...        torch.tensor([[1, 1],
            ...                      [0, 2]]),
            ...        torch.tensor([9, 10]),
            ...        size=(3, 3))
            >>> s.to_dense()
            tensor([[ 0,  0,  0],
                    [ 9,  0, 10],
                    [ 0,  0,  0]])
        """
    @overload
    def to_dense(self) -> Any:
        """
        to_dense(dtype=None, *, masked_grad=True) -> Tensor

        Creates a strided copy of :attr:`self` if :attr:`self` is not a strided tensor, otherwise returns :attr:`self`.

        Keyword args:
            {dtype}
            masked_grad (bool, optional): If set to ``True`` (default) and
              :attr:`self` has a sparse layout then the backward of
              :meth:`to_dense` returns ``grad.sparse_mask(self)``.

        Example::

            >>> s = torch.sparse_coo_tensor(
            ...        torch.tensor([[1, 1],
            ...                      [0, 2]]),
            ...        torch.tensor([9, 10]),
            ...        size=(3, 3))
            >>> s.to_dense()
            tensor([[ 0,  0,  0],
                    [ 9,  0, 10],
                    [ 0,  0,  0]])
        """
    def to_mkldnn(self) -> Tensor:
        """
        to_mkldnn() -> Tensor
        Returns a copy of the tensor in ``torch.mkldnn`` layout.

        """
    def to_padded_tensor(self, padding, output_size=...) -> Tensor:
        """
        to_padded_tensor(padding, output_size=None) -> Tensor
        See :func:`to_padded_tensor`
        """
    @overload
    def to_sparse(self, sparseDims) -> Tensor:
        """
        to_sparse(sparseDims) -> Tensor

        Returns a sparse copy of the tensor.  PyTorch supports sparse tensors in
        :ref:`coordinate format <sparse-coo-docs>`.

        Args:
            sparseDims (int, optional): the number of sparse dimensions to include in the new sparse tensor

        Example::

            >>> d = torch.tensor([[0, 0, 0], [9, 0, 10], [0, 0, 0]])
            >>> d
            tensor([[ 0,  0,  0],
                    [ 9,  0, 10],
                    [ 0,  0,  0]])
            >>> d.to_sparse()
            tensor(indices=tensor([[1, 1],
                                   [0, 2]]),
                   values=tensor([ 9, 10]),
                   size=(3, 3), nnz=2, layout=torch.sparse_coo)
            >>> d.to_sparse(1)
            tensor(indices=tensor([[1]]),
                   values=tensor([[ 9,  0, 10]]),
                   size=(3, 3), nnz=1, layout=torch.sparse_coo)

        .. method:: to_sparse(*, layout=None, blocksize=None, dense_dim=None) -> Tensor
           :noindex:

        Returns a sparse tensor with the specified layout and blocksize.  If
        the :attr:`self` is strided, the number of dense dimensions could be
        specified, and a hybrid sparse tensor will be created, with
        `dense_dim` dense dimensions and `self.dim() - 2 - dense_dim` batch
        dimension.

        .. note:: If the :attr:`self` layout and blocksize parameters match
                  with the specified layout and blocksize, return
                  :attr:`self`. Otherwise, return a sparse tensor copy of
                  :attr:`self`.

        Args:

            layout (:class:`torch.layout`, optional): The desired sparse
              layout. One of ``torch.sparse_coo``, ``torch.sparse_csr``,
              ``torch.sparse_csc``, ``torch.sparse_bsr``, or
              ``torch.sparse_bsc``. Default: if ``None``,
              ``torch.sparse_coo``.

            blocksize (list, tuple, :class:`torch.Size`, optional): Block size
              of the resulting BSR or BSC tensor. For other layouts,
              specifying the block size that is not ``None`` will result in a
              RuntimeError exception.  A block size must be a tuple of length
              two such that its items evenly divide the two sparse dimensions.

            dense_dim (int, optional): Number of dense dimensions of the
              resulting CSR, CSC, BSR or BSC tensor.  This argument should be
              used only if :attr:`self` is a strided tensor, and must be a
              value between 0 and dimension of :attr:`self` tensor minus two.

        Example::

            >>> x = torch.tensor([[1, 0], [0, 0], [2, 3]])
            >>> x.to_sparse(layout=torch.sparse_coo)
            tensor(indices=tensor([[0, 2, 2],
                                   [0, 0, 1]]),
                   values=tensor([1, 2, 3]),
                   size=(3, 2), nnz=3, layout=torch.sparse_coo)
            >>> x.to_sparse(layout=torch.sparse_bsr, blocksize=(1, 2))
            tensor(crow_indices=tensor([0, 1, 1, 2]),
                   col_indices=tensor([0, 0]),
                   values=tensor([[[1, 0]],
                                  [[2, 3]]]), size=(3, 2), nnz=2, layout=torch.sparse_bsr)
            >>> x.to_sparse(layout=torch.sparse_bsr, blocksize=(2, 1))
            RuntimeError: Tensor size(-2) 3 needs to be divisible by blocksize[0] 2
            >>> x.to_sparse(layout=torch.sparse_csr, blocksize=(3, 1))
            RuntimeError: to_sparse for Strided to SparseCsr conversion does not use specified blocksize

            >>> x = torch.tensor([[[1], [0]], [[0], [0]], [[2], [3]]])
            >>> x.to_sparse(layout=torch.sparse_csr, dense_dim=1)
            tensor(crow_indices=tensor([0, 1, 1, 3]),
                   col_indices=tensor([0, 0, 1]),
                   values=tensor([[1],
                                  [2],
                                  [3]]), size=(3, 2, 1), nnz=3, layout=torch.sparse_csr)

        """
    @overload
    def to_sparse(self) -> Any:
        """
        to_sparse(sparseDims) -> Tensor

        Returns a sparse copy of the tensor.  PyTorch supports sparse tensors in
        :ref:`coordinate format <sparse-coo-docs>`.

        Args:
            sparseDims (int, optional): the number of sparse dimensions to include in the new sparse tensor

        Example::

            >>> d = torch.tensor([[0, 0, 0], [9, 0, 10], [0, 0, 0]])
            >>> d
            tensor([[ 0,  0,  0],
                    [ 9,  0, 10],
                    [ 0,  0,  0]])
            >>> d.to_sparse()
            tensor(indices=tensor([[1, 1],
                                   [0, 2]]),
                   values=tensor([ 9, 10]),
                   size=(3, 3), nnz=2, layout=torch.sparse_coo)
            >>> d.to_sparse(1)
            tensor(indices=tensor([[1]]),
                   values=tensor([[ 9,  0, 10]]),
                   size=(3, 3), nnz=1, layout=torch.sparse_coo)

        .. method:: to_sparse(*, layout=None, blocksize=None, dense_dim=None) -> Tensor
           :noindex:

        Returns a sparse tensor with the specified layout and blocksize.  If
        the :attr:`self` is strided, the number of dense dimensions could be
        specified, and a hybrid sparse tensor will be created, with
        `dense_dim` dense dimensions and `self.dim() - 2 - dense_dim` batch
        dimension.

        .. note:: If the :attr:`self` layout and blocksize parameters match
                  with the specified layout and blocksize, return
                  :attr:`self`. Otherwise, return a sparse tensor copy of
                  :attr:`self`.

        Args:

            layout (:class:`torch.layout`, optional): The desired sparse
              layout. One of ``torch.sparse_coo``, ``torch.sparse_csr``,
              ``torch.sparse_csc``, ``torch.sparse_bsr``, or
              ``torch.sparse_bsc``. Default: if ``None``,
              ``torch.sparse_coo``.

            blocksize (list, tuple, :class:`torch.Size`, optional): Block size
              of the resulting BSR or BSC tensor. For other layouts,
              specifying the block size that is not ``None`` will result in a
              RuntimeError exception.  A block size must be a tuple of length
              two such that its items evenly divide the two sparse dimensions.

            dense_dim (int, optional): Number of dense dimensions of the
              resulting CSR, CSC, BSR or BSC tensor.  This argument should be
              used only if :attr:`self` is a strided tensor, and must be a
              value between 0 and dimension of :attr:`self` tensor minus two.

        Example::

            >>> x = torch.tensor([[1, 0], [0, 0], [2, 3]])
            >>> x.to_sparse(layout=torch.sparse_coo)
            tensor(indices=tensor([[0, 2, 2],
                                   [0, 0, 1]]),
                   values=tensor([1, 2, 3]),
                   size=(3, 2), nnz=3, layout=torch.sparse_coo)
            >>> x.to_sparse(layout=torch.sparse_bsr, blocksize=(1, 2))
            tensor(crow_indices=tensor([0, 1, 1, 2]),
                   col_indices=tensor([0, 0]),
                   values=tensor([[[1, 0]],
                                  [[2, 3]]]), size=(3, 2), nnz=2, layout=torch.sparse_bsr)
            >>> x.to_sparse(layout=torch.sparse_bsr, blocksize=(2, 1))
            RuntimeError: Tensor size(-2) 3 needs to be divisible by blocksize[0] 2
            >>> x.to_sparse(layout=torch.sparse_csr, blocksize=(3, 1))
            RuntimeError: to_sparse for Strided to SparseCsr conversion does not use specified blocksize

            >>> x = torch.tensor([[[1], [0]], [[0], [0]], [[2], [3]]])
            >>> x.to_sparse(layout=torch.sparse_csr, dense_dim=1)
            tensor(crow_indices=tensor([0, 1, 1, 3]),
                   col_indices=tensor([0, 0, 1]),
                   values=tensor([[1],
                                  [2],
                                  [3]]), size=(3, 2, 1), nnz=3, layout=torch.sparse_csr)

        """
    @overload
    def to_sparse(self, 1, layout=..., blocksize=..., dense_dim=...) -> Tensor:
        """
        to_sparse(sparseDims) -> Tensor

        Returns a sparse copy of the tensor.  PyTorch supports sparse tensors in
        :ref:`coordinate format <sparse-coo-docs>`.

        Args:
            sparseDims (int, optional): the number of sparse dimensions to include in the new sparse tensor

        Example::

            >>> d = torch.tensor([[0, 0, 0], [9, 0, 10], [0, 0, 0]])
            >>> d
            tensor([[ 0,  0,  0],
                    [ 9,  0, 10],
                    [ 0,  0,  0]])
            >>> d.to_sparse()
            tensor(indices=tensor([[1, 1],
                                   [0, 2]]),
                   values=tensor([ 9, 10]),
                   size=(3, 3), nnz=2, layout=torch.sparse_coo)
            >>> d.to_sparse(1)
            tensor(indices=tensor([[1]]),
                   values=tensor([[ 9,  0, 10]]),
                   size=(3, 3), nnz=1, layout=torch.sparse_coo)

        .. method:: to_sparse(*, layout=None, blocksize=None, dense_dim=None) -> Tensor
           :noindex:

        Returns a sparse tensor with the specified layout and blocksize.  If
        the :attr:`self` is strided, the number of dense dimensions could be
        specified, and a hybrid sparse tensor will be created, with
        `dense_dim` dense dimensions and `self.dim() - 2 - dense_dim` batch
        dimension.

        .. note:: If the :attr:`self` layout and blocksize parameters match
                  with the specified layout and blocksize, return
                  :attr:`self`. Otherwise, return a sparse tensor copy of
                  :attr:`self`.

        Args:

            layout (:class:`torch.layout`, optional): The desired sparse
              layout. One of ``torch.sparse_coo``, ``torch.sparse_csr``,
              ``torch.sparse_csc``, ``torch.sparse_bsr``, or
              ``torch.sparse_bsc``. Default: if ``None``,
              ``torch.sparse_coo``.

            blocksize (list, tuple, :class:`torch.Size`, optional): Block size
              of the resulting BSR or BSC tensor. For other layouts,
              specifying the block size that is not ``None`` will result in a
              RuntimeError exception.  A block size must be a tuple of length
              two such that its items evenly divide the two sparse dimensions.

            dense_dim (int, optional): Number of dense dimensions of the
              resulting CSR, CSC, BSR or BSC tensor.  This argument should be
              used only if :attr:`self` is a strided tensor, and must be a
              value between 0 and dimension of :attr:`self` tensor minus two.

        Example::

            >>> x = torch.tensor([[1, 0], [0, 0], [2, 3]])
            >>> x.to_sparse(layout=torch.sparse_coo)
            tensor(indices=tensor([[0, 2, 2],
                                   [0, 0, 1]]),
                   values=tensor([1, 2, 3]),
                   size=(3, 2), nnz=3, layout=torch.sparse_coo)
            >>> x.to_sparse(layout=torch.sparse_bsr, blocksize=(1, 2))
            tensor(crow_indices=tensor([0, 1, 1, 2]),
                   col_indices=tensor([0, 0]),
                   values=tensor([[[1, 0]],
                                  [[2, 3]]]), size=(3, 2), nnz=2, layout=torch.sparse_bsr)
            >>> x.to_sparse(layout=torch.sparse_bsr, blocksize=(2, 1))
            RuntimeError: Tensor size(-2) 3 needs to be divisible by blocksize[0] 2
            >>> x.to_sparse(layout=torch.sparse_csr, blocksize=(3, 1))
            RuntimeError: to_sparse for Strided to SparseCsr conversion does not use specified blocksize

            >>> x = torch.tensor([[[1], [0]], [[0], [0]], [[2], [3]]])
            >>> x.to_sparse(layout=torch.sparse_csr, dense_dim=1)
            tensor(crow_indices=tensor([0, 1, 1, 3]),
                   col_indices=tensor([0, 0, 1]),
                   values=tensor([[1],
                                  [2],
                                  [3]]), size=(3, 2, 1), nnz=3, layout=torch.sparse_csr)

        """
    @overload
    def to_sparse(self, layout=...) -> Any:
        """
        to_sparse(sparseDims) -> Tensor

        Returns a sparse copy of the tensor.  PyTorch supports sparse tensors in
        :ref:`coordinate format <sparse-coo-docs>`.

        Args:
            sparseDims (int, optional): the number of sparse dimensions to include in the new sparse tensor

        Example::

            >>> d = torch.tensor([[0, 0, 0], [9, 0, 10], [0, 0, 0]])
            >>> d
            tensor([[ 0,  0,  0],
                    [ 9,  0, 10],
                    [ 0,  0,  0]])
            >>> d.to_sparse()
            tensor(indices=tensor([[1, 1],
                                   [0, 2]]),
                   values=tensor([ 9, 10]),
                   size=(3, 3), nnz=2, layout=torch.sparse_coo)
            >>> d.to_sparse(1)
            tensor(indices=tensor([[1]]),
                   values=tensor([[ 9,  0, 10]]),
                   size=(3, 3), nnz=1, layout=torch.sparse_coo)

        .. method:: to_sparse(*, layout=None, blocksize=None, dense_dim=None) -> Tensor
           :noindex:

        Returns a sparse tensor with the specified layout and blocksize.  If
        the :attr:`self` is strided, the number of dense dimensions could be
        specified, and a hybrid sparse tensor will be created, with
        `dense_dim` dense dimensions and `self.dim() - 2 - dense_dim` batch
        dimension.

        .. note:: If the :attr:`self` layout and blocksize parameters match
                  with the specified layout and blocksize, return
                  :attr:`self`. Otherwise, return a sparse tensor copy of
                  :attr:`self`.

        Args:

            layout (:class:`torch.layout`, optional): The desired sparse
              layout. One of ``torch.sparse_coo``, ``torch.sparse_csr``,
              ``torch.sparse_csc``, ``torch.sparse_bsr``, or
              ``torch.sparse_bsc``. Default: if ``None``,
              ``torch.sparse_coo``.

            blocksize (list, tuple, :class:`torch.Size`, optional): Block size
              of the resulting BSR or BSC tensor. For other layouts,
              specifying the block size that is not ``None`` will result in a
              RuntimeError exception.  A block size must be a tuple of length
              two such that its items evenly divide the two sparse dimensions.

            dense_dim (int, optional): Number of dense dimensions of the
              resulting CSR, CSC, BSR or BSC tensor.  This argument should be
              used only if :attr:`self` is a strided tensor, and must be a
              value between 0 and dimension of :attr:`self` tensor minus two.

        Example::

            >>> x = torch.tensor([[1, 0], [0, 0], [2, 3]])
            >>> x.to_sparse(layout=torch.sparse_coo)
            tensor(indices=tensor([[0, 2, 2],
                                   [0, 0, 1]]),
                   values=tensor([1, 2, 3]),
                   size=(3, 2), nnz=3, layout=torch.sparse_coo)
            >>> x.to_sparse(layout=torch.sparse_bsr, blocksize=(1, 2))
            tensor(crow_indices=tensor([0, 1, 1, 2]),
                   col_indices=tensor([0, 0]),
                   values=tensor([[[1, 0]],
                                  [[2, 3]]]), size=(3, 2), nnz=2, layout=torch.sparse_bsr)
            >>> x.to_sparse(layout=torch.sparse_bsr, blocksize=(2, 1))
            RuntimeError: Tensor size(-2) 3 needs to be divisible by blocksize[0] 2
            >>> x.to_sparse(layout=torch.sparse_csr, blocksize=(3, 1))
            RuntimeError: to_sparse for Strided to SparseCsr conversion does not use specified blocksize

            >>> x = torch.tensor([[[1], [0]], [[0], [0]], [[2], [3]]])
            >>> x.to_sparse(layout=torch.sparse_csr, dense_dim=1)
            tensor(crow_indices=tensor([0, 1, 1, 3]),
                   col_indices=tensor([0, 0, 1]),
                   values=tensor([[1],
                                  [2],
                                  [3]]), size=(3, 2, 1), nnz=3, layout=torch.sparse_csr)

        """
    @overload
    def to_sparse(self, layout=..., blocksize=...) -> Any:
        """
        to_sparse(sparseDims) -> Tensor

        Returns a sparse copy of the tensor.  PyTorch supports sparse tensors in
        :ref:`coordinate format <sparse-coo-docs>`.

        Args:
            sparseDims (int, optional): the number of sparse dimensions to include in the new sparse tensor

        Example::

            >>> d = torch.tensor([[0, 0, 0], [9, 0, 10], [0, 0, 0]])
            >>> d
            tensor([[ 0,  0,  0],
                    [ 9,  0, 10],
                    [ 0,  0,  0]])
            >>> d.to_sparse()
            tensor(indices=tensor([[1, 1],
                                   [0, 2]]),
                   values=tensor([ 9, 10]),
                   size=(3, 3), nnz=2, layout=torch.sparse_coo)
            >>> d.to_sparse(1)
            tensor(indices=tensor([[1]]),
                   values=tensor([[ 9,  0, 10]]),
                   size=(3, 3), nnz=1, layout=torch.sparse_coo)

        .. method:: to_sparse(*, layout=None, blocksize=None, dense_dim=None) -> Tensor
           :noindex:

        Returns a sparse tensor with the specified layout and blocksize.  If
        the :attr:`self` is strided, the number of dense dimensions could be
        specified, and a hybrid sparse tensor will be created, with
        `dense_dim` dense dimensions and `self.dim() - 2 - dense_dim` batch
        dimension.

        .. note:: If the :attr:`self` layout and blocksize parameters match
                  with the specified layout and blocksize, return
                  :attr:`self`. Otherwise, return a sparse tensor copy of
                  :attr:`self`.

        Args:

            layout (:class:`torch.layout`, optional): The desired sparse
              layout. One of ``torch.sparse_coo``, ``torch.sparse_csr``,
              ``torch.sparse_csc``, ``torch.sparse_bsr``, or
              ``torch.sparse_bsc``. Default: if ``None``,
              ``torch.sparse_coo``.

            blocksize (list, tuple, :class:`torch.Size`, optional): Block size
              of the resulting BSR or BSC tensor. For other layouts,
              specifying the block size that is not ``None`` will result in a
              RuntimeError exception.  A block size must be a tuple of length
              two such that its items evenly divide the two sparse dimensions.

            dense_dim (int, optional): Number of dense dimensions of the
              resulting CSR, CSC, BSR or BSC tensor.  This argument should be
              used only if :attr:`self` is a strided tensor, and must be a
              value between 0 and dimension of :attr:`self` tensor minus two.

        Example::

            >>> x = torch.tensor([[1, 0], [0, 0], [2, 3]])
            >>> x.to_sparse(layout=torch.sparse_coo)
            tensor(indices=tensor([[0, 2, 2],
                                   [0, 0, 1]]),
                   values=tensor([1, 2, 3]),
                   size=(3, 2), nnz=3, layout=torch.sparse_coo)
            >>> x.to_sparse(layout=torch.sparse_bsr, blocksize=(1, 2))
            tensor(crow_indices=tensor([0, 1, 1, 2]),
                   col_indices=tensor([0, 0]),
                   values=tensor([[[1, 0]],
                                  [[2, 3]]]), size=(3, 2), nnz=2, layout=torch.sparse_bsr)
            >>> x.to_sparse(layout=torch.sparse_bsr, blocksize=(2, 1))
            RuntimeError: Tensor size(-2) 3 needs to be divisible by blocksize[0] 2
            >>> x.to_sparse(layout=torch.sparse_csr, blocksize=(3, 1))
            RuntimeError: to_sparse for Strided to SparseCsr conversion does not use specified blocksize

            >>> x = torch.tensor([[[1], [0]], [[0], [0]], [[2], [3]]])
            >>> x.to_sparse(layout=torch.sparse_csr, dense_dim=1)
            tensor(crow_indices=tensor([0, 1, 1, 3]),
                   col_indices=tensor([0, 0, 1]),
                   values=tensor([[1],
                                  [2],
                                  [3]]), size=(3, 2, 1), nnz=3, layout=torch.sparse_csr)

        """
    @overload
    def to_sparse(self, layout=..., blocksize=...) -> Any:
        """
        to_sparse(sparseDims) -> Tensor

        Returns a sparse copy of the tensor.  PyTorch supports sparse tensors in
        :ref:`coordinate format <sparse-coo-docs>`.

        Args:
            sparseDims (int, optional): the number of sparse dimensions to include in the new sparse tensor

        Example::

            >>> d = torch.tensor([[0, 0, 0], [9, 0, 10], [0, 0, 0]])
            >>> d
            tensor([[ 0,  0,  0],
                    [ 9,  0, 10],
                    [ 0,  0,  0]])
            >>> d.to_sparse()
            tensor(indices=tensor([[1, 1],
                                   [0, 2]]),
                   values=tensor([ 9, 10]),
                   size=(3, 3), nnz=2, layout=torch.sparse_coo)
            >>> d.to_sparse(1)
            tensor(indices=tensor([[1]]),
                   values=tensor([[ 9,  0, 10]]),
                   size=(3, 3), nnz=1, layout=torch.sparse_coo)

        .. method:: to_sparse(*, layout=None, blocksize=None, dense_dim=None) -> Tensor
           :noindex:

        Returns a sparse tensor with the specified layout and blocksize.  If
        the :attr:`self` is strided, the number of dense dimensions could be
        specified, and a hybrid sparse tensor will be created, with
        `dense_dim` dense dimensions and `self.dim() - 2 - dense_dim` batch
        dimension.

        .. note:: If the :attr:`self` layout and blocksize parameters match
                  with the specified layout and blocksize, return
                  :attr:`self`. Otherwise, return a sparse tensor copy of
                  :attr:`self`.

        Args:

            layout (:class:`torch.layout`, optional): The desired sparse
              layout. One of ``torch.sparse_coo``, ``torch.sparse_csr``,
              ``torch.sparse_csc``, ``torch.sparse_bsr``, or
              ``torch.sparse_bsc``. Default: if ``None``,
              ``torch.sparse_coo``.

            blocksize (list, tuple, :class:`torch.Size`, optional): Block size
              of the resulting BSR or BSC tensor. For other layouts,
              specifying the block size that is not ``None`` will result in a
              RuntimeError exception.  A block size must be a tuple of length
              two such that its items evenly divide the two sparse dimensions.

            dense_dim (int, optional): Number of dense dimensions of the
              resulting CSR, CSC, BSR or BSC tensor.  This argument should be
              used only if :attr:`self` is a strided tensor, and must be a
              value between 0 and dimension of :attr:`self` tensor minus two.

        Example::

            >>> x = torch.tensor([[1, 0], [0, 0], [2, 3]])
            >>> x.to_sparse(layout=torch.sparse_coo)
            tensor(indices=tensor([[0, 2, 2],
                                   [0, 0, 1]]),
                   values=tensor([1, 2, 3]),
                   size=(3, 2), nnz=3, layout=torch.sparse_coo)
            >>> x.to_sparse(layout=torch.sparse_bsr, blocksize=(1, 2))
            tensor(crow_indices=tensor([0, 1, 1, 2]),
                   col_indices=tensor([0, 0]),
                   values=tensor([[[1, 0]],
                                  [[2, 3]]]), size=(3, 2), nnz=2, layout=torch.sparse_bsr)
            >>> x.to_sparse(layout=torch.sparse_bsr, blocksize=(2, 1))
            RuntimeError: Tensor size(-2) 3 needs to be divisible by blocksize[0] 2
            >>> x.to_sparse(layout=torch.sparse_csr, blocksize=(3, 1))
            RuntimeError: to_sparse for Strided to SparseCsr conversion does not use specified blocksize

            >>> x = torch.tensor([[[1], [0]], [[0], [0]], [[2], [3]]])
            >>> x.to_sparse(layout=torch.sparse_csr, dense_dim=1)
            tensor(crow_indices=tensor([0, 1, 1, 3]),
                   col_indices=tensor([0, 0, 1]),
                   values=tensor([[1],
                                  [2],
                                  [3]]), size=(3, 2, 1), nnz=3, layout=torch.sparse_csr)

        """
    @overload
    def to_sparse(self, layout=..., blocksize=...) -> Any:
        """
        to_sparse(sparseDims) -> Tensor

        Returns a sparse copy of the tensor.  PyTorch supports sparse tensors in
        :ref:`coordinate format <sparse-coo-docs>`.

        Args:
            sparseDims (int, optional): the number of sparse dimensions to include in the new sparse tensor

        Example::

            >>> d = torch.tensor([[0, 0, 0], [9, 0, 10], [0, 0, 0]])
            >>> d
            tensor([[ 0,  0,  0],
                    [ 9,  0, 10],
                    [ 0,  0,  0]])
            >>> d.to_sparse()
            tensor(indices=tensor([[1, 1],
                                   [0, 2]]),
                   values=tensor([ 9, 10]),
                   size=(3, 3), nnz=2, layout=torch.sparse_coo)
            >>> d.to_sparse(1)
            tensor(indices=tensor([[1]]),
                   values=tensor([[ 9,  0, 10]]),
                   size=(3, 3), nnz=1, layout=torch.sparse_coo)

        .. method:: to_sparse(*, layout=None, blocksize=None, dense_dim=None) -> Tensor
           :noindex:

        Returns a sparse tensor with the specified layout and blocksize.  If
        the :attr:`self` is strided, the number of dense dimensions could be
        specified, and a hybrid sparse tensor will be created, with
        `dense_dim` dense dimensions and `self.dim() - 2 - dense_dim` batch
        dimension.

        .. note:: If the :attr:`self` layout and blocksize parameters match
                  with the specified layout and blocksize, return
                  :attr:`self`. Otherwise, return a sparse tensor copy of
                  :attr:`self`.

        Args:

            layout (:class:`torch.layout`, optional): The desired sparse
              layout. One of ``torch.sparse_coo``, ``torch.sparse_csr``,
              ``torch.sparse_csc``, ``torch.sparse_bsr``, or
              ``torch.sparse_bsc``. Default: if ``None``,
              ``torch.sparse_coo``.

            blocksize (list, tuple, :class:`torch.Size`, optional): Block size
              of the resulting BSR or BSC tensor. For other layouts,
              specifying the block size that is not ``None`` will result in a
              RuntimeError exception.  A block size must be a tuple of length
              two such that its items evenly divide the two sparse dimensions.

            dense_dim (int, optional): Number of dense dimensions of the
              resulting CSR, CSC, BSR or BSC tensor.  This argument should be
              used only if :attr:`self` is a strided tensor, and must be a
              value between 0 and dimension of :attr:`self` tensor minus two.

        Example::

            >>> x = torch.tensor([[1, 0], [0, 0], [2, 3]])
            >>> x.to_sparse(layout=torch.sparse_coo)
            tensor(indices=tensor([[0, 2, 2],
                                   [0, 0, 1]]),
                   values=tensor([1, 2, 3]),
                   size=(3, 2), nnz=3, layout=torch.sparse_coo)
            >>> x.to_sparse(layout=torch.sparse_bsr, blocksize=(1, 2))
            tensor(crow_indices=tensor([0, 1, 1, 2]),
                   col_indices=tensor([0, 0]),
                   values=tensor([[[1, 0]],
                                  [[2, 3]]]), size=(3, 2), nnz=2, layout=torch.sparse_bsr)
            >>> x.to_sparse(layout=torch.sparse_bsr, blocksize=(2, 1))
            RuntimeError: Tensor size(-2) 3 needs to be divisible by blocksize[0] 2
            >>> x.to_sparse(layout=torch.sparse_csr, blocksize=(3, 1))
            RuntimeError: to_sparse for Strided to SparseCsr conversion does not use specified blocksize

            >>> x = torch.tensor([[[1], [0]], [[0], [0]], [[2], [3]]])
            >>> x.to_sparse(layout=torch.sparse_csr, dense_dim=1)
            tensor(crow_indices=tensor([0, 1, 1, 3]),
                   col_indices=tensor([0, 0, 1]),
                   values=tensor([[1],
                                  [2],
                                  [3]]), size=(3, 2, 1), nnz=3, layout=torch.sparse_csr)

        """
    @overload
    def to_sparse(self, layout=..., dense_dim=...) -> Any:
        """
        to_sparse(sparseDims) -> Tensor

        Returns a sparse copy of the tensor.  PyTorch supports sparse tensors in
        :ref:`coordinate format <sparse-coo-docs>`.

        Args:
            sparseDims (int, optional): the number of sparse dimensions to include in the new sparse tensor

        Example::

            >>> d = torch.tensor([[0, 0, 0], [9, 0, 10], [0, 0, 0]])
            >>> d
            tensor([[ 0,  0,  0],
                    [ 9,  0, 10],
                    [ 0,  0,  0]])
            >>> d.to_sparse()
            tensor(indices=tensor([[1, 1],
                                   [0, 2]]),
                   values=tensor([ 9, 10]),
                   size=(3, 3), nnz=2, layout=torch.sparse_coo)
            >>> d.to_sparse(1)
            tensor(indices=tensor([[1]]),
                   values=tensor([[ 9,  0, 10]]),
                   size=(3, 3), nnz=1, layout=torch.sparse_coo)

        .. method:: to_sparse(*, layout=None, blocksize=None, dense_dim=None) -> Tensor
           :noindex:

        Returns a sparse tensor with the specified layout and blocksize.  If
        the :attr:`self` is strided, the number of dense dimensions could be
        specified, and a hybrid sparse tensor will be created, with
        `dense_dim` dense dimensions and `self.dim() - 2 - dense_dim` batch
        dimension.

        .. note:: If the :attr:`self` layout and blocksize parameters match
                  with the specified layout and blocksize, return
                  :attr:`self`. Otherwise, return a sparse tensor copy of
                  :attr:`self`.

        Args:

            layout (:class:`torch.layout`, optional): The desired sparse
              layout. One of ``torch.sparse_coo``, ``torch.sparse_csr``,
              ``torch.sparse_csc``, ``torch.sparse_bsr``, or
              ``torch.sparse_bsc``. Default: if ``None``,
              ``torch.sparse_coo``.

            blocksize (list, tuple, :class:`torch.Size`, optional): Block size
              of the resulting BSR or BSC tensor. For other layouts,
              specifying the block size that is not ``None`` will result in a
              RuntimeError exception.  A block size must be a tuple of length
              two such that its items evenly divide the two sparse dimensions.

            dense_dim (int, optional): Number of dense dimensions of the
              resulting CSR, CSC, BSR or BSC tensor.  This argument should be
              used only if :attr:`self` is a strided tensor, and must be a
              value between 0 and dimension of :attr:`self` tensor minus two.

        Example::

            >>> x = torch.tensor([[1, 0], [0, 0], [2, 3]])
            >>> x.to_sparse(layout=torch.sparse_coo)
            tensor(indices=tensor([[0, 2, 2],
                                   [0, 0, 1]]),
                   values=tensor([1, 2, 3]),
                   size=(3, 2), nnz=3, layout=torch.sparse_coo)
            >>> x.to_sparse(layout=torch.sparse_bsr, blocksize=(1, 2))
            tensor(crow_indices=tensor([0, 1, 1, 2]),
                   col_indices=tensor([0, 0]),
                   values=tensor([[[1, 0]],
                                  [[2, 3]]]), size=(3, 2), nnz=2, layout=torch.sparse_bsr)
            >>> x.to_sparse(layout=torch.sparse_bsr, blocksize=(2, 1))
            RuntimeError: Tensor size(-2) 3 needs to be divisible by blocksize[0] 2
            >>> x.to_sparse(layout=torch.sparse_csr, blocksize=(3, 1))
            RuntimeError: to_sparse for Strided to SparseCsr conversion does not use specified blocksize

            >>> x = torch.tensor([[[1], [0]], [[0], [0]], [[2], [3]]])
            >>> x.to_sparse(layout=torch.sparse_csr, dense_dim=1)
            tensor(crow_indices=tensor([0, 1, 1, 3]),
                   col_indices=tensor([0, 0, 1]),
                   values=tensor([[1],
                                  [2],
                                  [3]]), size=(3, 2, 1), nnz=3, layout=torch.sparse_csr)

        """
    def to_sparse_bsc(self, blocksize, dense_dim) -> Tensor:
        """
        to_sparse_bsc(blocksize, dense_dim) -> Tensor

        Convert a tensor to a block sparse column (BSC) storage format of
        given blocksize.  If the :attr:`self` is strided, then the number of
        dense dimensions could be specified, and a hybrid BSC tensor will be
        created, with `dense_dim` dense dimensions and `self.dim() - 2 -
        dense_dim` batch dimension.

        Args:

            blocksize (list, tuple, :class:`torch.Size`, optional): Block size
              of the resulting BSC tensor. A block size must be a tuple of
              length two such that its items evenly divide the two sparse
              dimensions.

            dense_dim (int, optional): Number of dense dimensions of the
              resulting BSC tensor.  This argument should be used only if
              :attr:`self` is a strided tensor, and must be a value between 0
              and dimension of :attr:`self` tensor minus two.

        Example::

            >>> dense = torch.randn(10, 10)
            >>> sparse = dense.to_sparse_csr()
            >>> sparse_bsc = sparse.to_sparse_bsc((5, 5))
            >>> sparse_bsc.row_indices()
            tensor([0, 1, 0, 1])

            >>> dense = torch.zeros(4, 3, 1)
            >>> dense[0:2, 0] = dense[0:2, 2] = dense[2:4, 1] = 1
            >>> dense.to_sparse_bsc((2, 1), 1)
            tensor(ccol_indices=tensor([0, 1, 2, 3]),
                   row_indices=tensor([0, 1, 0]),
                   values=tensor([[[[1.]],

                                   [[1.]]],


                                  [[[1.]],

                                   [[1.]]],


                                  [[[1.]],

                                   [[1.]]]]), size=(4, 3, 1), nnz=3,
                   layout=torch.sparse_bsc)

        """
    def to_sparse_bsr(self, blocksize, dense_dim) -> Tensor:
        """
        to_sparse_bsr(blocksize, dense_dim) -> Tensor

        Convert a tensor to a block sparse row (BSR) storage format of given
        blocksize.  If the :attr:`self` is strided, then the number of dense
        dimensions could be specified, and a hybrid BSR tensor will be
        created, with `dense_dim` dense dimensions and `self.dim() - 2 -
        dense_dim` batch dimension.

        Args:

            blocksize (list, tuple, :class:`torch.Size`, optional): Block size
              of the resulting BSR tensor. A block size must be a tuple of
              length two such that its items evenly divide the two sparse
              dimensions.

            dense_dim (int, optional): Number of dense dimensions of the
              resulting BSR tensor.  This argument should be used only if
              :attr:`self` is a strided tensor, and must be a value between 0
              and dimension of :attr:`self` tensor minus two.

        Example::

            >>> dense = torch.randn(10, 10)
            >>> sparse = dense.to_sparse_csr()
            >>> sparse_bsr = sparse.to_sparse_bsr((5, 5))
            >>> sparse_bsr.col_indices()
            tensor([0, 1, 0, 1])

            >>> dense = torch.zeros(4, 3, 1)
            >>> dense[0:2, 0] = dense[0:2, 2] = dense[2:4, 1] = 1
            >>> dense.to_sparse_bsr((2, 1), 1)
            tensor(crow_indices=tensor([0, 2, 3]),
                   col_indices=tensor([0, 2, 1]),
                   values=tensor([[[[1.]],

                                   [[1.]]],


                                  [[[1.]],

                                   [[1.]]],


                                  [[[1.]],

                                   [[1.]]]]), size=(4, 3, 1), nnz=3,
                   layout=torch.sparse_bsr)

        """
    @overload
    def to_sparse_csc(self) -> Tensor:
        """
        to_sparse_csc() -> Tensor

        Convert a tensor to compressed column storage (CSC) format.  Except
        for strided tensors, only works with 2D tensors.  If the :attr:`self`
        is strided, then the number of dense dimensions could be specified,
        and a hybrid CSC tensor will be created, with `dense_dim` dense
        dimensions and `self.dim() - 2 - dense_dim` batch dimension.

        Args:

            dense_dim (int, optional): Number of dense dimensions of the
              resulting CSC tensor.  This argument should be used only if
              :attr:`self` is a strided tensor, and must be a value between 0
              and dimension of :attr:`self` tensor minus two.

        Example::

            >>> dense = torch.randn(5, 5)
            >>> sparse = dense.to_sparse_csc()
            >>> sparse._nnz()
            25

            >>> dense = torch.zeros(3, 3, 1, 1)
            >>> dense[0, 0] = dense[1, 2] = dense[2, 1] = 1
            >>> dense.to_sparse_csc(dense_dim=2)
            tensor(ccol_indices=tensor([0, 1, 2, 3]),
                   row_indices=tensor([0, 2, 1]),
                   values=tensor([[[1.]],

                                  [[1.]],

                                  [[1.]]]), size=(3, 3, 1, 1), nnz=3,
                   layout=torch.sparse_csc)

        """
    @overload
    def to_sparse_csc(self) -> Any:
        """
        to_sparse_csc() -> Tensor

        Convert a tensor to compressed column storage (CSC) format.  Except
        for strided tensors, only works with 2D tensors.  If the :attr:`self`
        is strided, then the number of dense dimensions could be specified,
        and a hybrid CSC tensor will be created, with `dense_dim` dense
        dimensions and `self.dim() - 2 - dense_dim` batch dimension.

        Args:

            dense_dim (int, optional): Number of dense dimensions of the
              resulting CSC tensor.  This argument should be used only if
              :attr:`self` is a strided tensor, and must be a value between 0
              and dimension of :attr:`self` tensor minus two.

        Example::

            >>> dense = torch.randn(5, 5)
            >>> sparse = dense.to_sparse_csc()
            >>> sparse._nnz()
            25

            >>> dense = torch.zeros(3, 3, 1, 1)
            >>> dense[0, 0] = dense[1, 2] = dense[2, 1] = 1
            >>> dense.to_sparse_csc(dense_dim=2)
            tensor(ccol_indices=tensor([0, 1, 2, 3]),
                   row_indices=tensor([0, 2, 1]),
                   values=tensor([[[1.]],

                                  [[1.]],

                                  [[1.]]]), size=(3, 3, 1, 1), nnz=3,
                   layout=torch.sparse_csc)

        """
    @overload
    def to_sparse_csc(self, dense_dim=...) -> Any:
        """
        to_sparse_csc() -> Tensor

        Convert a tensor to compressed column storage (CSC) format.  Except
        for strided tensors, only works with 2D tensors.  If the :attr:`self`
        is strided, then the number of dense dimensions could be specified,
        and a hybrid CSC tensor will be created, with `dense_dim` dense
        dimensions and `self.dim() - 2 - dense_dim` batch dimension.

        Args:

            dense_dim (int, optional): Number of dense dimensions of the
              resulting CSC tensor.  This argument should be used only if
              :attr:`self` is a strided tensor, and must be a value between 0
              and dimension of :attr:`self` tensor minus two.

        Example::

            >>> dense = torch.randn(5, 5)
            >>> sparse = dense.to_sparse_csc()
            >>> sparse._nnz()
            25

            >>> dense = torch.zeros(3, 3, 1, 1)
            >>> dense[0, 0] = dense[1, 2] = dense[2, 1] = 1
            >>> dense.to_sparse_csc(dense_dim=2)
            tensor(ccol_indices=tensor([0, 1, 2, 3]),
                   row_indices=tensor([0, 2, 1]),
                   values=tensor([[[1.]],

                                  [[1.]],

                                  [[1.]]]), size=(3, 3, 1, 1), nnz=3,
                   layout=torch.sparse_csc)

        """
    @overload
    def to_sparse_csr(self, dense_dim=...) -> Tensor:
        """
        to_sparse_csr(dense_dim=None) -> Tensor

        Convert a tensor to compressed row storage format (CSR).  Except for
        strided tensors, only works with 2D tensors.  If the :attr:`self` is
        strided, then the number of dense dimensions could be specified, and a
        hybrid CSR tensor will be created, with `dense_dim` dense dimensions
        and `self.dim() - 2 - dense_dim` batch dimension.

        Args:

            dense_dim (int, optional): Number of dense dimensions of the
              resulting CSR tensor.  This argument should be used only if
              :attr:`self` is a strided tensor, and must be a value between 0
              and dimension of :attr:`self` tensor minus two.

        Example::

            >>> dense = torch.randn(5, 5)
            >>> sparse = dense.to_sparse_csr()
            >>> sparse._nnz()
            25

            >>> dense = torch.zeros(3, 3, 1, 1)
            >>> dense[0, 0] = dense[1, 2] = dense[2, 1] = 1
            >>> dense.to_sparse_csr(dense_dim=2)
            tensor(crow_indices=tensor([0, 1, 2, 3]),
                   col_indices=tensor([0, 2, 1]),
                   values=tensor([[[1.]],

                                  [[1.]],

                                  [[1.]]]), size=(3, 3, 1, 1), nnz=3,
                   layout=torch.sparse_csr)

        """
    @overload
    def to_sparse_csr(self) -> Any:
        """
        to_sparse_csr(dense_dim=None) -> Tensor

        Convert a tensor to compressed row storage format (CSR).  Except for
        strided tensors, only works with 2D tensors.  If the :attr:`self` is
        strided, then the number of dense dimensions could be specified, and a
        hybrid CSR tensor will be created, with `dense_dim` dense dimensions
        and `self.dim() - 2 - dense_dim` batch dimension.

        Args:

            dense_dim (int, optional): Number of dense dimensions of the
              resulting CSR tensor.  This argument should be used only if
              :attr:`self` is a strided tensor, and must be a value between 0
              and dimension of :attr:`self` tensor minus two.

        Example::

            >>> dense = torch.randn(5, 5)
            >>> sparse = dense.to_sparse_csr()
            >>> sparse._nnz()
            25

            >>> dense = torch.zeros(3, 3, 1, 1)
            >>> dense[0, 0] = dense[1, 2] = dense[2, 1] = 1
            >>> dense.to_sparse_csr(dense_dim=2)
            tensor(crow_indices=tensor([0, 1, 2, 3]),
                   col_indices=tensor([0, 2, 1]),
                   values=tensor([[[1.]],

                                  [[1.]],

                                  [[1.]]]), size=(3, 3, 1, 1), nnz=3,
                   layout=torch.sparse_csr)

        """
    @overload
    def to_sparse_csr(self, dense_dim=...) -> Any:
        """
        to_sparse_csr(dense_dim=None) -> Tensor

        Convert a tensor to compressed row storage format (CSR).  Except for
        strided tensors, only works with 2D tensors.  If the :attr:`self` is
        strided, then the number of dense dimensions could be specified, and a
        hybrid CSR tensor will be created, with `dense_dim` dense dimensions
        and `self.dim() - 2 - dense_dim` batch dimension.

        Args:

            dense_dim (int, optional): Number of dense dimensions of the
              resulting CSR tensor.  This argument should be used only if
              :attr:`self` is a strided tensor, and must be a value between 0
              and dimension of :attr:`self` tensor minus two.

        Example::

            >>> dense = torch.randn(5, 5)
            >>> sparse = dense.to_sparse_csr()
            >>> sparse._nnz()
            25

            >>> dense = torch.zeros(3, 3, 1, 1)
            >>> dense[0, 0] = dense[1, 2] = dense[2, 1] = 1
            >>> dense.to_sparse_csr(dense_dim=2)
            tensor(crow_indices=tensor([0, 1, 2, 3]),
                   col_indices=tensor([0, 2, 1]),
                   values=tensor([[[1.]],

                                  [[1.]],

                                  [[1.]]]), size=(3, 3, 1, 1), nnz=3,
                   layout=torch.sparse_csr)

        """
    @overload
    def tolist(self) -> listornumber:
        """
        tolist() -> list or number

        Returns the tensor as a (nested) list. For scalars, a standard
        Python number is returned, just like with :meth:`~Tensor.item`.
        Tensors are automatically moved to the CPU first if necessary.

        This operation is not differentiable.

        Examples::

            >>> a = torch.randn(2, 2)
            >>> a.tolist()
            [[0.012766935862600803, 0.5415473580360413],
             [-0.08909505605697632, 0.7729271650314331]]
            >>> a[0,0].tolist()
            0.012766935862600803
        """
    @overload
    def tolist(self) -> Any:
        """
        tolist() -> list or number

        Returns the tensor as a (nested) list. For scalars, a standard
        Python number is returned, just like with :meth:`~Tensor.item`.
        Tensors are automatically moved to the CPU first if necessary.

        This operation is not differentiable.

        Examples::

            >>> a = torch.randn(2, 2)
            >>> a.tolist()
            [[0.012766935862600803, 0.5415473580360413],
             [-0.08909505605697632, 0.7729271650314331]]
            >>> a[0,0].tolist()
            0.012766935862600803
        """
    @overload
    def tolist(self) -> Any:
        """
        tolist() -> list or number

        Returns the tensor as a (nested) list. For scalars, a standard
        Python number is returned, just like with :meth:`~Tensor.item`.
        Tensors are automatically moved to the CPU first if necessary.

        This operation is not differentiable.

        Examples::

            >>> a = torch.randn(2, 2)
            >>> a.tolist()
            [[0.012766935862600803, 0.5415473580360413],
             [-0.08909505605697632, 0.7729271650314331]]
            >>> a[0,0].tolist()
            0.012766935862600803
        """
    def topk(self, *args, **kwargs):
        """
        topk(k, dim=None, largest=True, sorted=True) -> (Tensor, LongTensor)

        See :func:`torch.topk`
        """
    def trace(self) -> Tensor:
        """
        trace() -> Tensor

        See :func:`torch.trace`
        """
    def transpose(self, dim0, dim1) -> Tensor:
        """
        transpose(dim0, dim1) -> Tensor

        See :func:`torch.transpose`
        """
    def transpose_(self, dim0, dim1) -> Tensor:
        """
        transpose_(dim0, dim1) -> Tensor

        In-place version of :meth:`~Tensor.transpose`
        """
    def triangular_solve(self, *args, **kwargs):
        """
        triangular_solve(A, upper=True, transpose=False, unitriangular=False) -> (Tensor, Tensor)

        See :func:`torch.triangular_solve`
        """
    def tril(self, diagonal=...) -> Tensor:
        """
        tril(diagonal=0) -> Tensor

        See :func:`torch.tril`
        """
    def tril_(self, diagonal=...) -> Tensor:
        """
        tril_(diagonal=0) -> Tensor

        In-place version of :meth:`~Tensor.tril`
        """
    def triu(self, diagonal=...) -> Tensor:
        """
        triu(diagonal=0) -> Tensor

        See :func:`torch.triu`
        """
    def triu_(self, diagonal=...) -> Tensor:
        """
        triu_(diagonal=0) -> Tensor

        In-place version of :meth:`~Tensor.triu`
        """
    def true_divide(self, value) -> Tensor:
        """
        true_divide(value) -> Tensor

        See :func:`torch.true_divide`
        """
    def true_divide_(self, value) -> Tensor:
        """
        true_divide_(value) -> Tensor

        In-place version of :meth:`~Tensor.true_divide_`
        """
    def trunc(self) -> Tensor:
        """
        trunc() -> Tensor

        See :func:`torch.trunc`
        """
    def trunc_(self) -> Tensor:
        """
        trunc_() -> Tensor

        In-place version of :meth:`~Tensor.trunc`
        """
    def type(self, dtype=..., non_blocking=..., **kwargs) -> strorTensor:
        """
        type(dtype=None, non_blocking=False, **kwargs) -> str or Tensor
        Returns the type if `dtype` is not provided, else casts this object to
        the specified type.

        If this is already of the correct type, no copy is performed and the
        original object is returned.

        Args:
            dtype (dtype or string): The desired type
            non_blocking (bool): If ``True``, and the source is in pinned memory
                and destination is on the GPU or vice versa, the copy is performed
                asynchronously with respect to the host. Otherwise, the argument
                has no effect.
            **kwargs: For compatibility, may contain the key ``async`` in place of
                the ``non_blocking`` argument. The ``async`` arg is deprecated.
        """
    def type_as(self, tensor) -> Tensor:
        """
        type_as(tensor) -> Tensor

        Returns this tensor cast to the type of the given tensor.

        This is a no-op if the tensor is already of the correct type. This is
        equivalent to ``self.type(tensor.type())``

        Args:
            tensor (Tensor): the tensor which has the desired type
        """
    def unbind(self, dim=...) -> seq:
        """
        unbind(dim=0) -> seq

        See :func:`torch.unbind`
        """
    def unflatten(self, *args, **kwargs): ...
    def unfold(self, dimension, size, step) -> Tensor:
        """
        unfold(dimension, size, step) -> Tensor

        Returns a view of the original tensor which contains all slices of size :attr:`size` from
        :attr:`self` tensor in the dimension :attr:`dimension`.

        Step between two slices is given by :attr:`step`.

        If `sizedim` is the size of dimension :attr:`dimension` for :attr:`self`, the size of
        dimension :attr:`dimension` in the returned tensor will be
        `(sizedim - size) / step + 1`.

        An additional dimension of size :attr:`size` is appended in the returned tensor.

        Args:
            dimension (int): dimension in which unfolding happens
            size (int): the size of each slice that is unfolded
            step (int): the step between each slice

        Example::

            >>> x = torch.arange(1., 8)
            >>> x
            tensor([ 1.,  2.,  3.,  4.,  5.,  6.,  7.])
            >>> x.unfold(0, 2, 1)
            tensor([[ 1.,  2.],
                    [ 2.,  3.],
                    [ 3.,  4.],
                    [ 4.,  5.],
                    [ 5.,  6.],
                    [ 6.,  7.]])
            >>> x.unfold(0, 2, 2)
            tensor([[ 1.,  2.],
                    [ 3.,  4.],
                    [ 5.,  6.]])
        """
    def uniform_(self, _from=..., to=..., generator=...) -> Tensor:
        """
        uniform_(from=0, to=1, *, generator=None) -> Tensor

        Fills :attr:`self` tensor with numbers sampled from the continuous uniform
        distribution:

        .. math::
            f(x) = \\dfrac{1}{\\text{to} - \\text{from}}
        """
    def unsafe_chunk(self, chunks, dim=...) -> ListofTensors:
        """
        unsafe_chunk(chunks, dim=0) -> List of Tensors

        See :func:`torch.unsafe_chunk`
        """
    def unsafe_split(self, split_size, dim=...) -> ListofTensors:
        """
        unsafe_split(split_size, dim=0) -> List of Tensors

        See :func:`torch.unsafe_split`
        """
    def unsafe_split_with_sizes(self, *args, **kwargs): ...
    def unsqueeze(self, dim) -> Tensor:
        """
        unsqueeze(dim) -> Tensor

        See :func:`torch.unsqueeze`
        """
    def unsqueeze_(self, dim) -> Tensor:
        """
        unsqueeze_(dim) -> Tensor

        In-place version of :meth:`~Tensor.unsqueeze`
        """
    def untyped_storage(self) -> torch.UntypedStorage:
        """
        untyped_storage() -> torch.UntypedStorage

        Returns the underlying :class:`UntypedStorage`.
        """
    def values(self) -> Tensor:
        """
        values() -> Tensor

        Return the values tensor of a :ref:`sparse COO tensor <sparse-coo-docs>`.

        .. warning::
          Throws an error if :attr:`self` is not a sparse COO tensor.

        See also :meth:`Tensor.indices`.

        .. note::
          This method can only be called on a coalesced sparse tensor. See
          :meth:`Tensor.coalesce` for details.
        """
    def var(self, dim=..., correction=..., keepdim=...) -> Tensor:
        """
        var(dim=None, *, correction=1, keepdim=False) -> Tensor

        See :func:`torch.var`
        """
    def vdot(self, other) -> Tensor:
        """
        vdot(other) -> Tensor

        See :func:`torch.vdot`
        """
    def view(self, *shape) -> Tensor:
        """
        view(*shape) -> Tensor

        Returns a new tensor with the same data as the :attr:`self` tensor but of a
        different :attr:`shape`.

        The returned tensor shares the same data and must have the same number
        of elements, but may have a different size. For a tensor to be viewed, the new
        view size must be compatible with its original size and stride, i.e., each new
        view dimension must either be a subspace of an original dimension, or only span
        across original dimensions :math:`d, d+1, \\dots, d+k` that satisfy the following
        contiguity-like condition that :math:`\\forall i = d, \\dots, d+k-1`,

        .. math::

          \\text{stride}[i] = \\text{stride}[i+1] \\times \\text{size}[i+1]

        Otherwise, it will not be possible to view :attr:`self` tensor as :attr:`shape`
        without copying it (e.g., via :meth:`contiguous`). When it is unclear whether a
        :meth:`view` can be performed, it is advisable to use :meth:`reshape`, which
        returns a view if the shapes are compatible, and copies (equivalent to calling
        :meth:`contiguous`) otherwise.

        Args:
            shape (torch.Size or int...): the desired size

        Example::

            >>> x = torch.randn(4, 4)
            >>> x.size()
            torch.Size([4, 4])
            >>> y = x.view(16)
            >>> y.size()
            torch.Size([16])
            >>> z = x.view(-1, 8)  # the size -1 is inferred from other dimensions
            >>> z.size()
            torch.Size([2, 8])

            >>> a = torch.randn(1, 2, 3, 4)
            >>> a.size()
            torch.Size([1, 2, 3, 4])
            >>> b = a.transpose(1, 2)  # Swaps 2nd and 3rd dimension
            >>> b.size()
            torch.Size([1, 3, 2, 4])
            >>> c = a.view(1, 3, 2, 4)  # Does not change tensor layout in memory
            >>> c.size()
            torch.Size([1, 3, 2, 4])
            >>> torch.equal(b, c)
            False


        .. method:: view(dtype) -> Tensor
           :noindex:

        Returns a new tensor with the same data as the :attr:`self` tensor but of a
        different :attr:`dtype`.

        If the element size of :attr:`dtype` is different than that of ``self.dtype``,
        then the size of the last dimension of the output will be scaled
        proportionally.  For instance, if :attr:`dtype` element size is twice that of
        ``self.dtype``, then each pair of elements in the last dimension of
        :attr:`self` will be combined, and the size of the last dimension of the output
        will be half that of :attr:`self`. If :attr:`dtype` element size is half that
        of ``self.dtype``, then each element in the last dimension of :attr:`self` will
        be split in two, and the size of the last dimension of the output will be
        double that of :attr:`self`. For this to be possible, the following conditions
        must be true:

            * ``self.dim()`` must be greater than 0.
            * ``self.stride(-1)`` must be 1.

        Additionally, if the element size of :attr:`dtype` is greater than that of
        ``self.dtype``, the following conditions must be true as well:

            * ``self.size(-1)`` must be divisible by the ratio between the element
              sizes of the dtypes.
            * ``self.storage_offset()`` must be divisible by the ratio between the
              element sizes of the dtypes.
            * The strides of all dimensions, except the last dimension, must be
              divisible by the ratio between the element sizes of the dtypes.

        If any of the above conditions are not met, an error is thrown.

        .. warning::

            This overload is not supported by TorchScript, and using it in a Torchscript
            program will cause undefined behavior.


        Args:
            dtype (:class:`torch.dtype`): the desired dtype

        Example::

            >>> x = torch.randn(4, 4)
            >>> x
            tensor([[ 0.9482, -0.0310,  1.4999, -0.5316],
                    [-0.1520,  0.7472,  0.5617, -0.8649],
                    [-2.4724, -0.0334, -0.2976, -0.8499],
                    [-0.2109,  1.9913, -0.9607, -0.6123]])
            >>> x.dtype
            torch.float32

            >>> y = x.view(torch.int32)
            >>> y
            tensor([[ 1064483442, -1124191867,  1069546515, -1089989247],
                    [-1105482831,  1061112040,  1057999968, -1084397505],
                    [-1071760287, -1123489973, -1097310419, -1084649136],
                    [-1101533110,  1073668768, -1082790149, -1088634448]],
                dtype=torch.int32)
            >>> y[0, 0] = 1000000000
            >>> x
            tensor([[ 0.0047, -0.0310,  1.4999, -0.5316],
                    [-0.1520,  0.7472,  0.5617, -0.8649],
                    [-2.4724, -0.0334, -0.2976, -0.8499],
                    [-0.2109,  1.9913, -0.9607, -0.6123]])

            >>> x.view(torch.cfloat)
            tensor([[ 0.0047-0.0310j,  1.4999-0.5316j],
                    [-0.1520+0.7472j,  0.5617-0.8649j],
                    [-2.4724-0.0334j, -0.2976-0.8499j],
                    [-0.2109+1.9913j, -0.9607-0.6123j]])
            >>> x.view(torch.cfloat).size()
            torch.Size([4, 2])

            >>> x.view(torch.uint8)
            tensor([[  0, 202, 154,  59, 182, 243, 253, 188, 185, 252, 191,  63, 240,  22,
                       8, 191],
                    [227, 165,  27, 190, 128,  72,  63,  63, 146, 203,  15,  63,  22, 106,
                      93, 191],
                    [205,  59,  30, 192, 112, 206,   8, 189,   7,  95, 152, 190,  12, 147,
                      89, 191],
                    [ 43, 246,  87, 190, 235, 226, 254,  63, 111, 240, 117, 191, 177, 191,
                      28, 191]], dtype=torch.uint8)
            >>> x.view(torch.uint8).size()
            torch.Size([4, 16])
        """
    @overload
    def view_as(self, other) -> Tensor:
        """
        view_as(other) -> Tensor

        View this tensor as the same size as :attr:`other`.
        ``self.view_as(other)`` is equivalent to ``self.view(other.size())``.

        Please see :meth:`~Tensor.view` for more information about ``view``.

        Args:
            other (:class:`torch.Tensor`): The result tensor has the same size
                as :attr:`other`.
        """
    @overload
    def view_as(self, other) -> Any:
        """
        view_as(other) -> Tensor

        View this tensor as the same size as :attr:`other`.
        ``self.view_as(other)`` is equivalent to ``self.view(other.size())``.

        Please see :meth:`~Tensor.view` for more information about ``view``.

        Args:
            other (:class:`torch.Tensor`): The result tensor has the same size
                as :attr:`other`.
        """
    def vsplit(self, split_size_or_sections) -> ListofTensors:
        """
        vsplit(split_size_or_sections) -> List of Tensors

        See :func:`torch.vsplit`
        """
    def where(self, condition, y) -> Tensor:
        """
        where(condition, y) -> Tensor

        ``self.where(condition, y)`` is equivalent to ``torch.where(condition, self, y)``.
        See :func:`torch.where`
        """
    def xlogy(self, other) -> Tensor:
        """
        xlogy(other) -> Tensor

        See :func:`torch.xlogy`
        """
    def xlogy_(self, other) -> Tensor:
        """
        xlogy_(other) -> Tensor

        In-place version of :meth:`~Tensor.xlogy`
        """
    def xpu(self, device=..., non_blocking=..., memory_format=...) -> Tensor:
        """
        xpu(device=None, non_blocking=False, memory_format=torch.preserve_format) -> Tensor

        Returns a copy of this object in XPU memory.

        If this object is already in XPU memory and on the correct device,
        then no copy is performed and the original object is returned.

        Args:
            device (:class:`torch.device`): The destination XPU device.
                Defaults to the current XPU device.
            non_blocking (bool): If ``True`` and the source is in pinned memory,
                the copy will be asynchronous with respect to the host.
                Otherwise, the argument has no effect. Default: ``False``.
            memory_format (:class:`torch.memory_format`, optional): the desired memory format of
                returned Tensor. Default: ``torch.preserve_format``.
        """
    def zero_(self) -> Tensor:
        """
        zero_() -> Tensor

        Fills :attr:`self` tensor with zeros.
        """
    def __add__(self, other): ...
    def __and__(self, other): ...
    def __bool__(self) -> bool: ...
    def __complex__(self) -> complex: ...
    def __delitem__(self, other) -> None:
        """Delete self[key]."""
    def __div__(self, *args, **kwargs): ...
    def __eq__(self, other: object) -> bool: ...
    def __float__(self) -> float: ...
    def __floordiv__(self, other): ...
    def __ge__(self, other: object) -> bool: ...
    def __getitem__(self, index):
        """Return self[key]."""
    def __gt__(self, other: object) -> bool: ...
    def __iadd__(self, other): ...
    def __iand__(self, other): ...
    def __idiv__(self, *args, **kwargs): ...
    def __ifloordiv__(self, other): ...
    def __ilshift__(self, other): ...
    def __imod__(self, other): ...
    def __imul__(self, other): ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __invert__(self): ...
    def __ior__(self, other): ...
    def __irshift__(self, other): ...
    def __isub__(self, other): ...
    def __ixor__(self, other): ...
    def __le__(self, other: object) -> bool: ...
    def __len__(self) -> int:
        """Return len(self)."""
    def __long__(self, *args, **kwargs): ...
    def __lshift__(self, other): ...
    def __lt__(self, other: object) -> bool: ...
    def __matmul__(self, *args, **kwargs): ...
    def __mod__(self, other): ...
    def __mul__(self, other): ...
    def __ne__(self, other: object) -> bool: ...
    def __nonzero__(self, *args, **kwargs): ...
    def __or__(self, other): ...
    def __radd__(self, other): ...
    def __rand__(self, other): ...
    def __rmul__(self, other): ...
    def __ror__(self, other): ...
    def __rshift__(self, other): ...
    def __rxor__(self, other): ...
    def __setitem__(self, index, object) -> None:
        """Set self[key] to value."""
    def __sub__(self, other): ...
    def __truediv__(self, other): ...
    def __xor__(self, other): ...

class _TensorMeta(type):
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""

class _TorchDispatchModeKey:
    """Members:

      FUNCTIONAL

      PROXY

      FAKE"""
    __members__: ClassVar[dict] = ...  # read-only
    FAKE: ClassVar[_TorchDispatchModeKey] = ...
    FUNCTIONAL: ClassVar[_TorchDispatchModeKey] = ...
    PROXY: ClassVar[_TorchDispatchModeKey] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None:
        """__init__(self: torch._C._TorchDispatchModeKey, value: int) -> None"""
    def _pybind11_conduit_v1_(self, *args, **kwargs): ...
    def __eq__(self, other: object) -> bool:
        """__eq__(self: object, other: object) -> bool"""
    def __hash__(self) -> int:
        """__hash__(self: object) -> int"""
    def __index__(self) -> int:
        """__index__(self: torch._C._TorchDispatchModeKey) -> int"""
    def __int__(self) -> int:
        """__int__(self: torch._C._TorchDispatchModeKey) -> int"""
    def __ne__(self, other: object) -> bool:
        """__ne__(self: object, other: object) -> bool"""
    @property
    def name(self) -> str:
        """name(self: object) -> str

        name(self: object) -> str
        """
    @property
    def value(self) -> int:
        """(arg0: torch._C._TorchDispatchModeKey) -> int"""

class _TorchFunctionState:
    """Members:

      ENABLED

      SUBCLASSES_DISABLED

      ALL_DISABLED"""
    __members__: ClassVar[dict] = ...  # read-only
    ALL_DISABLED: ClassVar[_TorchFunctionState] = ...
    ENABLED: ClassVar[_TorchFunctionState] = ...
    SUBCLASSES_DISABLED: ClassVar[_TorchFunctionState] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None:
        """__init__(self: torch._C._TorchFunctionState, value: int) -> None"""
    def _pybind11_conduit_v1_(self, *args, **kwargs): ...
    def __eq__(self, other: object) -> bool:
        """__eq__(self: object, other: object) -> bool"""
    def __hash__(self) -> int:
        """__hash__(self: object) -> int"""
    def __index__(self) -> int:
        """__index__(self: torch._C._TorchFunctionState) -> int"""
    def __int__(self) -> int:
        """__int__(self: torch._C._TorchFunctionState) -> int"""
    def __ne__(self, other: object) -> bool:
        """__ne__(self: object, other: object) -> bool"""
    @property
    def name(self) -> str:
        """name(self: object) -> str

        name(self: object) -> str
        """
    @property
    def value(self) -> int:
        """(arg0: torch._C._TorchFunctionState) -> int"""

class _UpgraderEntry:
    def __init__(self, arg0: int, arg1: str, arg2: str) -> None:
        """__init__(self: torch._C._UpgraderEntry, arg0: int, arg1: str, arg2: str) -> None"""
    def _pybind11_conduit_v1_(self, *args, **kwargs): ...
    @property
    def bumped_at_version(self) -> int:
        """(arg0: torch._C._UpgraderEntry) -> int"""
    @property
    def old_schema(self) -> str:
        """(arg0: torch._C._UpgraderEntry) -> str"""
    @property
    def upgrader_name(self) -> str:
        """(arg0: torch._C._UpgraderEntry) -> str"""

class _UpgraderRange:
    def __init__(self, arg0: int, arg1: int) -> None:
        """__init__(self: torch._C._UpgraderRange, arg0: int, arg1: int) -> None"""
    def _pybind11_conduit_v1_(self, *args, **kwargs): ...
    @property
    def max_version(self) -> int:
        """(arg0: torch._C._UpgraderRange) -> int"""
    @property
    def min_version(self) -> int:
        """(arg0: torch._C._UpgraderRange) -> int"""

class _VariableFunctionsClass:
    @staticmethod
    def _adaptive_avg_pool2d(*args, **kwargs): ...
    @staticmethod
    def _adaptive_avg_pool3d(*args, **kwargs): ...
    @staticmethod
    def _add_batch_dim(*args, **kwargs): ...
    @staticmethod
    def _add_relu(*args, **kwargs): ...
    @staticmethod
    def _add_relu_(*args, **kwargs): ...
    @staticmethod
    def _addmm_activation(*args, **kwargs): ...
    @staticmethod
    def _aminmax(*args, **kwargs): ...
    @staticmethod
    def _amp_foreach_non_finite_check_and_unscale_(*args, **kwargs): ...
    @staticmethod
    def _amp_update_scale_(*args, **kwargs): ...
    @staticmethod
    def _assert_async(tensor) -> void:
        """
        _assert_async(tensor) -> void

        Asynchronously assert that the contents of tensor are nonzero.  For CPU tensors,
        this is equivalent to ``assert tensor`` or ``assert tensor.is_nonzero()``; for
        CUDA tensors, we DO NOT synchronize and you may only find out the assertion
        failed at a later CUDA kernel launch.  Asynchronous assertion can be helpful for
        testing invariants in CUDA tensors without giving up performance.  This function
        is NOT intended to be used for regular error checking, as it will trash your CUDA
        context if the assert fails (forcing you to restart your PyTorch process.)

        Args:
            tensor (Tensor): a one element tensor to test to see if it is nonzero.  Zero
                elements (including False for boolean tensors) cause an assertion failure
                to be raised.
        """
    @staticmethod
    def _assert_scalar(*args, **kwargs): ...
    @staticmethod
    def _assert_tensor_metadata(*args, **kwargs): ...
    @staticmethod
    def _batch_norm_impl_index(*args, **kwargs): ...
    @staticmethod
    def _cast_Byte(*args, **kwargs): ...
    @staticmethod
    def _cast_Char(*args, **kwargs): ...
    @staticmethod
    def _cast_Double(*args, **kwargs): ...
    @staticmethod
    def _cast_Float(*args, **kwargs): ...
    @staticmethod
    def _cast_Half(*args, **kwargs): ...
    @staticmethod
    def _cast_Int(*args, **kwargs): ...
    @staticmethod
    def _cast_Long(*args, **kwargs): ...
    @staticmethod
    def _cast_Short(*args, **kwargs): ...
    @staticmethod
    def _choose_qparams_per_tensor(*args, **kwargs): ...
    @staticmethod
    def _chunk_cat(*args, **kwargs): ...
    @staticmethod
    def _coalesce(*args, **kwargs): ...
    @staticmethod
    def _compute_linear_combination(*args, **kwargs): ...
    @staticmethod
    def _conj(*args, **kwargs): ...
    @staticmethod
    def _conj_copy(*args, **kwargs): ...
    @staticmethod
    def _conj_physical(*args, **kwargs): ...
    @staticmethod
    def _convert_indices_from_coo_to_csr(*args, **kwargs): ...
    @staticmethod
    def _convert_indices_from_csr_to_coo(*args, **kwargs): ...
    @staticmethod
    def _convert_weight_to_int4pack(*args, **kwargs): ...
    @staticmethod
    def _convert_weight_to_int4pack_for_cpu(*args, **kwargs): ...
    @staticmethod
    def _convolution(*args, **kwargs): ...
    @staticmethod
    def _convolution_mode(*args, **kwargs): ...
    @staticmethod
    def _copy_from(*args, **kwargs): ...
    @staticmethod
    def _copy_from_and_resize(*args, **kwargs): ...
    @staticmethod
    def _cslt_compress(*args, **kwargs): ...
    @staticmethod
    def _cslt_sparse_mm(*args, **kwargs): ...
    @staticmethod
    def _cslt_sparse_mm_search(*args, **kwargs): ...
    @staticmethod
    def _ctc_loss(*args, **kwargs): ...
    @staticmethod
    def _cudnn_ctc_loss(*args, **kwargs): ...
    @staticmethod
    def _cudnn_init_dropout_state(*args, **kwargs): ...
    @staticmethod
    def _cudnn_rnn(*args, **kwargs): ...
    @staticmethod
    def _cudnn_rnn_flatten_weight(*args, **kwargs): ...
    @staticmethod
    def _cufft_clear_plan_cache(*args, **kwargs): ...
    @staticmethod
    def _cufft_get_plan_cache_max_size(*args, **kwargs): ...
    @staticmethod
    def _cufft_get_plan_cache_size(*args, **kwargs): ...
    @staticmethod
    def _cufft_set_plan_cache_max_size(*args, **kwargs): ...
    @staticmethod
    def _cummax_helper(*args, **kwargs): ...
    @staticmethod
    def _cummin_helper(*args, **kwargs): ...
    @staticmethod
    def _debug_has_internal_overlap(*args, **kwargs): ...
    @staticmethod
    def _dim_arange(*args, **kwargs): ...
    @staticmethod
    def _dirichlet_grad(*args, **kwargs): ...
    @staticmethod
    def _dyn_quant_matmul_4bit(*args, **kwargs): ...
    @staticmethod
    def _dyn_quant_pack_4bit_weight(*args, **kwargs): ...
    @staticmethod
    def _efficientzerotensor(*args, **kwargs): ...
    @staticmethod
    def _embedding_bag(*args, **kwargs): ...
    @staticmethod
    def _embedding_bag_forward_only(*args, **kwargs): ...
    @staticmethod
    def _empty_affine_quantized(*args, **kwargs): ...
    @staticmethod
    def _empty_per_channel_affine_quantized(*args, **kwargs): ...
    @staticmethod
    def _euclidean_dist(*args, **kwargs): ...
    @staticmethod
    def _fake_quantize_learnable_per_channel_affine(*args, **kwargs): ...
    @staticmethod
    def _fake_quantize_learnable_per_tensor_affine(*args, **kwargs): ...
    @staticmethod
    def _fake_quantize_per_tensor_affine_cachemask_tensor_qparams(*args, **kwargs): ...
    @staticmethod
    def _fft_c2c(*args, **kwargs): ...
    @staticmethod
    def _fft_c2r(*args, **kwargs): ...
    @staticmethod
    def _fft_r2c(*args, **kwargs): ...
    @staticmethod
    def _fill_mem_eff_dropout_mask_(*args, **kwargs): ...
    @staticmethod
    def _foobar(*args, **kwargs): ...
    @staticmethod
    def _foreach_abs(self: list[Tensor]) -> list[Tensor]:
        """
        _foreach_abs(self: List[Tensor]) -> List[Tensor]

        Apply :func:`torch.abs` to each Tensor of the input list.
            """
    @staticmethod
    def _foreach_abs_(self: list[Tensor]) -> None:
        """
        _foreach_abs_(self: List[Tensor]) -> None

        Apply :func:`torch.abs` to each Tensor of the input list.
        """
    @staticmethod
    def _foreach_acos(self: list[Tensor]) -> list[Tensor]:
        """
        _foreach_acos(self: List[Tensor]) -> List[Tensor]

        Apply :func:`torch.acos` to each Tensor of the input list.
            """
    @staticmethod
    def _foreach_acos_(self: list[Tensor]) -> None:
        """
        _foreach_acos_(self: List[Tensor]) -> None

        Apply :func:`torch.acos` to each Tensor of the input list.
        """
    @staticmethod
    def _foreach_add(*args, **kwargs): ...
    @staticmethod
    def _foreach_add_(*args, **kwargs): ...
    @staticmethod
    def _foreach_addcdiv(*args, **kwargs): ...
    @staticmethod
    def _foreach_addcdiv_(*args, **kwargs): ...
    @staticmethod
    def _foreach_addcmul(*args, **kwargs): ...
    @staticmethod
    def _foreach_addcmul_(*args, **kwargs): ...
    @staticmethod
    def _foreach_asin(self: list[Tensor]) -> list[Tensor]:
        """
        _foreach_asin(self: List[Tensor]) -> List[Tensor]

        Apply :func:`torch.asin` to each Tensor of the input list.
            """
    @staticmethod
    def _foreach_asin_(self: list[Tensor]) -> None:
        """
        _foreach_asin_(self: List[Tensor]) -> None

        Apply :func:`torch.asin` to each Tensor of the input list.
        """
    @staticmethod
    def _foreach_atan(self: list[Tensor]) -> list[Tensor]:
        """
        _foreach_atan(self: List[Tensor]) -> List[Tensor]

        Apply :func:`torch.atan` to each Tensor of the input list.
            """
    @staticmethod
    def _foreach_atan_(self: list[Tensor]) -> None:
        """
        _foreach_atan_(self: List[Tensor]) -> None

        Apply :func:`torch.atan` to each Tensor of the input list.
        """
    @staticmethod
    def _foreach_ceil(self: list[Tensor]) -> list[Tensor]:
        """
        _foreach_ceil(self: List[Tensor]) -> List[Tensor]

        Apply :func:`torch.ceil` to each Tensor of the input list.
            """
    @staticmethod
    def _foreach_ceil_(self: list[Tensor]) -> None:
        """
        _foreach_ceil_(self: List[Tensor]) -> None

        Apply :func:`torch.ceil` to each Tensor of the input list.
        """
    @staticmethod
    def _foreach_clamp_max(*args, **kwargs): ...
    @staticmethod
    def _foreach_clamp_max_(*args, **kwargs): ...
    @staticmethod
    def _foreach_clamp_min(*args, **kwargs): ...
    @staticmethod
    def _foreach_clamp_min_(*args, **kwargs): ...
    @staticmethod
    def _foreach_copy_(*args, **kwargs): ...
    @staticmethod
    def _foreach_cos(self: list[Tensor]) -> list[Tensor]:
        """
        _foreach_cos(self: List[Tensor]) -> List[Tensor]

        Apply :func:`torch.cos` to each Tensor of the input list.
            """
    @staticmethod
    def _foreach_cos_(self: list[Tensor]) -> None:
        """
        _foreach_cos_(self: List[Tensor]) -> None

        Apply :func:`torch.cos` to each Tensor of the input list.
        """
    @staticmethod
    def _foreach_cosh(self: list[Tensor]) -> list[Tensor]:
        """
        _foreach_cosh(self: List[Tensor]) -> List[Tensor]

        Apply :func:`torch.cosh` to each Tensor of the input list.
            """
    @staticmethod
    def _foreach_cosh_(self: list[Tensor]) -> None:
        """
        _foreach_cosh_(self: List[Tensor]) -> None

        Apply :func:`torch.cosh` to each Tensor of the input list.
        """
    @staticmethod
    def _foreach_div(*args, **kwargs): ...
    @staticmethod
    def _foreach_div_(*args, **kwargs): ...
    @staticmethod
    def _foreach_erf(self: list[Tensor]) -> list[Tensor]:
        """
        _foreach_erf(self: List[Tensor]) -> List[Tensor]

        Apply :func:`torch.erf` to each Tensor of the input list.
            """
    @staticmethod
    def _foreach_erf_(self: list[Tensor]) -> None:
        """
        _foreach_erf_(self: List[Tensor]) -> None

        Apply :func:`torch.erf` to each Tensor of the input list.
        """
    @staticmethod
    def _foreach_erfc(self: list[Tensor]) -> list[Tensor]:
        """
        _foreach_erfc(self: List[Tensor]) -> List[Tensor]

        Apply :func:`torch.erfc` to each Tensor of the input list.
            """
    @staticmethod
    def _foreach_erfc_(self: list[Tensor]) -> None:
        """
        _foreach_erfc_(self: List[Tensor]) -> None

        Apply :func:`torch.erfc` to each Tensor of the input list.
        """
    @staticmethod
    def _foreach_exp(self: list[Tensor]) -> list[Tensor]:
        """
        _foreach_exp(self: List[Tensor]) -> List[Tensor]

        Apply :func:`torch.exp` to each Tensor of the input list.
            """
    @staticmethod
    def _foreach_exp_(self: list[Tensor]) -> None:
        """
        _foreach_exp_(self: List[Tensor]) -> None

        Apply :func:`torch.exp` to each Tensor of the input list.
        """
    @staticmethod
    def _foreach_expm1(self: list[Tensor]) -> list[Tensor]:
        """
        _foreach_expm1(self: List[Tensor]) -> List[Tensor]

        Apply :func:`torch.expm1` to each Tensor of the input list.
            """
    @staticmethod
    def _foreach_expm1_(self: list[Tensor]) -> None:
        """
        _foreach_expm1_(self: List[Tensor]) -> None

        Apply :func:`torch.expm1` to each Tensor of the input list.
        """
    @staticmethod
    def _foreach_floor(self: list[Tensor]) -> list[Tensor]:
        """
        _foreach_floor(self: List[Tensor]) -> List[Tensor]

        Apply :func:`torch.floor` to each Tensor of the input list.
            """
    @staticmethod
    def _foreach_floor_(self: list[Tensor]) -> None:
        """
        _foreach_floor_(self: List[Tensor]) -> None

        Apply :func:`torch.floor` to each Tensor of the input list.
        """
    @staticmethod
    def _foreach_frac(self: list[Tensor]) -> list[Tensor]:
        """
        _foreach_frac(self: List[Tensor]) -> List[Tensor]

        Apply :func:`torch.frac` to each Tensor of the input list.
            """
    @staticmethod
    def _foreach_frac_(self: list[Tensor]) -> None:
        """
        _foreach_frac_(self: List[Tensor]) -> None

        Apply :func:`torch.frac` to each Tensor of the input list.
        """
    @staticmethod
    def _foreach_lerp(*args, **kwargs): ...
    @staticmethod
    def _foreach_lerp_(*args, **kwargs): ...
    @staticmethod
    def _foreach_lgamma(self: list[Tensor]) -> list[Tensor]:
        """
        _foreach_lgamma(self: List[Tensor]) -> List[Tensor]

        Apply :func:`torch.lgamma` to each Tensor of the input list.
            """
    @staticmethod
    def _foreach_lgamma_(self: list[Tensor]) -> None:
        """
        _foreach_lgamma_(self: List[Tensor]) -> None

        Apply :func:`torch.lgamma` to each Tensor of the input list.
        """
    @staticmethod
    def _foreach_log(self: list[Tensor]) -> list[Tensor]:
        """
        _foreach_log(self: List[Tensor]) -> List[Tensor]

        Apply :func:`torch.log` to each Tensor of the input list.
            """
    @staticmethod
    def _foreach_log10(self: list[Tensor]) -> list[Tensor]:
        """
        _foreach_log10(self: List[Tensor]) -> List[Tensor]

        Apply :func:`torch.log10` to each Tensor of the input list.
            """
    @staticmethod
    def _foreach_log10_(self: list[Tensor]) -> None:
        """
        _foreach_log10_(self: List[Tensor]) -> None

        Apply :func:`torch.log10` to each Tensor of the input list.
        """
    @staticmethod
    def _foreach_log1p(self: list[Tensor]) -> list[Tensor]:
        """
        _foreach_log1p(self: List[Tensor]) -> List[Tensor]

        Apply :func:`torch.log1p` to each Tensor of the input list.
            """
    @staticmethod
    def _foreach_log1p_(self: list[Tensor]) -> None:
        """
        _foreach_log1p_(self: List[Tensor]) -> None

        Apply :func:`torch.log1p` to each Tensor of the input list.
        """
    @staticmethod
    def _foreach_log2(self: list[Tensor]) -> list[Tensor]:
        """
        _foreach_log2(self: List[Tensor]) -> List[Tensor]

        Apply :func:`torch.log2` to each Tensor of the input list.
            """
    @staticmethod
    def _foreach_log2_(self: list[Tensor]) -> None:
        """
        _foreach_log2_(self: List[Tensor]) -> None

        Apply :func:`torch.log2` to each Tensor of the input list.
        """
    @staticmethod
    def _foreach_log_(self: list[Tensor]) -> None:
        """
        _foreach_log_(self: List[Tensor]) -> None

        Apply :func:`torch.log` to each Tensor of the input list.
        """
    @staticmethod
    def _foreach_max(*args, **kwargs): ...
    @staticmethod
    def _foreach_maximum(*args, **kwargs): ...
    @staticmethod
    def _foreach_maximum_(*args, **kwargs): ...
    @staticmethod
    def _foreach_minimum(*args, **kwargs): ...
    @staticmethod
    def _foreach_minimum_(*args, **kwargs): ...
    @staticmethod
    def _foreach_mul(*args, **kwargs): ...
    @staticmethod
    def _foreach_mul_(*args, **kwargs): ...
    @staticmethod
    def _foreach_neg(self: list[Tensor]) -> list[Tensor]:
        """
        _foreach_neg(self: List[Tensor]) -> List[Tensor]

        Apply :func:`torch.neg` to each Tensor of the input list.
            """
    @staticmethod
    def _foreach_neg_(self: list[Tensor]) -> None:
        """
        _foreach_neg_(self: List[Tensor]) -> None

        Apply :func:`torch.neg` to each Tensor of the input list.
        """
    @staticmethod
    def _foreach_norm(*args, **kwargs): ...
    @staticmethod
    def _foreach_pow(*args, **kwargs): ...
    @staticmethod
    def _foreach_pow_(*args, **kwargs): ...
    @staticmethod
    def _foreach_reciprocal(self: list[Tensor]) -> list[Tensor]:
        """
        _foreach_reciprocal(self: List[Tensor]) -> List[Tensor]

        Apply :func:`torch.reciprocal` to each Tensor of the input list.
            """
    @staticmethod
    def _foreach_reciprocal_(self: list[Tensor]) -> None:
        """
        _foreach_reciprocal_(self: List[Tensor]) -> None

        Apply :func:`torch.reciprocal` to each Tensor of the input list.
        """
    @staticmethod
    def _foreach_round(self: list[Tensor]) -> list[Tensor]:
        """
        _foreach_round(self: List[Tensor]) -> List[Tensor]

        Apply :func:`torch.round` to each Tensor of the input list.
            """
    @staticmethod
    def _foreach_round_(self: list[Tensor]) -> None:
        """
        _foreach_round_(self: List[Tensor]) -> None

        Apply :func:`torch.round` to each Tensor of the input list.
        """
    @staticmethod
    def _foreach_rsqrt(*args, **kwargs): ...
    @staticmethod
    def _foreach_rsqrt_(*args, **kwargs): ...
    @staticmethod
    def _foreach_sigmoid(self: list[Tensor]) -> list[Tensor]:
        """
        _foreach_sigmoid(self: List[Tensor]) -> List[Tensor]

        Apply :func:`torch.sigmoid` to each Tensor of the input list.
            """
    @staticmethod
    def _foreach_sigmoid_(self: list[Tensor]) -> None:
        """
        _foreach_sigmoid_(self: List[Tensor]) -> None

        Apply :func:`torch.sigmoid` to each Tensor of the input list.
        """
    @staticmethod
    def _foreach_sign(*args, **kwargs): ...
    @staticmethod
    def _foreach_sign_(*args, **kwargs): ...
    @staticmethod
    def _foreach_sin(self: list[Tensor]) -> list[Tensor]:
        """
        _foreach_sin(self: List[Tensor]) -> List[Tensor]

        Apply :func:`torch.sin` to each Tensor of the input list.
            """
    @staticmethod
    def _foreach_sin_(self: list[Tensor]) -> None:
        """
        _foreach_sin_(self: List[Tensor]) -> None

        Apply :func:`torch.sin` to each Tensor of the input list.
        """
    @staticmethod
    def _foreach_sinh(self: list[Tensor]) -> list[Tensor]:
        """
        _foreach_sinh(self: List[Tensor]) -> List[Tensor]

        Apply :func:`torch.sinh` to each Tensor of the input list.
            """
    @staticmethod
    def _foreach_sinh_(self: list[Tensor]) -> None:
        """
        _foreach_sinh_(self: List[Tensor]) -> None

        Apply :func:`torch.sinh` to each Tensor of the input list.
        """
    @staticmethod
    def _foreach_sqrt(self: list[Tensor]) -> list[Tensor]:
        """
        _foreach_sqrt(self: List[Tensor]) -> List[Tensor]

        Apply :func:`torch.sqrt` to each Tensor of the input list.
            """
    @staticmethod
    def _foreach_sqrt_(self: list[Tensor]) -> None:
        """
        _foreach_sqrt_(self: List[Tensor]) -> None

        Apply :func:`torch.sqrt` to each Tensor of the input list.
        """
    @staticmethod
    def _foreach_sub(*args, **kwargs): ...
    @staticmethod
    def _foreach_sub_(*args, **kwargs): ...
    @staticmethod
    def _foreach_tan(self: list[Tensor]) -> list[Tensor]:
        """
        _foreach_tan(self: List[Tensor]) -> List[Tensor]

        Apply :func:`torch.tan` to each Tensor of the input list.
            """
    @staticmethod
    def _foreach_tan_(self: list[Tensor]) -> None:
        """
        _foreach_tan_(self: List[Tensor]) -> None

        Apply :func:`torch.tan` to each Tensor of the input list.
        """
    @staticmethod
    def _foreach_tanh(self: list[Tensor]) -> list[Tensor]:
        """
        _foreach_tanh(self: List[Tensor]) -> List[Tensor]

        Apply :func:`torch.tanh` to each Tensor of the input list.
            """
    @staticmethod
    def _foreach_tanh_(self: list[Tensor]) -> None:
        """
        _foreach_tanh_(self: List[Tensor]) -> None

        Apply :func:`torch.tanh` to each Tensor of the input list.
        """
    @staticmethod
    def _foreach_trunc(self: list[Tensor]) -> list[Tensor]:
        """
        _foreach_trunc(self: List[Tensor]) -> List[Tensor]

        Apply :func:`torch.trunc` to each Tensor of the input list.
            """
    @staticmethod
    def _foreach_trunc_(self: list[Tensor]) -> None:
        """
        _foreach_trunc_(self: List[Tensor]) -> None

        Apply :func:`torch.trunc` to each Tensor of the input list.
        """
    @staticmethod
    def _foreach_zero_(self: list[Tensor]) -> None:
        """
        _foreach_zero_(self: List[Tensor]) -> None

        Apply :func:`torch.zero` to each Tensor of the input list.
        """
    @staticmethod
    def _functional_assert_async(*args, **kwargs): ...
    @staticmethod
    def _functional_assert_scalar(*args, **kwargs): ...
    @staticmethod
    def _functional_sym_constrain_range(*args, **kwargs): ...
    @staticmethod
    def _functional_sym_constrain_range_for_size(*args, **kwargs): ...
    @staticmethod
    def _fused_adagrad_(*args, **kwargs): ...
    @staticmethod
    def _fused_adam_(*args, **kwargs): ...
    @staticmethod
    def _fused_adamw_(*args, **kwargs): ...
    @staticmethod
    def _fused_dropout(*args, **kwargs): ...
    @staticmethod
    def _fused_moving_avg_obs_fq_helper(*args, **kwargs): ...
    @staticmethod
    def _fused_rms_norm(*args, **kwargs): ...
    @staticmethod
    def _fused_sdp_choice(*args, **kwargs): ...
    @staticmethod
    def _fused_sgd_(*args, **kwargs): ...
    @staticmethod
    def _fw_primal_copy(*args, **kwargs): ...
    @staticmethod
    def _grid_sampler_2d_cpu_fallback(*args, **kwargs): ...
    @staticmethod
    def _grouped_mm(*args, **kwargs): ...
    @staticmethod
    def _has_compatible_shallow_copy_type(*args, **kwargs): ...
    @staticmethod
    def _histogramdd_bin_edges(*args, **kwargs): ...
    @staticmethod
    def _histogramdd_from_bin_cts(*args, **kwargs): ...
    @staticmethod
    def _histogramdd_from_bin_tensors(*args, **kwargs): ...
    @staticmethod
    def _index_put_impl_(*args, **kwargs): ...
    @staticmethod
    def _indices_copy(*args, **kwargs): ...
    @staticmethod
    def _int_mm(*args, **kwargs): ...
    @staticmethod
    def _is_all_true(*args, **kwargs): ...
    @staticmethod
    def _is_any_true(*args, **kwargs): ...
    @staticmethod
    def _is_zerotensor(*args, **kwargs): ...
    @staticmethod
    def _lazy_clone(*args, **kwargs): ...
    @staticmethod
    def _linalg_check_errors(*args, **kwargs): ...
    @staticmethod
    def _linalg_det(*args, **kwargs): ...
    @staticmethod
    def _linalg_eigh(*args, **kwargs): ...
    @staticmethod
    def _linalg_slogdet(*args, **kwargs): ...
    @staticmethod
    def _linalg_solve_ex(*args, **kwargs): ...
    @staticmethod
    def _linalg_svd(*args, **kwargs): ...
    @staticmethod
    def _log_softmax(*args, **kwargs): ...
    @staticmethod
    def _log_softmax_backward_data(*args, **kwargs): ...
    @staticmethod
    def _logcumsumexp(*args, **kwargs): ...
    @staticmethod
    def _lstm_mps(*args, **kwargs): ...
    @staticmethod
    def _lu_with_info(*args, **kwargs): ...
    @staticmethod
    def _make_dep_token(*args, **kwargs): ...
    @staticmethod
    def _make_dual(*args, **kwargs): ...
    @staticmethod
    def _make_dual_copy(*args, **kwargs): ...
    @staticmethod
    def _make_per_channel_quantized_tensor(*args, **kwargs): ...
    @staticmethod
    def _make_per_tensor_quantized_tensor(*args, **kwargs): ...
    @staticmethod
    def _masked_scale(*args, **kwargs): ...
    @staticmethod
    def _masked_softmax(*args, **kwargs): ...
    @staticmethod
    def _mixed_dtypes_linear(*args, **kwargs): ...
    @staticmethod
    def _mkldnn_reshape(*args, **kwargs): ...
    @staticmethod
    def _mkldnn_transpose(*args, **kwargs): ...
    @staticmethod
    def _mkldnn_transpose_(*args, **kwargs): ...
    @staticmethod
    def _mps_convolution(*args, **kwargs): ...
    @staticmethod
    def _mps_convolution_transpose(*args, **kwargs): ...
    @staticmethod
    def _native_batch_norm_legit(*args, **kwargs): ...
    @staticmethod
    def _native_batch_norm_legit_no_training(*args, **kwargs): ...
    @staticmethod
    def _native_multi_head_attention(*args, **kwargs): ...
    @staticmethod
    def _neg_view(*args, **kwargs): ...
    @staticmethod
    def _neg_view_copy(*args, **kwargs): ...
    @staticmethod
    def _nested_compute_contiguous_strides_offsets(*args, **kwargs): ...
    @staticmethod
    def _nested_from_padded(*args, **kwargs): ...
    @staticmethod
    def _nested_from_padded_and_nested_example(*args, **kwargs): ...
    @staticmethod
    def _nested_from_padded_tensor(*args, **kwargs): ...
    @staticmethod
    def _nested_get_jagged_dummy(*args, **kwargs): ...
    @staticmethod
    def _nested_get_lengths(*args, **kwargs): ...
    @staticmethod
    def _nested_get_max_seqlen(*args, **kwargs): ...
    @staticmethod
    def _nested_get_min_seqlen(*args, **kwargs): ...
    @staticmethod
    def _nested_get_offsets(*args, **kwargs): ...
    @staticmethod
    def _nested_get_ragged_idx(*args, **kwargs): ...
    @staticmethod
    def _nested_get_values(*args, **kwargs): ...
    @staticmethod
    def _nested_get_values_copy(*args, **kwargs): ...
    @staticmethod
    def _nested_tensor_from_mask(*args, **kwargs): ...
    @staticmethod
    def _nested_tensor_from_mask_left_aligned(*args, **kwargs): ...
    @staticmethod
    def _nested_tensor_from_tensor_list(*args, **kwargs): ...
    @staticmethod
    def _nested_tensor_softmax_with_shape(*args, **kwargs): ...
    @staticmethod
    def _nested_view_from_buffer(*args, **kwargs): ...
    @staticmethod
    def _nested_view_from_buffer_copy(*args, **kwargs): ...
    @staticmethod
    def _nested_view_from_jagged(*args, **kwargs): ...
    @staticmethod
    def _nested_view_from_jagged_copy(*args, **kwargs): ...
    @staticmethod
    def _nnpack_available(*args, **kwargs): ...
    @staticmethod
    def _nnpack_spatial_convolution(*args, **kwargs): ...
    @staticmethod
    def _pack_padded_sequence(*args, **kwargs): ...
    @staticmethod
    def _pad_packed_sequence(*args, **kwargs): ...
    @staticmethod
    def _pin_memory(*args, **kwargs): ...
    @staticmethod
    def _prelu_kernel(*args, **kwargs): ...
    @staticmethod
    def _print(*args, **kwargs): ...
    @staticmethod
    def _propagate_xla_data(*args, **kwargs): ...
    @staticmethod
    def _remove_batch_dim(*args, **kwargs): ...
    @staticmethod
    def _reshape_alias_copy(*args, **kwargs): ...
    @staticmethod
    def _reshape_from_tensor(*args, **kwargs): ...
    @staticmethod
    def _resize_output_(*args, **kwargs): ...
    @staticmethod
    def _rowwise_prune(*args, **kwargs): ...
    @staticmethod
    def _safe_softmax(*args, **kwargs): ...
    @staticmethod
    def _sample_dirichlet(*args, **kwargs): ...
    @staticmethod
    def _saturate_weight_to_fp16(*args, **kwargs): ...
    @staticmethod
    def _scaled_dot_product_attention_math(*args, **kwargs): ...
    @staticmethod
    def _scaled_dot_product_attention_math_for_mps(*args, **kwargs): ...
    @staticmethod
    def _scaled_dot_product_cudnn_attention(*args, **kwargs): ...
    @staticmethod
    def _scaled_dot_product_efficient_attention(*args, **kwargs): ...
    @staticmethod
    def _scaled_dot_product_flash_attention(*args, **kwargs): ...
    @staticmethod
    def _scaled_dot_product_flash_attention_for_cpu(*args, **kwargs): ...
    @staticmethod
    def _scaled_grouped_mm(*args, **kwargs): ...
    @staticmethod
    def _scaled_mm(*args, **kwargs): ...
    @staticmethod
    def _shape_as_tensor(*args, **kwargs): ...
    @staticmethod
    def _sobol_engine_draw(*args, **kwargs): ...
    @staticmethod
    def _sobol_engine_ff_(*args, **kwargs): ...
    @staticmethod
    def _sobol_engine_initialize_state_(*args, **kwargs): ...
    @staticmethod
    def _sobol_engine_scramble_(*args, **kwargs): ...
    @staticmethod
    def _softmax(*args, **kwargs): ...
    @staticmethod
    def _softmax_backward_data(*args, **kwargs): ...
    @staticmethod
    def _sparse_broadcast_to(*args, **kwargs): ...
    @staticmethod
    def _sparse_broadcast_to_copy(*args, **kwargs): ...
    @staticmethod
    def _sparse_csr_prod(*args, **kwargs): ...
    @staticmethod
    def _sparse_csr_sum(*args, **kwargs): ...
    @staticmethod
    def _sparse_log_softmax_backward_data(*args, **kwargs): ...
    @staticmethod
    def _sparse_semi_structured_addmm(*args, **kwargs): ...
    @staticmethod
    def _sparse_semi_structured_apply(*args, **kwargs): ...
    @staticmethod
    def _sparse_semi_structured_apply_dense(*args, **kwargs): ...
    @staticmethod
    def _sparse_semi_structured_linear(*args, **kwargs): ...
    @staticmethod
    def _sparse_semi_structured_mm(*args, **kwargs): ...
    @staticmethod
    def _sparse_semi_structured_tile(*args, **kwargs): ...
    @staticmethod
    def _sparse_softmax_backward_data(*args, **kwargs): ...
    @staticmethod
    def _sparse_sparse_matmul(*args, **kwargs): ...
    @staticmethod
    def _sparse_sum(*args, **kwargs): ...
    @staticmethod
    def _stack(*args, **kwargs): ...
    @staticmethod
    def _standard_gamma(*args, **kwargs): ...
    @staticmethod
    def _standard_gamma_grad(*args, **kwargs): ...
    @staticmethod
    def _test_autograd_multiple_dispatch(*args, **kwargs): ...
    @staticmethod
    def _test_autograd_multiple_dispatch_view(*args, **kwargs): ...
    @staticmethod
    def _test_autograd_multiple_dispatch_view_copy(*args, **kwargs): ...
    @staticmethod
    def _test_check_tensor(*args, **kwargs): ...
    @staticmethod
    def _test_functorch_fallback(*args, **kwargs): ...
    @staticmethod
    def _test_parallel_materialize(*args, **kwargs): ...
    @staticmethod
    def _test_serialization_subcmul(*args, **kwargs): ...
    @staticmethod
    def _to_cpu(*args, **kwargs): ...
    @staticmethod
    def _to_sparse_semi_structured(*args, **kwargs): ...
    @staticmethod
    def _transform_bias_rescale_qkv(*args, **kwargs): ...
    @staticmethod
    def _transformer_encoder_layer_fwd(*args, **kwargs): ...
    @staticmethod
    def _trilinear(*args, **kwargs): ...
    @staticmethod
    def _triton_multi_head_attention(*args, **kwargs): ...
    @staticmethod
    def _triton_scaled_dot_attention(*args, **kwargs): ...
    @staticmethod
    def _unique(*args, **kwargs): ...
    @staticmethod
    def _unique2(*args, **kwargs): ...
    @staticmethod
    def _unpack_dual(*args, **kwargs): ...
    @staticmethod
    def _unsafe_index(*args, **kwargs): ...
    @staticmethod
    def _unsafe_index_put(*args, **kwargs): ...
    @staticmethod
    def _unsafe_masked_index(*args, **kwargs): ...
    @staticmethod
    def _unsafe_masked_index_put_accumulate(*args, **kwargs): ...
    @staticmethod
    def _use_cudnn_ctc_loss(*args, **kwargs): ...
    @staticmethod
    def _use_cudnn_rnn_flatten_weight(*args, **kwargs): ...
    @staticmethod
    def _validate_compressed_sparse_indices(*args, **kwargs): ...
    @staticmethod
    def _validate_sparse_bsc_tensor_args(*args, **kwargs): ...
    @staticmethod
    def _validate_sparse_bsr_tensor_args(*args, **kwargs): ...
    @staticmethod
    def _validate_sparse_compressed_tensor_args(*args, **kwargs): ...
    @staticmethod
    def _validate_sparse_coo_tensor_args(*args, **kwargs): ...
    @staticmethod
    def _validate_sparse_csc_tensor_args(*args, **kwargs): ...
    @staticmethod
    def _validate_sparse_csr_tensor_args(*args, **kwargs): ...
    @staticmethod
    def _values_copy(*args, **kwargs): ...
    @staticmethod
    def _weight_int4pack_mm(*args, **kwargs): ...
    @staticmethod
    def _weight_int4pack_mm_for_cpu(*args, **kwargs): ...
    @staticmethod
    def _weight_int4pack_mm_with_scales_and_zeros(*args, **kwargs): ...
    @staticmethod
    def _weight_int8pack_mm(*args, **kwargs): ...
    @staticmethod
    def _weight_norm(*args, **kwargs): ...
    @staticmethod
    def _weight_norm_interface(*args, **kwargs): ...
    @staticmethod
    def _wrapped_linear_prepack(*args, **kwargs): ...
    @staticmethod
    def _wrapped_quantized_linear_prepacked(*args, **kwargs): ...
    @staticmethod
    def abs(input: Tensor, out: Tensor | None) -> Tensor:
        """
        abs(input: Tensor, *, out: Optional[Tensor]) -> Tensor

        Computes the absolute value of each element in :attr:`input`.

        .. math::
            \\text{out}_{i} = |\\text{input}_{i}|

        Args:
            input (Tensor): the input tensor.

        Keyword args:
            out (Tensor, optional): the output tensor.

        Example::

            >>> torch.abs(torch.tensor([-1, -2, 3]))
            tensor([ 1,  2,  3])
        """
    @staticmethod
    def abs_(*args, **kwargs): ...
    @staticmethod
    def absolute(input: Tensor, out: Tensor | None) -> Tensor:
        """
        absolute(input: Tensor, *, out: Optional[Tensor]) -> Tensor

        Alias for :func:`torch.abs`
        """
    @staticmethod
    def acos(input: Tensor, out: Tensor | None) -> Tensor:
        """
        acos(input: Tensor, *, out: Optional[Tensor]) -> Tensor

        Computes the inverse cosine of each element in :attr:`input`.

        .. math::
            \\text{out}_{i} = \\cos^{-1}(\\text{input}_{i})

        Args:
            input (Tensor): the input tensor.

        Keyword args:
            out (Tensor, optional): the output tensor.

        Example::

            >>> a = torch.randn(4)
            >>> a
            tensor([ 0.3348, -0.5889,  0.2005, -0.1584])
            >>> torch.acos(a)
            tensor([ 1.2294,  2.2004,  1.3690,  1.7298])
        """
    @staticmethod
    def acos_(*args, **kwargs): ...
    @staticmethod
    def acosh(input: Tensor, out: Tensor | None) -> Tensor:
        """
        acosh(input: Tensor, *, out: Optional[Tensor]) -> Tensor

        Returns a new tensor with the inverse hyperbolic cosine of the elements of :attr:`input`.

        .. math::
            \\text{out}_{i} = \\cosh^{-1}(\\text{input}_{i})

        Note:
            The domain of the inverse hyperbolic cosine is `[1, inf)` and values outside this range
            will be mapped to ``NaN``, except for `+ INF` for which the output is mapped to `+ INF`.

        Args:
            input (Tensor): the input tensor.

        Keyword arguments:
            out (Tensor, optional): the output tensor.

        Example::

            >>> a = torch.randn(4).uniform_(1, 2)
            >>> a
            tensor([ 1.3192, 1.9915, 1.9674, 1.7151 ])
            >>> torch.acosh(a)
            tensor([ 0.7791, 1.3120, 1.2979, 1.1341 ])
        """
    @staticmethod
    def acosh_(*args, **kwargs): ...
    @staticmethod
    def adaptive_avg_pool1d(input, output_size) -> Tensor:
        """
        adaptive_avg_pool1d(input, output_size) -> Tensor

        Applies a 1D adaptive average pooling over an input signal composed of
        several input planes.

        See :class:`~torch.nn.AdaptiveAvgPool1d` for details and output shape.

        Args:
            output_size: the target output size (single integer)
        """
    @staticmethod
    def adaptive_max_pool1d(*args, **kwargs): ...
    @staticmethod
    def add(input, other, alpha=..., out=...) -> Tensor:
        """
        add(input, other, *, alpha=1, out=None) -> Tensor

        Adds :attr:`other`, scaled by :attr:`alpha`, to :attr:`input`.

        .. math::
            \\text{{out}}_i = \\text{{input}}_i + \\text{{alpha}} \\times \\text{{other}}_i


        Supports :ref:`broadcasting to a common shape <broadcasting-semantics>`,
        :ref:`type promotion <type-promotion-doc>`, and integer, float, and complex inputs.

        Args:
            input (Tensor): the input tensor.
            other (Tensor or Number): the tensor or number to add to :attr:`input`.

        Keyword arguments:
            alpha (Number): the multiplier for :attr:`other`.
            out (Tensor, optional): the output tensor.

        Examples::

            >>> a = torch.randn(4)
            >>> a
            tensor([ 0.0202,  1.0985,  1.3506, -0.6056])
            >>> torch.add(a, 20)
            tensor([ 20.0202,  21.0985,  21.3506,  19.3944])

            >>> b = torch.randn(4)
            >>> b
            tensor([-0.9732, -0.3497,  0.6245,  0.4022])
            >>> c = torch.randn(4, 1)
            >>> c
            tensor([[ 0.3743],
                    [-1.7724],
                    [-0.5811],
                    [-0.8017]])
            >>> torch.add(b, c, alpha=10)
            tensor([[  2.7695,   3.3930,   4.3672,   4.1450],
                    [-18.6971, -18.0736, -17.0994, -17.3216],
                    [ -6.7845,  -6.1610,  -5.1868,  -5.4090],
                    [ -8.9902,  -8.3667,  -7.3925,  -7.6147]])
        """
    @staticmethod
    def addbmm(input, batch1, batch2, beta=..., alpha=..., out=...) -> Tensor:
        """
        addbmm(input, batch1, batch2, *, beta=1, alpha=1, out=None) -> Tensor

        Performs a batch matrix-matrix product of matrices stored
        in :attr:`batch1` and :attr:`batch2`,
        with a reduced add step (all matrix multiplications get accumulated
        along the first dimension).
        :attr:`input` is added to the final result.

        :attr:`batch1` and :attr:`batch2` must be 3-D tensors each containing the
        same number of matrices.

        If :attr:`batch1` is a :math:`(b \\times n \\times m)` tensor, :attr:`batch2` is a
        :math:`(b \\times m \\times p)` tensor, :attr:`input` must be
        :ref:`broadcastable <broadcasting-semantics>` with a :math:`(n \\times p)` tensor
        and :attr:`out` will be a :math:`(n \\times p)` tensor.

        .. math::
            out = \\beta\\ \\text{input} + \\alpha\\ (\\sum_{i=0}^{b-1} \\text{batch1}_i \\mathbin{@} \\text{batch2}_i)

        If :attr:`beta` is 0, then the content of :attr:`input` will be ignored, and `nan` and `inf` in
        it will not be propagated.

        For inputs of type `FloatTensor` or `DoubleTensor`, arguments :attr:`beta` and :attr:`alpha`
        must be real numbers, otherwise they should be integers.

        This operator supports :ref:`TensorFloat32<tf32_on_ampere>`.

        On certain ROCm devices, when using float16 inputs this module will use :ref:`different precision<fp16_on_mi200>` for backward.

        Args:
            input (Tensor): matrix to be added
            batch1 (Tensor): the first batch of matrices to be multiplied
            batch2 (Tensor): the second batch of matrices to be multiplied

        Keyword args:
            beta (Number, optional): multiplier for :attr:`input` (:math:`\\beta`)
            alpha (Number, optional): multiplier for `batch1 @ batch2` (:math:`\\alpha`)
            out (Tensor, optional): the output tensor.

        Example::

            >>> M = torch.randn(3, 5)
            >>> batch1 = torch.randn(10, 3, 4)
            >>> batch2 = torch.randn(10, 4, 5)
            >>> torch.addbmm(M, batch1, batch2)
            tensor([[  6.6311,   0.0503,   6.9768, -12.0362,  -2.1653],
                    [ -4.8185,  -1.4255,  -6.6760,   8.9453,   2.5743],
                    [ -3.8202,   4.3691,   1.0943,  -1.1109,   5.4730]])
        """
    @staticmethod
    def addcdiv(input, tensor1, tensor2, value=..., out=...) -> Tensor:
        """
        addcdiv(input, tensor1, tensor2, *, value=1, out=None) -> Tensor

        Performs the element-wise division of :attr:`tensor1` by :attr:`tensor2`,
        multiplies the result by the scalar :attr:`value` and adds it to :attr:`input`.

        .. warning::
            Integer division with addcdiv is no longer supported, and in a future
            release addcdiv will perform a true division of tensor1 and tensor2.
            The historic addcdiv behavior can be implemented as
            (input + value * torch.trunc(tensor1 / tensor2)).to(input.dtype)
            for integer inputs and as (input + value * tensor1 / tensor2) for float inputs.
            The future addcdiv behavior is just the latter implementation:
            (input + value * tensor1 / tensor2), for all dtypes.

        .. math::
            \\text{out}_i = \\text{input}_i + \\text{value} \\times \\frac{\\text{tensor1}_i}{\\text{tensor2}_i}


        The shapes of :attr:`input`, :attr:`tensor1`, and :attr:`tensor2` must be
        :ref:`broadcastable <broadcasting-semantics>`.

        For inputs of type `FloatTensor` or `DoubleTensor`, :attr:`value` must be
        a real number, otherwise an integer.

        Args:
            input (Tensor): the tensor to be added
            tensor1 (Tensor): the numerator tensor
            tensor2 (Tensor): the denominator tensor

        Keyword args:
            value (Number, optional): multiplier for :math:`\\text{tensor1} / \\text{tensor2}`
            out (Tensor, optional): the output tensor.

        Example::

            >>> t = torch.randn(1, 3)
            >>> t1 = torch.randn(3, 1)
            >>> t2 = torch.randn(1, 3)
            >>> torch.addcdiv(t, t1, t2, value=0.1)
            tensor([[-0.2312, -3.6496,  0.1312],
                    [-1.0428,  3.4292, -0.1030],
                    [-0.5369, -0.9829,  0.0430]])
        """
    @staticmethod
    def addcmul(input, tensor1, tensor2, value=..., out=...) -> Tensor:
        """
        addcmul(input, tensor1, tensor2, *, value=1, out=None) -> Tensor

        Performs the element-wise multiplication of :attr:`tensor1`
        by :attr:`tensor2`, multiplies the result by the scalar :attr:`value`
        and adds it to :attr:`input`.

        .. math::
            \\text{out}_i = \\text{input}_i + \\text{value} \\times \\text{tensor1}_i \\times \\text{tensor2}_i

        The shapes of :attr:`tensor`, :attr:`tensor1`, and :attr:`tensor2` must be
        :ref:`broadcastable <broadcasting-semantics>`.

        For inputs of type `FloatTensor` or `DoubleTensor`, :attr:`value` must be
        a real number, otherwise an integer.

        Args:
            input (Tensor): the tensor to be added
            tensor1 (Tensor): the tensor to be multiplied
            tensor2 (Tensor): the tensor to be multiplied

        Keyword args:
            value (Number, optional): multiplier for :math:`tensor1 .* tensor2`
            out (Tensor, optional): the output tensor.

        Example::

            >>> t = torch.randn(1, 3)
            >>> t1 = torch.randn(3, 1)
            >>> t2 = torch.randn(1, 3)
            >>> torch.addcmul(t, t1, t2, value=0.1)
            tensor([[-0.8635, -0.6391,  1.6174],
                    [-0.7617, -0.5879,  1.7388],
                    [-0.8353, -0.6249,  1.6511]])
        """
    @staticmethod
    def addmm(input, mat1, mat2, out_dtype=..., beta=..., alpha=..., out=...) -> Tensor:
        """
        addmm(input, mat1, mat2, out_dtype=None, *, beta=1, alpha=1, out=None) -> Tensor

        Performs a matrix multiplication of the matrices :attr:`mat1` and :attr:`mat2`.
        The matrix :attr:`input` is added to the final result.

        If :attr:`mat1` is a :math:`(n \\times m)` tensor, :attr:`mat2` is a
        :math:`(m \\times p)` tensor, then :attr:`input` must be
        :ref:`broadcastable <broadcasting-semantics>` with a :math:`(n \\times p)` tensor
        and :attr:`out` will be a :math:`(n \\times p)` tensor.

        :attr:`alpha` and :attr:`beta` are scaling factors on matrix-vector product between
        :attr:`mat1` and :attr:`mat2` and the added matrix :attr:`input` respectively.

        .. math::
            \\text{out} = \\beta\\ \\text{input} + \\alpha\\ (\\text{mat1}_i \\mathbin{@} \\text{mat2}_i)

        If :attr:`beta` is 0, then the content of :attr:`input` will be ignored, and `nan` and `inf` in
        it will not be propagated.

        For inputs of type `FloatTensor` or `DoubleTensor`, arguments :attr:`beta` and
        :attr:`alpha` must be real numbers, otherwise they should be integers.

        This operation has support for arguments with :ref:`sparse layouts<sparse-docs>`. If
        :attr:`input` is sparse the result will have the same layout and if :attr:`out`
        is provided it must have the same layout as :attr:`input`.


        .. warning::
            Sparse support is a beta feature and some layout(s)/dtype/device combinations may not be supported,
            or may not have autograd support. If you notice missing functionality please
            open a feature request.

        This operator supports :ref:`TensorFloat32<tf32_on_ampere>`.

        On certain ROCm devices, when using float16 inputs this module will use :ref:`different precision<fp16_on_mi200>` for backward.

        Args:
            input (Tensor): matrix to be added
            mat1 (Tensor): the first matrix to be matrix multiplied
            mat2 (Tensor): the second matrix to be matrix multiplied
            out_dtype (dtype, optional): the dtype of the output tensor,
                Supported only on CUDA and for torch.float32 given
                torch.float16/torch.bfloat16 input dtypes

        Keyword args:
            beta (Number, optional): multiplier for :attr:`input` (:math:`\\beta`)
            alpha (Number, optional): multiplier for :math:`mat1 @ mat2` (:math:`\\alpha`)
            out (Tensor, optional): the output tensor.

        Example::

            >>> M = torch.randn(2, 3)
            >>> mat1 = torch.randn(2, 3)
            >>> mat2 = torch.randn(3, 3)
            >>> torch.addmm(M, mat1, mat2)
            tensor([[-4.8716,  1.4671, -1.3746],
                    [ 0.7573, -3.9555, -2.8681]])
        """
    @staticmethod
    def addmv(input, mat, vec, beta=..., alpha=..., out=...) -> Tensor:
        """
        addmv(input, mat, vec, *, beta=1, alpha=1, out=None) -> Tensor

        Performs a matrix-vector product of the matrix :attr:`mat` and
        the vector :attr:`vec`.
        The vector :attr:`input` is added to the final result.

        If :attr:`mat` is a :math:`(n \\times m)` tensor, :attr:`vec` is a 1-D tensor of
        size `m`, then :attr:`input` must be
        :ref:`broadcastable <broadcasting-semantics>` with a 1-D tensor of size `n` and
        :attr:`out` will be 1-D tensor of size `n`.

        :attr:`alpha` and :attr:`beta` are scaling factors on matrix-vector product between
        :attr:`mat` and :attr:`vec` and the added tensor :attr:`input` respectively.

        .. math::
            \\text{out} = \\beta\\ \\text{input} + \\alpha\\ (\\text{mat} \\mathbin{@} \\text{vec})

        If :attr:`beta` is 0, then the content of :attr:`input` will be ignored, and `nan` and `inf` in
        it will not be propagated.

        For inputs of type `FloatTensor` or `DoubleTensor`, arguments :attr:`beta` and
        :attr:`alpha` must be real numbers, otherwise they should be integers.

        Args:
            input (Tensor): vector to be added
            mat (Tensor): matrix to be matrix multiplied
            vec (Tensor): vector to be matrix multiplied

        Keyword args:
            beta (Number, optional): multiplier for :attr:`input` (:math:`\\beta`)
            alpha (Number, optional): multiplier for :math:`mat @ vec` (:math:`\\alpha`)
            out (Tensor, optional): the output tensor.

        Example::

            >>> M = torch.randn(2)
            >>> mat = torch.randn(2, 3)
            >>> vec = torch.randn(3)
            >>> torch.addmv(M, mat, vec)
            tensor([-0.3768, -5.5565])
        """
    @staticmethod
    def addmv_(*args, **kwargs): ...
    @staticmethod
    def addr(input, vec1, vec2, beta=..., alpha=..., out=...) -> Tensor:
        """
        addr(input, vec1, vec2, *, beta=1, alpha=1, out=None) -> Tensor

        Performs the outer-product of vectors :attr:`vec1` and :attr:`vec2`
        and adds it to the matrix :attr:`input`.

        Optional values :attr:`beta` and :attr:`alpha` are scaling factors on the
        outer product between :attr:`vec1` and :attr:`vec2` and the added matrix
        :attr:`input` respectively.

        .. math::
            \\text{out} = \\beta\\ \\text{input} + \\alpha\\ (\\text{vec1} \\otimes \\text{vec2})

        If :attr:`beta` is 0, then the content of :attr:`input` will be ignored, and `nan` and `inf` in
        it will not be propagated.

        If :attr:`vec1` is a vector of size `n` and :attr:`vec2` is a vector
        of size `m`, then :attr:`input` must be
        :ref:`broadcastable <broadcasting-semantics>` with a matrix of size
        :math:`(n \\times m)` and :attr:`out` will be a matrix of size
        :math:`(n \\times m)`.

        Args:
            input (Tensor): matrix to be added
            vec1 (Tensor): the first vector of the outer product
            vec2 (Tensor): the second vector of the outer product

        Keyword args:
            beta (Number, optional): multiplier for :attr:`input` (:math:`\\beta`)
            alpha (Number, optional): multiplier for :math:`\\text{vec1} \\otimes \\text{vec2}` (:math:`\\alpha`)
            out (Tensor, optional): the output tensor.

        Example::

            >>> vec1 = torch.arange(1., 4.)
            >>> vec2 = torch.arange(1., 3.)
            >>> M = torch.zeros(3, 2)
            >>> torch.addr(M, vec1, vec2)
            tensor([[ 1.,  2.],
                    [ 2.,  4.],
                    [ 3.,  6.]])
        """
    @overload
    @staticmethod
    def adjoint(input: Tensor) -> Tensor:
        """
        adjoint(input: Tensor) -> Tensor
        Returns a view of the tensor conjugated and with the last two dimensions transposed.

        ``x.adjoint()`` is equivalent to ``x.transpose(-2, -1).conj()`` for complex tensors and
        to ``x.transpose(-2, -1)`` for real tensors.

        Args:
            {input}

        Example::

            >>> x = torch.arange(4, dtype=torch.float)
            >>> A = torch.complex(x, x).reshape(2, 2)
            >>> A
            tensor([[0.+0.j, 1.+1.j],
                    [2.+2.j, 3.+3.j]])
            >>> A.adjoint()
            tensor([[0.-0.j, 2.-2.j],
                    [1.-1.j, 3.-3.j]])
            >>> (A.adjoint() == A.mH).all()
            tensor(True)
        """
    @overload
    @staticmethod
    def adjoint() -> Any:
        """
        adjoint(input: Tensor) -> Tensor
        Returns a view of the tensor conjugated and with the last two dimensions transposed.

        ``x.adjoint()`` is equivalent to ``x.transpose(-2, -1).conj()`` for complex tensors and
        to ``x.transpose(-2, -1)`` for real tensors.

        Args:
            {input}

        Example::

            >>> x = torch.arange(4, dtype=torch.float)
            >>> A = torch.complex(x, x).reshape(2, 2)
            >>> A
            tensor([[0.+0.j, 1.+1.j],
                    [2.+2.j, 3.+3.j]])
            >>> A.adjoint()
            tensor([[0.-0.j, 2.-2.j],
                    [1.-1.j, 3.-3.j]])
            >>> (A.adjoint() == A.mH).all()
            tensor(True)
        """
    @overload
    @staticmethod
    def adjoint() -> Any:
        """
        adjoint(input: Tensor) -> Tensor
        Returns a view of the tensor conjugated and with the last two dimensions transposed.

        ``x.adjoint()`` is equivalent to ``x.transpose(-2, -1).conj()`` for complex tensors and
        to ``x.transpose(-2, -1)`` for real tensors.

        Args:
            {input}

        Example::

            >>> x = torch.arange(4, dtype=torch.float)
            >>> A = torch.complex(x, x).reshape(2, 2)
            >>> A
            tensor([[0.+0.j, 1.+1.j],
                    [2.+2.j, 3.+3.j]])
            >>> A.adjoint()
            tensor([[0.-0.j, 2.-2.j],
                    [1.-1.j, 3.-3.j]])
            >>> (A.adjoint() == A.mH).all()
            tensor(True)
        """
    @overload
    @staticmethod
    def adjoint() -> Any:
        """
        adjoint(input: Tensor) -> Tensor
        Returns a view of the tensor conjugated and with the last two dimensions transposed.

        ``x.adjoint()`` is equivalent to ``x.transpose(-2, -1).conj()`` for complex tensors and
        to ``x.transpose(-2, -1)`` for real tensors.

        Args:
            {input}

        Example::

            >>> x = torch.arange(4, dtype=torch.float)
            >>> A = torch.complex(x, x).reshape(2, 2)
            >>> A
            tensor([[0.+0.j, 1.+1.j],
                    [2.+2.j, 3.+3.j]])
            >>> A.adjoint()
            tensor([[0.-0.j, 2.-2.j],
                    [1.-1.j, 3.-3.j]])
            >>> (A.adjoint() == A.mH).all()
            tensor(True)
        """
    @staticmethod
    def affine_grid_generator(*args, **kwargs): ...
    @staticmethod
    def alias_copy(*args, **kwargs):
        """
        Performs the same operation as :func:`torch.alias`, but all output tensors
        are freshly created instead of aliasing the input.
        """
    @staticmethod
    def align_tensors(*args, **kwargs): ...
    @overload
    @staticmethod
    def all(input: Tensor, out=...) -> Tensor:
        """
        all(input: Tensor, *, out=None) -> Tensor

        Tests if all elements in :attr:`input` evaluate to `True`.

        .. note:: This function matches the behaviour of NumPy in returning
                  output of dtype `bool` for all supported dtypes except `uint8`.
                  For `uint8` the dtype of output is `uint8` itself.

        Args:
            input (Tensor): the input tensor.

        Keyword args:
            out (Tensor, optional): the output tensor.

        Example::

            >>> a = torch.rand(1, 2).bool()
            >>> a
            tensor([[False, True]], dtype=torch.bool)
            >>> torch.all(a)
            tensor(False, dtype=torch.bool)
            >>> a = torch.arange(0, 3)
            >>> a
            tensor([0, 1, 2])
            >>> torch.all(a)
            tensor(False)

        .. function:: all(input, dim, keepdim=False, *, out=None) -> Tensor
           :noindex:

        For each row of :attr:`input` in the given dimension :attr:`dim`,
        returns `True` if all elements in the row evaluate to `True` and `False` otherwise.


        If :attr:`keepdim` is ``True``, the output tensor is of the same size
        as :attr:`input` except in the dimension(s) :attr:`dim` where it is of size 1.
        Otherwise, :attr:`dim` is squeezed (see :func:`torch.squeeze`), resulting in the
        output tensor having 1 (or ``len(dim)``) fewer dimension(s).


        Args:
            input (Tensor): the input tensor.
    
            dim (int or tuple of ints, optional): the dimension or dimensions to reduce.
                If ``None``, all dimensions are reduced.

    
            keepdim (bool, optional): whether the output tensor has :attr:`dim` retained or not. Default: ``False``.


        Keyword args:
            out (Tensor, optional): the output tensor.

        Example::

            >>> a = torch.rand(4, 2).bool()
            >>> a
            tensor([[True, True],
                    [True, False],
                    [True, True],
                    [True, True]], dtype=torch.bool)
            >>> torch.all(a, dim=1)
            tensor([ True, False,  True,  True], dtype=torch.bool)
            >>> torch.all(a, dim=0)
            tensor([ True, False], dtype=torch.bool)
        """
    @overload
    @staticmethod
    def all(a) -> Any:
        """
        all(input: Tensor, *, out=None) -> Tensor

        Tests if all elements in :attr:`input` evaluate to `True`.

        .. note:: This function matches the behaviour of NumPy in returning
                  output of dtype `bool` for all supported dtypes except `uint8`.
                  For `uint8` the dtype of output is `uint8` itself.

        Args:
            input (Tensor): the input tensor.

        Keyword args:
            out (Tensor, optional): the output tensor.

        Example::

            >>> a = torch.rand(1, 2).bool()
            >>> a
            tensor([[False, True]], dtype=torch.bool)
            >>> torch.all(a)
            tensor(False, dtype=torch.bool)
            >>> a = torch.arange(0, 3)
            >>> a
            tensor([0, 1, 2])
            >>> torch.all(a)
            tensor(False)

        .. function:: all(input, dim, keepdim=False, *, out=None) -> Tensor
           :noindex:

        For each row of :attr:`input` in the given dimension :attr:`dim`,
        returns `True` if all elements in the row evaluate to `True` and `False` otherwise.


        If :attr:`keepdim` is ``True``, the output tensor is of the same size
        as :attr:`input` except in the dimension(s) :attr:`dim` where it is of size 1.
        Otherwise, :attr:`dim` is squeezed (see :func:`torch.squeeze`), resulting in the
        output tensor having 1 (or ``len(dim)``) fewer dimension(s).


        Args:
            input (Tensor): the input tensor.
    
            dim (int or tuple of ints, optional): the dimension or dimensions to reduce.
                If ``None``, all dimensions are reduced.

    
            keepdim (bool, optional): whether the output tensor has :attr:`dim` retained or not. Default: ``False``.


        Keyword args:
            out (Tensor, optional): the output tensor.

        Example::

            >>> a = torch.rand(4, 2).bool()
            >>> a
            tensor([[True, True],
                    [True, False],
                    [True, True],
                    [True, True]], dtype=torch.bool)
            >>> torch.all(a, dim=1)
            tensor([ True, False,  True,  True], dtype=torch.bool)
            >>> torch.all(a, dim=0)
            tensor([ True, False], dtype=torch.bool)
        """
    @overload
    @staticmethod
    def all(a) -> Any:
        """
        all(input: Tensor, *, out=None) -> Tensor

        Tests if all elements in :attr:`input` evaluate to `True`.

        .. note:: This function matches the behaviour of NumPy in returning
                  output of dtype `bool` for all supported dtypes except `uint8`.
                  For `uint8` the dtype of output is `uint8` itself.

        Args:
            input (Tensor): the input tensor.

        Keyword args:
            out (Tensor, optional): the output tensor.

        Example::

            >>> a = torch.rand(1, 2).bool()
            >>> a
            tensor([[False, True]], dtype=torch.bool)
            >>> torch.all(a)
            tensor(False, dtype=torch.bool)
            >>> a = torch.arange(0, 3)
            >>> a
            tensor([0, 1, 2])
            >>> torch.all(a)
            tensor(False)

        .. function:: all(input, dim, keepdim=False, *, out=None) -> Tensor
           :noindex:

        For each row of :attr:`input` in the given dimension :attr:`dim`,
        returns `True` if all elements in the row evaluate to `True` and `False` otherwise.


        If :attr:`keepdim` is ``True``, the output tensor is of the same size
        as :attr:`input` except in the dimension(s) :attr:`dim` where it is of size 1.
        Otherwise, :attr:`dim` is squeezed (see :func:`torch.squeeze`), resulting in the
        output tensor having 1 (or ``len(dim)``) fewer dimension(s).


        Args:
            input (Tensor): the input tensor.
    
            dim (int or tuple of ints, optional): the dimension or dimensions to reduce.
                If ``None``, all dimensions are reduced.

    
            keepdim (bool, optional): whether the output tensor has :attr:`dim` retained or not. Default: ``False``.


        Keyword args:
            out (Tensor, optional): the output tensor.

        Example::

            >>> a = torch.rand(4, 2).bool()
            >>> a
            tensor([[True, True],
                    [True, False],
                    [True, True],
                    [True, True]], dtype=torch.bool)
            >>> torch.all(a, dim=1)
            tensor([ True, False,  True,  True], dtype=torch.bool)
            >>> torch.all(a, dim=0)
            tensor([ True, False], dtype=torch.bool)
        """
    @overload
    @staticmethod
    def all(a, dim=...) -> Any:
        """
        all(input: Tensor, *, out=None) -> Tensor

        Tests if all elements in :attr:`input` evaluate to `True`.

        .. note:: This function matches the behaviour of NumPy in returning
                  output of dtype `bool` for all supported dtypes except `uint8`.
                  For `uint8` the dtype of output is `uint8` itself.

        Args:
            input (Tensor): the input tensor.

        Keyword args:
            out (Tensor, optional): the output tensor.

        Example::

            >>> a = torch.rand(1, 2).bool()
            >>> a
            tensor([[False, True]], dtype=torch.bool)
            >>> torch.all(a)
            tensor(False, dtype=torch.bool)
            >>> a = torch.arange(0, 3)
            >>> a
            tensor([0, 1, 2])
            >>> torch.all(a)
            tensor(False)

        .. function:: all(input, dim, keepdim=False, *, out=None) -> Tensor
           :noindex:

        For each row of :attr:`input` in the given dimension :attr:`dim`,
        returns `True` if all elements in the row evaluate to `True` and `False` otherwise.


        If :attr:`keepdim` is ``True``, the output tensor is of the same size
        as :attr:`input` except in the dimension(s) :attr:`dim` where it is of size 1.
        Otherwise, :attr:`dim` is squeezed (see :func:`torch.squeeze`), resulting in the
        output tensor having 1 (or ``len(dim)``) fewer dimension(s).


        Args:
            input (Tensor): the input tensor.
    
            dim (int or tuple of ints, optional): the dimension or dimensions to reduce.
                If ``None``, all dimensions are reduced.

    
            keepdim (bool, optional): whether the output tensor has :attr:`dim` retained or not. Default: ``False``.


        Keyword args:
            out (Tensor, optional): the output tensor.

        Example::

            >>> a = torch.rand(4, 2).bool()
            >>> a
            tensor([[True, True],
                    [True, False],
                    [True, True],
                    [True, True]], dtype=torch.bool)
            >>> torch.all(a, dim=1)
            tensor([ True, False,  True,  True], dtype=torch.bool)
            >>> torch.all(a, dim=0)
            tensor([ True, False], dtype=torch.bool)
        """
    @overload
    @staticmethod
    def all(a, dim=...) -> Any:
        """
        all(input: Tensor, *, out=None) -> Tensor

        Tests if all elements in :attr:`input` evaluate to `True`.

        .. note:: This function matches the behaviour of NumPy in returning
                  output of dtype `bool` for all supported dtypes except `uint8`.
                  For `uint8` the dtype of output is `uint8` itself.

        Args:
            input (Tensor): the input tensor.

        Keyword args:
            out (Tensor, optional): the output tensor.

        Example::

            >>> a = torch.rand(1, 2).bool()
            >>> a
            tensor([[False, True]], dtype=torch.bool)
            >>> torch.all(a)
            tensor(False, dtype=torch.bool)
            >>> a = torch.arange(0, 3)
            >>> a
            tensor([0, 1, 2])
            >>> torch.all(a)
            tensor(False)

        .. function:: all(input, dim, keepdim=False, *, out=None) -> Tensor
           :noindex:

        For each row of :attr:`input` in the given dimension :attr:`dim`,
        returns `True` if all elements in the row evaluate to `True` and `False` otherwise.


        If :attr:`keepdim` is ``True``, the output tensor is of the same size
        as :attr:`input` except in the dimension(s) :attr:`dim` where it is of size 1.
        Otherwise, :attr:`dim` is squeezed (see :func:`torch.squeeze`), resulting in the
        output tensor having 1 (or ``len(dim)``) fewer dimension(s).


        Args:
            input (Tensor): the input tensor.
    
            dim (int or tuple of ints, optional): the dimension or dimensions to reduce.
                If ``None``, all dimensions are reduced.

    
            keepdim (bool, optional): whether the output tensor has :attr:`dim` retained or not. Default: ``False``.


        Keyword args:
            out (Tensor, optional): the output tensor.

        Example::

            >>> a = torch.rand(4, 2).bool()
            >>> a
            tensor([[True, True],
                    [True, False],
                    [True, True],
                    [True, True]], dtype=torch.bool)
            >>> torch.all(a, dim=1)
            tensor([ True, False,  True,  True], dtype=torch.bool)
            >>> torch.all(a, dim=0)
            tensor([ True, False], dtype=torch.bool)
        """
    @staticmethod
    def allclose(input: Tensor, other: Tensor, rtol: float = ..., atol: float = ..., equal_nan: bool = ...) -> bool:
        """
        allclose(input: Tensor, other: Tensor, rtol: float = 1e-05, atol: float = 1e-08, equal_nan: bool = False) -> bool

        This function checks if :attr:`input` and :attr:`other` satisfy the condition:

        .. math::
            \\lvert \\text{input}_i - \\text{other}_i \\rvert \\leq \\texttt{atol} + \\texttt{rtol} \\times \\lvert \\text{other}_i \\rvert

        elementwise, for all elements of :attr:`input` and :attr:`other`. The behaviour of this function is analogous to
        `numpy.allclose <https://numpy.org/doc/stable/reference/generated/numpy.allclose.html>`_

        Args:
            input (Tensor): first tensor to compare
            other (Tensor): second tensor to compare
            atol (float, optional): absolute tolerance. Default: 1e-08
            rtol (float, optional): relative tolerance. Default: 1e-05
            equal_nan (bool, optional): if ``True``, then two ``NaN`` s will be considered equal. Default: ``False``

        Example::

            >>> torch.allclose(torch.tensor([10000., 1e-07]), torch.tensor([10000.1, 1e-08]))
            False
            >>> torch.allclose(torch.tensor([10000., 1e-08]), torch.tensor([10000.1, 1e-09]))
            True
            >>> torch.allclose(torch.tensor([1.0, float('nan')]), torch.tensor([1.0, float('nan')]))
            False
            >>> torch.allclose(torch.tensor([1.0, float('nan')]), torch.tensor([1.0, float('nan')]), equal_nan=True)
            True
        """
    @staticmethod
    def alpha_dropout(*args, **kwargs): ...
    @staticmethod
    def alpha_dropout_(*args, **kwargs): ...
    @staticmethod
    def amax(input, dim, keepdim=..., out=...) -> Tensor:
        """
        amax(input, dim, keepdim=False, *, out=None) -> Tensor

        Returns the maximum value of each slice of the :attr:`input` tensor in the given
        dimension(s) :attr:`dim`.

        .. note::
            The difference between ``max``/``min`` and ``amax``/``amin`` is:
                - ``amax``/``amin`` supports reducing on multiple dimensions,
                - ``amax``/``amin`` does not return indices.

            Both ``max``/``min`` and ``amax``/``amin`` evenly distribute gradients between equal values
            when there are multiple input elements with the same minimum or maximum value.


        If :attr:`keepdim` is ``True``, the output tensor is of the same size
        as :attr:`input` except in the dimension(s) :attr:`dim` where it is of size 1.
        Otherwise, :attr:`dim` is squeezed (see :func:`torch.squeeze`), resulting in the
        output tensor having 1 (or ``len(dim)``) fewer dimension(s).


        Args:
            input (Tensor): the input tensor.
    
            dim (int or tuple of ints, optional): the dimension or dimensions to reduce.
                If ``None``, all dimensions are reduced.

    
            keepdim (bool, optional): whether the output tensor has :attr:`dim` retained or not. Default: ``False``.


        Keyword args:
          out (Tensor, optional): the output tensor.

        Example::

            >>> a = torch.randn(4, 4)
            >>> a
            tensor([[ 0.8177,  1.4878, -0.2491,  0.9130],
                    [-0.7158,  1.1775,  2.0992,  0.4817],
                    [-0.0053,  0.0164, -1.3738, -0.0507],
                    [ 1.9700,  1.1106, -1.0318, -1.0816]])
            >>> torch.amax(a, 1)
            tensor([1.4878, 2.0992, 0.0164, 1.9700])
        """
    @staticmethod
    def amin(input, dim, keepdim=..., out=...) -> Tensor:
        """
        amin(input, dim, keepdim=False, *, out=None) -> Tensor

        Returns the minimum value of each slice of the :attr:`input` tensor in the given
        dimension(s) :attr:`dim`.

        .. note::
            The difference between ``max``/``min`` and ``amax``/``amin`` is:
                - ``amax``/``amin`` supports reducing on multiple dimensions,
                - ``amax``/``amin`` does not return indices.

            Both ``max``/``min`` and ``amax``/``amin`` evenly distribute gradients between equal values
            when there are multiple input elements with the same minimum or maximum value.


        If :attr:`keepdim` is ``True``, the output tensor is of the same size
        as :attr:`input` except in the dimension(s) :attr:`dim` where it is of size 1.
        Otherwise, :attr:`dim` is squeezed (see :func:`torch.squeeze`), resulting in the
        output tensor having 1 (or ``len(dim)``) fewer dimension(s).


        Args:
            input (Tensor): the input tensor.
    
            dim (int or tuple of ints, optional): the dimension or dimensions to reduce.
                If ``None``, all dimensions are reduced.

    
            keepdim (bool, optional): whether the output tensor has :attr:`dim` retained or not. Default: ``False``.


        Keyword args:
          out (Tensor, optional): the output tensor.

        Example::

            >>> a = torch.randn(4, 4)
            >>> a
            tensor([[ 0.6451, -0.4866,  0.2987, -1.3312],
                    [-0.5744,  1.2980,  1.8397, -0.2713],
                    [ 0.9128,  0.9214, -1.7268, -0.2995],
                    [ 0.9023,  0.4853,  0.9075, -1.6165]])
            >>> torch.amin(a, 1)
            tensor([-1.3312, -0.5744, -1.7268, -1.6165])
        """
    @overload
    @staticmethod
    def aminmax(
min=..., 
max=...) -> Any:
        """
        aminmax(input, *, dim=None, keepdim=False, out=None) -> (Tensor min, Tensor max)

        Computes the minimum and maximum values of the :attr:`input` tensor.

        Args:
            input (Tensor):
                The input tensor

        Keyword Args:
            dim (Optional[int]):
                The dimension along which to compute the values. If `None`,
                computes the values over the entire :attr:`input` tensor.
                Default is `None`.
            keepdim (bool):
                If `True`, the reduced dimensions will be kept in the output
                tensor as dimensions with size 1 for broadcasting, otherwise
                they will be removed, as if calling (:func:`torch.squeeze`).
                Default is `False`.
            out (Optional[Tuple[Tensor, Tensor]]):
                Optional tensors on which to write the result. Must have the same
                shape and dtype as the expected output.
                Default is `None`.

        Returns:
            A named tuple `(min, max)` containing the minimum and maximum values.

        Raises:
            RuntimeError
                If any of the dimensions to compute the values over has size 0.

        .. note::
            NaN values are propagated to the output if at least one value is NaN.

        .. seealso::
            :func:`torch.amin` computes just the minimum value
            :func:`torch.amax` computes just the maximum value

        Example::

            >>> torch.aminmax(torch.tensor([1, -3, 5]))
            torch.return_types.aminmax(
            min=tensor(-3),
            max=tensor(5))

            >>> # aminmax propagates NaNs
            >>> torch.aminmax(torch.tensor([1, -3, 5, torch.nan]))
            torch.return_types.aminmax(
            min=tensor(nan),
            max=tensor(nan))

            >>> t = torch.arange(10).view(2, 5)
            >>> t
            tensor([[0, 1, 2, 3, 4],
                    [5, 6, 7, 8, 9]])
            >>> t.aminmax(dim=0, keepdim=True)
            torch.return_types.aminmax(
            min=tensor([[0, 1, 2, 3, 4]]),
            max=tensor([[5, 6, 7, 8, 9]]))
        """
    @overload
    @staticmethod
    def aminmax(
min=..., 
max=...) -> Any:
        """
        aminmax(input, *, dim=None, keepdim=False, out=None) -> (Tensor min, Tensor max)

        Computes the minimum and maximum values of the :attr:`input` tensor.

        Args:
            input (Tensor):
                The input tensor

        Keyword Args:
            dim (Optional[int]):
                The dimension along which to compute the values. If `None`,
                computes the values over the entire :attr:`input` tensor.
                Default is `None`.
            keepdim (bool):
                If `True`, the reduced dimensions will be kept in the output
                tensor as dimensions with size 1 for broadcasting, otherwise
                they will be removed, as if calling (:func:`torch.squeeze`).
                Default is `False`.
            out (Optional[Tuple[Tensor, Tensor]]):
                Optional tensors on which to write the result. Must have the same
                shape and dtype as the expected output.
                Default is `None`.

        Returns:
            A named tuple `(min, max)` containing the minimum and maximum values.

        Raises:
            RuntimeError
                If any of the dimensions to compute the values over has size 0.

        .. note::
            NaN values are propagated to the output if at least one value is NaN.

        .. seealso::
            :func:`torch.amin` computes just the minimum value
            :func:`torch.amax` computes just the maximum value

        Example::

            >>> torch.aminmax(torch.tensor([1, -3, 5]))
            torch.return_types.aminmax(
            min=tensor(-3),
            max=tensor(5))

            >>> # aminmax propagates NaNs
            >>> torch.aminmax(torch.tensor([1, -3, 5, torch.nan]))
            torch.return_types.aminmax(
            min=tensor(nan),
            max=tensor(nan))

            >>> t = torch.arange(10).view(2, 5)
            >>> t
            tensor([[0, 1, 2, 3, 4],
                    [5, 6, 7, 8, 9]])
            >>> t.aminmax(dim=0, keepdim=True)
            torch.return_types.aminmax(
            min=tensor([[0, 1, 2, 3, 4]]),
            max=tensor([[5, 6, 7, 8, 9]]))
        """
    @overload
    @staticmethod
    def aminmax(dim=..., keepdim=...) -> Any:
        """
        aminmax(input, *, dim=None, keepdim=False, out=None) -> (Tensor min, Tensor max)

        Computes the minimum and maximum values of the :attr:`input` tensor.

        Args:
            input (Tensor):
                The input tensor

        Keyword Args:
            dim (Optional[int]):
                The dimension along which to compute the values. If `None`,
                computes the values over the entire :attr:`input` tensor.
                Default is `None`.
            keepdim (bool):
                If `True`, the reduced dimensions will be kept in the output
                tensor as dimensions with size 1 for broadcasting, otherwise
                they will be removed, as if calling (:func:`torch.squeeze`).
                Default is `False`.
            out (Optional[Tuple[Tensor, Tensor]]):
                Optional tensors on which to write the result. Must have the same
                shape and dtype as the expected output.
                Default is `None`.

        Returns:
            A named tuple `(min, max)` containing the minimum and maximum values.

        Raises:
            RuntimeError
                If any of the dimensions to compute the values over has size 0.

        .. note::
            NaN values are propagated to the output if at least one value is NaN.

        .. seealso::
            :func:`torch.amin` computes just the minimum value
            :func:`torch.amax` computes just the maximum value

        Example::

            >>> torch.aminmax(torch.tensor([1, -3, 5]))
            torch.return_types.aminmax(
            min=tensor(-3),
            max=tensor(5))

            >>> # aminmax propagates NaNs
            >>> torch.aminmax(torch.tensor([1, -3, 5, torch.nan]))
            torch.return_types.aminmax(
            min=tensor(nan),
            max=tensor(nan))

            >>> t = torch.arange(10).view(2, 5)
            >>> t
            tensor([[0, 1, 2, 3, 4],
                    [5, 6, 7, 8, 9]])
            >>> t.aminmax(dim=0, keepdim=True)
            torch.return_types.aminmax(
            min=tensor([[0, 1, 2, 3, 4]]),
            max=tensor([[5, 6, 7, 8, 9]]))
        """
    @overload
    @staticmethod
    def aminmax(
min=..., 
max=...) -> Any:
        """
        aminmax(input, *, dim=None, keepdim=False, out=None) -> (Tensor min, Tensor max)

        Computes the minimum and maximum values of the :attr:`input` tensor.

        Args:
            input (Tensor):
                The input tensor

        Keyword Args:
            dim (Optional[int]):
                The dimension along which to compute the values. If `None`,
                computes the values over the entire :attr:`input` tensor.
                Default is `None`.
            keepdim (bool):
                If `True`, the reduced dimensions will be kept in the output
                tensor as dimensions with size 1 for broadcasting, otherwise
                they will be removed, as if calling (:func:`torch.squeeze`).
                Default is `False`.
            out (Optional[Tuple[Tensor, Tensor]]):
                Optional tensors on which to write the result. Must have the same
                shape and dtype as the expected output.
                Default is `None`.

        Returns:
            A named tuple `(min, max)` containing the minimum and maximum values.

        Raises:
            RuntimeError
                If any of the dimensions to compute the values over has size 0.

        .. note::
            NaN values are propagated to the output if at least one value is NaN.

        .. seealso::
            :func:`torch.amin` computes just the minimum value
            :func:`torch.amax` computes just the maximum value

        Example::

            >>> torch.aminmax(torch.tensor([1, -3, 5]))
            torch.return_types.aminmax(
            min=tensor(-3),
            max=tensor(5))

            >>> # aminmax propagates NaNs
            >>> torch.aminmax(torch.tensor([1, -3, 5, torch.nan]))
            torch.return_types.aminmax(
            min=tensor(nan),
            max=tensor(nan))

            >>> t = torch.arange(10).view(2, 5)
            >>> t
            tensor([[0, 1, 2, 3, 4],
                    [5, 6, 7, 8, 9]])
            >>> t.aminmax(dim=0, keepdim=True)
            torch.return_types.aminmax(
            min=tensor([[0, 1, 2, 3, 4]]),
            max=tensor([[5, 6, 7, 8, 9]]))
        """
    @overload
    @staticmethod
    def angle(input: Tensor, out: Tensor | None) -> Tensor:
        """
        angle(input: Tensor, *, out: Optional[Tensor]) -> Tensor

        Computes the element-wise angle (in radians) of the given :attr:`input` tensor.

        .. math::
            \\text{out}_{i} = angle(\\text{input}_{i})

        Args:
            input (Tensor): the input tensor.

        Keyword args:
            out (Tensor, optional): the output tensor.

        .. note:: Starting in PyTorch 1.8, angle returns pi for negative real numbers,
                  zero for non-negative real numbers, and propagates NaNs. Previously
                  the function would return zero for all real numbers and not propagate
                  floating-point NaNs.

        Example::

            >>> torch.angle(torch.tensor([-1 + 1j, -2 + 2j, 3 - 3j]))*180/3.14159
            tensor([ 135.,  135,  -45])
        """
    @overload
    @staticmethod
    def angle(inradians) -> Any:
        """
        angle(input: Tensor, *, out: Optional[Tensor]) -> Tensor

        Computes the element-wise angle (in radians) of the given :attr:`input` tensor.

        .. math::
            \\text{out}_{i} = angle(\\text{input}_{i})

        Args:
            input (Tensor): the input tensor.

        Keyword args:
            out (Tensor, optional): the output tensor.

        .. note:: Starting in PyTorch 1.8, angle returns pi for negative real numbers,
                  zero for non-negative real numbers, and propagates NaNs. Previously
                  the function would return zero for all real numbers and not propagate
                  floating-point NaNs.

        Example::

            >>> torch.angle(torch.tensor([-1 + 1j, -2 + 2j, 3 - 3j]))*180/3.14159
            tensor([ 135.,  135,  -45])
        """
    @overload
    @staticmethod
    def any(input: Tensor, out: Tensor | None) -> Tensor:
        """
        any(input: Tensor, *, out: Optional[Tensor]) -> Tensor

        Tests if any element in :attr:`input` evaluates to `True`.

        .. note:: This function matches the behaviour of NumPy in returning
                  output of dtype `bool` for all supported dtypes except `uint8`.
                  For `uint8` the dtype of output is `uint8` itself.

        Args:
            input (Tensor): the input tensor.

        Keyword args:
            out (Tensor, optional): the output tensor.

        Example::

            >>> a = torch.rand(1, 2).bool()
            >>> a
            tensor([[False, True]], dtype=torch.bool)
            >>> torch.any(a)
            tensor(True, dtype=torch.bool)
            >>> a = torch.arange(0, 3)
            >>> a
            tensor([0, 1, 2])
            >>> torch.any(a)
            tensor(True)

        .. function:: any(input, dim, keepdim=False, *, out=None) -> Tensor
           :noindex:

        For each row of :attr:`input` in the given dimension :attr:`dim`,
        returns `True` if any element in the row evaluate to `True` and `False` otherwise.


        If :attr:`keepdim` is ``True``, the output tensor is of the same size
        as :attr:`input` except in the dimension(s) :attr:`dim` where it is of size 1.
        Otherwise, :attr:`dim` is squeezed (see :func:`torch.squeeze`), resulting in the
        output tensor having 1 (or ``len(dim)``) fewer dimension(s).


        Args:
            input (Tensor): the input tensor.
    
            dim (int or tuple of ints, optional): the dimension or dimensions to reduce.
                If ``None``, all dimensions are reduced.

    
            keepdim (bool, optional): whether the output tensor has :attr:`dim` retained or not. Default: ``False``.


        Keyword args:
            out (Tensor, optional): the output tensor.

        Example::

            >>> a = torch.randn(4, 2) < 0
            >>> a
            tensor([[ True,  True],
                    [False,  True],
                    [ True,  True],
                    [False, False]])
            >>> torch.any(a, 1)
            tensor([ True,  True,  True, False])
            >>> torch.any(a, 0)
            tensor([True, True])
        """
    @overload
    @staticmethod
    def any(a) -> Any:
        """
        any(input: Tensor, *, out: Optional[Tensor]) -> Tensor

        Tests if any element in :attr:`input` evaluates to `True`.

        .. note:: This function matches the behaviour of NumPy in returning
                  output of dtype `bool` for all supported dtypes except `uint8`.
                  For `uint8` the dtype of output is `uint8` itself.

        Args:
            input (Tensor): the input tensor.

        Keyword args:
            out (Tensor, optional): the output tensor.

        Example::

            >>> a = torch.rand(1, 2).bool()
            >>> a
            tensor([[False, True]], dtype=torch.bool)
            >>> torch.any(a)
            tensor(True, dtype=torch.bool)
            >>> a = torch.arange(0, 3)
            >>> a
            tensor([0, 1, 2])
            >>> torch.any(a)
            tensor(True)

        .. function:: any(input, dim, keepdim=False, *, out=None) -> Tensor
           :noindex:

        For each row of :attr:`input` in the given dimension :attr:`dim`,
        returns `True` if any element in the row evaluate to `True` and `False` otherwise.


        If :attr:`keepdim` is ``True``, the output tensor is of the same size
        as :attr:`input` except in the dimension(s) :attr:`dim` where it is of size 1.
        Otherwise, :attr:`dim` is squeezed (see :func:`torch.squeeze`), resulting in the
        output tensor having 1 (or ``len(dim)``) fewer dimension(s).


        Args:
            input (Tensor): the input tensor.
    
            dim (int or tuple of ints, optional): the dimension or dimensions to reduce.
                If ``None``, all dimensions are reduced.

    
            keepdim (bool, optional): whether the output tensor has :attr:`dim` retained or not. Default: ``False``.


        Keyword args:
            out (Tensor, optional): the output tensor.

        Example::

            >>> a = torch.randn(4, 2) < 0
            >>> a
            tensor([[ True,  True],
                    [False,  True],
                    [ True,  True],
                    [False, False]])
            >>> torch.any(a, 1)
            tensor([ True,  True,  True, False])
            >>> torch.any(a, 0)
            tensor([True, True])
        """
    @overload
    @staticmethod
    def any(a) -> Any:
        """
        any(input: Tensor, *, out: Optional[Tensor]) -> Tensor

        Tests if any element in :attr:`input` evaluates to `True`.

        .. note:: This function matches the behaviour of NumPy in returning
                  output of dtype `bool` for all supported dtypes except `uint8`.
                  For `uint8` the dtype of output is `uint8` itself.

        Args:
            input (Tensor): the input tensor.

        Keyword args:
            out (Tensor, optional): the output tensor.

        Example::

            >>> a = torch.rand(1, 2).bool()
            >>> a
            tensor([[False, True]], dtype=torch.bool)
            >>> torch.any(a)
            tensor(True, dtype=torch.bool)
            >>> a = torch.arange(0, 3)
            >>> a
            tensor([0, 1, 2])
            >>> torch.any(a)
            tensor(True)

        .. function:: any(input, dim, keepdim=False, *, out=None) -> Tensor
           :noindex:

        For each row of :attr:`input` in the given dimension :attr:`dim`,
        returns `True` if any element in the row evaluate to `True` and `False` otherwise.


        If :attr:`keepdim` is ``True``, the output tensor is of the same size
        as :attr:`input` except in the dimension(s) :attr:`dim` where it is of size 1.
        Otherwise, :attr:`dim` is squeezed (see :func:`torch.squeeze`), resulting in the
        output tensor having 1 (or ``len(dim)``) fewer dimension(s).


        Args:
            input (Tensor): the input tensor.
    
            dim (int or tuple of ints, optional): the dimension or dimensions to reduce.
                If ``None``, all dimensions are reduced.

    
            keepdim (bool, optional): whether the output tensor has :attr:`dim` retained or not. Default: ``False``.


        Keyword args:
            out (Tensor, optional): the output tensor.

        Example::

            >>> a = torch.randn(4, 2) < 0
            >>> a
            tensor([[ True,  True],
                    [False,  True],
                    [ True,  True],
                    [False, False]])
            >>> torch.any(a, 1)
            tensor([ True,  True,  True, False])
            >>> torch.any(a, 0)
            tensor([True, True])
        """
    @staticmethod
    def arange(start=..., end, step=..., out=..., dtype=..., layout=..., device=..., requires_grad=...) -> Tensor:
        """
        arange(start=0, end, step=1, *, out=None, dtype=None, layout=torch.strided, device=None, requires_grad=False) -> Tensor

        Returns a 1-D tensor of size :math:`\\left\\lceil \\frac{\\text{end} - \\text{start}}{\\text{step}} \\right\\rceil`
        with values from the interval ``[start, end)`` taken with common difference
        :attr:`step` beginning from `start`.

        Note: When using floating-point dtypes (especially reduced precision types like ``bfloat16``),
        the results may be affected by floating-point rounding behavior. Some values in the sequence
        might not be exactly representable in certain floating-point formats, which can lead to
        repeated values or unexpected rounding. For precise sequences, it is recommended to use
        integer dtypes instead of floating-point dtypes.

        Note that non-integer :attr:`step` is subject to floating point rounding errors when
        comparing against :attr:`end`; to avoid inconsistency, we advise subtracting a small epsilon from :attr:`end`
        in such cases.

        .. math::
            \\text{out}_{{i+1}} = \\text{out}_{i} + \\text{step}

        Args:
            start (Number, optional): the starting value for the set of points. Default: ``0``.
            end (Number): the ending value for the set of points
            step (Number, optional): the gap between each pair of adjacent points. Default: ``1``.

        Keyword args:
            out (Tensor, optional): the output tensor.
            dtype (:class:`torch.dtype`, optional): the desired data type of returned tensor.
                Default: if ``None``, uses a global default (see :func:`torch.set_default_dtype`). If `dtype` is not given, infer the data type from the other input
                arguments. If any of `start`, `end`, or `stop` are floating-point, the
                `dtype` is inferred to be the default dtype, see
                :meth:`~torch.get_default_dtype`. Otherwise, the `dtype` is inferred to
                be `torch.int64`.
            layout (:class:`torch.layout`, optional): the desired layout of returned Tensor.
                Default: ``torch.strided``.
            device (:class:`torch.device`, optional): the desired device of returned tensor.
                Default: if ``None``, uses the current device for the default tensor type
                (see :func:`torch.set_default_device`). :attr:`device` will be the CPU
                for CPU tensor types and the current CUDA device for CUDA tensor types.
            requires_grad (bool, optional): If autograd should record operations on the
                returned tensor. Default: ``False``.

        Example::

            >>> torch.arange(5)
            tensor([ 0,  1,  2,  3,  4])
            >>> torch.arange(1, 4)
            tensor([ 1,  2,  3])
            >>> torch.arange(1, 2.5, 0.5)
            tensor([ 1.0000,  1.5000,  2.0000])
        """
    @staticmethod
    def arccos(input: Tensor, out: Tensor | None) -> Tensor:
        """
        arccos(input: Tensor, *, out: Optional[Tensor]) -> Tensor

        Alias for :func:`torch.acos`.
        """
    @staticmethod
    def arccos_(*args, **kwargs): ...
    @staticmethod
    def arccosh(input: Tensor, out: Tensor | None) -> Tensor:
        """
        arccosh(input: Tensor, *, out: Optional[Tensor]) -> Tensor

        Alias for :func:`torch.acosh`.
        """
    @staticmethod
    def arccosh_(*args, **kwargs): ...
    @staticmethod
    def arcsin(input: Tensor, out: Tensor | None) -> Tensor:
        """
        arcsin(input: Tensor, *, out: Optional[Tensor]) -> Tensor

        Alias for :func:`torch.asin`.
        """
    @staticmethod
    def arcsin_(*args, **kwargs): ...
    @staticmethod
    def arcsinh(input: Tensor, out: Tensor | None) -> Tensor:
        """
        arcsinh(input: Tensor, *, out: Optional[Tensor]) -> Tensor

        Alias for :func:`torch.asinh`.
        """
    @staticmethod
    def arcsinh_(*args, **kwargs): ...
    @staticmethod
    def arctan(input: Tensor, out: Tensor | None) -> Tensor:
        """
        arctan(input: Tensor, *, out: Optional[Tensor]) -> Tensor

        Alias for :func:`torch.atan`.
        """
    @staticmethod
    def arctan2(input: Tensor, other: Tensor, out: Tensor | None) -> Tensor:
        """
        arctan2(input: Tensor, other: Tensor, *, out: Optional[Tensor]) -> Tensor
        Alias for :func:`torch.atan2`.
        """
    @staticmethod
    def arctan_(*args, **kwargs): ...
    @staticmethod
    def arctanh(input: Tensor, out: Tensor | None) -> Tensor:
        """
        arctanh(input: Tensor, *, out: Optional[Tensor]) -> Tensor

        Alias for :func:`torch.atanh`.
        """
    @staticmethod
    def arctanh_(*args, **kwargs): ...
    @staticmethod
    def argmax(*args, **kwargs):
        """
        argmax(input) -> LongTensor

        Returns the indices of the maximum value of all elements in the :attr:`input` tensor.

        This is the second value returned by :meth:`torch.max`. See its
        documentation for the exact semantics of this method.

        .. note:: If there are multiple maximal values then the indices of the first maximal value are returned.

        Args:
            input (Tensor): the input tensor.

        Example::

            >>> a = torch.randn(4, 4)
            >>> a
            tensor([[ 1.3398,  0.2663, -0.2686,  0.2450],
                    [-0.7401, -0.8805, -0.3402, -1.1936],
                    [ 0.4907, -1.3948, -1.0691, -0.3132],
                    [-1.6092,  0.5419, -0.2993,  0.3195]])
            >>> torch.argmax(a)
            tensor(0)

        .. function:: argmax(input, dim, keepdim=False) -> LongTensor
           :noindex:

        Returns the indices of the maximum values of a tensor across a dimension.

        This is the second value returned by :meth:`torch.max`. See its
        documentation for the exact semantics of this method.

        Args:
            input (Tensor): the input tensor.
    
            dim (int, optional): the dimension to reduce.
         If ``None``, the argmax of the flattened input is returned.
    
            keepdim (bool, optional): whether the output tensor has :attr:`dim` retained or not. Default: ``False``.


        Example::

            >>> a = torch.randn(4, 4)
            >>> a
            tensor([[ 1.3398,  0.2663, -0.2686,  0.2450],
                    [-0.7401, -0.8805, -0.3402, -1.1936],
                    [ 0.4907, -1.3948, -1.0691, -0.3132],
                    [-1.6092,  0.5419, -0.2993,  0.3195]])
            >>> torch.argmax(a, dim=1)
            tensor([ 0,  2,  0,  1])
        """
    @staticmethod
    def argmin(*args, **kwargs):
        """
        argmin(input, dim=None, keepdim=False) -> LongTensor

        Returns the indices of the minimum value(s) of the flattened tensor or along a dimension

        This is the second value returned by :meth:`torch.min`. See its
        documentation for the exact semantics of this method.

        .. note:: If there are multiple minimal values then the indices of the first minimal value are returned.

        Args:
            input (Tensor): the input tensor.
    
            dim (int, optional): the dimension to reduce.
         If ``None``, the argmin of the flattened input is returned.
    
            keepdim (bool, optional): whether the output tensor has :attr:`dim` retained or not. Default: ``False``.


        Example::

            >>> a = torch.randn(4, 4)
            >>> a
            tensor([[ 0.1139,  0.2254, -0.1381,  0.3687],
                    [ 1.0100, -1.1975, -0.0102, -0.4732],
                    [-0.9240,  0.1207, -0.7506, -1.0213],
                    [ 1.7809, -1.2960,  0.9384,  0.1438]])
            >>> torch.argmin(a)
            tensor(13)
            >>> torch.argmin(a, dim=1)
            tensor([ 2,  1,  3,  1])
            >>> torch.argmin(a, dim=1, keepdim=True)
            tensor([[2],
                    [1],
                    [3],
                    [1]])
        """
    @overload
    @staticmethod
    def argsort(input, dim=..., descending=..., stable=...) -> Tensor:
        """
        argsort(input, dim=-1, descending=False, stable=False) -> Tensor

        Returns the indices that sort a tensor along a given dimension in ascending
        order by value.

        This is the second value returned by :meth:`torch.sort`.  See its documentation
        for the exact semantics of this method.

        If :attr:`stable` is ``True`` then the sorting routine becomes stable, preserving
        the order of equivalent elements. If ``False``, the relative order of values
        which compare equal is not guaranteed. ``True`` is slower.

        Args:
            input (Tensor): the input tensor.
            dim (int, optional): the dimension to sort along
            descending (bool, optional): controls the sorting order (ascending or descending)
            stable (bool, optional): controls the relative order of equivalent elements

        Example::

            >>> a = torch.randn(4, 4)
            >>> a
            tensor([[ 0.0785,  1.5267, -0.8521,  0.4065],
                    [ 0.1598,  0.0788, -0.0745, -1.2700],
                    [ 1.2208,  1.0722, -0.7064,  1.2564],
                    [ 0.0669, -0.2318, -0.8229, -0.9280]])


            >>> torch.argsort(a, dim=1)
            tensor([[2, 0, 3, 1],
                    [3, 2, 1, 0],
                    [2, 1, 0, 3],
                    [3, 2, 1, 0]])
        """
    @overload
    @staticmethod
    def argsort(a, dim=...) -> Any:
        """
        argsort(input, dim=-1, descending=False, stable=False) -> Tensor

        Returns the indices that sort a tensor along a given dimension in ascending
        order by value.

        This is the second value returned by :meth:`torch.sort`.  See its documentation
        for the exact semantics of this method.

        If :attr:`stable` is ``True`` then the sorting routine becomes stable, preserving
        the order of equivalent elements. If ``False``, the relative order of values
        which compare equal is not guaranteed. ``True`` is slower.

        Args:
            input (Tensor): the input tensor.
            dim (int, optional): the dimension to sort along
            descending (bool, optional): controls the sorting order (ascending or descending)
            stable (bool, optional): controls the relative order of equivalent elements

        Example::

            >>> a = torch.randn(4, 4)
            >>> a
            tensor([[ 0.0785,  1.5267, -0.8521,  0.4065],
                    [ 0.1598,  0.0788, -0.0745, -1.2700],
                    [ 1.2208,  1.0722, -0.7064,  1.2564],
                    [ 0.0669, -0.2318, -0.8229, -0.9280]])


            >>> torch.argsort(a, dim=1)
            tensor([[2, 0, 3, 1],
                    [3, 2, 1, 0],
                    [2, 1, 0, 3],
                    [3, 2, 1, 0]])
        """
    @staticmethod
    def argwhere(input) -> Tensor:
        """
        argwhere(input) -> Tensor

        Returns a tensor containing the indices of all non-zero elements of
        :attr:`input`.  Each row in the result contains the indices of a non-zero
        element in :attr:`input`. The result is sorted lexicographically, with
        the last index changing the fastest (C-style).

        If :attr:`input` has :math:`n` dimensions, then the resulting indices tensor
        :attr:`out` is of size :math:`(z \\times n)`, where :math:`z` is the total number of
        non-zero elements in the :attr:`input` tensor.

        .. note::
            This function is similar to NumPy's `argwhere`.

            When :attr:`input` is on CUDA, this function causes host-device synchronization.

        Args:
            {input}

        Example::

            >>> t = torch.tensor([1, 0, 1])
            >>> torch.argwhere(t)
            tensor([[0],
                    [2]])
            >>> t = torch.tensor([[1, 0, 1], [0, 1, 1]])
            >>> torch.argwhere(t)
            tensor([[0, 0],
                    [0, 2],
                    [1, 1],
                    [1, 2]])
        """
    @staticmethod
    def as_strided(input, size, stride, storage_offset=...) -> Tensor:
        '''
        as_strided(input, size, stride, storage_offset=None) -> Tensor

        Create a view of an existing `torch.Tensor` :attr:`input` with specified
        :attr:`size`, :attr:`stride` and :attr:`storage_offset`.

        .. warning::
            Prefer using other view functions, like :meth:`torch.Tensor.view` or
            :meth:`torch.Tensor.expand`, to setting a view\'s strides manually with
            `as_strided`, as this function will throw an error on non-standard Pytorch
            backends (that do not have a concept of stride) and the result will depend
            on the current layout in memory. The constructed view must only refer to
            elements within the Tensor\'s storage or a runtime error will be thrown.
            If the generated view is "overlapped" (with multiple indices referring to
            the same element in memory), the behavior of inplace operations on this view
            is undefined (and might not throw runtime errors).

        Args:
            input (Tensor): the input tensor.
            size (tuple or ints): the shape of the output tensor
            stride (tuple or ints): the stride of the output tensor
            storage_offset (int, optional): the offset in the underlying storage of the output tensor.
                If ``None``, the storage_offset of the output tensor will match the input tensor.

        Example::

            >>> x = torch.randn(3, 3)
            >>> x
            tensor([[ 0.9039,  0.6291,  1.0795],
                    [ 0.1586,  2.1939, -0.4900],
                    [-0.1909, -0.7503,  1.9355]])
            >>> t = torch.as_strided(x, (2, 2), (1, 2))
            >>> t
            tensor([[0.9039, 1.0795],
                    [0.6291, 0.1586]])
            >>> t = torch.as_strided(x, (2, 2), (1, 2), 1)
            tensor([[0.6291, 0.1586],
                    [1.0795, 2.1939]])
        '''
    @staticmethod
    def as_strided_(*args, **kwargs): ...
    @staticmethod
    def as_strided_copy(*args, **kwargs):
        """
        Performs the same operation as :func:`torch.as_strided`, but all output tensors
        are freshly created instead of aliasing the input.
        """
    @staticmethod
    def as_strided_scatter(input, src, size, stride, storage_offset=...) -> Tensor:
        """
        as_strided_scatter(input, src, size, stride, storage_offset=None) -> Tensor

        Embeds the values of the :attr:`src` tensor into :attr:`input` along
        the elements corresponding to the result of calling
        input.as_strided(size, stride, storage_offset).

        This function returns a tensor with fresh storage; it does not
        return a view.

        Args:
            input (Tensor): the input tensor.
            size (tuple or ints): the shape of the output tensor
            stride (tuple or ints): the stride of the output tensor
            storage_offset (int, optional): the offset in the underlying storage of the output tensor

        .. note::

            :attr:`src` must be of the proper size in order to be embedded
            into :attr:`input`. Specifically, it should have the same shape as
            `torch.as_strided(input, size, stride, storage_offset)`

        Example::

            >>> a = torch.arange(4).reshape(2, 2) + 1
            >>> a
            tensor([[1, 2],
                    [3, 4]])
            >>> b = torch.zeros(3, 3)
            >>> b
            tensor([[0., 0., 0.],
                    [0., 0., 0.],
                    [0., 0., 0.]])
            >>> torch.as_strided_scatter(b, a, (2, 2), (1, 2))
            tensor([[1., 3., 2.],
                    [4., 0., 0.],
                    [0., 0., 0.]])

        """
    @staticmethod
    def as_tensor(data: Any, dtype: dtype | None = ..., device: DeviceLikeType | None) -> Tensor:
        '''
        as_tensor(data: Any, dtype: Optional[dtype] = None, device: Optional[DeviceLikeType]) -> Tensor

        Converts :attr:`data` into a tensor, sharing data and preserving autograd
        history if possible.

        If :attr:`data` is already a tensor with the requested dtype and device
        then :attr:`data` itself is returned, but if :attr:`data` is a
        tensor with a different dtype or device then it\'s copied as if using
        `data.to(dtype=dtype, device=device)`.

        If :attr:`data` is a NumPy array (an ndarray) with the same dtype and device then a
        tensor is constructed using :func:`torch.from_numpy`.

        If :attr:`data` is a CuPy array, the returned tensor will be located on the same device as the CuPy array unless
        specifically overwritten by :attr:`device` or a default device.

        .. seealso::

            :func:`torch.tensor` never shares its data and creates a new "leaf tensor" (see :doc:`/notes/autograd`).


        Args:
            data (array_like): Initial data for the tensor. Can be a list, tuple,
                NumPy ``ndarray``, scalar, and other types.
            dtype (:class:`torch.dtype`, optional): the desired data type of returned tensor.
                Default: if ``None``, infers data type from :attr:`data`.
            device (:class:`torch.device`, optional): the device of the constructed tensor. If None and data is a tensor
                then the device of data is used. If None and data is not a tensor then
                the result tensor is constructed on the current device.


        Example::

            >>> a = numpy.array([1, 2, 3])
            >>> t = torch.as_tensor(a)
            >>> t
            tensor([ 1,  2,  3])
            >>> t[0] = -1
            >>> a
            array([-1,  2,  3])

            >>> a = numpy.array([1, 2, 3])
            >>> t = torch.as_tensor(a, device=torch.device(\'cuda\'))
            >>> t
            tensor([ 1,  2,  3])
            >>> t[0] = -1
            >>> a
            array([1,  2,  3])
        '''
    @staticmethod
    def asarray(*args, **kwargs):
        """
        asarray(obj: Any, *, dtype: Optional[dtype], device: Optional[DeviceLikeType], copy: Optional[bool] = None, requires_grad: bool = False) -> Tensor # noqa: B950

        Converts :attr:`obj` to a tensor.

        :attr:`obj` can be one of:

        1. a tensor
        2. a NumPy array or a NumPy scalar
        3. a DLPack capsule
        4. an object that implements Python's buffer protocol
        5. a scalar
        6. a sequence of scalars

        When :attr:`obj` is a tensor, NumPy array, or DLPack capsule the returned tensor will,
        by default, not require a gradient, have the same datatype as :attr:`obj`, be on the
        same device, and share memory with it. These properties can be controlled with the
        :attr:`dtype`, :attr:`device`, :attr:`copy`, and :attr:`requires_grad` keyword arguments.
        If the returned tensor is of a different datatype, on a different device, or a copy is
        requested then it will not share its memory with :attr:`obj`. If :attr:`requires_grad`
        is ``True`` then the returned tensor will require a gradient, and if :attr:`obj` is
        also a tensor with an autograd history then the returned tensor will have the same history.

        When :attr:`obj` is not a tensor, NumPy array, or DLPack capsule but implements Python's
        buffer protocol then the buffer is interpreted as an array of bytes grouped according to
        the size of the datatype passed to the :attr:`dtype` keyword argument. (If no datatype is
        passed then the default floating point datatype is used, instead.) The returned tensor
        will have the specified datatype (or default floating point datatype if none is specified)
        and, by default, be on the CPU device and share memory with the buffer.

        When :attr:`obj` is a NumPy scalar, the returned tensor will be a 0-dimensional tensor on
        the CPU and that doesn't share its memory (i.e. ``copy=True``). By default datatype will
        be the PyTorch datatype corresponding to the NumPy's scalar's datatype.

        When :attr:`obj` is none of the above but a scalar, or a sequence of scalars then the
        returned tensor will, by default, infer its datatype from the scalar values, be on the
        current default device, and not share its memory.

        .. seealso::

            :func:`torch.tensor` creates a tensor that always copies the data from the input object.
            :func:`torch.from_numpy` creates a tensor that always shares memory from NumPy arrays.
            :func:`torch.frombuffer` creates a tensor that always shares memory from objects that
            implement the buffer protocol.
            :func:`torch.from_dlpack` creates a tensor that always shares memory from
            DLPack capsules.

        Args:
            obj (object): a tensor, NumPy array, DLPack Capsule, object that implements Python's
                   buffer protocol, scalar, or sequence of scalars.

        Keyword args:
            dtype (:class:`torch.dtype`, optional): the datatype of the returned tensor.
                   Default: ``None``, which causes the datatype of the returned tensor to be
                   inferred from :attr:`obj`.
            copy (bool, optional): controls whether the returned tensor shares memory with :attr:`obj`.
                   Default: ``None``, which causes the returned tensor to share memory with :attr:`obj`
                   whenever possible. If ``True`` then the returned tensor does not share its memory.
                   If ``False`` then the returned tensor shares its memory with :attr:`obj` and an
                   error is thrown if it cannot.
            device (:class:`torch.device`, optional): the device of the returned tensor.
                   Default: ``None``, which causes the device of :attr:`obj` to be used. Or, if
                   :attr:`obj` is a Python sequence, the current default device will be used.
            requires_grad (bool, optional): whether the returned tensor requires grad.
                   Default: ``False``, which causes the returned tensor not to require a gradient.
                   If ``True``, then the returned tensor will require a gradient, and if :attr:`obj`
                   is also a tensor with an autograd history then the returned tensor will have
                   the same history.

        Example::

            >>> a = torch.tensor([1, 2, 3])
            >>> # Shares memory with tensor 'a'
            >>> b = torch.asarray(a)
            >>> a.data_ptr() == b.data_ptr()
            True
            >>> # Forces memory copy
            >>> c = torch.asarray(a, copy=True)
            >>> a.data_ptr() == c.data_ptr()
            False

            >>> a = torch.tensor([1., 2., 3.], requires_grad=True)
            >>> b = a + 2
            >>> b
            tensor([3., 4., 5.], grad_fn=<AddBackward0>)
            >>> # Shares memory with tensor 'b', with no grad
            >>> c = torch.asarray(b)
            >>> c
            tensor([3., 4., 5.])
            >>> # Shares memory with tensor 'b', retaining autograd history
            >>> d = torch.asarray(b, requires_grad=True)
            >>> d
            tensor([3., 4., 5.], grad_fn=<AddBackward0>)

            >>> array = numpy.array([1, 2, 3])
            >>> # Shares memory with array 'array'
            >>> t1 = torch.asarray(array)
            >>> array.__array_interface__['data'][0] == t1.data_ptr()
            True
            >>> # Copies memory due to dtype mismatch
            >>> t2 = torch.asarray(array, dtype=torch.float32)
            >>> array.__array_interface__['data'][0] == t2.data_ptr()
            False

            >>> scalar = numpy.float64(0.5)
            >>> torch.asarray(scalar)
            tensor(0.5000, dtype=torch.float64)
        """
    @staticmethod
    def asin(input: Tensor, out: Tensor | None) -> Tensor:
        """
        asin(input: Tensor, *, out: Optional[Tensor]) -> Tensor

        Returns a new tensor with the arcsine of the elements of :attr:`input`.

        .. math::
            \\text{out}_{i} = \\sin^{-1}(\\text{input}_{i})

        Args:
            input (Tensor): the input tensor.

        Keyword args:
            out (Tensor, optional): the output tensor.

        Example::

            >>> a = torch.randn(4)
            >>> a
            tensor([-0.5962,  1.4985, -0.4396,  1.4525])
            >>> torch.asin(a)
            tensor([-0.6387,     nan, -0.4552,     nan])
        """
    @staticmethod
    def asin_(*args, **kwargs): ...
    @staticmethod
    def asinh(input: Tensor, out: Tensor | None) -> Tensor:
        """
        asinh(input: Tensor, *, out: Optional[Tensor]) -> Tensor

        Returns a new tensor with the inverse hyperbolic sine of the elements of :attr:`input`.

        .. math::
            \\text{out}_{i} = \\sinh^{-1}(\\text{input}_{i})

        Args:
            input (Tensor): the input tensor.

        Keyword arguments:
            out (Tensor, optional): the output tensor.

        Example::

            >>> a = torch.randn(4)
            >>> a
            tensor([ 0.1606, -1.4267, -1.0899, -1.0250 ])
            >>> torch.asinh(a)
            tensor([ 0.1599, -1.1534, -0.9435, -0.8990 ])
        """
    @staticmethod
    def asinh_(*args, **kwargs): ...
    @staticmethod
    def atan(input: Tensor, out: Tensor | None) -> Tensor:
        """
        atan(input: Tensor, *, out: Optional[Tensor]) -> Tensor

        Returns a new tensor with the arctangent of the elements of :attr:`input`.

        .. math::
            \\text{out}_{i} = \\tan^{-1}(\\text{input}_{i})

        Args:
            input (Tensor): the input tensor.

        Keyword args:
            out (Tensor, optional): the output tensor.

        Example::

            >>> a = torch.randn(4)
            >>> a
            tensor([ 0.2341,  0.2539, -0.6256, -0.6448])
            >>> torch.atan(a)
            tensor([ 0.2299,  0.2487, -0.5591, -0.5727])
        """
    @staticmethod
    def atan2(input: Tensor, other: Tensor, out: Tensor | None) -> Tensor:
        """
        atan2(input: Tensor, other: Tensor, *, out: Optional[Tensor]) -> Tensor

        Element-wise arctangent of :math:`\\text{input}_{i} / \\text{other}_{i}`
        with consideration of the quadrant. Returns a new tensor with the signed angles
        in radians between vector :math:`(\\text{other}_{i}, \\text{input}_{i})`
        and vector :math:`(1, 0)`. (Note that :math:`\\text{other}_{i}`, the second
        parameter, is the x-coordinate, while :math:`\\text{input}_{i}`, the first
        parameter, is the y-coordinate.)

        The shapes of ``input`` and ``other`` must be
        :ref:`broadcastable <broadcasting-semantics>`.

        Args:
            input (Tensor): the first input tensor
            other (Tensor): the second input tensor

        Keyword args:
            out (Tensor, optional): the output tensor.

        Example::

            >>> a = torch.randn(4)
            >>> a
            tensor([ 0.9041,  0.0196, -0.3108, -2.4423])
            >>> torch.atan2(a, torch.randn(4))
            tensor([ 0.9833,  0.0811, -1.9743, -1.4151])
        """
    @staticmethod
    def atan_(*args, **kwargs): ...
    @staticmethod
    def atanh(input: Tensor, out: Tensor | None) -> Tensor:
        """
        atanh(input: Tensor, *, out: Optional[Tensor]) -> Tensor

        Returns a new tensor with the inverse hyperbolic tangent of the elements of :attr:`input`.

        Note:
            The domain of the inverse hyperbolic tangent is `(-1, 1)` and values outside this range
            will be mapped to ``NaN``, except for the values `1` and `-1` for which the output is
            mapped to `+/-INF` respectively.

        .. math::
            \\text{out}_{i} = \\tanh^{-1}(\\text{input}_{i})

        Args:
            input (Tensor): the input tensor.

        Keyword arguments:
            out (Tensor, optional): the output tensor.

        Example::

            >>> a = torch.randn(4).uniform_(-1, 1)
            >>> a
            tensor([ -0.9385, 0.2968, -0.8591, -0.1871 ])
            >>> torch.atanh(a)
            tensor([ -1.7253, 0.3060, -1.2899, -0.1893 ])
        """
    @staticmethod
    def atanh_(*args, **kwargs): ...
    @staticmethod
    def atleast_1d(*args, **kwargs): ...
    @staticmethod
    def atleast_2d(*args, **kwargs): ...
    @staticmethod
    def atleast_3d(*args, **kwargs): ...
    @staticmethod
    def avg_pool1d(input, kernel_size, stride=..., padding=..., ceil_mode=..., count_include_pad=...) -> Tensor:
        """
        avg_pool1d(input, kernel_size, stride=None, padding=0, ceil_mode=False, count_include_pad=True) -> Tensor

        Applies a 1D average pooling over an input signal composed of several
        input planes.

        .. note::
            pad should be at most half of effective kernel size.

        See :class:`~torch.nn.AvgPool1d` for details and output shape.

        Args:
            input: input tensor of shape :math:`(\\text{minibatch} , \\text{in\\_channels} , iW)`
            kernel_size: the size of the window. Can be a single number or a
              tuple `(kW,)`
            stride: the stride of the window. Can be a single number or a tuple
              `(sW,)`. Default: :attr:`kernel_size`
            padding: implicit zero paddings on both sides of the input. Can be a
              single number or a tuple `(padW,)`. Default: 0
            ceil_mode: when True, will use `ceil` instead of `floor` to compute the
                output shape. Default: ``False``
            count_include_pad: when True, will include the zero-padding in the
                averaging calculation. Default: ``True``

        Examples::

            >>> # pool of square window of size=3, stride=2
            >>> input = torch.tensor([[[1, 2, 3, 4, 5, 6, 7]]], dtype=torch.float32)
            >>> F.avg_pool1d(input, kernel_size=3, stride=2)
            tensor([[[ 2.,  4.,  6.]]])

        """
    @staticmethod
    def baddbmm(input, batch1, batch2, out_dtype=..., beta=..., alpha=..., out=...) -> Tensor:
        """
        baddbmm(input, batch1, batch2, out_dtype=None, *, beta=1, alpha=1, out=None) -> Tensor

        Performs a batch matrix-matrix product of matrices in :attr:`batch1`
        and :attr:`batch2`.
        :attr:`input` is added to the final result.

        :attr:`batch1` and :attr:`batch2` must be 3-D tensors each containing the same
        number of matrices.

        If :attr:`batch1` is a :math:`(b \\times n \\times m)` tensor, :attr:`batch2` is a
        :math:`(b \\times m \\times p)` tensor, then :attr:`input` must be
        :ref:`broadcastable <broadcasting-semantics>` with a
        :math:`(b \\times n \\times p)` tensor and :attr:`out` will be a
        :math:`(b \\times n \\times p)` tensor. Both :attr:`alpha` and :attr:`beta` mean the
        same as the scaling factors used in :meth:`torch.addbmm`.

        .. math::
            \\text{out}_i = \\beta\\ \\text{input}_i + \\alpha\\ (\\text{batch1}_i \\mathbin{@} \\text{batch2}_i)

        If :attr:`beta` is 0, then the content of :attr:`input` will be ignored, and `nan` and `inf` in
        it will not be propagated.

        For inputs of type `FloatTensor` or `DoubleTensor`, arguments :attr:`beta` and
        :attr:`alpha` must be real numbers, otherwise they should be integers.

        This operator supports :ref:`TensorFloat32<tf32_on_ampere>`.

        On certain ROCm devices, when using float16 inputs this module will use :ref:`different precision<fp16_on_mi200>` for backward.

        Args:
            input (Tensor): the tensor to be added
            batch1 (Tensor): the first batch of matrices to be multiplied
            batch2 (Tensor): the second batch of matrices to be multiplied
            out_dtype (dtype, optional): the dtype of the output tensor,
                Supported only on CUDA and for torch.float32 given
                torch.float16/torch.bfloat16 input dtypes

        Keyword args:
            beta (Number, optional): multiplier for :attr:`input` (:math:`\\beta`)
            alpha (Number, optional): multiplier for :math:`\\text{batch1} \\mathbin{@} \\text{batch2}` (:math:`\\alpha`)
            out (Tensor, optional): the output tensor.

        Example::

            >>> M = torch.randn(10, 3, 5)
            >>> batch1 = torch.randn(10, 3, 4)
            >>> batch2 = torch.randn(10, 4, 5)
            >>> torch.baddbmm(M, batch1, batch2).size()
            torch.Size([10, 3, 5])
        """
    @staticmethod
    def bartlett_window(window_length, periodic=..., dtype=..., layout=..., device=..., requires_grad=...) -> Tensor:
        """
        bartlett_window(window_length, periodic=True, *, dtype=None, layout=torch.strided, device=None, requires_grad=False) -> Tensor

        Bartlett window function.

        .. math::
            w[n] = 1 - \\left| \\frac{2n}{N-1} - 1 \\right| = \\begin{cases}
                \\frac{2n}{N - 1} & \\text{if } 0 \\leq n \\leq \\frac{N - 1}{2} \\\\\n                2 - \\frac{2n}{N - 1} & \\text{if } \\frac{N - 1}{2} < n < N \\\\\n            \\end{cases},

        where :math:`N` is the full window size.

        The input :attr:`window_length` is a positive integer controlling the
        returned window size. :attr:`periodic` flag determines whether the returned
        window trims off the last duplicate value from the symmetric window and is
        ready to be used as a periodic window with functions like
        :meth:`torch.stft`. Therefore, if :attr:`periodic` is true, the :math:`N` in
        above formula is in fact :math:`\\text{window\\_length} + 1`. Also, we always have
        ``torch.bartlett_window(L, periodic=True)`` equal to
        ``torch.bartlett_window(L + 1, periodic=False)[:-1])``.

        .. note::
            If :attr:`window_length` :math:`=1`, the returned window contains a single value 1.

        Arguments:
            window_length (int): the size of returned window
            periodic (bool, optional): If True, returns a window to be used as periodic
                function. If False, return a symmetric window.

        Keyword args:
            dtype (:class:`torch.dtype`, optional): the desired data type of returned tensor.
                Default: if ``None``, uses a global default (see :func:`torch.set_default_dtype`). Only floating point types are supported.
            layout (:class:`torch.layout`, optional): the desired layout of returned window tensor. Only
                  ``torch.strided`` (dense layout) is supported.
            device (:class:`torch.device`, optional): the desired device of returned tensor.
                Default: if ``None``, uses the current device for the default tensor type
                (see :func:`torch.set_default_device`). :attr:`device` will be the CPU
                for CPU tensor types and the current CUDA device for CUDA tensor types.
            requires_grad (bool, optional): If autograd should record operations on the
                returned tensor. Default: ``False``.

        Returns:
            Tensor: A 1-D tensor of size :math:`(\\text{window\\_length},)` containing the window

        """
    @staticmethod
    def batch_norm(*args, **kwargs): ...
    @staticmethod
    def batch_norm_backward_elemt(*args, **kwargs): ...
    @staticmethod
    def batch_norm_backward_reduce(*args, **kwargs): ...
    @staticmethod
    def batch_norm_elemt(*args, **kwargs): ...
    @staticmethod
    def batch_norm_gather_stats(*args, **kwargs): ...
    @staticmethod
    def batch_norm_gather_stats_with_counts(*args, **kwargs): ...
    @staticmethod
    def batch_norm_stats(*args, **kwargs): ...
    @staticmethod
    def batch_norm_update_stats(*args, **kwargs): ...
    @staticmethod
    def bernoulli(input: Tensor, generator: Generator | None, out: Tensor | None) -> Tensor:
        '''
        bernoulli(input: Tensor, *, generator: Optional[Generator], out: Optional[Tensor]) -> Tensor

        Draws binary random numbers (0 or 1) from a Bernoulli distribution.

        The :attr:`input` tensor should be a tensor containing probabilities
        to be used for drawing the binary random number.
        Hence, all values in :attr:`input` have to be in the range:
        :math:`0 \\leq \\text{input}_i \\leq 1`.

        The :math:`\\text{i}^{th}` element of the output tensor will draw a
        value :math:`1` according to the :math:`\\text{i}^{th}` probability value given
        in :attr:`input`.

        .. math::
            \\text{out}_{i} \\sim \\mathrm{Bernoulli}(p = \\text{input}_{i})

        The returned :attr:`out` tensor only has values 0 or 1 and is of the same
        shape as :attr:`input`.

        :attr:`out` can have integral ``dtype``, but :attr:`input` must have floating
        point ``dtype``.

        Args:
            input (Tensor): the input tensor of probability values for the Bernoulli distribution

        Keyword args:
            generator (:class:`torch.Generator`, optional): a pseudorandom number generator for sampling
            out (Tensor, optional): the output tensor.

        Example::

            >>> a = torch.empty(3, 3).uniform_(0, 1)  # generate a uniform random matrix with range [0, 1]
            >>> a
            tensor([[ 0.1737,  0.0950,  0.3609],
                    [ 0.7148,  0.0289,  0.2676],
                    [ 0.9456,  0.8937,  0.7202]])
            >>> torch.bernoulli(a)
            tensor([[ 1.,  0.,  0.],
                    [ 0.,  0.,  0.],
                    [ 1.,  1.,  1.]])

            >>> a = torch.ones(3, 3) # probability of drawing "1" is 1
            >>> torch.bernoulli(a)
            tensor([[ 1.,  1.,  1.],
                    [ 1.,  1.,  1.],
                    [ 1.,  1.,  1.]])
            >>> a = torch.zeros(3, 3) # probability of drawing "1" is 0
            >>> torch.bernoulli(a)
            tensor([[ 0.,  0.,  0.],
                    [ 0.,  0.,  0.],
                    [ 0.,  0.,  0.]])
        '''
    @staticmethod
    def bilinear(input1, input2, weight, bias=...) -> Tensor:
        """
        bilinear(input1, input2, weight, bias=None) -> Tensor

        Applies a bilinear transformation to the incoming data:
        :math:`y = x_1^T A x_2 + b`

        Shape:

            - input1: :math:`(N, *, H_{in1})` where :math:`H_{in1}=\\text{in1\\_features}`
              and :math:`*` means any number of additional dimensions.
              All but the last dimension of the inputs should be the same.
            - input2: :math:`(N, *, H_{in2})` where :math:`H_{in2}=\\text{in2\\_features}`
            - weight: :math:`(\\text{out\\_features}, \\text{in1\\_features},
              \\text{in2\\_features})`
            - bias: :math:`(\\text{out\\_features})`
            - output: :math:`(N, *, H_{out})` where :math:`H_{out}=\\text{out\\_features}`
              and all but the last dimension are the same shape as the input.
        """
    @staticmethod
    def binary_cross_entropy_with_logits(*args, **kwargs): ...
    @staticmethod
    def bincount(input, weights=..., minlength=...) -> Tensor:
        """
        bincount(input, weights=None, minlength=0) -> Tensor

        Count the frequency of each value in an array of non-negative ints.

        The number of bins (size 1) is one larger than the largest value in
        :attr:`input` unless :attr:`input` is empty, in which case the result is a
        tensor of size 0. If :attr:`minlength` is specified, the number of bins is at least
        :attr:`minlength` and if :attr:`input` is empty, then the result is tensor of size
        :attr:`minlength` filled with zeros. If ``n`` is the value at position ``i``,
        ``out[n] += weights[i]`` if :attr:`weights` is specified else
        ``out[n] += 1``.

        Note:
            This operation may produce nondeterministic gradients when given tensors on a CUDA device. See :doc:`/notes/randomness` for more information.

        Arguments:
            input (Tensor): 1-d int tensor
            weights (Tensor): optional, weight for each value in the input tensor.
                Should be of same size as input tensor.
            minlength (int): optional, minimum number of bins. Should be non-negative.

        Returns:
            output (Tensor): a tensor of shape ``Size([max(input) + 1])`` if
            :attr:`input` is non-empty, else ``Size(0)``

        Example::

            >>> input = torch.randint(0, 8, (5,), dtype=torch.int64)
            >>> weights = torch.linspace(0, 1, steps=5)
            >>> input, weights
            (tensor([4, 3, 6, 3, 4]),
             tensor([ 0.0000,  0.2500,  0.5000,  0.7500,  1.0000])

            >>> torch.bincount(input)
            tensor([0, 0, 0, 2, 2, 0, 1])

            >>> input.bincount(weights)
            tensor([0.0000, 0.0000, 0.0000, 1.0000, 1.0000, 0.0000, 0.5000])
        """
    @staticmethod
    def binomial(*args, **kwargs): ...
    @staticmethod
    def bitwise_and(input, other, out=...) -> Tensor:
        """
        bitwise_and(input, other, *, out=None) -> Tensor

        Computes the bitwise AND of :attr:`input` and :attr:`other`. The input tensor must be of
        integral or Boolean types. For bool tensors, it computes the logical AND.

        Args:
            input: the first input tensor
            other: the second input tensor

        Keyword args:
            out (Tensor, optional): the output tensor.

        Example::

            >>> torch.bitwise_and(torch.tensor([-1, -2, 3], dtype=torch.int8), torch.tensor([1, 0, 3], dtype=torch.int8))
            tensor([1, 0,  3], dtype=torch.int8)
            >>> torch.bitwise_and(torch.tensor([True, True, False]), torch.tensor([False, True, False]))
            tensor([ False, True, False])
        """
    @staticmethod
    def bitwise_left_shift(input, other, out=...) -> Tensor:
        """
        bitwise_left_shift(input, other, *, out=None) -> Tensor

        Computes the left arithmetic shift of :attr:`input` by :attr:`other` bits.
        The input tensor must be of integral type. This operator supports
        :ref:`broadcasting to a common shape <broadcasting-semantics>` and
        :ref:`type promotion <type-promotion-doc>`.

        The operation applied is:

        .. math::
            \\text{out}_i = \\text{input}_i << \\text{other}_i

        Args:
            input (Tensor or Scalar): the first input tensor
            other (Tensor or Scalar): the second input tensor

        Keyword args:
            out (Tensor, optional): the output tensor.

        Example::

            >>> torch.bitwise_left_shift(torch.tensor([-1, -2, 3], dtype=torch.int8), torch.tensor([1, 0, 3], dtype=torch.int8))
            tensor([-2, -2, 24], dtype=torch.int8)
        """
    @staticmethod
    def bitwise_not(input, out=...) -> Tensor:
        """
        bitwise_not(input, *, out=None) -> Tensor

        Computes the bitwise NOT of the given input tensor. The input tensor must be of
        integral or Boolean types. For bool tensors, it computes the logical NOT.

        Args:
            input (Tensor): the input tensor.

        Keyword args:
            out (Tensor, optional): the output tensor.

        Example::

            >>> torch.bitwise_not(torch.tensor([-1, -2, 3], dtype=torch.int8))
            tensor([ 0,  1, -4], dtype=torch.int8)
        """
    @staticmethod
    def bitwise_or(input: Tensor, other: Tensor, out: Tensor | None) -> Tensor:
        """
        bitwise_or(input: Tensor, other: Tensor, *, out: Optional[Tensor]) -> Tensor

        Computes the bitwise OR of :attr:`input` and :attr:`other`. The input tensor must be of
        integral or Boolean types. For bool tensors, it computes the logical OR.

        Args:
            input: the first input tensor
            other: the second input tensor

        Keyword args:
            out (Tensor, optional): the output tensor.

        Example::

            >>> torch.bitwise_or(torch.tensor([-1, -2, 3], dtype=torch.int8), torch.tensor([1, 0, 3], dtype=torch.int8))
            tensor([-1, -2,  3], dtype=torch.int8)
            >>> torch.bitwise_or(torch.tensor([True, True, False]), torch.tensor([False, True, False]))
            tensor([ True, True, False])
        """
    @staticmethod
    def bitwise_right_shift(input, other, out=...) -> Tensor:
        """
        bitwise_right_shift(input, other, *, out=None) -> Tensor

        Computes the right arithmetic shift of :attr:`input` by :attr:`other` bits.
        The input tensor must be of integral type. This operator supports
        :ref:`broadcasting to a common shape <broadcasting-semantics>` and
        :ref:`type promotion <type-promotion-doc>`.
        In any case, if the value of the right operand is negative or is greater
        or equal to the number of bits in the promoted left operand, the behavior is undefined.

        The operation applied is:

        .. math::
            \\text{out}_i = \\text{input}_i >> \\text{other}_i

        Args:
            input (Tensor or Scalar): the first input tensor
            other (Tensor or Scalar): the second input tensor

        Keyword args:
            out (Tensor, optional): the output tensor.

        Example::

            >>> torch.bitwise_right_shift(torch.tensor([-2, -7, 31], dtype=torch.int8), torch.tensor([1, 0, 3], dtype=torch.int8))
            tensor([-1, -7,  3], dtype=torch.int8)
        """
    @staticmethod
    def bitwise_xor(input, other, out=...) -> Tensor:
        """
        bitwise_xor(input, other, *, out=None) -> Tensor

        Computes the bitwise XOR of :attr:`input` and :attr:`other`. The input tensor must be of
        integral or Boolean types. For bool tensors, it computes the logical XOR.

        Args:
            input: the first input tensor
            other: the second input tensor

        Keyword args:
            out (Tensor, optional): the output tensor.

        Example::

            >>> torch.bitwise_xor(torch.tensor([-1, -2, 3], dtype=torch.int8), torch.tensor([1, 0, 3], dtype=torch.int8))
            tensor([-2, -2,  0], dtype=torch.int8)
            >>> torch.bitwise_xor(torch.tensor([True, True, False]), torch.tensor([False, True, False]))
            tensor([ True, False, False])
        """
    @staticmethod
    def blackman_window(window_length, periodic=..., dtype=..., layout=..., device=..., requires_grad=...) -> Tensor:
        """
        blackman_window(window_length, periodic=True, *, dtype=None, layout=torch.strided, device=None, requires_grad=False) -> Tensor

        Blackman window function.

        .. math::
            w[n] = 0.42 - 0.5 \\cos \\left( \\frac{2 \\pi n}{N - 1} \\right) + 0.08 \\cos \\left( \\frac{4 \\pi n}{N - 1} \\right)

        where :math:`N` is the full window size.

        The input :attr:`window_length` is a positive integer controlling the
        returned window size. :attr:`periodic` flag determines whether the returned
        window trims off the last duplicate value from the symmetric window and is
        ready to be used as a periodic window with functions like
        :meth:`torch.stft`. Therefore, if :attr:`periodic` is true, the :math:`N` in
        above formula is in fact :math:`\\text{window\\_length} + 1`. Also, we always have
        ``torch.blackman_window(L, periodic=True)`` equal to
        ``torch.blackman_window(L + 1, periodic=False)[:-1]``.

        .. note::
            If :attr:`window_length` :math:`=1`, the returned window contains a single value 1.

        Arguments:
            window_length (int): the size of returned window
            periodic (bool, optional): If True, returns a window to be used as periodic
                function. If False, return a symmetric window.

        Keyword args:
            dtype (:class:`torch.dtype`, optional): the desired data type of returned tensor.
                Default: if ``None``, uses a global default (see :func:`torch.set_default_dtype`). Only floating point types are supported.
            layout (:class:`torch.layout`, optional): the desired layout of returned window tensor. Only
                  ``torch.strided`` (dense layout) is supported.
            device (:class:`torch.device`, optional): the desired device of returned tensor.
                Default: if ``None``, uses the current device for the default tensor type
                (see :func:`torch.set_default_device`). :attr:`device` will be the CPU
                for CPU tensor types and the current CUDA device for CUDA tensor types.
            requires_grad (bool, optional): If autograd should record operations on the
                returned tensor. Default: ``False``.

        Returns:
            Tensor: A 1-D tensor of size :math:`(\\text{window\\_length},)` containing the window

        """
    @staticmethod
    def block_diag(*args, **kwargs): ...
    @staticmethod
    def bmm(input, mat2, out_dtype=..., out=...) -> Tensor:
        """
        bmm(input, mat2, out_dtype=None, *, out=None) -> Tensor

        Performs a batch matrix-matrix product of matrices stored in :attr:`input`
        and :attr:`mat2`.

        :attr:`input` and :attr:`mat2` must be 3-D tensors each containing
        the same number of matrices.

        If :attr:`input` is a :math:`(b \\times n \\times m)` tensor, :attr:`mat2` is a
        :math:`(b \\times m \\times p)` tensor, :attr:`out` will be a
        :math:`(b \\times n \\times p)` tensor.

        .. math::
            \\text{out}_i = \\text{input}_i \\mathbin{@} \\text{mat2}_i

        This operator supports :ref:`TensorFloat32<tf32_on_ampere>`.

        On certain ROCm devices, when using float16 inputs this module will use :ref:`different precision<fp16_on_mi200>` for backward.

        .. note:: This function does not :ref:`broadcast <broadcasting-semantics>`.
                  For broadcasting matrix products, see :func:`torch.matmul`.

        Args:
            input (Tensor): the first batch of matrices to be multiplied
            mat2 (Tensor): the second batch of matrices to be multiplied
            out_dtype (dtype, optional): the dtype of the output tensor,
                Supported only on CUDA and for torch.float32 given
                torch.float16/torch.bfloat16 input dtypes

        Keyword Args:
            out (Tensor, optional): the output tensor.

        Example::

            >>> input = torch.randn(10, 3, 4)
            >>> mat2 = torch.randn(10, 4, 5)
            >>> res = torch.bmm(input, mat2)
            >>> res.size()
            torch.Size([10, 3, 5])
        """
    @staticmethod
    def broadcast_tensors(*args, **kwargs): ...
    @staticmethod
    def broadcast_to(input, shape) -> Tensor:
        """
        broadcast_to(input, shape) -> Tensor

        Broadcasts :attr:`input` to the shape :attr:`\\shape`.
        Equivalent to calling ``input.expand(shape)``. See :meth:`~Tensor.expand` for details.

        Args:
            input (Tensor): the input tensor.
            shape (list, tuple, or :class:`torch.Size`): the new shape.

        Example::

            >>> x = torch.tensor([1, 2, 3])
            >>> torch.broadcast_to(x, (3, 3))
            tensor([[1, 2, 3],
                    [1, 2, 3],
                    [1, 2, 3]])
        """
    @overload
    @staticmethod
    def bucketize(input, boundaries, out_int32=..., right=..., out=...) -> Tensor:
        """
        bucketize(input, boundaries, *, out_int32=False, right=False, out=None) -> Tensor

        Returns the indices of the buckets to which each value in the :attr:`input` belongs, where the
        boundaries of the buckets are set by :attr:`boundaries`. Return a new tensor with the same size
        as :attr:`input`. If :attr:`right` is False (default), then the left boundary is open. Note that
        this behavior is opposite the behavior of
        `numpy.digitize <https://numpy.org/doc/stable/reference/generated/numpy.digitize.html>`_.
        More formally, the returned index satisfies the following rules:

        .. list-table::
           :widths: 15 85
           :header-rows: 1

           * - :attr:`right`
             - *returned index satisfies*
           * - False
             - ``boundaries[i-1] < input[m][n]...[l][x] <= boundaries[i]``
           * - True
             - ``boundaries[i-1] <= input[m][n]...[l][x] < boundaries[i]``

        Args:
            input (Tensor or Scalar): N-D tensor or a Scalar containing the search value(s).
            boundaries (Tensor): 1-D tensor, must contain a strictly increasing sequence, or the return value is undefined.

        Keyword args:
            out_int32 (bool, optional): indicate the output data type. torch.int32 if True, torch.int64 otherwise.
                                        Default value is False, i.e. default output data type is torch.int64.
            right (bool, optional): determines the behavior for values in :attr:`boundaries`. See the table above.
            out (Tensor, optional): the output tensor, must be the same size as :attr:`input` if provided.


        Example::

            >>> boundaries = torch.tensor([1, 3, 5, 7, 9])
            >>> boundaries
            tensor([1, 3, 5, 7, 9])
            >>> v = torch.tensor([[3, 6, 9], [3, 6, 9]])
            >>> v
            tensor([[3, 6, 9],
                    [3, 6, 9]])
            >>> torch.bucketize(v, boundaries)
            tensor([[1, 3, 4],
                    [1, 3, 4]])
            >>> torch.bucketize(v, boundaries, right=True)
            tensor([[2, 3, 5],
                    [2, 3, 5]])
        """
    @overload
    @staticmethod
    def bucketize(v, boundaries) -> Any:
        """
        bucketize(input, boundaries, *, out_int32=False, right=False, out=None) -> Tensor

        Returns the indices of the buckets to which each value in the :attr:`input` belongs, where the
        boundaries of the buckets are set by :attr:`boundaries`. Return a new tensor with the same size
        as :attr:`input`. If :attr:`right` is False (default), then the left boundary is open. Note that
        this behavior is opposite the behavior of
        `numpy.digitize <https://numpy.org/doc/stable/reference/generated/numpy.digitize.html>`_.
        More formally, the returned index satisfies the following rules:

        .. list-table::
           :widths: 15 85
           :header-rows: 1

           * - :attr:`right`
             - *returned index satisfies*
           * - False
             - ``boundaries[i-1] < input[m][n]...[l][x] <= boundaries[i]``
           * - True
             - ``boundaries[i-1] <= input[m][n]...[l][x] < boundaries[i]``

        Args:
            input (Tensor or Scalar): N-D tensor or a Scalar containing the search value(s).
            boundaries (Tensor): 1-D tensor, must contain a strictly increasing sequence, or the return value is undefined.

        Keyword args:
            out_int32 (bool, optional): indicate the output data type. torch.int32 if True, torch.int64 otherwise.
                                        Default value is False, i.e. default output data type is torch.int64.
            right (bool, optional): determines the behavior for values in :attr:`boundaries`. See the table above.
            out (Tensor, optional): the output tensor, must be the same size as :attr:`input` if provided.


        Example::

            >>> boundaries = torch.tensor([1, 3, 5, 7, 9])
            >>> boundaries
            tensor([1, 3, 5, 7, 9])
            >>> v = torch.tensor([[3, 6, 9], [3, 6, 9]])
            >>> v
            tensor([[3, 6, 9],
                    [3, 6, 9]])
            >>> torch.bucketize(v, boundaries)
            tensor([[1, 3, 4],
                    [1, 3, 4]])
            >>> torch.bucketize(v, boundaries, right=True)
            tensor([[2, 3, 5],
                    [2, 3, 5]])
        """
    @overload
    @staticmethod
    def bucketize(v, boundaries, right=...) -> Any:
        """
        bucketize(input, boundaries, *, out_int32=False, right=False, out=None) -> Tensor

        Returns the indices of the buckets to which each value in the :attr:`input` belongs, where the
        boundaries of the buckets are set by :attr:`boundaries`. Return a new tensor with the same size
        as :attr:`input`. If :attr:`right` is False (default), then the left boundary is open. Note that
        this behavior is opposite the behavior of
        `numpy.digitize <https://numpy.org/doc/stable/reference/generated/numpy.digitize.html>`_.
        More formally, the returned index satisfies the following rules:

        .. list-table::
           :widths: 15 85
           :header-rows: 1

           * - :attr:`right`
             - *returned index satisfies*
           * - False
             - ``boundaries[i-1] < input[m][n]...[l][x] <= boundaries[i]``
           * - True
             - ``boundaries[i-1] <= input[m][n]...[l][x] < boundaries[i]``

        Args:
            input (Tensor or Scalar): N-D tensor or a Scalar containing the search value(s).
            boundaries (Tensor): 1-D tensor, must contain a strictly increasing sequence, or the return value is undefined.

        Keyword args:
            out_int32 (bool, optional): indicate the output data type. torch.int32 if True, torch.int64 otherwise.
                                        Default value is False, i.e. default output data type is torch.int64.
            right (bool, optional): determines the behavior for values in :attr:`boundaries`. See the table above.
            out (Tensor, optional): the output tensor, must be the same size as :attr:`input` if provided.


        Example::

            >>> boundaries = torch.tensor([1, 3, 5, 7, 9])
            >>> boundaries
            tensor([1, 3, 5, 7, 9])
            >>> v = torch.tensor([[3, 6, 9], [3, 6, 9]])
            >>> v
            tensor([[3, 6, 9],
                    [3, 6, 9]])
            >>> torch.bucketize(v, boundaries)
            tensor([[1, 3, 4],
                    [1, 3, 4]])
            >>> torch.bucketize(v, boundaries, right=True)
            tensor([[2, 3, 5],
                    [2, 3, 5]])
        """
    @staticmethod
    def can_cast(from_, to) -> bool:
        """
        can_cast(from_, to) -> bool

        Determines if a type conversion is allowed under PyTorch casting rules
        described in the type promotion :ref:`documentation <type-promotion-doc>`.

        Args:
            from\\_ (dtype): The original :class:`torch.dtype`.
            to (dtype): The target :class:`torch.dtype`.

        Example::

            >>> torch.can_cast(torch.double, torch.float)
            True
            >>> torch.can_cast(torch.float, torch.int)
            False
        """
    @staticmethod
    def cartesian_prod(*args, **kwargs): ...
    @staticmethod
    def cat(tensors, dim=..., out=...) -> Tensor:
        """
        cat(tensors, dim=0, *, out=None) -> Tensor

        Concatenates the given sequence of tensors in :attr:`tensors` in the given dimension.
        All tensors must either have the same shape (except in the concatenating
        dimension) or be a 1-D empty tensor with size ``(0,)``.

        :func:`torch.cat` can be seen as an inverse operation for :func:`torch.split`
        and :func:`torch.chunk`.

        :func:`torch.cat` can be best understood via examples.

        .. seealso::

            :func:`torch.stack` concatenates the given sequence along a new dimension.

        Args:
            tensors (sequence of Tensors): Non-empty tensors provided must have the same shape,
                except in the cat dimension.

            dim (int, optional): the dimension over which the tensors are concatenated

        Keyword args:
            out (Tensor, optional): the output tensor.

        Example::

            >>> x = torch.randn(2, 3)
            >>> x
            tensor([[ 0.6580, -1.0969, -0.4614],
                    [-0.1034, -0.5790,  0.1497]])
            >>> torch.cat((x, x, x), 0)
            tensor([[ 0.6580, -1.0969, -0.4614],
                    [-0.1034, -0.5790,  0.1497],
                    [ 0.6580, -1.0969, -0.4614],
                    [-0.1034, -0.5790,  0.1497],
                    [ 0.6580, -1.0969, -0.4614],
                    [-0.1034, -0.5790,  0.1497]])
            >>> torch.cat((x, x, x), 1)
            tensor([[ 0.6580, -1.0969, -0.4614,  0.6580, -1.0969, -0.4614,  0.6580,
                     -1.0969, -0.4614],
                    [-0.1034, -0.5790,  0.1497, -0.1034, -0.5790,  0.1497, -0.1034,
                     -0.5790,  0.1497]])
        """
    @staticmethod
    def ccol_indices_copy(*args, **kwargs): ...
    @staticmethod
    def cdist(*args, **kwargs): ...
    @staticmethod
    def ceil(input, out=...) -> Tensor:
        """
        ceil(input, *, out=None) -> Tensor

        Returns a new tensor with the ceil of the elements of :attr:`input`,
        the smallest integer greater than or equal to each element.

        For integer inputs, follows the array-api convention of returning a
        copy of the input tensor.

        .. math::
            \\text{out}_{i} = \\left\\lceil \\text{input}_{i} \\right\\rceil

        Args:
            input (Tensor): the input tensor.

        Keyword args:
            out (Tensor, optional): the output tensor.

        Example::

            >>> a = torch.randn(4)
            >>> a
            tensor([-0.6341, -1.4208, -1.0900,  0.5826])
            >>> torch.ceil(a)
            tensor([-0., -1., -1.,  1.])
        """
    @staticmethod
    def ceil_(*args, **kwargs): ...
    @staticmethod
    def celu(*args, **kwargs): ...
    @staticmethod
    def celu_(input, alpha=...) -> Tensor:
        """
        celu_(input, alpha=1.) -> Tensor

        In-place version of :func:`~celu`.
        """
    @staticmethod
    def chain_matmul(*args, **kwargs): ...
    @staticmethod
    def channel_shuffle(input, groups) -> Tensor:
        """
        channel_shuffle(input, groups) -> Tensor

        Divide the channels in a tensor of shape :math:`(*, C , H, W)`
        into g groups and rearrange them as :math:`(*, C \\frac g, g, H, W)`,
        while keeping the original tensor shape.

        See :class:`~torch.nn.ChannelShuffle` for details.

        Args:
            input (Tensor): the input tensor
            groups (int): number of groups to divide channels in and rearrange.

        Examples::

            >>> input = torch.randn(1, 4, 2, 2)
            >>> print(input)
            [[[[1, 2],
               [3, 4]],
              [[5, 6],
               [7, 8]],
              [[9, 10],
               [11, 12]],
              [[13, 14],
               [15, 16]],
             ]]
            >>> output = torch.nn.functional.channel_shuffle(input, 2)
            >>> print(output)
            [[[[1, 2],
               [3, 4]],
              [[9, 10],
               [11, 12]],
              [[5, 6],
               [7, 8]],
              [[13, 14],
               [15, 16]],
             ]]
        """
    @overload
    @staticmethod
    def cholesky(input, upper=..., out=...) -> Tensor:
        """
        cholesky(input, upper=False, *, out=None) -> Tensor

        Computes the Cholesky decomposition of a symmetric positive-definite
        matrix :math:`A` or for batches of symmetric positive-definite matrices.

        If :attr:`upper` is ``True``, the returned matrix ``U`` is upper-triangular, and
        the decomposition has the form:

        .. math::

          A = U^TU

        If :attr:`upper` is ``False``, the returned matrix ``L`` is lower-triangular, and
        the decomposition has the form:

        .. math::

            A = LL^T

        If :attr:`upper` is ``True``, and :math:`A` is a batch of symmetric positive-definite
        matrices, then the returned tensor will be composed of upper-triangular Cholesky factors
        of each of the individual matrices. Similarly, when :attr:`upper` is ``False``, the returned
        tensor will be composed of lower-triangular Cholesky factors of each of the individual
        matrices.

        .. warning::

            :func:`torch.cholesky` is deprecated in favor of :func:`torch.linalg.cholesky`
            and will be removed in a future PyTorch release.

            ``L = torch.cholesky(A)`` should be replaced with

            .. code:: python

                L = torch.linalg.cholesky(A)

            ``U = torch.cholesky(A, upper=True)`` should be replaced with

            .. code:: python

                U = torch.linalg.cholesky(A).mH

            This transform will produce equivalent results for all valid (symmetric positive definite) inputs.

        Args:
            input (Tensor): the input tensor :math:`A` of size :math:`(*, n, n)` where `*` is zero or more
                        batch dimensions consisting of symmetric positive-definite matrices.
            upper (bool, optional): flag that indicates whether to return a
                                    upper or lower triangular matrix. Default: ``False``

        Keyword args:
            out (Tensor, optional): the output matrix

        Example::

            >>> a = torch.randn(3, 3)
            >>> a = a @ a.mT + 1e-3 # make symmetric positive-definite
            >>> l = torch.cholesky(a)
            >>> a
            tensor([[ 2.4112, -0.7486,  1.4551],
                    [-0.7486,  1.3544,  0.1294],
                    [ 1.4551,  0.1294,  1.6724]])
            >>> l
            tensor([[ 1.5528,  0.0000,  0.0000],
                    [-0.4821,  1.0592,  0.0000],
                    [ 0.9371,  0.5487,  0.7023]])
            >>> l @ l.mT
            tensor([[ 2.4112, -0.7486,  1.4551],
                    [-0.7486,  1.3544,  0.1294],
                    [ 1.4551,  0.1294,  1.6724]])
            >>> a = torch.randn(3, 2, 2) # Example for batched input
            >>> a = a @ a.mT + 1e-03 # make symmetric positive-definite
            >>> l = torch.cholesky(a)
            >>> z = l @ l.mT
            >>> torch.dist(z, a)
            tensor(2.3842e-07)
        """
    @overload
    @staticmethod
    def cholesky(A) -> Any:
        """
        cholesky(input, upper=False, *, out=None) -> Tensor

        Computes the Cholesky decomposition of a symmetric positive-definite
        matrix :math:`A` or for batches of symmetric positive-definite matrices.

        If :attr:`upper` is ``True``, the returned matrix ``U`` is upper-triangular, and
        the decomposition has the form:

        .. math::

          A = U^TU

        If :attr:`upper` is ``False``, the returned matrix ``L`` is lower-triangular, and
        the decomposition has the form:

        .. math::

            A = LL^T

        If :attr:`upper` is ``True``, and :math:`A` is a batch of symmetric positive-definite
        matrices, then the returned tensor will be composed of upper-triangular Cholesky factors
        of each of the individual matrices. Similarly, when :attr:`upper` is ``False``, the returned
        tensor will be composed of lower-triangular Cholesky factors of each of the individual
        matrices.

        .. warning::

            :func:`torch.cholesky` is deprecated in favor of :func:`torch.linalg.cholesky`
            and will be removed in a future PyTorch release.

            ``L = torch.cholesky(A)`` should be replaced with

            .. code:: python

                L = torch.linalg.cholesky(A)

            ``U = torch.cholesky(A, upper=True)`` should be replaced with

            .. code:: python

                U = torch.linalg.cholesky(A).mH

            This transform will produce equivalent results for all valid (symmetric positive definite) inputs.

        Args:
            input (Tensor): the input tensor :math:`A` of size :math:`(*, n, n)` where `*` is zero or more
                        batch dimensions consisting of symmetric positive-definite matrices.
            upper (bool, optional): flag that indicates whether to return a
                                    upper or lower triangular matrix. Default: ``False``

        Keyword args:
            out (Tensor, optional): the output matrix

        Example::

            >>> a = torch.randn(3, 3)
            >>> a = a @ a.mT + 1e-3 # make symmetric positive-definite
            >>> l = torch.cholesky(a)
            >>> a
            tensor([[ 2.4112, -0.7486,  1.4551],
                    [-0.7486,  1.3544,  0.1294],
                    [ 1.4551,  0.1294,  1.6724]])
            >>> l
            tensor([[ 1.5528,  0.0000,  0.0000],
                    [-0.4821,  1.0592,  0.0000],
                    [ 0.9371,  0.5487,  0.7023]])
            >>> l @ l.mT
            tensor([[ 2.4112, -0.7486,  1.4551],
                    [-0.7486,  1.3544,  0.1294],
                    [ 1.4551,  0.1294,  1.6724]])
            >>> a = torch.randn(3, 2, 2) # Example for batched input
            >>> a = a @ a.mT + 1e-03 # make symmetric positive-definite
            >>> l = torch.cholesky(a)
            >>> z = l @ l.mT
            >>> torch.dist(z, a)
            tensor(2.3842e-07)
        """
    @overload
    @staticmethod
    def cholesky(A) -> Any:
        """
        cholesky(input, upper=False, *, out=None) -> Tensor

        Computes the Cholesky decomposition of a symmetric positive-definite
        matrix :math:`A` or for batches of symmetric positive-definite matrices.

        If :attr:`upper` is ``True``, the returned matrix ``U`` is upper-triangular, and
        the decomposition has the form:

        .. math::

          A = U^TU

        If :attr:`upper` is ``False``, the returned matrix ``L`` is lower-triangular, and
        the decomposition has the form:

        .. math::

            A = LL^T

        If :attr:`upper` is ``True``, and :math:`A` is a batch of symmetric positive-definite
        matrices, then the returned tensor will be composed of upper-triangular Cholesky factors
        of each of the individual matrices. Similarly, when :attr:`upper` is ``False``, the returned
        tensor will be composed of lower-triangular Cholesky factors of each of the individual
        matrices.

        .. warning::

            :func:`torch.cholesky` is deprecated in favor of :func:`torch.linalg.cholesky`
            and will be removed in a future PyTorch release.

            ``L = torch.cholesky(A)`` should be replaced with

            .. code:: python

                L = torch.linalg.cholesky(A)

            ``U = torch.cholesky(A, upper=True)`` should be replaced with

            .. code:: python

                U = torch.linalg.cholesky(A).mH

            This transform will produce equivalent results for all valid (symmetric positive definite) inputs.

        Args:
            input (Tensor): the input tensor :math:`A` of size :math:`(*, n, n)` where `*` is zero or more
                        batch dimensions consisting of symmetric positive-definite matrices.
            upper (bool, optional): flag that indicates whether to return a
                                    upper or lower triangular matrix. Default: ``False``

        Keyword args:
            out (Tensor, optional): the output matrix

        Example::

            >>> a = torch.randn(3, 3)
            >>> a = a @ a.mT + 1e-3 # make symmetric positive-definite
            >>> l = torch.cholesky(a)
            >>> a
            tensor([[ 2.4112, -0.7486,  1.4551],
                    [-0.7486,  1.3544,  0.1294],
                    [ 1.4551,  0.1294,  1.6724]])
            >>> l
            tensor([[ 1.5528,  0.0000,  0.0000],
                    [-0.4821,  1.0592,  0.0000],
                    [ 0.9371,  0.5487,  0.7023]])
            >>> l @ l.mT
            tensor([[ 2.4112, -0.7486,  1.4551],
                    [-0.7486,  1.3544,  0.1294],
                    [ 1.4551,  0.1294,  1.6724]])
            >>> a = torch.randn(3, 2, 2) # Example for batched input
            >>> a = a @ a.mT + 1e-03 # make symmetric positive-definite
            >>> l = torch.cholesky(a)
            >>> z = l @ l.mT
            >>> torch.dist(z, a)
            tensor(2.3842e-07)
        """
    @overload
    @staticmethod
    def cholesky(A, upper=...) -> Any:
        """
        cholesky(input, upper=False, *, out=None) -> Tensor

        Computes the Cholesky decomposition of a symmetric positive-definite
        matrix :math:`A` or for batches of symmetric positive-definite matrices.

        If :attr:`upper` is ``True``, the returned matrix ``U`` is upper-triangular, and
        the decomposition has the form:

        .. math::

          A = U^TU

        If :attr:`upper` is ``False``, the returned matrix ``L`` is lower-triangular, and
        the decomposition has the form:

        .. math::

            A = LL^T

        If :attr:`upper` is ``True``, and :math:`A` is a batch of symmetric positive-definite
        matrices, then the returned tensor will be composed of upper-triangular Cholesky factors
        of each of the individual matrices. Similarly, when :attr:`upper` is ``False``, the returned
        tensor will be composed of lower-triangular Cholesky factors of each of the individual
        matrices.

        .. warning::

            :func:`torch.cholesky` is deprecated in favor of :func:`torch.linalg.cholesky`
            and will be removed in a future PyTorch release.

            ``L = torch.cholesky(A)`` should be replaced with

            .. code:: python

                L = torch.linalg.cholesky(A)

            ``U = torch.cholesky(A, upper=True)`` should be replaced with

            .. code:: python

                U = torch.linalg.cholesky(A).mH

            This transform will produce equivalent results for all valid (symmetric positive definite) inputs.

        Args:
            input (Tensor): the input tensor :math:`A` of size :math:`(*, n, n)` where `*` is zero or more
                        batch dimensions consisting of symmetric positive-definite matrices.
            upper (bool, optional): flag that indicates whether to return a
                                    upper or lower triangular matrix. Default: ``False``

        Keyword args:
            out (Tensor, optional): the output matrix

        Example::

            >>> a = torch.randn(3, 3)
            >>> a = a @ a.mT + 1e-3 # make symmetric positive-definite
            >>> l = torch.cholesky(a)
            >>> a
            tensor([[ 2.4112, -0.7486,  1.4551],
                    [-0.7486,  1.3544,  0.1294],
                    [ 1.4551,  0.1294,  1.6724]])
            >>> l
            tensor([[ 1.5528,  0.0000,  0.0000],
                    [-0.4821,  1.0592,  0.0000],
                    [ 0.9371,  0.5487,  0.7023]])
            >>> l @ l.mT
            tensor([[ 2.4112, -0.7486,  1.4551],
                    [-0.7486,  1.3544,  0.1294],
                    [ 1.4551,  0.1294,  1.6724]])
            >>> a = torch.randn(3, 2, 2) # Example for batched input
            >>> a = a @ a.mT + 1e-03 # make symmetric positive-definite
            >>> l = torch.cholesky(a)
            >>> z = l @ l.mT
            >>> torch.dist(z, a)
            tensor(2.3842e-07)
        """
    @overload
    @staticmethod
    def cholesky(A) -> Any:
        """
        cholesky(input, upper=False, *, out=None) -> Tensor

        Computes the Cholesky decomposition of a symmetric positive-definite
        matrix :math:`A` or for batches of symmetric positive-definite matrices.

        If :attr:`upper` is ``True``, the returned matrix ``U`` is upper-triangular, and
        the decomposition has the form:

        .. math::

          A = U^TU

        If :attr:`upper` is ``False``, the returned matrix ``L`` is lower-triangular, and
        the decomposition has the form:

        .. math::

            A = LL^T

        If :attr:`upper` is ``True``, and :math:`A` is a batch of symmetric positive-definite
        matrices, then the returned tensor will be composed of upper-triangular Cholesky factors
        of each of the individual matrices. Similarly, when :attr:`upper` is ``False``, the returned
        tensor will be composed of lower-triangular Cholesky factors of each of the individual
        matrices.

        .. warning::

            :func:`torch.cholesky` is deprecated in favor of :func:`torch.linalg.cholesky`
            and will be removed in a future PyTorch release.

            ``L = torch.cholesky(A)`` should be replaced with

            .. code:: python

                L = torch.linalg.cholesky(A)

            ``U = torch.cholesky(A, upper=True)`` should be replaced with

            .. code:: python

                U = torch.linalg.cholesky(A).mH

            This transform will produce equivalent results for all valid (symmetric positive definite) inputs.

        Args:
            input (Tensor): the input tensor :math:`A` of size :math:`(*, n, n)` where `*` is zero or more
                        batch dimensions consisting of symmetric positive-definite matrices.
            upper (bool, optional): flag that indicates whether to return a
                                    upper or lower triangular matrix. Default: ``False``

        Keyword args:
            out (Tensor, optional): the output matrix

        Example::

            >>> a = torch.randn(3, 3)
            >>> a = a @ a.mT + 1e-3 # make symmetric positive-definite
            >>> l = torch.cholesky(a)
            >>> a
            tensor([[ 2.4112, -0.7486,  1.4551],
                    [-0.7486,  1.3544,  0.1294],
                    [ 1.4551,  0.1294,  1.6724]])
            >>> l
            tensor([[ 1.5528,  0.0000,  0.0000],
                    [-0.4821,  1.0592,  0.0000],
                    [ 0.9371,  0.5487,  0.7023]])
            >>> l @ l.mT
            tensor([[ 2.4112, -0.7486,  1.4551],
                    [-0.7486,  1.3544,  0.1294],
                    [ 1.4551,  0.1294,  1.6724]])
            >>> a = torch.randn(3, 2, 2) # Example for batched input
            >>> a = a @ a.mT + 1e-03 # make symmetric positive-definite
            >>> l = torch.cholesky(a)
            >>> z = l @ l.mT
            >>> torch.dist(z, a)
            tensor(2.3842e-07)
        """
    @overload
    @staticmethod
    def cholesky(a) -> Any:
        """
        cholesky(input, upper=False, *, out=None) -> Tensor

        Computes the Cholesky decomposition of a symmetric positive-definite
        matrix :math:`A` or for batches of symmetric positive-definite matrices.

        If :attr:`upper` is ``True``, the returned matrix ``U`` is upper-triangular, and
        the decomposition has the form:

        .. math::

          A = U^TU

        If :attr:`upper` is ``False``, the returned matrix ``L`` is lower-triangular, and
        the decomposition has the form:

        .. math::

            A = LL^T

        If :attr:`upper` is ``True``, and :math:`A` is a batch of symmetric positive-definite
        matrices, then the returned tensor will be composed of upper-triangular Cholesky factors
        of each of the individual matrices. Similarly, when :attr:`upper` is ``False``, the returned
        tensor will be composed of lower-triangular Cholesky factors of each of the individual
        matrices.

        .. warning::

            :func:`torch.cholesky` is deprecated in favor of :func:`torch.linalg.cholesky`
            and will be removed in a future PyTorch release.

            ``L = torch.cholesky(A)`` should be replaced with

            .. code:: python

                L = torch.linalg.cholesky(A)

            ``U = torch.cholesky(A, upper=True)`` should be replaced with

            .. code:: python

                U = torch.linalg.cholesky(A).mH

            This transform will produce equivalent results for all valid (symmetric positive definite) inputs.

        Args:
            input (Tensor): the input tensor :math:`A` of size :math:`(*, n, n)` where `*` is zero or more
                        batch dimensions consisting of symmetric positive-definite matrices.
            upper (bool, optional): flag that indicates whether to return a
                                    upper or lower triangular matrix. Default: ``False``

        Keyword args:
            out (Tensor, optional): the output matrix

        Example::

            >>> a = torch.randn(3, 3)
            >>> a = a @ a.mT + 1e-3 # make symmetric positive-definite
            >>> l = torch.cholesky(a)
            >>> a
            tensor([[ 2.4112, -0.7486,  1.4551],
                    [-0.7486,  1.3544,  0.1294],
                    [ 1.4551,  0.1294,  1.6724]])
            >>> l
            tensor([[ 1.5528,  0.0000,  0.0000],
                    [-0.4821,  1.0592,  0.0000],
                    [ 0.9371,  0.5487,  0.7023]])
            >>> l @ l.mT
            tensor([[ 2.4112, -0.7486,  1.4551],
                    [-0.7486,  1.3544,  0.1294],
                    [ 1.4551,  0.1294,  1.6724]])
            >>> a = torch.randn(3, 2, 2) # Example for batched input
            >>> a = a @ a.mT + 1e-03 # make symmetric positive-definite
            >>> l = torch.cholesky(a)
            >>> z = l @ l.mT
            >>> torch.dist(z, a)
            tensor(2.3842e-07)
        """
    @overload
    @staticmethod
    def cholesky(a) -> Any:
        """
        cholesky(input, upper=False, *, out=None) -> Tensor

        Computes the Cholesky decomposition of a symmetric positive-definite
        matrix :math:`A` or for batches of symmetric positive-definite matrices.

        If :attr:`upper` is ``True``, the returned matrix ``U`` is upper-triangular, and
        the decomposition has the form:

        .. math::

          A = U^TU

        If :attr:`upper` is ``False``, the returned matrix ``L`` is lower-triangular, and
        the decomposition has the form:

        .. math::

            A = LL^T

        If :attr:`upper` is ``True``, and :math:`A` is a batch of symmetric positive-definite
        matrices, then the returned tensor will be composed of upper-triangular Cholesky factors
        of each of the individual matrices. Similarly, when :attr:`upper` is ``False``, the returned
        tensor will be composed of lower-triangular Cholesky factors of each of the individual
        matrices.

        .. warning::

            :func:`torch.cholesky` is deprecated in favor of :func:`torch.linalg.cholesky`
            and will be removed in a future PyTorch release.

            ``L = torch.cholesky(A)`` should be replaced with

            .. code:: python

                L = torch.linalg.cholesky(A)

            ``U = torch.cholesky(A, upper=True)`` should be replaced with

            .. code:: python

                U = torch.linalg.cholesky(A).mH

            This transform will produce equivalent results for all valid (symmetric positive definite) inputs.

        Args:
            input (Tensor): the input tensor :math:`A` of size :math:`(*, n, n)` where `*` is zero or more
                        batch dimensions consisting of symmetric positive-definite matrices.
            upper (bool, optional): flag that indicates whether to return a
                                    upper or lower triangular matrix. Default: ``False``

        Keyword args:
            out (Tensor, optional): the output matrix

        Example::

            >>> a = torch.randn(3, 3)
            >>> a = a @ a.mT + 1e-3 # make symmetric positive-definite
            >>> l = torch.cholesky(a)
            >>> a
            tensor([[ 2.4112, -0.7486,  1.4551],
                    [-0.7486,  1.3544,  0.1294],
                    [ 1.4551,  0.1294,  1.6724]])
            >>> l
            tensor([[ 1.5528,  0.0000,  0.0000],
                    [-0.4821,  1.0592,  0.0000],
                    [ 0.9371,  0.5487,  0.7023]])
            >>> l @ l.mT
            tensor([[ 2.4112, -0.7486,  1.4551],
                    [-0.7486,  1.3544,  0.1294],
                    [ 1.4551,  0.1294,  1.6724]])
            >>> a = torch.randn(3, 2, 2) # Example for batched input
            >>> a = a @ a.mT + 1e-03 # make symmetric positive-definite
            >>> l = torch.cholesky(a)
            >>> z = l @ l.mT
            >>> torch.dist(z, a)
            tensor(2.3842e-07)
        """
    @staticmethod
    def cholesky_inverse(L, upper=..., out=...) -> Tensor:
        """
        cholesky_inverse(L, upper=False, *, out=None) -> Tensor

        Computes the inverse of a complex Hermitian or real symmetric
        positive-definite matrix given its Cholesky decomposition.

        Let :math:`A` be a complex Hermitian or real symmetric positive-definite matrix,
        and :math:`L` its Cholesky decomposition such that:

        .. math::

            A = LL^{\\text{H}}

        where :math:`L^{\\text{H}}` is the conjugate transpose when :math:`L` is complex,
        and the transpose when :math:`L` is real-valued.

        Computes the inverse matrix :math:`A^{-1}`.

        Supports input of float, double, cfloat and cdouble dtypes.
        Also supports batches of matrices, and if :math:`A` is a batch of matrices
        then the output has the same batch dimensions.

        Args:
            L (Tensor): tensor of shape `(*, n, n)` where `*` is zero or more batch dimensions
                consisting of lower or upper triangular Cholesky decompositions of
                symmetric or Hermitian positive-definite matrices.
            upper (bool, optional): flag that indicates whether :math:`L` is lower triangular
                or upper triangular. Default: ``False``

        Keyword args:
            out (Tensor, optional): output tensor. Ignored if `None`. Default: `None`.

        Example::

            >>> A = torch.randn(3, 3)
            >>> A = A @ A.T + torch.eye(3) * 1e-3 # Creates a symmetric positive-definite matrix
            >>> L = torch.linalg.cholesky(A) # Extract Cholesky decomposition
            >>> torch.cholesky_inverse(L)
            tensor([[ 1.9314,  1.2251, -0.0889],
                    [ 1.2251,  2.4439,  0.2122],
                    [-0.0889,  0.2122,  0.1412]])
            >>> A.inverse()
            tensor([[ 1.9314,  1.2251, -0.0889],
                    [ 1.2251,  2.4439,  0.2122],
                    [-0.0889,  0.2122,  0.1412]])

            >>> A = torch.randn(3, 2, 2, dtype=torch.complex64)
            >>> A = A @ A.mH + torch.eye(2) * 1e-3 # Batch of Hermitian positive-definite matrices
            >>> L = torch.linalg.cholesky(A)
            >>> torch.dist(torch.inverse(A), torch.cholesky_inverse(L))
            tensor(5.6358e-7)
        """
    @staticmethod
    def cholesky_solve(B, L, upper=..., out=...) -> Tensor:
        """
        cholesky_solve(B, L, upper=False, *, out=None) -> Tensor

        Computes the solution of a system of linear equations with complex Hermitian
        or real symmetric positive-definite lhs given its Cholesky decomposition.

        Let :math:`A` be a complex Hermitian or real symmetric positive-definite matrix,
        and :math:`L` its Cholesky decomposition such that:

        .. math::

            A = LL^{\\text{H}}

        where :math:`L^{\\text{H}}` is the conjugate transpose when :math:`L` is complex,
        and the transpose when :math:`L` is real-valued.

        Returns the solution :math:`X` of the following linear system:

        .. math::

            AX = B

        Supports inputs of float, double, cfloat and cdouble dtypes.
        Also supports batches of matrices, and if :math:`A` or :math:`B` is a batch of matrices
        then the output has the same batch dimensions.

        Args:
            B (Tensor): right-hand side tensor of shape `(*, n, k)`
                where :math:`*` is zero or more batch dimensions
            L (Tensor): tensor of shape `(*, n, n)` where `*` is zero or more batch dimensions
                consisting of lower or upper triangular Cholesky decompositions of
                symmetric or Hermitian positive-definite matrices.
            upper (bool, optional): flag that indicates whether :math:`L` is lower triangular
                or upper triangular. Default: ``False``.

        Keyword args:
            out (Tensor, optional): output tensor. Ignored if `None`. Default: `None`.

        Example::

            >>> A = torch.randn(3, 3)
            >>> A = A @ A.T + torch.eye(3) * 1e-3 # Creates a symmetric positive-definite matrix
            >>> L = torch.linalg.cholesky(A) # Extract Cholesky decomposition
            >>> B = torch.randn(3, 2)
            >>> torch.cholesky_solve(B, L)
            tensor([[ -8.1625,  19.6097],
                    [ -5.8398,  14.2387],
                    [ -4.3771,  10.4173]])
            >>> A.inverse() @  B
            tensor([[ -8.1626,  19.6097],
                    [ -5.8398,  14.2387],
                    [ -4.3771,  10.4173]])

            >>> A = torch.randn(3, 2, 2, dtype=torch.complex64)
            >>> A = A @ A.mH + torch.eye(2) * 1e-3 # Batch of Hermitian positive-definite matrices
            >>> L = torch.linalg.cholesky(A)
            >>> B = torch.randn(2, 1, dtype=torch.complex64)
            >>> X = torch.cholesky_solve(B, L)
            >>> torch.dist(X, A.inverse() @ B)
            tensor(1.6881e-5)
        """
    @staticmethod
    def choose_qparams_optimized(*args, **kwargs): ...
    @staticmethod
    def chunk(input: Tensor, chunks: int, dim: int = ...) -> tuple[Tensor, ...]:
        """
        chunk(input: Tensor, chunks: int, dim: int = 0) -> Tuple[Tensor, ...]

        Attempts to split a tensor into the specified number of chunks. Each chunk is a view of
        the input tensor.


        .. note::

            This function may return fewer than the specified number of chunks!

        .. seealso::

            :func:`torch.tensor_split` a function that always returns exactly the specified number of chunks

        If the tensor size along the given dimension :attr:`dim` is divisible by :attr:`chunks`,
        all returned chunks will be the same size.
        If the tensor size along the given dimension :attr:`dim` is not divisible by :attr:`chunks`,
        all returned chunks will be the same size, except the last one.
        If such division is not possible, this function may return fewer
        than the specified number of chunks.

        Arguments:
            input (Tensor): the tensor to split
            chunks (int): number of chunks to return
            dim (int): dimension along which to split the tensor

        Example:
            >>> torch.arange(11).chunk(6)
            (tensor([0, 1]),
             tensor([2, 3]),
             tensor([4, 5]),
             tensor([6, 7]),
             tensor([8, 9]),
             tensor([10]))
            >>> torch.arange(12).chunk(6)
            (tensor([0, 1]),
             tensor([2, 3]),
             tensor([4, 5]),
             tensor([6, 7]),
             tensor([8, 9]),
             tensor([10, 11]))
            >>> torch.arange(13).chunk(6)
            (tensor([0, 1, 2]),
             tensor([3, 4, 5]),
             tensor([6, 7, 8]),
             tensor([ 9, 10, 11]),
             tensor([12]))
        """
    @staticmethod
    def clamp(input, min=..., max=..., out=...) -> Tensor:
        """
        clamp(input, min=None, max=None, *, out=None) -> Tensor

        Clamps all elements in :attr:`input` into the range `[` :attr:`min`, :attr:`max` `]`.
        Letting min_value and max_value be :attr:`min` and :attr:`max`, respectively, this returns:

        .. math::
            y_i = \\min(\\max(x_i, \\text{min\\_value}_i), \\text{max\\_value}_i)

        If :attr:`min` is ``None``, there is no lower bound.
        Or, if :attr:`max` is ``None`` there is no upper bound.


        .. note::
            If :attr:`min` is greater than :attr:`max` :func:`torch.clamp(..., min, max) <torch.clamp>`
            sets all elements in :attr:`input` to the value of :attr:`max`.

        Args:
            input (Tensor): the input tensor.
            min (Number or Tensor, optional): lower-bound of the range to be clamped to
            max (Number or Tensor, optional): upper-bound of the range to be clamped to

        Keyword args:
            out (Tensor, optional): the output tensor.

        Example::

            >>> a = torch.randn(4)
            >>> a
            tensor([-1.7120,  0.1734, -0.0478, -0.0922])
            >>> torch.clamp(a, min=-0.5, max=0.5)
            tensor([-0.5000,  0.1734, -0.0478, -0.0922])

            >>> min = torch.linspace(-1, 1, steps=4)
            >>> torch.clamp(a, min=min)
            tensor([-1.0000,  0.1734,  0.3333,  1.0000])

        """
    @staticmethod
    def clamp_(*args, **kwargs): ...
    @staticmethod
    def clamp_max(*args, **kwargs): ...
    @staticmethod
    def clamp_max_(*args, **kwargs): ...
    @staticmethod
    def clamp_min(*args, **kwargs): ...
    @staticmethod
    def clamp_min_(*args, **kwargs): ...
    @staticmethod
    def clip(input, min=..., max=..., out=...) -> Tensor:
        """
        clip(input, min=None, max=None, *, out=None) -> Tensor

        Alias for :func:`torch.clamp`.
        """
    @staticmethod
    def clip_(*args, **kwargs): ...
    @staticmethod
    def clone(input, memory_format=...) -> Tensor:
        """
        clone(input, *, memory_format=torch.preserve_format) -> Tensor

        Returns a copy of :attr:`input`.

        .. note::

            This function is differentiable, so gradients will flow back from the
            result of this operation to :attr:`input`. To create a tensor without an
            autograd relationship to :attr:`input` see :meth:`~Tensor.detach`.

        Args:
            input (Tensor): the input tensor.

        Keyword args:
            memory_format (:class:`torch.memory_format`, optional): the desired memory format of
                returned tensor. Default: ``torch.preserve_format``.
        """
    @staticmethod
    def col_indices_copy(*args, **kwargs):
        """
        Performs the same operation as :func:`torch.col_indices`, but all output tensors
        are freshly created instead of aliasing the input.
        """
    @staticmethod
    def column_stack(tensors, out=...) -> Tensor:
        """
        column_stack(tensors, *, out=None) -> Tensor

        Creates a new tensor by horizontally stacking the tensors in :attr:`tensors`.

        Equivalent to ``torch.hstack(tensors)``, except each zero or one dimensional tensor ``t``
        in :attr:`tensors` is first reshaped into a ``(t.numel(), 1)`` column before being stacked horizontally.

        Args:
            tensors (sequence of Tensors): sequence of tensors to concatenate

        Keyword args:
            out (Tensor, optional): the output tensor.

        Example::

            >>> a = torch.tensor([1, 2, 3])
            >>> b = torch.tensor([4, 5, 6])
            >>> torch.column_stack((a, b))
            tensor([[1, 4],
                [2, 5],
                [3, 6]])
            >>> a = torch.arange(5)
            >>> b = torch.arange(10).reshape(5, 2)
            >>> torch.column_stack((a, b, b))
            tensor([[0, 0, 1, 0, 1],
                    [1, 2, 3, 2, 3],
                    [2, 4, 5, 4, 5],
                    [3, 6, 7, 6, 7],
                    [4, 8, 9, 8, 9]])

        """
    @staticmethod
    def combinations(input: Tensor, r: int = ..., with_replacement: bool = ...) -> seq:
        """
        combinations(input: Tensor, r: int = 2, with_replacement: bool = False) -> seq

        Compute combinations of length :math:`r` of the given tensor. The behavior is similar to
        python's `itertools.combinations` when `with_replacement` is set to `False`, and
        `itertools.combinations_with_replacement` when `with_replacement` is set to `True`.

        Arguments:
            input (Tensor): 1D vector.
            r (int, optional): number of elements to combine
            with_replacement (bool, optional): whether to allow duplication in combination

        Returns:
            Tensor: A tensor equivalent to converting all the input tensors into lists, do
            `itertools.combinations` or `itertools.combinations_with_replacement` on these
            lists, and finally convert the resulting list into tensor.

        Example::

            >>> a = [1, 2, 3]
            >>> list(itertools.combinations(a, r=2))
            [(1, 2), (1, 3), (2, 3)]
            >>> list(itertools.combinations(a, r=3))
            [(1, 2, 3)]
            >>> list(itertools.combinations_with_replacement(a, r=2))
            [(1, 1), (1, 2), (1, 3), (2, 2), (2, 3), (3, 3)]
            >>> tensor_a = torch.tensor(a)
            >>> torch.combinations(tensor_a)
            tensor([[1, 2],
                    [1, 3],
                    [2, 3]])
            >>> torch.combinations(tensor_a, r=3)
            tensor([[1, 2, 3]])
            >>> torch.combinations(tensor_a, with_replacement=True)
            tensor([[1, 1],
                    [1, 2],
                    [1, 3],
                    [2, 2],
                    [2, 3],
                    [3, 3]])

        """
    @overload
    @staticmethod
    def complex(real, imag, out=...) -> Tensor:
        """
        complex(real, imag, *, out=None) -> Tensor

        Constructs a complex tensor with its real part equal to :attr:`real` and its
        imaginary part equal to :attr:`imag`.

        Args:
            real (Tensor): The real part of the complex tensor. Must be half, float or double.
            imag (Tensor): The imaginary part of the complex tensor. Must be same dtype
                as :attr:`real`.

        Keyword args:
            out (Tensor): If the inputs are ``torch.float32``, must be
                ``torch.complex64``. If the inputs are ``torch.float64``, must be
                ``torch.complex128``.

        Example::

            >>> real = torch.tensor([1, 2], dtype=torch.float32)
            >>> imag = torch.tensor([3, 4], dtype=torch.float32)
            >>> z = torch.complex(real, imag)
            >>> z
            tensor([(1.+3.j), (2.+4.j)])
            >>> z.dtype
            torch.complex64

        """
    @overload
    @staticmethod
    def complex(real, imag) -> Any:
        """
        complex(real, imag, *, out=None) -> Tensor

        Constructs a complex tensor with its real part equal to :attr:`real` and its
        imaginary part equal to :attr:`imag`.

        Args:
            real (Tensor): The real part of the complex tensor. Must be half, float or double.
            imag (Tensor): The imaginary part of the complex tensor. Must be same dtype
                as :attr:`real`.

        Keyword args:
            out (Tensor): If the inputs are ``torch.float32``, must be
                ``torch.complex64``. If the inputs are ``torch.float64``, must be
                ``torch.complex128``.

        Example::

            >>> real = torch.tensor([1, 2], dtype=torch.float32)
            >>> imag = torch.tensor([3, 4], dtype=torch.float32)
            >>> z = torch.complex(real, imag)
            >>> z
            tensor([(1.+3.j), (2.+4.j)])
            >>> z.dtype
            torch.complex64

        """
    @staticmethod
    def concat(tensors, dim=..., out=...) -> Tensor:
        """
        concat(tensors, dim=0, *, out=None) -> Tensor

        Alias of :func:`torch.cat`.
        """
    @staticmethod
    def concatenate(tensors, axis=..., out=...) -> Tensor:
        """
        concatenate(tensors, axis=0, out=None) -> Tensor

        Alias of :func:`torch.cat`.
        """
    @staticmethod
    def conj(input) -> Tensor:
        """
        conj(input) -> Tensor

        Returns a view of :attr:`input` with a flipped conjugate bit. If :attr:`input` has a non-complex dtype,
        this function just returns :attr:`input`.

        .. note::
            :func:`torch.conj` performs a lazy conjugation, but the actual conjugated tensor can be materialized
            at any time using :func:`torch.resolve_conj`.

        .. warning:: In the future, :func:`torch.conj` may return a non-writeable view for an :attr:`input` of
                     non-complex dtype. It's recommended that programs not modify the tensor returned by :func:`torch.conj_physical`
                     when :attr:`input` is of non-complex dtype to be compatible with this change.

        Args:
            input (Tensor): the input tensor.

        Example::

            >>> x = torch.tensor([-1 + 1j, -2 + 2j, 3 - 3j])
            >>> x.is_conj()
            False
            >>> y = torch.conj(x)
            >>> y.is_conj()
            True
        """
    @staticmethod
    def conj_physical(input, out=...) -> Tensor:
        """
        conj_physical(input, *, out=None) -> Tensor

        Computes the element-wise conjugate of the given :attr:`input` tensor.
        If :attr:`input` has a non-complex dtype, this function just returns :attr:`input`.

        .. note::
           This performs the conjugate operation regardless of the fact conjugate bit is set or not.

        .. warning:: In the future, :func:`torch.conj_physical` may return a non-writeable view for an :attr:`input` of
                     non-complex dtype. It's recommended that programs not modify the tensor returned by :func:`torch.conj_physical`
                     when :attr:`input` is of non-complex dtype to be compatible with this change.

        .. math::
            \\text{out}_{i} = conj(\\text{input}_{i})

        Args:
            input (Tensor): the input tensor.

        Keyword args:
            out (Tensor, optional): the output tensor.

        Example::

            >>> torch.conj_physical(torch.tensor([-1 + 1j, -2 + 2j, 3 - 3j]))
            tensor([-1 - 1j, -2 - 2j, 3 + 3j])
        """
    @staticmethod
    def conj_physical_(*args, **kwargs): ...
    @staticmethod
    def constant_pad_nd(*args, **kwargs): ...
    @staticmethod
    def conv1d(input, weight, bias=..., stride=..., padding=..., dilation=..., groups=...) -> Tensor:
        """
        conv1d(input, weight, bias=None, stride=1, padding=0, dilation=1, groups=1) -> Tensor

        Applies a 1D convolution over an input signal composed of several input
        planes.

        This operator supports :ref:`TensorFloat32<tf32_on_ampere>`.

        See :class:`~torch.nn.Conv1d` for details and output shape.

        Note:
            In some circumstances when given tensors on a CUDA device and using CuDNN, this operator may select a nondeterministic algorithm to increase performance. If this is undesirable, you can try to make the operation deterministic (potentially at a performance cost) by setting ``torch.backends.cudnn.deterministic = True``. See :doc:`/notes/randomness` for more information.

        Note:
            This operator supports complex data types i.e. ``complex32, complex64, complex128``.


        Args:
            input: input tensor of shape :math:`(\\text{minibatch} , \\text{in\\_channels} , iW)`
            weight: filters of shape :math:`(\\text{out\\_channels} , \\frac{\\text{in\\_channels}}{\\text{groups}} , kW)`
            bias: optional bias of shape :math:`(\\text{out\\_channels})`. Default: ``None``
            stride: the stride of the convolving kernel. Can be a single number or
              a one-element tuple `(sW,)`. Default: 1
            padding: implicit paddings on both sides of the input. Can be a string {'valid', 'same'},
              single number or a one-element tuple `(padW,)`. Default: 0
              ``padding='valid'`` is the same as no padding. ``padding='same'`` pads
              the input so the output has the same shape as the input. However, this mode
              doesn't support any stride values other than 1.

              .. warning::
                  For ``padding='same'``, if the ``weight`` is even-length and
                  ``dilation`` is odd in any dimension, a full :func:`pad` operation
                  may be needed internally. Lowering performance.
            dilation: the spacing between kernel elements. Can be a single number or
              a one-element tuple `(dW,)`. Default: 1
            groups: split input into groups, :math:`\\text{in\\_channels}` should be divisible by
              the number of groups. Default: 1

        Examples::

            >>> inputs = torch.randn(33, 16, 30)
            >>> filters = torch.randn(20, 16, 5)
            >>> F.conv1d(inputs, filters)
        """
    @staticmethod
    def conv2d(input, weight, bias=..., stride=..., padding=..., dilation=..., groups=...) -> Tensor:
        """
        conv2d(input, weight, bias=None, stride=1, padding=0, dilation=1, groups=1) -> Tensor

        Applies a 2D convolution over an input image composed of several input
        planes.

        This operator supports :ref:`TensorFloat32<tf32_on_ampere>`.

        See :class:`~torch.nn.Conv2d` for details and output shape.

        Note:
            In some circumstances when given tensors on a CUDA device and using CuDNN, this operator may select a nondeterministic algorithm to increase performance. If this is undesirable, you can try to make the operation deterministic (potentially at a performance cost) by setting ``torch.backends.cudnn.deterministic = True``. See :doc:`/notes/randomness` for more information.

        Note:
            This operator supports complex data types i.e. ``complex32, complex64, complex128``.


        Args:
            input: input tensor of shape :math:`(\\text{minibatch} , \\text{in\\_channels} , iH , iW)`
            weight: filters of shape :math:`(\\text{out\\_channels} , \\frac{\\text{in\\_channels}}{\\text{groups}} , kH , kW)`
            bias: optional bias tensor of shape :math:`(\\text{out\\_channels})`. Default: ``None``
            stride: the stride of the convolving kernel. Can be a single number or a
              tuple `(sH, sW)`. Default: 1
            padding: implicit paddings on both sides of the input. Can be a string {'valid', 'same'},
              single number or a tuple `(padH, padW)`. Default: 0
              ``padding='valid'`` is the same as no padding. ``padding='same'`` pads
              the input so the output has the same shape as the input. However, this mode
              doesn't support any stride values other than 1.

              .. warning::
                  For ``padding='same'``, if the ``weight`` is even-length and
                  ``dilation`` is odd in any dimension, a full :func:`pad` operation
                  may be needed internally. Lowering performance.

            dilation: the spacing between kernel elements. Can be a single number or
              a tuple `(dH, dW)`. Default: 1
            groups: split input into groups, both :math:`\\text{in\\_channels}` and :math:`\\text{out\\_channels}`
              should be divisible by the number of groups. Default: 1

        Examples::

            >>> # With square kernels and equal stride
            >>> filters = torch.randn(8, 4, 3, 3)
            >>> inputs = torch.randn(1, 4, 5, 5)
            >>> F.conv2d(inputs, filters, padding=1)
        """
    @staticmethod
    def conv3d(input, weight, bias=..., stride=..., padding=..., dilation=..., groups=...) -> Tensor:
        """
        conv3d(input, weight, bias=None, stride=1, padding=0, dilation=1, groups=1) -> Tensor

        Applies a 3D convolution over an input image composed of several input
        planes.

        This operator supports :ref:`TensorFloat32<tf32_on_ampere>`.

        See :class:`~torch.nn.Conv3d` for details and output shape.

        Note:
            In some circumstances when given tensors on a CUDA device and using CuDNN, this operator may select a nondeterministic algorithm to increase performance. If this is undesirable, you can try to make the operation deterministic (potentially at a performance cost) by setting ``torch.backends.cudnn.deterministic = True``. See :doc:`/notes/randomness` for more information.

        Note:
            This operator supports complex data types i.e. ``complex32, complex64, complex128``.


        Args:
            input: input tensor of shape :math:`(\\text{minibatch} , \\text{in\\_channels} , iT , iH , iW)`
            weight: filters of shape :math:`(\\text{out\\_channels} , \\frac{\\text{in\\_channels}}{\\text{groups}} , kT , kH , kW)`
            bias: optional bias tensor of shape :math:`(\\text{out\\_channels})`. Default: None
            stride: the stride of the convolving kernel. Can be a single number or a
              tuple `(sT, sH, sW)`. Default: 1
            padding: implicit paddings on both sides of the input. Can be a string {'valid', 'same'},
              single number or a tuple `(padT, padH, padW)`. Default: 0
              ``padding='valid'`` is the same as no padding. ``padding='same'`` pads
              the input so the output has the same shape as the input. However, this mode
              doesn't support any stride values other than 1.

              .. warning::
                  For ``padding='same'``, if the ``weight`` is even-length and
                  ``dilation`` is odd in any dimension, a full :func:`pad` operation
                  may be needed internally. Lowering performance.

            dilation: the spacing between kernel elements. Can be a single number or
              a tuple `(dT, dH, dW)`. Default: 1
            groups: split input into groups, :math:`\\text{in\\_channels}` should be divisible by
              the number of groups. Default: 1

        Examples::

            >>> filters = torch.randn(33, 16, 3, 3, 3)
            >>> inputs = torch.randn(20, 16, 50, 10, 20)
            >>> F.conv3d(inputs, filters)
        """
    @staticmethod
    def conv_tbc(*args, **kwargs):
        """
        Applies a 1-dimensional sequence convolution over an input sequence.
        Input and output dimensions are (Time, Batch, Channels) - hence TBC.

        Args:
            input: input tensor of shape :math:`(\\text{sequence length} \\times batch \\times \\text{in\\_channels})`
            weight: filter of shape (:math:`\\text{kernel width} \\times \\text{in\\_channels} \\times \\text{out\\_channels}`)
            bias: bias of shape (:math:`\\text{out\\_channels}`)
            pad: number of timesteps to pad. Default: 0
        """
    @staticmethod
    def conv_transpose1d(input, weight, bias=..., stride=..., padding=..., output_padding=..., groups=..., dilation=...) -> Tensor:
        '''
        conv_transpose1d(input, weight, bias=None, stride=1, padding=0, output_padding=0, groups=1, dilation=1) -> Tensor

        Applies a 1D transposed convolution operator over an input signal
        composed of several input planes, sometimes also called "deconvolution".

        This operator supports :ref:`TensorFloat32<tf32_on_ampere>`.

        See :class:`~torch.nn.ConvTranspose1d` for details and output shape.

        Note:
            In some circumstances when given tensors on a CUDA device and using CuDNN, this operator may select a nondeterministic algorithm to increase performance. If this is undesirable, you can try to make the operation deterministic (potentially at a performance cost) by setting ``torch.backends.cudnn.deterministic = True``. See :doc:`/notes/randomness` for more information.


        Args:
            input: input tensor of shape :math:`(\\text{minibatch} , \\text{in\\_channels} , iW)`
            weight: filters of shape :math:`(\\text{in\\_channels} , \\frac{\\text{out\\_channels}}{\\text{groups}} , kW)`
            bias: optional bias of shape :math:`(\\text{out\\_channels})`. Default: None
            stride: the stride of the convolving kernel. Can be a single number or a
              tuple ``(sW,)``. Default: 1
            padding: ``dilation * (kernel_size - 1) - padding`` zero-padding will be added to both
              sides of each dimension in the input. Can be a single number or a tuple
              ``(padW,)``. Default: 0
            output_padding: additional size added to one side of each dimension in the
              output shape. Can be a single number or a tuple ``(out_padW)``. Default: 0
            groups: split input into groups, :math:`\\text{in\\_channels}` should be divisible by the
              number of groups. Default: 1
            dilation: the spacing between kernel elements. Can be a single number or
              a tuple ``(dW,)``. Default: 1

        Examples::

            >>> inputs = torch.randn(20, 16, 50)
            >>> weights = torch.randn(16, 33, 5)
            >>> F.conv_transpose1d(inputs, weights)
        '''
    @staticmethod
    def conv_transpose2d(input, weight, bias=..., stride=..., padding=..., output_padding=..., groups=..., dilation=...) -> Tensor:
        '''
        conv_transpose2d(input, weight, bias=None, stride=1, padding=0, output_padding=0, groups=1, dilation=1) -> Tensor

        Applies a 2D transposed convolution operator over an input image
        composed of several input planes, sometimes also called "deconvolution".

        This operator supports :ref:`TensorFloat32<tf32_on_ampere>`.

        See :class:`~torch.nn.ConvTranspose2d` for details and output shape.

        Note:
            In some circumstances when given tensors on a CUDA device and using CuDNN, this operator may select a nondeterministic algorithm to increase performance. If this is undesirable, you can try to make the operation deterministic (potentially at a performance cost) by setting ``torch.backends.cudnn.deterministic = True``. See :doc:`/notes/randomness` for more information.


        Args:
            input: input tensor of shape :math:`(\\text{minibatch} , \\text{in\\_channels} , iH , iW)`
            weight: filters of shape :math:`(\\text{in\\_channels} , \\frac{\\text{out\\_channels}}{\\text{groups}} , kH , kW)`
            bias: optional bias of shape :math:`(\\text{out\\_channels})`. Default: None
            stride: the stride of the convolving kernel. Can be a single number or a
              tuple ``(sH, sW)``. Default: 1
            padding: ``dilation * (kernel_size - 1) - padding`` zero-padding will be added to both
              sides of each dimension in the input. Can be a single number or a tuple
              ``(padH, padW)``. Default: 0
            output_padding: additional size added to one side of each dimension in the
              output shape. Can be a single number or a tuple ``(out_padH, out_padW)``.
              Default: 0
            groups: split input into groups, :math:`\\text{in\\_channels}` should be divisible by the
              number of groups. Default: 1
            dilation: the spacing between kernel elements. Can be a single number or
              a tuple ``(dH, dW)``. Default: 1

        Examples::

            >>> # With square kernels and equal stride
            >>> inputs = torch.randn(1, 4, 5, 5)
            >>> weights = torch.randn(4, 8, 3, 3)
            >>> F.conv_transpose2d(inputs, weights, padding=1)
        '''
    @staticmethod
    def conv_transpose3d(input, weight, bias=..., stride=..., padding=..., output_padding=..., groups=..., dilation=...) -> Tensor:
        '''
        conv_transpose3d(input, weight, bias=None, stride=1, padding=0, output_padding=0, groups=1, dilation=1) -> Tensor

        Applies a 3D transposed convolution operator over an input image
        composed of several input planes, sometimes also called "deconvolution"

        This operator supports :ref:`TensorFloat32<tf32_on_ampere>`.

        See :class:`~torch.nn.ConvTranspose3d` for details and output shape.

        Note:
            In some circumstances when given tensors on a CUDA device and using CuDNN, this operator may select a nondeterministic algorithm to increase performance. If this is undesirable, you can try to make the operation deterministic (potentially at a performance cost) by setting ``torch.backends.cudnn.deterministic = True``. See :doc:`/notes/randomness` for more information.


        Args:
            input: input tensor of shape :math:`(\\text{minibatch} , \\text{in\\_channels} , iT , iH , iW)`
            weight: filters of shape :math:`(\\text{in\\_channels} , \\frac{\\text{out\\_channels}}{\\text{groups}} , kT , kH , kW)`
            bias: optional bias of shape :math:`(\\text{out\\_channels})`. Default: None
            stride: the stride of the convolving kernel. Can be a single number or a
              tuple ``(sT, sH, sW)``. Default: 1
            padding: ``dilation * (kernel_size - 1) - padding`` zero-padding will be added to both
              sides of each dimension in the input. Can be a single number or a tuple
              ``(padT, padH, padW)``. Default: 0
            output_padding: additional size added to one side of each dimension in the
              output shape. Can be a single number or a tuple
              ``(out_padT, out_padH, out_padW)``. Default: 0
            groups: split input into groups, :math:`\\text{in\\_channels}` should be divisible by the
              number of groups. Default: 1
            dilation: the spacing between kernel elements. Can be a single number or
              a tuple `(dT, dH, dW)`. Default: 1

        Examples::

            >>> inputs = torch.randn(20, 16, 50, 10, 20)
            >>> weights = torch.randn(16, 33, 3, 3, 3)
            >>> F.conv_transpose3d(inputs, weights)
        '''
    @staticmethod
    def convolution(*args, **kwargs): ...
    @staticmethod
    def copysign(input, other, out=...) -> Tensor:
        """
        copysign(input, other, *, out=None) -> Tensor

        Create a new floating-point tensor with the magnitude of :attr:`input` and the sign of :attr:`other`, elementwise.

        .. math::
            \\text{out}_{i} = \\begin{cases}
                -|\\text{input}_{i}| & \\text{if } \\text{other}_{i} \\leq -0.0 \\\\\n                 |\\text{input}_{i}| & \\text{if } \\text{other}_{i} \\geq 0.0 \\\\\n            \\end{cases}


        Supports :ref:`broadcasting to a common shape <broadcasting-semantics>`,
        and integer and float inputs.

        Args:
            input (Tensor): magnitudes.
            other (Tensor or Number): contains value(s) whose signbit(s) are
                applied to the magnitudes in :attr:`input`.

        Keyword args:
            out (Tensor, optional): the output tensor.

        Example::

            >>> a = torch.randn(5)
            >>> a
            tensor([-1.2557, -0.0026, -0.5387,  0.4740, -0.9244])
            >>> torch.copysign(a, 1)
            tensor([1.2557, 0.0026, 0.5387, 0.4740, 0.9244])
            >>> a = torch.randn(4, 4)
            >>> a
            tensor([[ 0.7079,  0.2778, -1.0249,  0.5719],
                    [-0.0059, -0.2600, -0.4475, -1.3948],
                    [ 0.3667, -0.9567, -2.5757, -0.1751],
                    [ 0.2046, -0.0742,  0.2998, -0.1054]])
            >>> b = torch.randn(4)
            tensor([ 0.2373,  0.3120,  0.3190, -1.1128])
            >>> torch.copysign(a, b)
            tensor([[ 0.7079,  0.2778,  1.0249, -0.5719],
                    [ 0.0059,  0.2600,  0.4475, -1.3948],
                    [ 0.3667,  0.9567,  2.5757, -0.1751],
                    [ 0.2046,  0.0742,  0.2998, -0.1054]])
            >>> a = torch.tensor([1.])
            >>> b = torch.tensor([-0.])
            >>> torch.copysign(a, b)
            tensor([-1.])

        .. note::
            copysign handles signed zeros. If the other argument has a negative zero (-0),
            the corresponding output value will be negative.

        """
    @staticmethod
    def corrcoef(input) -> Tensor:
        """
        corrcoef(input) -> Tensor

        Estimates the Pearson product-moment correlation coefficient matrix of the variables given by the :attr:`input` matrix,
        where rows are the variables and columns are the observations.

        .. note::

            The correlation coefficient matrix R is computed using the covariance matrix C as given by
            :math:`R_{ij} = \\frac{ C_{ij} } { \\sqrt{ C_{ii} * C_{jj} } }`

        .. note::

            Due to floating point rounding, the resulting array may not be Hermitian and its diagonal elements may not be 1.
            The real and imaginary values are clipped to the interval [-1, 1] in an attempt to improve this situation.

        Args:
            input (Tensor): A 2D matrix containing multiple variables and observations, or a
                Scalar or 1D vector representing a single variable.

        Returns:
            (Tensor) The correlation coefficient matrix of the variables.

        .. seealso::

                :func:`torch.cov` covariance matrix.

        Example::

            >>> x = torch.tensor([[0, 1, 2], [2, 1, 0]])
            >>> torch.corrcoef(x)
            tensor([[ 1., -1.],
                    [-1.,  1.]])
            >>> x = torch.randn(2, 4)
            >>> x
            tensor([[-0.2678, -0.0908, -0.3766,  0.2780],
                    [-0.5812,  0.1535,  0.2387,  0.2350]])
            >>> torch.corrcoef(x)
            tensor([[1.0000, 0.3582],
                    [0.3582, 1.0000]])
            >>> torch.corrcoef(x[0])
            tensor(1.)
        """
    @staticmethod
    def cos(input, out=...) -> Tensor:
        """
        cos(input, *, out=None) -> Tensor

        Returns a new tensor with the cosine  of the elements of :attr:`input`.

        .. math::
            \\text{out}_{i} = \\cos(\\text{input}_{i})

        Args:
            input (Tensor): the input tensor.

        Keyword args:
            out (Tensor, optional): the output tensor.

        Example::

            >>> a = torch.randn(4)
            >>> a
            tensor([ 1.4309,  1.2706, -0.8562,  0.9796])
            >>> torch.cos(a)
            tensor([ 0.1395,  0.2957,  0.6553,  0.5574])
        """
    @staticmethod
    def cos_(*args, **kwargs): ...
    @staticmethod
    def cosh(input, out=...) -> Tensor:
        """
        cosh(input, *, out=None) -> Tensor

        Returns a new tensor with the hyperbolic cosine  of the elements of
        :attr:`input`.

        .. math::
            \\text{out}_{i} = \\cosh(\\text{input}_{i})

        Args:
            input (Tensor): the input tensor.

        Keyword args:
            out (Tensor, optional): the output tensor.

        Example::

            >>> a = torch.randn(4)
            >>> a
            tensor([ 0.1632,  1.1835, -0.6979, -0.7325])
            >>> torch.cosh(a)
            tensor([ 1.0133,  1.7860,  1.2536,  1.2805])

        .. note::
           When :attr:`input` is on the CPU, the implementation of torch.cosh may use
           the Sleef library, which rounds very large results to infinity or negative
           infinity. See `here <https://sleef.org/purec.xhtml>`_ for details.
        """
    @staticmethod
    def cosh_(*args, **kwargs): ...
    @staticmethod
    def cosine_embedding_loss(*args, **kwargs): ...
    @staticmethod
    def cosine_similarity(x1, x2, dim=..., eps=...) -> Tensor:
        """
        cosine_similarity(x1, x2, dim=1, eps=1e-8) -> Tensor

        Returns cosine similarity between ``x1`` and ``x2``, computed along dim. ``x1`` and ``x2`` must be broadcastable
        to a common shape. ``dim`` refers to the dimension in this common shape. Dimension ``dim`` of the output is
        squeezed (see :func:`torch.squeeze`), resulting in the
        output tensor having 1 fewer dimension.

        .. math ::
            \\text{similarity} = \\dfrac{x_1 \\cdot x_2}{\\max(\\Vert x_1 \\Vert _2, \\epsilon) \\cdot \\max(\\Vert x_2 \\Vert _2, \\epsilon)}

        Supports :ref:`type promotion <type-promotion-doc>`.

        Args:
            x1 (Tensor): First input.
            x2 (Tensor): Second input.
            dim (int, optional): Dimension along which cosine similarity is computed. Default: 1
            eps (float, optional): Small value to avoid division by zero.
                Default: 1e-8

        Example::

            >>> input1 = torch.randn(100, 128)
            >>> input2 = torch.randn(100, 128)
            >>> output = F.cosine_similarity(input1, input2)
            >>> print(output)
        """
    @overload
    @staticmethod
    def count_nonzero(input, dim=...) -> Tensor:
        """
        count_nonzero(input, dim=None) -> Tensor

        Counts the number of non-zero values in the tensor :attr:`input` along the given :attr:`dim`.
        If no dim is specified then all non-zeros in the tensor are counted.

        Args:
            input (Tensor): the input tensor.
            dim (int or tuple of ints, optional): Dim or tuple of dims along which to count non-zeros.

        Example::

            >>> x = torch.zeros(3,3)
            >>> x[torch.randn(3,3) > 0.5] = 1
            >>> x
            tensor([[0., 1., 1.],
                    [0., 0., 0.],
                    [0., 0., 1.]])
            >>> torch.count_nonzero(x)
            tensor(3)
            >>> torch.count_nonzero(x, dim=0)
            tensor([0, 1, 2])
        """
    @overload
    @staticmethod
    def count_nonzero(x) -> Any:
        """
        count_nonzero(input, dim=None) -> Tensor

        Counts the number of non-zero values in the tensor :attr:`input` along the given :attr:`dim`.
        If no dim is specified then all non-zeros in the tensor are counted.

        Args:
            input (Tensor): the input tensor.
            dim (int or tuple of ints, optional): Dim or tuple of dims along which to count non-zeros.

        Example::

            >>> x = torch.zeros(3,3)
            >>> x[torch.randn(3,3) > 0.5] = 1
            >>> x
            tensor([[0., 1., 1.],
                    [0., 0., 0.],
                    [0., 0., 1.]])
            >>> torch.count_nonzero(x)
            tensor(3)
            >>> torch.count_nonzero(x, dim=0)
            tensor([0, 1, 2])
        """
    @overload
    @staticmethod
    def count_nonzero(x, dim=...) -> Any:
        """
        count_nonzero(input, dim=None) -> Tensor

        Counts the number of non-zero values in the tensor :attr:`input` along the given :attr:`dim`.
        If no dim is specified then all non-zeros in the tensor are counted.

        Args:
            input (Tensor): the input tensor.
            dim (int or tuple of ints, optional): Dim or tuple of dims along which to count non-zeros.

        Example::

            >>> x = torch.zeros(3,3)
            >>> x[torch.randn(3,3) > 0.5] = 1
            >>> x
            tensor([[0., 1., 1.],
                    [0., 0., 0.],
                    [0., 0., 1.]])
            >>> torch.count_nonzero(x)
            tensor(3)
            >>> torch.count_nonzero(x, dim=0)
            tensor([0, 1, 2])
        """
    @staticmethod
    def cov(input, correction=..., fweights=..., aweights=...) -> Tensor:
        '''
        cov(input, *, correction=1, fweights=None, aweights=None) -> Tensor

        Estimates the covariance matrix of the variables given by the :attr:`input` matrix, where rows are
        the variables and columns are the observations.

        A covariance matrix is a square matrix giving the covariance of each pair of variables. The diagonal contains
        the variance of each variable (covariance of a variable with itself). By definition, if :attr:`input` represents
        a single variable (Scalar or 1D) then its variance is returned.

        The sample covariance of the variables :math:`x` and :math:`y` is given by:

        .. math::
            \\text{cov}(x,y) = \\frac{\\sum^{N}_{i = 1}(x_{i} - \\bar{x})(y_{i} - \\bar{y})}{\\max(0,~N~-~\\delta N)}

        where :math:`\\bar{x}` and :math:`\\bar{y}` are the simple means of the :math:`x` and :math:`y` respectively, and
        :math:`\\delta N` is the :attr:`correction`.

        If :attr:`fweights` and/or :attr:`aweights` are provided, the weighted covariance
        is calculated, which is given by:

        .. math::
            \\text{cov}_w(x,y) = \\frac{\\sum^{N}_{i = 1}w_i(x_{i} - \\mu_x^*)(y_{i} - \\mu_y^*)}
            {\\max(0,~\\sum^{N}_{i = 1}w_i~-~\\frac{\\sum^{N}_{i = 1}w_ia_i}{\\sum^{N}_{i = 1}w_i}~\\delta N)}

        where :math:`w` denotes :attr:`fweights` or :attr:`aweights` (``f`` and ``a`` for brevity) based on whichever is
        provided, or :math:`w = f \\times a` if both are provided, and
        :math:`\\mu_x^* = \\frac{\\sum^{N}_{i = 1}w_ix_{i} }{\\sum^{N}_{i = 1}w_i}` is the weighted mean of the variable. If not
        provided, ``f`` and/or ``a`` can be seen as a :math:`\\mathbb{1}` vector of appropriate size.

        Args:
            input (Tensor): A 2D matrix containing multiple variables and observations, or a
                Scalar or 1D vector representing a single variable.

        Keyword Args:
            correction (int, optional): difference between the sample size and sample degrees of freedom.
                Defaults to Bessel\'s correction, ``correction = 1`` which returns the unbiased estimate,
                even if both :attr:`fweights` and :attr:`aweights` are specified. ``correction = 0``
                will return the simple average. Defaults to ``1``.
            fweights (tensor, optional): A Scalar or 1D tensor of observation vector frequencies representing the number of
                times each observation should be repeated. Its numel must equal the number of columns of :attr:`input`.
                Must have integral dtype. Ignored if ``None``. Defaults to ``None``.
            aweights (tensor, optional): A Scalar or 1D array of observation vector weights.
                These relative weights are typically large for observations considered "important" and smaller for
                observations considered less "important". Its numel must equal the number of columns of :attr:`input`.
                Must have floating point dtype. Ignored if ``None``. Defaults to ``None``.

        Returns:
            (Tensor) The covariance matrix of the variables.

        .. seealso::

                :func:`torch.corrcoef` normalized covariance matrix.

        Example::

            >>> x = torch.tensor([[0, 2], [1, 1], [2, 0]]).T
            >>> x
            tensor([[0, 1, 2],
                    [2, 1, 0]])
            >>> torch.cov(x)
            tensor([[ 1., -1.],
                    [-1.,  1.]])
            >>> torch.cov(x, correction=0)
            tensor([[ 0.6667, -0.6667],
                    [-0.6667,  0.6667]])
            >>> fw = torch.randint(1, 10, (3,))
            >>> fw
            tensor([1, 6, 9])
            >>> aw = torch.rand(3)
            >>> aw
            tensor([0.4282, 0.0255, 0.4144])
            >>> torch.cov(x, fweights=fw, aweights=aw)
            tensor([[ 0.4169, -0.4169],
                    [-0.4169,  0.4169]])
        '''
    @overload
    @staticmethod
    def cross(input, other, dim=..., out=...) -> Tensor:
        """
        cross(input, other, dim=None, *, out=None) -> Tensor


        Returns the cross product of vectors in dimension :attr:`dim` of :attr:`input`
        and :attr:`other`.

        Supports input of float, double, cfloat and cdouble dtypes. Also supports batches
        of vectors, for which it computes the product along the dimension :attr:`dim`.
        In this case, the output has the same batch dimensions as the inputs.

        .. warning::
            If :attr:`dim` is not given, it defaults to the first dimension found
            with the size 3. Note that this might be unexpected.

            This behavior is deprecated and will be changed to match that of :func:`torch.linalg.cross`
            in a future release.

        .. seealso::
                :func:`torch.linalg.cross` which has dim=-1 as default.


        Args:
            input (Tensor): the input tensor.
            other (Tensor): the second input tensor
            dim  (int, optional): the dimension to take the cross-product in.

        Keyword args:
            out (Tensor, optional): the output tensor.

        Example::

            >>> a = torch.randn(4, 3)
            >>> a
            tensor([[-0.3956,  1.1455,  1.6895],
                    [-0.5849,  1.3672,  0.3599],
                    [-1.1626,  0.7180, -0.0521],
                    [-0.1339,  0.9902, -2.0225]])
            >>> b = torch.randn(4, 3)
            >>> b
            tensor([[-0.0257, -1.4725, -1.2251],
                    [-1.1479, -0.7005, -1.9757],
                    [-1.3904,  0.3726, -1.1836],
                    [-0.9688, -0.7153,  0.2159]])
            >>> torch.cross(a, b, dim=1)
            tensor([[ 1.0844, -0.5281,  0.6120],
                    [-2.4490, -1.5687,  1.9792],
                    [-0.8304, -1.3037,  0.5650],
                    [-1.2329,  1.9883,  1.0551]])
            >>> torch.cross(a, b)
            tensor([[ 1.0844, -0.5281,  0.6120],
                    [-2.4490, -1.5687,  1.9792],
                    [-0.8304, -1.3037,  0.5650],
                    [-1.2329,  1.9883,  1.0551]])
        """
    @overload
    @staticmethod
    def cross(a, b, dim=...) -> Any:
        """
        cross(input, other, dim=None, *, out=None) -> Tensor


        Returns the cross product of vectors in dimension :attr:`dim` of :attr:`input`
        and :attr:`other`.

        Supports input of float, double, cfloat and cdouble dtypes. Also supports batches
        of vectors, for which it computes the product along the dimension :attr:`dim`.
        In this case, the output has the same batch dimensions as the inputs.

        .. warning::
            If :attr:`dim` is not given, it defaults to the first dimension found
            with the size 3. Note that this might be unexpected.

            This behavior is deprecated and will be changed to match that of :func:`torch.linalg.cross`
            in a future release.

        .. seealso::
                :func:`torch.linalg.cross` which has dim=-1 as default.


        Args:
            input (Tensor): the input tensor.
            other (Tensor): the second input tensor
            dim  (int, optional): the dimension to take the cross-product in.

        Keyword args:
            out (Tensor, optional): the output tensor.

        Example::

            >>> a = torch.randn(4, 3)
            >>> a
            tensor([[-0.3956,  1.1455,  1.6895],
                    [-0.5849,  1.3672,  0.3599],
                    [-1.1626,  0.7180, -0.0521],
                    [-0.1339,  0.9902, -2.0225]])
            >>> b = torch.randn(4, 3)
            >>> b
            tensor([[-0.0257, -1.4725, -1.2251],
                    [-1.1479, -0.7005, -1.9757],
                    [-1.3904,  0.3726, -1.1836],
                    [-0.9688, -0.7153,  0.2159]])
            >>> torch.cross(a, b, dim=1)
            tensor([[ 1.0844, -0.5281,  0.6120],
                    [-2.4490, -1.5687,  1.9792],
                    [-0.8304, -1.3037,  0.5650],
                    [-1.2329,  1.9883,  1.0551]])
            >>> torch.cross(a, b)
            tensor([[ 1.0844, -0.5281,  0.6120],
                    [-2.4490, -1.5687,  1.9792],
                    [-0.8304, -1.3037,  0.5650],
                    [-1.2329,  1.9883,  1.0551]])
        """
    @overload
    @staticmethod
    def cross(a, b) -> Any:
        """
        cross(input, other, dim=None, *, out=None) -> Tensor


        Returns the cross product of vectors in dimension :attr:`dim` of :attr:`input`
        and :attr:`other`.

        Supports input of float, double, cfloat and cdouble dtypes. Also supports batches
        of vectors, for which it computes the product along the dimension :attr:`dim`.
        In this case, the output has the same batch dimensions as the inputs.

        .. warning::
            If :attr:`dim` is not given, it defaults to the first dimension found
            with the size 3. Note that this might be unexpected.

            This behavior is deprecated and will be changed to match that of :func:`torch.linalg.cross`
            in a future release.

        .. seealso::
                :func:`torch.linalg.cross` which has dim=-1 as default.


        Args:
            input (Tensor): the input tensor.
            other (Tensor): the second input tensor
            dim  (int, optional): the dimension to take the cross-product in.

        Keyword args:
            out (Tensor, optional): the output tensor.

        Example::

            >>> a = torch.randn(4, 3)
            >>> a
            tensor([[-0.3956,  1.1455,  1.6895],
                    [-0.5849,  1.3672,  0.3599],
                    [-1.1626,  0.7180, -0.0521],
                    [-0.1339,  0.9902, -2.0225]])
            >>> b = torch.randn(4, 3)
            >>> b
            tensor([[-0.0257, -1.4725, -1.2251],
                    [-1.1479, -0.7005, -1.9757],
                    [-1.3904,  0.3726, -1.1836],
                    [-0.9688, -0.7153,  0.2159]])
            >>> torch.cross(a, b, dim=1)
            tensor([[ 1.0844, -0.5281,  0.6120],
                    [-2.4490, -1.5687,  1.9792],
                    [-0.8304, -1.3037,  0.5650],
                    [-1.2329,  1.9883,  1.0551]])
            >>> torch.cross(a, b)
            tensor([[ 1.0844, -0.5281,  0.6120],
                    [-2.4490, -1.5687,  1.9792],
                    [-0.8304, -1.3037,  0.5650],
                    [-1.2329,  1.9883,  1.0551]])
        """
    @staticmethod
    def crow_indices_copy(*args, **kwargs):
        """
        Performs the same operation as :func:`torch.crow_indices`, but all output tensors
        are freshly created instead of aliasing the input.
        """
    @staticmethod
    def ctc_loss(*args, **kwargs): ...
    @staticmethod
    def cudnn_affine_grid_generator(*args, **kwargs): ...
    @staticmethod
    def cudnn_batch_norm(*args, **kwargs): ...
    @staticmethod
    def cudnn_convolution(*args, **kwargs): ...
    @staticmethod
    def cudnn_convolution_add_relu(*args, **kwargs): ...
    @staticmethod
    def cudnn_convolution_relu(*args, **kwargs): ...
    @staticmethod
    def cudnn_convolution_transpose(*args, **kwargs): ...
    @staticmethod
    def cudnn_grid_sampler(*args, **kwargs): ...
    @staticmethod
    def cudnn_is_acceptable(*args, **kwargs): ...
    @staticmethod
    def cummax(*args, **kwargs):
        """
        cummax(input, dim, *, out=None) -> (Tensor, LongTensor)
        Returns a namedtuple ``(values, indices)`` where ``values`` is the cumulative maximum of
        elements of :attr:`input` in the dimension :attr:`dim`. And ``indices`` is the index
        location of each maximum value found in the dimension :attr:`dim`.

        .. math::
            y_i = max(x_1, x_2, x_3, \\dots, x_i)

        Args:
            input (Tensor): the input tensor.
            dim  (int): the dimension to do the operation over

        Keyword args:
            out (tuple, optional): the result tuple of two output tensors (values, indices)

        Example::

            >>> a = torch.randn(10)
            >>> a
            tensor([-0.3449, -1.5447,  0.0685, -1.5104, -1.1706,  0.2259,  1.4696, -1.3284,
                 1.9946, -0.8209])
            >>> torch.cummax(a, dim=0)
            torch.return_types.cummax(
                values=tensor([-0.3449, -0.3449,  0.0685,  0.0685,  0.0685,  0.2259,  1.4696,  1.4696,
                 1.9946,  1.9946]),
                indices=tensor([0, 0, 2, 2, 2, 5, 6, 6, 8, 8]))
        """
    @staticmethod
    def cummin(*args, **kwargs):
        """
        cummin(input, dim, *, out=None) -> (Tensor, LongTensor)
        Returns a namedtuple ``(values, indices)`` where ``values`` is the cumulative minimum of
        elements of :attr:`input` in the dimension :attr:`dim`. And ``indices`` is the index
        location of each maximum value found in the dimension :attr:`dim`.

        .. math::
            y_i = min(x_1, x_2, x_3, \\dots, x_i)

        Args:
            input (Tensor): the input tensor.
            dim  (int): the dimension to do the operation over

        Keyword args:
            out (tuple, optional): the result tuple of two output tensors (values, indices)

        Example::

            >>> a = torch.randn(10)
            >>> a
            tensor([-0.2284, -0.6628,  0.0975,  0.2680, -1.3298, -0.4220, -0.3885,  1.1762,
                 0.9165,  1.6684])
            >>> torch.cummin(a, dim=0)
            torch.return_types.cummin(
                values=tensor([-0.2284, -0.6628, -0.6628, -0.6628, -1.3298, -1.3298, -1.3298, -1.3298,
                -1.3298, -1.3298]),
                indices=tensor([0, 1, 1, 1, 4, 4, 4, 4, 4, 4]))
        """
    @staticmethod
    def cumprod(input, dim, dtype=..., out=...) -> Tensor:
        """
        cumprod(input, dim, *, dtype=None, out=None) -> Tensor

        Returns the cumulative product of elements of :attr:`input` in the dimension
        :attr:`dim`.

        For example, if :attr:`input` is a vector of size N, the result will also be
        a vector of size N, with elements.

        .. math::
            y_i = x_1 \\times x_2\\times x_3\\times \\dots \\times x_i

        Args:
            input (Tensor): the input tensor.
            dim  (int): the dimension to do the operation over

        Keyword args:
            dtype (:class:`torch.dtype`, optional): the desired data type of returned tensor.
                If specified, the input tensor is casted to :attr:`dtype` before the operation
                is performed. This is useful for preventing data type overflows. Default: None.
            out (Tensor, optional): the output tensor.

        Example::

            >>> a = torch.randn(10)
            >>> a
            tensor([ 0.6001,  0.2069, -0.1919,  0.9792,  0.6727,  1.0062,  0.4126,
                    -0.2129, -0.4206,  0.1968])
            >>> torch.cumprod(a, dim=0)
            tensor([ 0.6001,  0.1241, -0.0238, -0.0233, -0.0157, -0.0158, -0.0065,
                     0.0014, -0.0006, -0.0001])

            >>> a[5] = 0.0
            >>> torch.cumprod(a, dim=0)
            tensor([ 0.6001,  0.1241, -0.0238, -0.0233, -0.0157, -0.0000, -0.0000,
                     0.0000, -0.0000, -0.0000])
        """
    @staticmethod
    def cumsum(input, dim, dtype=..., out=...) -> Tensor:
        """
        cumsum(input, dim, *, dtype=None, out=None) -> Tensor

        Returns the cumulative sum of elements of :attr:`input` in the dimension
        :attr:`dim`.

        For example, if :attr:`input` is a vector of size N, the result will also be
        a vector of size N, with elements.

        .. math::
            y_i = x_1 + x_2 + x_3 + \\dots + x_i

        Args:
            input (Tensor): the input tensor.
            dim  (int): the dimension to do the operation over

        Keyword args:
            dtype (:class:`torch.dtype`, optional): the desired data type of returned tensor.
                If specified, the input tensor is casted to :attr:`dtype` before the operation
                is performed. This is useful for preventing data type overflows. Default: None.
            out (Tensor, optional): the output tensor.

        Example::

            >>> a = torch.randint(1, 20, (10,))
            >>> a
            tensor([13,  7,  3, 10, 13,  3, 15, 10,  9, 10])
            >>> torch.cumsum(a, dim=0)
            tensor([13, 20, 23, 33, 46, 49, 64, 74, 83, 93])
        """
    @overload
    @staticmethod
    def cumulative_trapezoid(y, x=..., dx=..., dim=...) -> Tensor:
        """
        cumulative_trapezoid(y, x=None, *, dx=None, dim=-1) -> Tensor

        Cumulatively computes the `trapezoidal rule <https://en.wikipedia.org/wiki/Trapezoidal_rule>`_
        along :attr:`dim`. By default the spacing between elements is assumed to be 1, but
        :attr:`dx` can be used to specify a different constant spacing, and :attr:`x` can be
        used to specify arbitrary spacing along :attr:`dim`.

        For more details, please read :func:`torch.trapezoid`. The difference between :func:`torch.trapezoid`
        and this function is that, :func:`torch.trapezoid` returns a value for each integration,
        where as this function returns a cumulative value for every spacing within the integration. This
        is analogous to how `.sum` returns a value and `.cumsum` returns a cumulative sum.

        Arguments:
            y (Tensor): Values to use when computing the trapezoidal rule.
            x (Tensor): If specified, defines spacing between values as specified above.

        Keyword arguments:
            dx (float): constant spacing between values. If neither :attr:`x` or :attr:`dx`
                are specified then this defaults to 1. Effectively multiplies the result by its value.
            dim (int): The dimension along which to compute the trapezoidal rule.
                The last (inner-most) dimension by default.

        Examples::

            >>> # Cumulatively computes the trapezoidal rule in 1D, spacing is implicitly 1.
            >>> y = torch.tensor([1, 5, 10])
            >>> torch.cumulative_trapezoid(y)
            tensor([3., 10.5])

            >>> # Computes the same trapezoidal rule directly up to each element to verify
            >>> (1 + 5) / 2
            3.0
            >>> (1 + 10 + 10) / 2
            10.5

            >>> # Cumulatively computes the trapezoidal rule in 1D with constant spacing of 2
            >>> # NOTE: the result is the same as before, but multiplied by 2
            >>> torch.cumulative_trapezoid(y, dx=2)
            tensor([6., 21.])

            >>> # Cumulatively computes the trapezoidal rule in 1D with arbitrary spacing
            >>> x = torch.tensor([1, 3, 6])
            >>> torch.cumulative_trapezoid(y, x)
            tensor([6., 28.5])

            >>> # Computes the same trapezoidal rule directly up to each element to verify
            >>> ((3 - 1) * (1 + 5)) / 2
            6.0
            >>> ((3 - 1) * (1 + 5) + (6 - 3) * (5 + 10)) / 2
            28.5

            >>> # Cumulatively computes the trapezoidal rule for each row of a 3x3 matrix
            >>> y = torch.arange(9).reshape(3, 3)
            tensor([[0, 1, 2],
                    [3, 4, 5],
                    [6, 7, 8]])
            >>> torch.cumulative_trapezoid(y)
            tensor([[ 0.5,  2.],
                    [ 3.5,  8.],
                    [ 6.5, 14.]])

            >>> # Cumulatively computes the trapezoidal rule for each column of the matrix
            >>> torch.cumulative_trapezoid(y, dim=0)
            tensor([[ 1.5,  2.5,  3.5],
                    [ 6.0,  8.0, 10.0]])

            >>> # Cumulatively computes the trapezoidal rule for each row of a 3x3 ones matrix
            >>> #   with the same arbitrary spacing
            >>> y = torch.ones(3, 3)
            >>> x = torch.tensor([1, 3, 6])
            >>> torch.cumulative_trapezoid(y, x)
            tensor([[2., 5.],
                    [2., 5.],
                    [2., 5.]])

            >>> # Cumulatively computes the trapezoidal rule for each row of a 3x3 ones matrix
            >>> #   with different arbitrary spacing per row
            >>> y = torch.ones(3, 3)
            >>> x = torch.tensor([[1, 2, 3], [1, 3, 5], [1, 4, 7]])
            >>> torch.cumulative_trapezoid(y, x)
            tensor([[1., 2.],
                    [2., 4.],
                    [3., 6.]])
        """
    @overload
    @staticmethod
    def cumulative_trapezoid(y) -> Any:
        """
        cumulative_trapezoid(y, x=None, *, dx=None, dim=-1) -> Tensor

        Cumulatively computes the `trapezoidal rule <https://en.wikipedia.org/wiki/Trapezoidal_rule>`_
        along :attr:`dim`. By default the spacing between elements is assumed to be 1, but
        :attr:`dx` can be used to specify a different constant spacing, and :attr:`x` can be
        used to specify arbitrary spacing along :attr:`dim`.

        For more details, please read :func:`torch.trapezoid`. The difference between :func:`torch.trapezoid`
        and this function is that, :func:`torch.trapezoid` returns a value for each integration,
        where as this function returns a cumulative value for every spacing within the integration. This
        is analogous to how `.sum` returns a value and `.cumsum` returns a cumulative sum.

        Arguments:
            y (Tensor): Values to use when computing the trapezoidal rule.
            x (Tensor): If specified, defines spacing between values as specified above.

        Keyword arguments:
            dx (float): constant spacing between values. If neither :attr:`x` or :attr:`dx`
                are specified then this defaults to 1. Effectively multiplies the result by its value.
            dim (int): The dimension along which to compute the trapezoidal rule.
                The last (inner-most) dimension by default.

        Examples::

            >>> # Cumulatively computes the trapezoidal rule in 1D, spacing is implicitly 1.
            >>> y = torch.tensor([1, 5, 10])
            >>> torch.cumulative_trapezoid(y)
            tensor([3., 10.5])

            >>> # Computes the same trapezoidal rule directly up to each element to verify
            >>> (1 + 5) / 2
            3.0
            >>> (1 + 10 + 10) / 2
            10.5

            >>> # Cumulatively computes the trapezoidal rule in 1D with constant spacing of 2
            >>> # NOTE: the result is the same as before, but multiplied by 2
            >>> torch.cumulative_trapezoid(y, dx=2)
            tensor([6., 21.])

            >>> # Cumulatively computes the trapezoidal rule in 1D with arbitrary spacing
            >>> x = torch.tensor([1, 3, 6])
            >>> torch.cumulative_trapezoid(y, x)
            tensor([6., 28.5])

            >>> # Computes the same trapezoidal rule directly up to each element to verify
            >>> ((3 - 1) * (1 + 5)) / 2
            6.0
            >>> ((3 - 1) * (1 + 5) + (6 - 3) * (5 + 10)) / 2
            28.5

            >>> # Cumulatively computes the trapezoidal rule for each row of a 3x3 matrix
            >>> y = torch.arange(9).reshape(3, 3)
            tensor([[0, 1, 2],
                    [3, 4, 5],
                    [6, 7, 8]])
            >>> torch.cumulative_trapezoid(y)
            tensor([[ 0.5,  2.],
                    [ 3.5,  8.],
                    [ 6.5, 14.]])

            >>> # Cumulatively computes the trapezoidal rule for each column of the matrix
            >>> torch.cumulative_trapezoid(y, dim=0)
            tensor([[ 1.5,  2.5,  3.5],
                    [ 6.0,  8.0, 10.0]])

            >>> # Cumulatively computes the trapezoidal rule for each row of a 3x3 ones matrix
            >>> #   with the same arbitrary spacing
            >>> y = torch.ones(3, 3)
            >>> x = torch.tensor([1, 3, 6])
            >>> torch.cumulative_trapezoid(y, x)
            tensor([[2., 5.],
                    [2., 5.],
                    [2., 5.]])

            >>> # Cumulatively computes the trapezoidal rule for each row of a 3x3 ones matrix
            >>> #   with different arbitrary spacing per row
            >>> y = torch.ones(3, 3)
            >>> x = torch.tensor([[1, 2, 3], [1, 3, 5], [1, 4, 7]])
            >>> torch.cumulative_trapezoid(y, x)
            tensor([[1., 2.],
                    [2., 4.],
                    [3., 6.]])
        """
    @overload
    @staticmethod
    def cumulative_trapezoid(y, dx=...) -> Any:
        """
        cumulative_trapezoid(y, x=None, *, dx=None, dim=-1) -> Tensor

        Cumulatively computes the `trapezoidal rule <https://en.wikipedia.org/wiki/Trapezoidal_rule>`_
        along :attr:`dim`. By default the spacing between elements is assumed to be 1, but
        :attr:`dx` can be used to specify a different constant spacing, and :attr:`x` can be
        used to specify arbitrary spacing along :attr:`dim`.

        For more details, please read :func:`torch.trapezoid`. The difference between :func:`torch.trapezoid`
        and this function is that, :func:`torch.trapezoid` returns a value for each integration,
        where as this function returns a cumulative value for every spacing within the integration. This
        is analogous to how `.sum` returns a value and `.cumsum` returns a cumulative sum.

        Arguments:
            y (Tensor): Values to use when computing the trapezoidal rule.
            x (Tensor): If specified, defines spacing between values as specified above.

        Keyword arguments:
            dx (float): constant spacing between values. If neither :attr:`x` or :attr:`dx`
                are specified then this defaults to 1. Effectively multiplies the result by its value.
            dim (int): The dimension along which to compute the trapezoidal rule.
                The last (inner-most) dimension by default.

        Examples::

            >>> # Cumulatively computes the trapezoidal rule in 1D, spacing is implicitly 1.
            >>> y = torch.tensor([1, 5, 10])
            >>> torch.cumulative_trapezoid(y)
            tensor([3., 10.5])

            >>> # Computes the same trapezoidal rule directly up to each element to verify
            >>> (1 + 5) / 2
            3.0
            >>> (1 + 10 + 10) / 2
            10.5

            >>> # Cumulatively computes the trapezoidal rule in 1D with constant spacing of 2
            >>> # NOTE: the result is the same as before, but multiplied by 2
            >>> torch.cumulative_trapezoid(y, dx=2)
            tensor([6., 21.])

            >>> # Cumulatively computes the trapezoidal rule in 1D with arbitrary spacing
            >>> x = torch.tensor([1, 3, 6])
            >>> torch.cumulative_trapezoid(y, x)
            tensor([6., 28.5])

            >>> # Computes the same trapezoidal rule directly up to each element to verify
            >>> ((3 - 1) * (1 + 5)) / 2
            6.0
            >>> ((3 - 1) * (1 + 5) + (6 - 3) * (5 + 10)) / 2
            28.5

            >>> # Cumulatively computes the trapezoidal rule for each row of a 3x3 matrix
            >>> y = torch.arange(9).reshape(3, 3)
            tensor([[0, 1, 2],
                    [3, 4, 5],
                    [6, 7, 8]])
            >>> torch.cumulative_trapezoid(y)
            tensor([[ 0.5,  2.],
                    [ 3.5,  8.],
                    [ 6.5, 14.]])

            >>> # Cumulatively computes the trapezoidal rule for each column of the matrix
            >>> torch.cumulative_trapezoid(y, dim=0)
            tensor([[ 1.5,  2.5,  3.5],
                    [ 6.0,  8.0, 10.0]])

            >>> # Cumulatively computes the trapezoidal rule for each row of a 3x3 ones matrix
            >>> #   with the same arbitrary spacing
            >>> y = torch.ones(3, 3)
            >>> x = torch.tensor([1, 3, 6])
            >>> torch.cumulative_trapezoid(y, x)
            tensor([[2., 5.],
                    [2., 5.],
                    [2., 5.]])

            >>> # Cumulatively computes the trapezoidal rule for each row of a 3x3 ones matrix
            >>> #   with different arbitrary spacing per row
            >>> y = torch.ones(3, 3)
            >>> x = torch.tensor([[1, 2, 3], [1, 3, 5], [1, 4, 7]])
            >>> torch.cumulative_trapezoid(y, x)
            tensor([[1., 2.],
                    [2., 4.],
                    [3., 6.]])
        """
    @overload
    @staticmethod
    def cumulative_trapezoid(y, x) -> Any:
        """
        cumulative_trapezoid(y, x=None, *, dx=None, dim=-1) -> Tensor

        Cumulatively computes the `trapezoidal rule <https://en.wikipedia.org/wiki/Trapezoidal_rule>`_
        along :attr:`dim`. By default the spacing between elements is assumed to be 1, but
        :attr:`dx` can be used to specify a different constant spacing, and :attr:`x` can be
        used to specify arbitrary spacing along :attr:`dim`.

        For more details, please read :func:`torch.trapezoid`. The difference between :func:`torch.trapezoid`
        and this function is that, :func:`torch.trapezoid` returns a value for each integration,
        where as this function returns a cumulative value for every spacing within the integration. This
        is analogous to how `.sum` returns a value and `.cumsum` returns a cumulative sum.

        Arguments:
            y (Tensor): Values to use when computing the trapezoidal rule.
            x (Tensor): If specified, defines spacing between values as specified above.

        Keyword arguments:
            dx (float): constant spacing between values. If neither :attr:`x` or :attr:`dx`
                are specified then this defaults to 1. Effectively multiplies the result by its value.
            dim (int): The dimension along which to compute the trapezoidal rule.
                The last (inner-most) dimension by default.

        Examples::

            >>> # Cumulatively computes the trapezoidal rule in 1D, spacing is implicitly 1.
            >>> y = torch.tensor([1, 5, 10])
            >>> torch.cumulative_trapezoid(y)
            tensor([3., 10.5])

            >>> # Computes the same trapezoidal rule directly up to each element to verify
            >>> (1 + 5) / 2
            3.0
            >>> (1 + 10 + 10) / 2
            10.5

            >>> # Cumulatively computes the trapezoidal rule in 1D with constant spacing of 2
            >>> # NOTE: the result is the same as before, but multiplied by 2
            >>> torch.cumulative_trapezoid(y, dx=2)
            tensor([6., 21.])

            >>> # Cumulatively computes the trapezoidal rule in 1D with arbitrary spacing
            >>> x = torch.tensor([1, 3, 6])
            >>> torch.cumulative_trapezoid(y, x)
            tensor([6., 28.5])

            >>> # Computes the same trapezoidal rule directly up to each element to verify
            >>> ((3 - 1) * (1 + 5)) / 2
            6.0
            >>> ((3 - 1) * (1 + 5) + (6 - 3) * (5 + 10)) / 2
            28.5

            >>> # Cumulatively computes the trapezoidal rule for each row of a 3x3 matrix
            >>> y = torch.arange(9).reshape(3, 3)
            tensor([[0, 1, 2],
                    [3, 4, 5],
                    [6, 7, 8]])
            >>> torch.cumulative_trapezoid(y)
            tensor([[ 0.5,  2.],
                    [ 3.5,  8.],
                    [ 6.5, 14.]])

            >>> # Cumulatively computes the trapezoidal rule for each column of the matrix
            >>> torch.cumulative_trapezoid(y, dim=0)
            tensor([[ 1.5,  2.5,  3.5],
                    [ 6.0,  8.0, 10.0]])

            >>> # Cumulatively computes the trapezoidal rule for each row of a 3x3 ones matrix
            >>> #   with the same arbitrary spacing
            >>> y = torch.ones(3, 3)
            >>> x = torch.tensor([1, 3, 6])
            >>> torch.cumulative_trapezoid(y, x)
            tensor([[2., 5.],
                    [2., 5.],
                    [2., 5.]])

            >>> # Cumulatively computes the trapezoidal rule for each row of a 3x3 ones matrix
            >>> #   with different arbitrary spacing per row
            >>> y = torch.ones(3, 3)
            >>> x = torch.tensor([[1, 2, 3], [1, 3, 5], [1, 4, 7]])
            >>> torch.cumulative_trapezoid(y, x)
            tensor([[1., 2.],
                    [2., 4.],
                    [3., 6.]])
        """
    @overload
    @staticmethod
    def cumulative_trapezoid(y) -> Any:
        """
        cumulative_trapezoid(y, x=None, *, dx=None, dim=-1) -> Tensor

        Cumulatively computes the `trapezoidal rule <https://en.wikipedia.org/wiki/Trapezoidal_rule>`_
        along :attr:`dim`. By default the spacing between elements is assumed to be 1, but
        :attr:`dx` can be used to specify a different constant spacing, and :attr:`x` can be
        used to specify arbitrary spacing along :attr:`dim`.

        For more details, please read :func:`torch.trapezoid`. The difference between :func:`torch.trapezoid`
        and this function is that, :func:`torch.trapezoid` returns a value for each integration,
        where as this function returns a cumulative value for every spacing within the integration. This
        is analogous to how `.sum` returns a value and `.cumsum` returns a cumulative sum.

        Arguments:
            y (Tensor): Values to use when computing the trapezoidal rule.
            x (Tensor): If specified, defines spacing between values as specified above.

        Keyword arguments:
            dx (float): constant spacing between values. If neither :attr:`x` or :attr:`dx`
                are specified then this defaults to 1. Effectively multiplies the result by its value.
            dim (int): The dimension along which to compute the trapezoidal rule.
                The last (inner-most) dimension by default.

        Examples::

            >>> # Cumulatively computes the trapezoidal rule in 1D, spacing is implicitly 1.
            >>> y = torch.tensor([1, 5, 10])
            >>> torch.cumulative_trapezoid(y)
            tensor([3., 10.5])

            >>> # Computes the same trapezoidal rule directly up to each element to verify
            >>> (1 + 5) / 2
            3.0
            >>> (1 + 10 + 10) / 2
            10.5

            >>> # Cumulatively computes the trapezoidal rule in 1D with constant spacing of 2
            >>> # NOTE: the result is the same as before, but multiplied by 2
            >>> torch.cumulative_trapezoid(y, dx=2)
            tensor([6., 21.])

            >>> # Cumulatively computes the trapezoidal rule in 1D with arbitrary spacing
            >>> x = torch.tensor([1, 3, 6])
            >>> torch.cumulative_trapezoid(y, x)
            tensor([6., 28.5])

            >>> # Computes the same trapezoidal rule directly up to each element to verify
            >>> ((3 - 1) * (1 + 5)) / 2
            6.0
            >>> ((3 - 1) * (1 + 5) + (6 - 3) * (5 + 10)) / 2
            28.5

            >>> # Cumulatively computes the trapezoidal rule for each row of a 3x3 matrix
            >>> y = torch.arange(9).reshape(3, 3)
            tensor([[0, 1, 2],
                    [3, 4, 5],
                    [6, 7, 8]])
            >>> torch.cumulative_trapezoid(y)
            tensor([[ 0.5,  2.],
                    [ 3.5,  8.],
                    [ 6.5, 14.]])

            >>> # Cumulatively computes the trapezoidal rule for each column of the matrix
            >>> torch.cumulative_trapezoid(y, dim=0)
            tensor([[ 1.5,  2.5,  3.5],
                    [ 6.0,  8.0, 10.0]])

            >>> # Cumulatively computes the trapezoidal rule for each row of a 3x3 ones matrix
            >>> #   with the same arbitrary spacing
            >>> y = torch.ones(3, 3)
            >>> x = torch.tensor([1, 3, 6])
            >>> torch.cumulative_trapezoid(y, x)
            tensor([[2., 5.],
                    [2., 5.],
                    [2., 5.]])

            >>> # Cumulatively computes the trapezoidal rule for each row of a 3x3 ones matrix
            >>> #   with different arbitrary spacing per row
            >>> y = torch.ones(3, 3)
            >>> x = torch.tensor([[1, 2, 3], [1, 3, 5], [1, 4, 7]])
            >>> torch.cumulative_trapezoid(y, x)
            tensor([[1., 2.],
                    [2., 4.],
                    [3., 6.]])
        """
    @overload
    @staticmethod
    def cumulative_trapezoid(y, dim=...) -> Any:
        """
        cumulative_trapezoid(y, x=None, *, dx=None, dim=-1) -> Tensor

        Cumulatively computes the `trapezoidal rule <https://en.wikipedia.org/wiki/Trapezoidal_rule>`_
        along :attr:`dim`. By default the spacing between elements is assumed to be 1, but
        :attr:`dx` can be used to specify a different constant spacing, and :attr:`x` can be
        used to specify arbitrary spacing along :attr:`dim`.

        For more details, please read :func:`torch.trapezoid`. The difference between :func:`torch.trapezoid`
        and this function is that, :func:`torch.trapezoid` returns a value for each integration,
        where as this function returns a cumulative value for every spacing within the integration. This
        is analogous to how `.sum` returns a value and `.cumsum` returns a cumulative sum.

        Arguments:
            y (Tensor): Values to use when computing the trapezoidal rule.
            x (Tensor): If specified, defines spacing between values as specified above.

        Keyword arguments:
            dx (float): constant spacing between values. If neither :attr:`x` or :attr:`dx`
                are specified then this defaults to 1. Effectively multiplies the result by its value.
            dim (int): The dimension along which to compute the trapezoidal rule.
                The last (inner-most) dimension by default.

        Examples::

            >>> # Cumulatively computes the trapezoidal rule in 1D, spacing is implicitly 1.
            >>> y = torch.tensor([1, 5, 10])
            >>> torch.cumulative_trapezoid(y)
            tensor([3., 10.5])

            >>> # Computes the same trapezoidal rule directly up to each element to verify
            >>> (1 + 5) / 2
            3.0
            >>> (1 + 10 + 10) / 2
            10.5

            >>> # Cumulatively computes the trapezoidal rule in 1D with constant spacing of 2
            >>> # NOTE: the result is the same as before, but multiplied by 2
            >>> torch.cumulative_trapezoid(y, dx=2)
            tensor([6., 21.])

            >>> # Cumulatively computes the trapezoidal rule in 1D with arbitrary spacing
            >>> x = torch.tensor([1, 3, 6])
            >>> torch.cumulative_trapezoid(y, x)
            tensor([6., 28.5])

            >>> # Computes the same trapezoidal rule directly up to each element to verify
            >>> ((3 - 1) * (1 + 5)) / 2
            6.0
            >>> ((3 - 1) * (1 + 5) + (6 - 3) * (5 + 10)) / 2
            28.5

            >>> # Cumulatively computes the trapezoidal rule for each row of a 3x3 matrix
            >>> y = torch.arange(9).reshape(3, 3)
            tensor([[0, 1, 2],
                    [3, 4, 5],
                    [6, 7, 8]])
            >>> torch.cumulative_trapezoid(y)
            tensor([[ 0.5,  2.],
                    [ 3.5,  8.],
                    [ 6.5, 14.]])

            >>> # Cumulatively computes the trapezoidal rule for each column of the matrix
            >>> torch.cumulative_trapezoid(y, dim=0)
            tensor([[ 1.5,  2.5,  3.5],
                    [ 6.0,  8.0, 10.0]])

            >>> # Cumulatively computes the trapezoidal rule for each row of a 3x3 ones matrix
            >>> #   with the same arbitrary spacing
            >>> y = torch.ones(3, 3)
            >>> x = torch.tensor([1, 3, 6])
            >>> torch.cumulative_trapezoid(y, x)
            tensor([[2., 5.],
                    [2., 5.],
                    [2., 5.]])

            >>> # Cumulatively computes the trapezoidal rule for each row of a 3x3 ones matrix
            >>> #   with different arbitrary spacing per row
            >>> y = torch.ones(3, 3)
            >>> x = torch.tensor([[1, 2, 3], [1, 3, 5], [1, 4, 7]])
            >>> torch.cumulative_trapezoid(y, x)
            tensor([[1., 2.],
                    [2., 4.],
                    [3., 6.]])
        """
    @overload
    @staticmethod
    def cumulative_trapezoid(y, x) -> Any:
        """
        cumulative_trapezoid(y, x=None, *, dx=None, dim=-1) -> Tensor

        Cumulatively computes the `trapezoidal rule <https://en.wikipedia.org/wiki/Trapezoidal_rule>`_
        along :attr:`dim`. By default the spacing between elements is assumed to be 1, but
        :attr:`dx` can be used to specify a different constant spacing, and :attr:`x` can be
        used to specify arbitrary spacing along :attr:`dim`.

        For more details, please read :func:`torch.trapezoid`. The difference between :func:`torch.trapezoid`
        and this function is that, :func:`torch.trapezoid` returns a value for each integration,
        where as this function returns a cumulative value for every spacing within the integration. This
        is analogous to how `.sum` returns a value and `.cumsum` returns a cumulative sum.

        Arguments:
            y (Tensor): Values to use when computing the trapezoidal rule.
            x (Tensor): If specified, defines spacing between values as specified above.

        Keyword arguments:
            dx (float): constant spacing between values. If neither :attr:`x` or :attr:`dx`
                are specified then this defaults to 1. Effectively multiplies the result by its value.
            dim (int): The dimension along which to compute the trapezoidal rule.
                The last (inner-most) dimension by default.

        Examples::

            >>> # Cumulatively computes the trapezoidal rule in 1D, spacing is implicitly 1.
            >>> y = torch.tensor([1, 5, 10])
            >>> torch.cumulative_trapezoid(y)
            tensor([3., 10.5])

            >>> # Computes the same trapezoidal rule directly up to each element to verify
            >>> (1 + 5) / 2
            3.0
            >>> (1 + 10 + 10) / 2
            10.5

            >>> # Cumulatively computes the trapezoidal rule in 1D with constant spacing of 2
            >>> # NOTE: the result is the same as before, but multiplied by 2
            >>> torch.cumulative_trapezoid(y, dx=2)
            tensor([6., 21.])

            >>> # Cumulatively computes the trapezoidal rule in 1D with arbitrary spacing
            >>> x = torch.tensor([1, 3, 6])
            >>> torch.cumulative_trapezoid(y, x)
            tensor([6., 28.5])

            >>> # Computes the same trapezoidal rule directly up to each element to verify
            >>> ((3 - 1) * (1 + 5)) / 2
            6.0
            >>> ((3 - 1) * (1 + 5) + (6 - 3) * (5 + 10)) / 2
            28.5

            >>> # Cumulatively computes the trapezoidal rule for each row of a 3x3 matrix
            >>> y = torch.arange(9).reshape(3, 3)
            tensor([[0, 1, 2],
                    [3, 4, 5],
                    [6, 7, 8]])
            >>> torch.cumulative_trapezoid(y)
            tensor([[ 0.5,  2.],
                    [ 3.5,  8.],
                    [ 6.5, 14.]])

            >>> # Cumulatively computes the trapezoidal rule for each column of the matrix
            >>> torch.cumulative_trapezoid(y, dim=0)
            tensor([[ 1.5,  2.5,  3.5],
                    [ 6.0,  8.0, 10.0]])

            >>> # Cumulatively computes the trapezoidal rule for each row of a 3x3 ones matrix
            >>> #   with the same arbitrary spacing
            >>> y = torch.ones(3, 3)
            >>> x = torch.tensor([1, 3, 6])
            >>> torch.cumulative_trapezoid(y, x)
            tensor([[2., 5.],
                    [2., 5.],
                    [2., 5.]])

            >>> # Cumulatively computes the trapezoidal rule for each row of a 3x3 ones matrix
            >>> #   with different arbitrary spacing per row
            >>> y = torch.ones(3, 3)
            >>> x = torch.tensor([[1, 2, 3], [1, 3, 5], [1, 4, 7]])
            >>> torch.cumulative_trapezoid(y, x)
            tensor([[1., 2.],
                    [2., 4.],
                    [3., 6.]])
        """
    @overload
    @staticmethod
    def cumulative_trapezoid(y, x) -> Any:
        """
        cumulative_trapezoid(y, x=None, *, dx=None, dim=-1) -> Tensor

        Cumulatively computes the `trapezoidal rule <https://en.wikipedia.org/wiki/Trapezoidal_rule>`_
        along :attr:`dim`. By default the spacing between elements is assumed to be 1, but
        :attr:`dx` can be used to specify a different constant spacing, and :attr:`x` can be
        used to specify arbitrary spacing along :attr:`dim`.

        For more details, please read :func:`torch.trapezoid`. The difference between :func:`torch.trapezoid`
        and this function is that, :func:`torch.trapezoid` returns a value for each integration,
        where as this function returns a cumulative value for every spacing within the integration. This
        is analogous to how `.sum` returns a value and `.cumsum` returns a cumulative sum.

        Arguments:
            y (Tensor): Values to use when computing the trapezoidal rule.
            x (Tensor): If specified, defines spacing between values as specified above.

        Keyword arguments:
            dx (float): constant spacing between values. If neither :attr:`x` or :attr:`dx`
                are specified then this defaults to 1. Effectively multiplies the result by its value.
            dim (int): The dimension along which to compute the trapezoidal rule.
                The last (inner-most) dimension by default.

        Examples::

            >>> # Cumulatively computes the trapezoidal rule in 1D, spacing is implicitly 1.
            >>> y = torch.tensor([1, 5, 10])
            >>> torch.cumulative_trapezoid(y)
            tensor([3., 10.5])

            >>> # Computes the same trapezoidal rule directly up to each element to verify
            >>> (1 + 5) / 2
            3.0
            >>> (1 + 10 + 10) / 2
            10.5

            >>> # Cumulatively computes the trapezoidal rule in 1D with constant spacing of 2
            >>> # NOTE: the result is the same as before, but multiplied by 2
            >>> torch.cumulative_trapezoid(y, dx=2)
            tensor([6., 21.])

            >>> # Cumulatively computes the trapezoidal rule in 1D with arbitrary spacing
            >>> x = torch.tensor([1, 3, 6])
            >>> torch.cumulative_trapezoid(y, x)
            tensor([6., 28.5])

            >>> # Computes the same trapezoidal rule directly up to each element to verify
            >>> ((3 - 1) * (1 + 5)) / 2
            6.0
            >>> ((3 - 1) * (1 + 5) + (6 - 3) * (5 + 10)) / 2
            28.5

            >>> # Cumulatively computes the trapezoidal rule for each row of a 3x3 matrix
            >>> y = torch.arange(9).reshape(3, 3)
            tensor([[0, 1, 2],
                    [3, 4, 5],
                    [6, 7, 8]])
            >>> torch.cumulative_trapezoid(y)
            tensor([[ 0.5,  2.],
                    [ 3.5,  8.],
                    [ 6.5, 14.]])

            >>> # Cumulatively computes the trapezoidal rule for each column of the matrix
            >>> torch.cumulative_trapezoid(y, dim=0)
            tensor([[ 1.5,  2.5,  3.5],
                    [ 6.0,  8.0, 10.0]])

            >>> # Cumulatively computes the trapezoidal rule for each row of a 3x3 ones matrix
            >>> #   with the same arbitrary spacing
            >>> y = torch.ones(3, 3)
            >>> x = torch.tensor([1, 3, 6])
            >>> torch.cumulative_trapezoid(y, x)
            tensor([[2., 5.],
                    [2., 5.],
                    [2., 5.]])

            >>> # Cumulatively computes the trapezoidal rule for each row of a 3x3 ones matrix
            >>> #   with different arbitrary spacing per row
            >>> y = torch.ones(3, 3)
            >>> x = torch.tensor([[1, 2, 3], [1, 3, 5], [1, 4, 7]])
            >>> torch.cumulative_trapezoid(y, x)
            tensor([[1., 2.],
                    [2., 4.],
                    [3., 6.]])
        """
    @overload
    @staticmethod
    def deg2rad(input, out=...) -> Tensor:
        """
        deg2rad(input, *, out=None) -> Tensor

        Returns a new tensor with each of the elements of :attr:`input`
        converted from angles in degrees to radians.

        Args:
            input (Tensor): the input tensor.

        Keyword arguments:
            out (Tensor, optional): the output tensor.

        Example::

            >>> a = torch.tensor([[180.0, -180.0], [360.0, -360.0], [90.0, -90.0]])
            >>> torch.deg2rad(a)
            tensor([[ 3.1416, -3.1416],
                    [ 6.2832, -6.2832],
                    [ 1.5708, -1.5708]])

        """
    @overload
    @staticmethod
    def deg2rad(a) -> Any:
        """
        deg2rad(input, *, out=None) -> Tensor

        Returns a new tensor with each of the elements of :attr:`input`
        converted from angles in degrees to radians.

        Args:
            input (Tensor): the input tensor.

        Keyword arguments:
            out (Tensor, optional): the output tensor.

        Example::

            >>> a = torch.tensor([[180.0, -180.0], [360.0, -360.0], [90.0, -90.0]])
            >>> torch.deg2rad(a)
            tensor([[ 3.1416, -3.1416],
                    [ 6.2832, -6.2832],
                    [ 1.5708, -1.5708]])

        """
    @staticmethod
    def deg2rad_(*args, **kwargs): ...
    @overload
    @staticmethod
    def dequantize(tensor) -> Tensor:
        """
        dequantize(tensor) -> Tensor

        Returns an fp32 Tensor by dequantizing a quantized Tensor

        Args:
            tensor (Tensor): A quantized Tensor

        .. function:: dequantize(tensors) -> sequence of Tensors
           :noindex:

        Given a list of quantized Tensors, dequantize them and return a list of fp32 Tensors

        Args:
             tensors (sequence of Tensors): A list of quantized Tensors
        """
    @overload
    @staticmethod
    def dequantize(tensors) -> sequenceofTensors:
        """
        dequantize(tensor) -> Tensor

        Returns an fp32 Tensor by dequantizing a quantized Tensor

        Args:
            tensor (Tensor): A quantized Tensor

        .. function:: dequantize(tensors) -> sequence of Tensors
           :noindex:

        Given a list of quantized Tensors, dequantize them and return a list of fp32 Tensors

        Args:
             tensors (sequence of Tensors): A list of quantized Tensors
        """
    @staticmethod
    def det(input) -> Tensor:
        """
        det(input) -> Tensor

        Alias for :func:`torch.linalg.det`
        """
    @staticmethod
    def detach(*args, **kwargs): ...
    @staticmethod
    def detach_(*args, **kwargs): ...
    @staticmethod
    def detach_copy(*args, **kwargs):
        """
        Performs the same operation as :func:`torch.detach`, but all output tensors
        are freshly created instead of aliasing the input.
        """
    @overload
    @staticmethod
    def diag(input, diagonal=..., out=...) -> Tensor:
        """
        diag(input, diagonal=0, *, out=None) -> Tensor

        - If :attr:`input` is a vector (1-D tensor), then returns a 2-D square tensor
          with the elements of :attr:`input` as the diagonal.
        - If :attr:`input` is a matrix (2-D tensor), then returns a 1-D tensor with
          the diagonal elements of :attr:`input`.

        The argument :attr:`diagonal` controls which diagonal to consider:

        - If :attr:`diagonal` = 0, it is the main diagonal.
        - If :attr:`diagonal` > 0, it is above the main diagonal.
        - If :attr:`diagonal` < 0, it is below the main diagonal.

        Args:
            input (Tensor): the input tensor.
            diagonal (int, optional): the diagonal to consider

        Keyword args:
            out (Tensor, optional): the output tensor.

        .. seealso::

                :func:`torch.diagonal` always returns the diagonal of its input.

                :func:`torch.diagflat` always constructs a tensor with diagonal elements
                specified by the input.

        Examples:

        Get the square matrix where the input vector is the diagonal::

            >>> a = torch.randn(3)
            >>> a
            tensor([ 0.5950,-0.0872, 2.3298])
            >>> torch.diag(a)
            tensor([[ 0.5950, 0.0000, 0.0000],
                    [ 0.0000,-0.0872, 0.0000],
                    [ 0.0000, 0.0000, 2.3298]])
            >>> torch.diag(a, 1)
            tensor([[ 0.0000, 0.5950, 0.0000, 0.0000],
                    [ 0.0000, 0.0000,-0.0872, 0.0000],
                    [ 0.0000, 0.0000, 0.0000, 2.3298],
                    [ 0.0000, 0.0000, 0.0000, 0.0000]])

        Get the k-th diagonal of a given matrix::

            >>> a = torch.randn(3, 3)
            >>> a
            tensor([[-0.4264, 0.0255,-0.1064],
                    [ 0.8795,-0.2429, 0.1374],
                    [ 0.1029,-0.6482,-1.6300]])
            >>> torch.diag(a, 0)
            tensor([-0.4264,-0.2429,-1.6300])
            >>> torch.diag(a, 1)
            tensor([ 0.0255, 0.1374])
        """
    @overload
    @staticmethod
    def diag(a) -> Any:
        """
        diag(input, diagonal=0, *, out=None) -> Tensor

        - If :attr:`input` is a vector (1-D tensor), then returns a 2-D square tensor
          with the elements of :attr:`input` as the diagonal.
        - If :attr:`input` is a matrix (2-D tensor), then returns a 1-D tensor with
          the diagonal elements of :attr:`input`.

        The argument :attr:`diagonal` controls which diagonal to consider:

        - If :attr:`diagonal` = 0, it is the main diagonal.
        - If :attr:`diagonal` > 0, it is above the main diagonal.
        - If :attr:`diagonal` < 0, it is below the main diagonal.

        Args:
            input (Tensor): the input tensor.
            diagonal (int, optional): the diagonal to consider

        Keyword args:
            out (Tensor, optional): the output tensor.

        .. seealso::

                :func:`torch.diagonal` always returns the diagonal of its input.

                :func:`torch.diagflat` always constructs a tensor with diagonal elements
                specified by the input.

        Examples:

        Get the square matrix where the input vector is the diagonal::

            >>> a = torch.randn(3)
            >>> a
            tensor([ 0.5950,-0.0872, 2.3298])
            >>> torch.diag(a)
            tensor([[ 0.5950, 0.0000, 0.0000],
                    [ 0.0000,-0.0872, 0.0000],
                    [ 0.0000, 0.0000, 2.3298]])
            >>> torch.diag(a, 1)
            tensor([[ 0.0000, 0.5950, 0.0000, 0.0000],
                    [ 0.0000, 0.0000,-0.0872, 0.0000],
                    [ 0.0000, 0.0000, 0.0000, 2.3298],
                    [ 0.0000, 0.0000, 0.0000, 0.0000]])

        Get the k-th diagonal of a given matrix::

            >>> a = torch.randn(3, 3)
            >>> a
            tensor([[-0.4264, 0.0255,-0.1064],
                    [ 0.8795,-0.2429, 0.1374],
                    [ 0.1029,-0.6482,-1.6300]])
            >>> torch.diag(a, 0)
            tensor([-0.4264,-0.2429,-1.6300])
            >>> torch.diag(a, 1)
            tensor([ 0.0255, 0.1374])
        """
    @overload
    @staticmethod
    def diag_embed(input, offset=..., dim1=..., dim2=...) -> Tensor:
        """
        diag_embed(input, offset=0, dim1=-2, dim2=-1) -> Tensor

        Creates a tensor whose diagonals of certain 2D planes (specified by
        :attr:`dim1` and :attr:`dim2`) are filled by :attr:`input`.
        To facilitate creating batched diagonal matrices, the 2D planes formed by
        the last two dimensions of the returned tensor are chosen by default.

        The argument :attr:`offset` controls which diagonal to consider:

        - If :attr:`offset` = 0, it is the main diagonal.
        - If :attr:`offset` > 0, it is above the main diagonal.
        - If :attr:`offset` < 0, it is below the main diagonal.

        The size of the new matrix will be calculated to make the specified diagonal
        of the size of the last input dimension.
        Note that for :attr:`offset` other than :math:`0`, the order of :attr:`dim1`
        and :attr:`dim2` matters. Exchanging them is equivalent to changing the
        sign of :attr:`offset`.

        Applying :meth:`torch.diagonal` to the output of this function with
        the same arguments yields a matrix identical to input. However,
        :meth:`torch.diagonal` has different default dimensions, so those
        need to be explicitly specified.

        Args:
            input (Tensor): the input tensor. Must be at least 1-dimensional.
            offset (int, optional): which diagonal to consider. Default: 0
                (main diagonal).
            dim1 (int, optional): first dimension with respect to which to
                take diagonal. Default: -2.
            dim2 (int, optional): second dimension with respect to which to
                take diagonal. Default: -1.

        Example::

            >>> a = torch.randn(2, 3)
            >>> torch.diag_embed(a)
            tensor([[[ 1.5410,  0.0000,  0.0000],
                     [ 0.0000, -0.2934,  0.0000],
                     [ 0.0000,  0.0000, -2.1788]],

                    [[ 0.5684,  0.0000,  0.0000],
                     [ 0.0000, -1.0845,  0.0000],
                     [ 0.0000,  0.0000, -1.3986]]])

            >>> torch.diag_embed(a, offset=1, dim1=0, dim2=2)
            tensor([[[ 0.0000,  1.5410,  0.0000,  0.0000],
                     [ 0.0000,  0.5684,  0.0000,  0.0000]],

                    [[ 0.0000,  0.0000, -0.2934,  0.0000],
                     [ 0.0000,  0.0000, -1.0845,  0.0000]],

                    [[ 0.0000,  0.0000,  0.0000, -2.1788],
                     [ 0.0000,  0.0000,  0.0000, -1.3986]],

                    [[ 0.0000,  0.0000,  0.0000,  0.0000],
                     [ 0.0000,  0.0000,  0.0000,  0.0000]]])
        """
    @overload
    @staticmethod
    def diag_embed(a) -> Any:
        """
        diag_embed(input, offset=0, dim1=-2, dim2=-1) -> Tensor

        Creates a tensor whose diagonals of certain 2D planes (specified by
        :attr:`dim1` and :attr:`dim2`) are filled by :attr:`input`.
        To facilitate creating batched diagonal matrices, the 2D planes formed by
        the last two dimensions of the returned tensor are chosen by default.

        The argument :attr:`offset` controls which diagonal to consider:

        - If :attr:`offset` = 0, it is the main diagonal.
        - If :attr:`offset` > 0, it is above the main diagonal.
        - If :attr:`offset` < 0, it is below the main diagonal.

        The size of the new matrix will be calculated to make the specified diagonal
        of the size of the last input dimension.
        Note that for :attr:`offset` other than :math:`0`, the order of :attr:`dim1`
        and :attr:`dim2` matters. Exchanging them is equivalent to changing the
        sign of :attr:`offset`.

        Applying :meth:`torch.diagonal` to the output of this function with
        the same arguments yields a matrix identical to input. However,
        :meth:`torch.diagonal` has different default dimensions, so those
        need to be explicitly specified.

        Args:
            input (Tensor): the input tensor. Must be at least 1-dimensional.
            offset (int, optional): which diagonal to consider. Default: 0
                (main diagonal).
            dim1 (int, optional): first dimension with respect to which to
                take diagonal. Default: -2.
            dim2 (int, optional): second dimension with respect to which to
                take diagonal. Default: -1.

        Example::

            >>> a = torch.randn(2, 3)
            >>> torch.diag_embed(a)
            tensor([[[ 1.5410,  0.0000,  0.0000],
                     [ 0.0000, -0.2934,  0.0000],
                     [ 0.0000,  0.0000, -2.1788]],

                    [[ 0.5684,  0.0000,  0.0000],
                     [ 0.0000, -1.0845,  0.0000],
                     [ 0.0000,  0.0000, -1.3986]]])

            >>> torch.diag_embed(a, offset=1, dim1=0, dim2=2)
            tensor([[[ 0.0000,  1.5410,  0.0000,  0.0000],
                     [ 0.0000,  0.5684,  0.0000,  0.0000]],

                    [[ 0.0000,  0.0000, -0.2934,  0.0000],
                     [ 0.0000,  0.0000, -1.0845,  0.0000]],

                    [[ 0.0000,  0.0000,  0.0000, -2.1788],
                     [ 0.0000,  0.0000,  0.0000, -1.3986]],

                    [[ 0.0000,  0.0000,  0.0000,  0.0000],
                     [ 0.0000,  0.0000,  0.0000,  0.0000]]])
        """
    @overload
    @staticmethod
    def diag_embed(a, offset=..., dim1=..., dim2=...) -> Any:
        """
        diag_embed(input, offset=0, dim1=-2, dim2=-1) -> Tensor

        Creates a tensor whose diagonals of certain 2D planes (specified by
        :attr:`dim1` and :attr:`dim2`) are filled by :attr:`input`.
        To facilitate creating batched diagonal matrices, the 2D planes formed by
        the last two dimensions of the returned tensor are chosen by default.

        The argument :attr:`offset` controls which diagonal to consider:

        - If :attr:`offset` = 0, it is the main diagonal.
        - If :attr:`offset` > 0, it is above the main diagonal.
        - If :attr:`offset` < 0, it is below the main diagonal.

        The size of the new matrix will be calculated to make the specified diagonal
        of the size of the last input dimension.
        Note that for :attr:`offset` other than :math:`0`, the order of :attr:`dim1`
        and :attr:`dim2` matters. Exchanging them is equivalent to changing the
        sign of :attr:`offset`.

        Applying :meth:`torch.diagonal` to the output of this function with
        the same arguments yields a matrix identical to input. However,
        :meth:`torch.diagonal` has different default dimensions, so those
        need to be explicitly specified.

        Args:
            input (Tensor): the input tensor. Must be at least 1-dimensional.
            offset (int, optional): which diagonal to consider. Default: 0
                (main diagonal).
            dim1 (int, optional): first dimension with respect to which to
                take diagonal. Default: -2.
            dim2 (int, optional): second dimension with respect to which to
                take diagonal. Default: -1.

        Example::

            >>> a = torch.randn(2, 3)
            >>> torch.diag_embed(a)
            tensor([[[ 1.5410,  0.0000,  0.0000],
                     [ 0.0000, -0.2934,  0.0000],
                     [ 0.0000,  0.0000, -2.1788]],

                    [[ 0.5684,  0.0000,  0.0000],
                     [ 0.0000, -1.0845,  0.0000],
                     [ 0.0000,  0.0000, -1.3986]]])

            >>> torch.diag_embed(a, offset=1, dim1=0, dim2=2)
            tensor([[[ 0.0000,  1.5410,  0.0000,  0.0000],
                     [ 0.0000,  0.5684,  0.0000,  0.0000]],

                    [[ 0.0000,  0.0000, -0.2934,  0.0000],
                     [ 0.0000,  0.0000, -1.0845,  0.0000]],

                    [[ 0.0000,  0.0000,  0.0000, -2.1788],
                     [ 0.0000,  0.0000,  0.0000, -1.3986]],

                    [[ 0.0000,  0.0000,  0.0000,  0.0000],
                     [ 0.0000,  0.0000,  0.0000,  0.0000]]])
        """
    @overload
    @staticmethod
    def diagflat(input, offset=...) -> Tensor:
        """
        diagflat(input, offset=0) -> Tensor

        - If :attr:`input` is a vector (1-D tensor), then returns a 2-D square tensor
          with the elements of :attr:`input` as the diagonal.
        - If :attr:`input` is a tensor with more than one dimension, then returns a
          2-D tensor with diagonal elements equal to a flattened :attr:`input`.

        The argument :attr:`offset` controls which diagonal to consider:

        - If :attr:`offset` = 0, it is the main diagonal.
        - If :attr:`offset` > 0, it is above the main diagonal.
        - If :attr:`offset` < 0, it is below the main diagonal.

        Args:
            input (Tensor): the input tensor.
            offset (int, optional): the diagonal to consider. Default: 0 (main
                diagonal).

        Examples::

            >>> a = torch.randn(3)
            >>> a
            tensor([-0.2956, -0.9068,  0.1695])
            >>> torch.diagflat(a)
            tensor([[-0.2956,  0.0000,  0.0000],
                    [ 0.0000, -0.9068,  0.0000],
                    [ 0.0000,  0.0000,  0.1695]])
            >>> torch.diagflat(a, 1)
            tensor([[ 0.0000, -0.2956,  0.0000,  0.0000],
                    [ 0.0000,  0.0000, -0.9068,  0.0000],
                    [ 0.0000,  0.0000,  0.0000,  0.1695],
                    [ 0.0000,  0.0000,  0.0000,  0.0000]])

            >>> a = torch.randn(2, 2)
            >>> a
            tensor([[ 0.2094, -0.3018],
                    [-0.1516,  1.9342]])
            >>> torch.diagflat(a)
            tensor([[ 0.2094,  0.0000,  0.0000,  0.0000],
                    [ 0.0000, -0.3018,  0.0000,  0.0000],
                    [ 0.0000,  0.0000, -0.1516,  0.0000],
                    [ 0.0000,  0.0000,  0.0000,  1.9342]])
        """
    @overload
    @staticmethod
    def diagflat(a) -> Any:
        """
        diagflat(input, offset=0) -> Tensor

        - If :attr:`input` is a vector (1-D tensor), then returns a 2-D square tensor
          with the elements of :attr:`input` as the diagonal.
        - If :attr:`input` is a tensor with more than one dimension, then returns a
          2-D tensor with diagonal elements equal to a flattened :attr:`input`.

        The argument :attr:`offset` controls which diagonal to consider:

        - If :attr:`offset` = 0, it is the main diagonal.
        - If :attr:`offset` > 0, it is above the main diagonal.
        - If :attr:`offset` < 0, it is below the main diagonal.

        Args:
            input (Tensor): the input tensor.
            offset (int, optional): the diagonal to consider. Default: 0 (main
                diagonal).

        Examples::

            >>> a = torch.randn(3)
            >>> a
            tensor([-0.2956, -0.9068,  0.1695])
            >>> torch.diagflat(a)
            tensor([[-0.2956,  0.0000,  0.0000],
                    [ 0.0000, -0.9068,  0.0000],
                    [ 0.0000,  0.0000,  0.1695]])
            >>> torch.diagflat(a, 1)
            tensor([[ 0.0000, -0.2956,  0.0000,  0.0000],
                    [ 0.0000,  0.0000, -0.9068,  0.0000],
                    [ 0.0000,  0.0000,  0.0000,  0.1695],
                    [ 0.0000,  0.0000,  0.0000,  0.0000]])

            >>> a = torch.randn(2, 2)
            >>> a
            tensor([[ 0.2094, -0.3018],
                    [-0.1516,  1.9342]])
            >>> torch.diagflat(a)
            tensor([[ 0.2094,  0.0000,  0.0000,  0.0000],
                    [ 0.0000, -0.3018,  0.0000,  0.0000],
                    [ 0.0000,  0.0000, -0.1516,  0.0000],
                    [ 0.0000,  0.0000,  0.0000,  1.9342]])
        """
    @overload
    @staticmethod
    def diagflat(a) -> Any:
        """
        diagflat(input, offset=0) -> Tensor

        - If :attr:`input` is a vector (1-D tensor), then returns a 2-D square tensor
          with the elements of :attr:`input` as the diagonal.
        - If :attr:`input` is a tensor with more than one dimension, then returns a
          2-D tensor with diagonal elements equal to a flattened :attr:`input`.

        The argument :attr:`offset` controls which diagonal to consider:

        - If :attr:`offset` = 0, it is the main diagonal.
        - If :attr:`offset` > 0, it is above the main diagonal.
        - If :attr:`offset` < 0, it is below the main diagonal.

        Args:
            input (Tensor): the input tensor.
            offset (int, optional): the diagonal to consider. Default: 0 (main
                diagonal).

        Examples::

            >>> a = torch.randn(3)
            >>> a
            tensor([-0.2956, -0.9068,  0.1695])
            >>> torch.diagflat(a)
            tensor([[-0.2956,  0.0000,  0.0000],
                    [ 0.0000, -0.9068,  0.0000],
                    [ 0.0000,  0.0000,  0.1695]])
            >>> torch.diagflat(a, 1)
            tensor([[ 0.0000, -0.2956,  0.0000,  0.0000],
                    [ 0.0000,  0.0000, -0.9068,  0.0000],
                    [ 0.0000,  0.0000,  0.0000,  0.1695],
                    [ 0.0000,  0.0000,  0.0000,  0.0000]])

            >>> a = torch.randn(2, 2)
            >>> a
            tensor([[ 0.2094, -0.3018],
                    [-0.1516,  1.9342]])
            >>> torch.diagflat(a)
            tensor([[ 0.2094,  0.0000,  0.0000,  0.0000],
                    [ 0.0000, -0.3018,  0.0000,  0.0000],
                    [ 0.0000,  0.0000, -0.1516,  0.0000],
                    [ 0.0000,  0.0000,  0.0000,  1.9342]])
        """
    @overload
    @staticmethod
    def diagonal(input, offset=..., dim1=..., dim2=...) -> Tensor:
        """
        diagonal(input, offset=0, dim1=0, dim2=1) -> Tensor

        Returns a partial view of :attr:`input` with the its diagonal elements
        with respect to :attr:`dim1` and :attr:`dim2` appended as a dimension
        at the end of the shape.

        The argument :attr:`offset` controls which diagonal to consider:

        - If :attr:`offset` = 0, it is the main diagonal.
        - If :attr:`offset` > 0, it is above the main diagonal.
        - If :attr:`offset` < 0, it is below the main diagonal.

        Applying :meth:`torch.diag_embed` to the output of this function with
        the same arguments yields a diagonal matrix with the diagonal entries
        of the input. However, :meth:`torch.diag_embed` has different default
        dimensions, so those need to be explicitly specified.

        Args:
            input (Tensor): the input tensor. Must be at least 2-dimensional.
            offset (int, optional): which diagonal to consider. Default: 0
                (main diagonal).
            dim1 (int, optional): first dimension with respect to which to
                take diagonal. Default: 0.
            dim2 (int, optional): second dimension with respect to which to
                take diagonal. Default: 1.

        .. note::  To take a batch diagonal, pass in dim1=-2, dim2=-1.

        Examples::

            >>> a = torch.randn(3, 3)
            >>> a
            tensor([[-1.0854,  1.1431, -0.1752],
                    [ 0.8536, -0.0905,  0.0360],
                    [ 0.6927, -0.3735, -0.4945]])


            >>> torch.diagonal(a)
            tensor([-1.0854, -0.0905, -0.4945])


            >>> torch.diagonal(a, 1)
            tensor([ 1.1431,  0.0360])

            >>> b = torch.randn(2, 5)
            >>> b
            tensor([[-1.7948, -1.2731, -0.3181,  2.0200, -1.6745],
                    [ 1.8262, -1.5049,  0.4114,  1.0704, -1.2607]])

            >>> torch.diagonal(b, 1, 1, 0)
            tensor([1.8262])

            >>> x = torch.randn(2, 5, 4, 2)
            >>> torch.diagonal(x, offset=-1, dim1=1, dim2=2)
            tensor([[[-1.2631,  0.3755, -1.5977, -1.8172],
                     [-1.1065,  1.0401, -0.2235, -0.7938]],

                    [[-1.7325, -0.3081,  0.6166,  0.2335],
                     [ 1.0500,  0.7336, -0.3836, -1.1015]]])
        """
    @overload
    @staticmethod
    def diagonal(a) -> Any:
        """
        diagonal(input, offset=0, dim1=0, dim2=1) -> Tensor

        Returns a partial view of :attr:`input` with the its diagonal elements
        with respect to :attr:`dim1` and :attr:`dim2` appended as a dimension
        at the end of the shape.

        The argument :attr:`offset` controls which diagonal to consider:

        - If :attr:`offset` = 0, it is the main diagonal.
        - If :attr:`offset` > 0, it is above the main diagonal.
        - If :attr:`offset` < 0, it is below the main diagonal.

        Applying :meth:`torch.diag_embed` to the output of this function with
        the same arguments yields a diagonal matrix with the diagonal entries
        of the input. However, :meth:`torch.diag_embed` has different default
        dimensions, so those need to be explicitly specified.

        Args:
            input (Tensor): the input tensor. Must be at least 2-dimensional.
            offset (int, optional): which diagonal to consider. Default: 0
                (main diagonal).
            dim1 (int, optional): first dimension with respect to which to
                take diagonal. Default: 0.
            dim2 (int, optional): second dimension with respect to which to
                take diagonal. Default: 1.

        .. note::  To take a batch diagonal, pass in dim1=-2, dim2=-1.

        Examples::

            >>> a = torch.randn(3, 3)
            >>> a
            tensor([[-1.0854,  1.1431, -0.1752],
                    [ 0.8536, -0.0905,  0.0360],
                    [ 0.6927, -0.3735, -0.4945]])


            >>> torch.diagonal(a)
            tensor([-1.0854, -0.0905, -0.4945])


            >>> torch.diagonal(a, 1)
            tensor([ 1.1431,  0.0360])

            >>> b = torch.randn(2, 5)
            >>> b
            tensor([[-1.7948, -1.2731, -0.3181,  2.0200, -1.6745],
                    [ 1.8262, -1.5049,  0.4114,  1.0704, -1.2607]])

            >>> torch.diagonal(b, 1, 1, 0)
            tensor([1.8262])

            >>> x = torch.randn(2, 5, 4, 2)
            >>> torch.diagonal(x, offset=-1, dim1=1, dim2=2)
            tensor([[[-1.2631,  0.3755, -1.5977, -1.8172],
                     [-1.1065,  1.0401, -0.2235, -0.7938]],

                    [[-1.7325, -0.3081,  0.6166,  0.2335],
                     [ 1.0500,  0.7336, -0.3836, -1.1015]]])
        """
    @overload
    @staticmethod
    def diagonal(x, offset=..., dim1=..., dim2=...) -> Any:
        """
        diagonal(input, offset=0, dim1=0, dim2=1) -> Tensor

        Returns a partial view of :attr:`input` with the its diagonal elements
        with respect to :attr:`dim1` and :attr:`dim2` appended as a dimension
        at the end of the shape.

        The argument :attr:`offset` controls which diagonal to consider:

        - If :attr:`offset` = 0, it is the main diagonal.
        - If :attr:`offset` > 0, it is above the main diagonal.
        - If :attr:`offset` < 0, it is below the main diagonal.

        Applying :meth:`torch.diag_embed` to the output of this function with
        the same arguments yields a diagonal matrix with the diagonal entries
        of the input. However, :meth:`torch.diag_embed` has different default
        dimensions, so those need to be explicitly specified.

        Args:
            input (Tensor): the input tensor. Must be at least 2-dimensional.
            offset (int, optional): which diagonal to consider. Default: 0
                (main diagonal).
            dim1 (int, optional): first dimension with respect to which to
                take diagonal. Default: 0.
            dim2 (int, optional): second dimension with respect to which to
                take diagonal. Default: 1.

        .. note::  To take a batch diagonal, pass in dim1=-2, dim2=-1.

        Examples::

            >>> a = torch.randn(3, 3)
            >>> a
            tensor([[-1.0854,  1.1431, -0.1752],
                    [ 0.8536, -0.0905,  0.0360],
                    [ 0.6927, -0.3735, -0.4945]])


            >>> torch.diagonal(a)
            tensor([-1.0854, -0.0905, -0.4945])


            >>> torch.diagonal(a, 1)
            tensor([ 1.1431,  0.0360])

            >>> b = torch.randn(2, 5)
            >>> b
            tensor([[-1.7948, -1.2731, -0.3181,  2.0200, -1.6745],
                    [ 1.8262, -1.5049,  0.4114,  1.0704, -1.2607]])

            >>> torch.diagonal(b, 1, 1, 0)
            tensor([1.8262])

            >>> x = torch.randn(2, 5, 4, 2)
            >>> torch.diagonal(x, offset=-1, dim1=1, dim2=2)
            tensor([[[-1.2631,  0.3755, -1.5977, -1.8172],
                     [-1.1065,  1.0401, -0.2235, -0.7938]],

                    [[-1.7325, -0.3081,  0.6166,  0.2335],
                     [ 1.0500,  0.7336, -0.3836, -1.1015]]])
        """
    @staticmethod
    def diagonal_copy(*args, **kwargs):
        """
        Performs the same operation as :func:`torch.diagonal`, but all output tensors
        are freshly created instead of aliasing the input.
        """
    @staticmethod
    def diagonal_scatter(input, src, offset=..., dim1=..., dim2=...) -> Tensor:
        """
        diagonal_scatter(input, src, offset=0, dim1=0, dim2=1) -> Tensor

        Embeds the values of the :attr:`src` tensor into :attr:`input` along
        the diagonal elements of :attr:`input`, with respect to :attr:`dim1`
        and :attr:`dim2`.

        This function returns a tensor with fresh storage; it does not
        return a view.

        The argument :attr:`offset` controls which diagonal to consider:

        - If :attr:`offset` = 0, it is the main diagonal.
        - If :attr:`offset` > 0, it is above the main diagonal.
        - If :attr:`offset` < 0, it is below the main diagonal.

        Args:
            input (Tensor): the input tensor. Must be at least 2-dimensional.
            src (Tensor): the tensor to embed into :attr:`input`.
            offset (int, optional): which diagonal to consider. Default: 0
                (main diagonal).
            dim1 (int, optional): first dimension with respect to which to
                take diagonal. Default: 0.
            dim2 (int, optional): second dimension with respect to which to
                take diagonal. Default: 1.

        .. note::

            :attr:`src` must be of the proper size in order to be embedded
            into :attr:`input`. Specifically, it should have the same shape as
            ``torch.diagonal(input, offset, dim1, dim2)``

        Examples::

            >>> a = torch.zeros(3, 3)
            >>> a
            tensor([[0., 0., 0.],
                    [0., 0., 0.],
                    [0., 0., 0.]])

            >>> torch.diagonal_scatter(a, torch.ones(3), 0)
            tensor([[1., 0., 0.],
                    [0., 1., 0.],
                    [0., 0., 1.]])

            >>> torch.diagonal_scatter(a, torch.ones(2), 1)
            tensor([[0., 1., 0.],
                    [0., 0., 1.],
                    [0., 0., 0.]])
        """
    @staticmethod
    def diff(input, n=..., dim=..., prepend=..., append=...) -> Tensor:
        """
        diff(input, n=1, dim=-1, prepend=None, append=None) -> Tensor

        Computes the n-th forward difference along the given dimension.

        The first-order differences are given by `out[i] = input[i + 1] - input[i]`. Higher-order
        differences are calculated by using :func:`torch.diff` recursively.

        Args:
            input (Tensor): the tensor to compute the differences on
            n (int, optional): the number of times to recursively compute the difference
            dim (int, optional): the dimension to compute the difference along.
                Default is the last dimension.
            prepend, append (Tensor, optional): values to prepend or append to
                :attr:`input` along :attr:`dim` before computing the difference.
                Their dimensions must be equivalent to that of input, and their shapes
                must match input's shape except on :attr:`dim`.

        Keyword args:
            out (Tensor, optional): the output tensor.

        Example::

            >>> a = torch.tensor([1, 3, 2])
            >>> torch.diff(a)
            tensor([ 2, -1])
            >>> b = torch.tensor([4, 5])
            >>> torch.diff(a, append=b)
            tensor([ 2, -1,  2,  1])
            >>> c = torch.tensor([[1, 2, 3], [3, 4, 5]])
            >>> torch.diff(c, dim=0)
            tensor([[2, 2, 2]])
            >>> torch.diff(c, dim=1)
            tensor([[1, 1],
                    [1, 1]])
        """
    @staticmethod
    def digamma(input, out=...) -> Tensor:
        """
        digamma(input, *, out=None) -> Tensor

        Alias for :func:`torch.special.digamma`.
        """
    @staticmethod
    def dist(input, other, p=...) -> Tensor:
        """
        dist(input, other, p=2) -> Tensor

        Returns the p-norm of (:attr:`input` - :attr:`other`)

        The shapes of :attr:`input` and :attr:`other` must be
        :ref:`broadcastable <broadcasting-semantics>`.

        Args:
            input (Tensor): the input tensor.
            other (Tensor): the Right-hand-side input tensor
            p (float, optional): the norm to be computed

        Example::

            >>> x = torch.randn(4)
            >>> x
            tensor([-1.5393, -0.8675,  0.5916,  1.6321])
            >>> y = torch.randn(4)
            >>> y
            tensor([ 0.0967, -1.0511,  0.6295,  0.8360])
            >>> torch.dist(x, y, 3.5)
            tensor(1.6727)
            >>> torch.dist(x, y, 3)
            tensor(1.6973)
            >>> torch.dist(x, y, 0)
            tensor(4.)
            >>> torch.dist(x, y, 1)
            tensor(2.6537)
        """
    @staticmethod
    def div(input, other, rounding_mode=..., out=...) -> Tensor:
        '''
        div(input, other, *, rounding_mode=None, out=None) -> Tensor

        Divides each element of the input ``input`` by the corresponding element of
        :attr:`other`.

        .. math::
            \\text{out}_i = \\frac{\\text{input}_i}{\\text{other}_i}

        .. note::
            By default, this performs a "true" division like Python 3.
            See the :attr:`rounding_mode` argument for floor division.

        Supports :ref:`broadcasting to a common shape <broadcasting-semantics>`,
        :ref:`type promotion <type-promotion-doc>`, and integer, float, and complex inputs.
        Always promotes integer types to the default scalar type.

        Args:
            input (Tensor): the dividend
            other (Tensor or Number): the divisor

        Keyword args:
            rounding_mode (str, optional): Type of rounding applied to the result:

                * None - default behavior. Performs no rounding and, if both :attr:`input` and
                  :attr:`other` are integer types, promotes the inputs to the default scalar type.
                  Equivalent to true division in Python (the ``/`` operator) and NumPy\'s ``np.true_divide``.
                * ``"trunc"`` - rounds the results of the division towards zero.
                  Equivalent to C-style integer division.
                * ``"floor"`` - rounds the results of the division down.
                  Equivalent to floor division in Python (the ``//`` operator) and NumPy\'s ``np.floor_divide``.

            out (Tensor, optional): the output tensor.

        Examples::

            >>> x = torch.tensor([ 0.3810,  1.2774, -0.2972, -0.3719,  0.4637])
            >>> torch.div(x, 0.5)
            tensor([ 0.7620,  2.5548, -0.5944, -0.7438,  0.9274])

            >>> a = torch.tensor([[-0.3711, -1.9353, -0.4605, -0.2917],
            ...                   [ 0.1815, -1.0111,  0.9805, -1.5923],
            ...                   [ 0.1062,  1.4581,  0.7759, -1.2344],
            ...                   [-0.1830, -0.0313,  1.1908, -1.4757]])
            >>> b = torch.tensor([ 0.8032,  0.2930, -0.8113, -0.2308])
            >>> torch.div(a, b)
            tensor([[-0.4620, -6.6051,  0.5676,  1.2639],
                    [ 0.2260, -3.4509, -1.2086,  6.8990],
                    [ 0.1322,  4.9764, -0.9564,  5.3484],
                    [-0.2278, -0.1068, -1.4678,  6.3938]])

            >>> torch.div(a, b, rounding_mode=\'trunc\')
            tensor([[-0., -6.,  0.,  1.],
                    [ 0., -3., -1.,  6.],
                    [ 0.,  4., -0.,  5.],
                    [-0., -0., -1.,  6.]])

            >>> torch.div(a, b, rounding_mode=\'floor\')
            tensor([[-1., -7.,  0.,  1.],
                    [ 0., -4., -2.,  6.],
                    [ 0.,  4., -1.,  5.],
                    [-1., -1., -2.,  6.]])

        '''
    @staticmethod
    def divide(input, other, rounding_mode=..., out=...) -> Tensor:
        """
        divide(input, other, *, rounding_mode=None, out=None) -> Tensor

        Alias for :func:`torch.div`.
        """
    @staticmethod
    def dot(input, tensor, out=...) -> Tensor:
        """
        dot(input, tensor, *, out=None) -> Tensor

        Computes the dot product of two 1D tensors.

        .. note::

            Unlike NumPy's dot, torch.dot intentionally only supports computing the dot product
            of two 1D tensors with the same number of elements.

        Args:
            input (Tensor): first tensor in the dot product, must be 1D.
            tensor (Tensor): second tensor in the dot product, must be 1D.

        Keyword args:
            out (Tensor, optional): the output tensor.

        Example::

            >>> torch.dot(torch.tensor([2, 3]), torch.tensor([2, 1]))
            tensor(7)

            >>> t1, t2 = torch.tensor([0, 1]), torch.tensor([2, 3])
            >>> torch.dot(t1, t2)
            tensor(3)
        """
    @staticmethod
    def dropout(*args, **kwargs): ...
    @staticmethod
    def dropout_(*args, **kwargs): ...
    @staticmethod
    def dsmm(*args, **kwargs): ...
    @staticmethod
    def dsplit(input, indices_or_sections) -> ListofTensors:
        """
        dsplit(input, indices_or_sections) -> List of Tensors

        Splits :attr:`input`, a tensor with three or more dimensions, into multiple tensors
        depthwise according to :attr:`indices_or_sections`. Each split is a view of
        :attr:`input`.

        This is equivalent to calling torch.tensor_split(input, indices_or_sections, dim=2)
        (the split dimension is 2), except that if :attr:`indices_or_sections` is an integer
        it must evenly divide the split dimension or a runtime error will be thrown.

        This function is based on NumPy's :func:`numpy.dsplit`.

        Args:
            input (Tensor): tensor to split.
            indices_or_sections (int or list or tuple of ints): See argument in :func:`torch.tensor_split`.

        Example::

            >>> t = torch.arange(16.0).reshape(2, 2, 4)
            >>> t
            tensor([[[ 0.,  1.,  2.,  3.],
                     [ 4.,  5.,  6.,  7.]],
                    [[ 8.,  9., 10., 11.],
                     [12., 13., 14., 15.]]])
            >>> torch.dsplit(t, 2)
            (tensor([[[ 0.,  1.],
                    [ 4.,  5.]],
                   [[ 8.,  9.],
                    [12., 13.]]]),
             tensor([[[ 2.,  3.],
                      [ 6.,  7.]],
                     [[10., 11.],
                      [14., 15.]]]))

            >>> torch.dsplit(t, [3, 6])
            (tensor([[[ 0.,  1.,  2.],
                      [ 4.,  5.,  6.]],
                     [[ 8.,  9., 10.],
                      [12., 13., 14.]]]),
             tensor([[[ 3.],
                      [ 7.]],
                     [[11.],
                      [15.]]]),
             tensor([], size=(2, 2, 0)))

        """
    @staticmethod
    def dstack(tensors, out=...) -> Tensor:
        """
        dstack(tensors, *, out=None) -> Tensor

        Stack tensors in sequence depthwise (along third axis).

        This is equivalent to concatenation along the third axis after 1-D and 2-D tensors have been reshaped by :func:`torch.atleast_3d`.

        Args:
            tensors (sequence of Tensors): sequence of tensors to concatenate

        Keyword args:
            out (Tensor, optional): the output tensor.

        Example::

            >>> a = torch.tensor([1, 2, 3])
            >>> b = torch.tensor([4, 5, 6])
            >>> torch.dstack((a,b))
            tensor([[[1, 4],
                     [2, 5],
                     [3, 6]]])
            >>> a = torch.tensor([[1],[2],[3]])
            >>> b = torch.tensor([[4],[5],[6]])
            >>> torch.dstack((a,b))
            tensor([[[1, 4]],
                    [[2, 5]],
                    [[3, 6]]])


        """
    @staticmethod
    def einsum(*args, **kwargs): ...
    @staticmethod
    def embedding(*args, **kwargs): ...
    @staticmethod
    def embedding_bag(*args, **kwargs): ...
    @staticmethod
    def embedding_renorm_(*args, **kwargs): ...
    @staticmethod
    def empty(*args, **kwargs):
        """
        empty(*size, *, out=None, dtype=None, layout=torch.strided, device=None, requires_grad=False, pin_memory=False, memory_format=torch.contiguous_format) -> Tensor

        Returns a tensor filled with uninitialized data. The shape of the tensor is
        defined by the variable argument :attr:`size`.

        .. note::
            If :func:`torch.use_deterministic_algorithms()` and
            :attr:`torch.utils.deterministic.fill_uninitialized_memory` are both set to
            ``True``, the output tensor is initialized to prevent any possible
            nondeterministic behavior from using the data as an input to an operation.
            Floating point and complex tensors are filled with NaN, and integer tensors
            are filled with the maximum value.

        Args:
            size (int...): a sequence of integers defining the shape of the output tensor.
                Can be a variable number of arguments or a collection like a list or tuple.

        Keyword args:
            out (Tensor, optional): the output tensor.
            dtype (:class:`torch.dtype`, optional): the desired data type of returned tensor.
                Default: if ``None``, uses a global default (see :func:`torch.set_default_dtype`).
            layout (:class:`torch.layout`, optional): the desired layout of returned Tensor.
                Default: ``torch.strided``.
            device (:class:`torch.device`, optional): the desired device of returned tensor.
                Default: if ``None``, uses the current device for the default tensor type
                (see :func:`torch.set_default_device`). :attr:`device` will be the CPU
                for CPU tensor types and the current CUDA device for CUDA tensor types.
            requires_grad (bool, optional): If autograd should record operations on the
                returned tensor. Default: ``False``.
            pin_memory (bool, optional): If set, returned tensor would be allocated in
                the pinned memory. Works only for CPU tensors. Default: ``False``.
            memory_format (:class:`torch.memory_format`, optional): the desired memory format of
                returned Tensor. Default: ``torch.contiguous_format``.

        Example::

            >>> torch.empty((2,3), dtype=torch.int64)
            tensor([[ 9.4064e+13,  2.8000e+01,  9.3493e+13],
                    [ 7.5751e+18,  7.1428e+18,  7.5955e+18]])
        """
    @overload
    @staticmethod
    def empty_like(input, dtype=..., layout=..., device=..., requires_grad=..., memory_format=...) -> Tensor:
        """
        empty_like(input, *, dtype=None, layout=None, device=None, requires_grad=False, memory_format=torch.preserve_format) -> Tensor

        Returns an uninitialized tensor with the same size as :attr:`input`.
        ``torch.empty_like(input)`` is equivalent to
        ``torch.empty(input.size(), dtype=input.dtype, layout=input.layout, device=input.device)``.

        .. note::
            If :func:`torch.use_deterministic_algorithms()` and
            :attr:`torch.utils.deterministic.fill_uninitialized_memory` are both set to
            ``True``, the output tensor is initialized to prevent any possible
            nondeterministic behavior from using the data as an input to an operation.
            Floating point and complex tensors are filled with NaN, and integer tensors
            are filled with the maximum value.

        Args:
            input (Tensor): the size of :attr:`input` will determine size of the output tensor.

        Keyword args:
            dtype (:class:`torch.dtype`, optional): the desired data type of returned Tensor.
                Default: if ``None``, defaults to the dtype of :attr:`input`.
            layout (:class:`torch.layout`, optional): the desired layout of returned tensor.
                Default: if ``None``, defaults to the layout of :attr:`input`.
            device (:class:`torch.device`, optional): the desired device of returned tensor.
                Default: if ``None``, defaults to the device of :attr:`input`.
            requires_grad (bool, optional): If autograd should record operations on the
                returned tensor. Default: ``False``.
            memory_format (:class:`torch.memory_format`, optional): the desired memory format of
                returned Tensor. Default: ``torch.preserve_format``.

        Example::

            >>> a=torch.empty((2,3), dtype=torch.int32, device = 'cuda')
            >>> torch.empty_like(a)
            tensor([[0, 0, 0],
                    [0, 0, 0]], device='cuda:0', dtype=torch.int32)
        """
    @overload
    @staticmethod
    def empty_like(input) -> Any:
        """
        empty_like(input, *, dtype=None, layout=None, device=None, requires_grad=False, memory_format=torch.preserve_format) -> Tensor

        Returns an uninitialized tensor with the same size as :attr:`input`.
        ``torch.empty_like(input)`` is equivalent to
        ``torch.empty(input.size(), dtype=input.dtype, layout=input.layout, device=input.device)``.

        .. note::
            If :func:`torch.use_deterministic_algorithms()` and
            :attr:`torch.utils.deterministic.fill_uninitialized_memory` are both set to
            ``True``, the output tensor is initialized to prevent any possible
            nondeterministic behavior from using the data as an input to an operation.
            Floating point and complex tensors are filled with NaN, and integer tensors
            are filled with the maximum value.

        Args:
            input (Tensor): the size of :attr:`input` will determine size of the output tensor.

        Keyword args:
            dtype (:class:`torch.dtype`, optional): the desired data type of returned Tensor.
                Default: if ``None``, defaults to the dtype of :attr:`input`.
            layout (:class:`torch.layout`, optional): the desired layout of returned tensor.
                Default: if ``None``, defaults to the layout of :attr:`input`.
            device (:class:`torch.device`, optional): the desired device of returned tensor.
                Default: if ``None``, defaults to the device of :attr:`input`.
            requires_grad (bool, optional): If autograd should record operations on the
                returned tensor. Default: ``False``.
            memory_format (:class:`torch.memory_format`, optional): the desired memory format of
                returned Tensor. Default: ``torch.preserve_format``.

        Example::

            >>> a=torch.empty((2,3), dtype=torch.int32, device = 'cuda')
            >>> torch.empty_like(a)
            tensor([[0, 0, 0],
                    [0, 0, 0]], device='cuda:0', dtype=torch.int32)
        """
    @overload
    @staticmethod
    def empty_like(a) -> Any:
        """
        empty_like(input, *, dtype=None, layout=None, device=None, requires_grad=False, memory_format=torch.preserve_format) -> Tensor

        Returns an uninitialized tensor with the same size as :attr:`input`.
        ``torch.empty_like(input)`` is equivalent to
        ``torch.empty(input.size(), dtype=input.dtype, layout=input.layout, device=input.device)``.

        .. note::
            If :func:`torch.use_deterministic_algorithms()` and
            :attr:`torch.utils.deterministic.fill_uninitialized_memory` are both set to
            ``True``, the output tensor is initialized to prevent any possible
            nondeterministic behavior from using the data as an input to an operation.
            Floating point and complex tensors are filled with NaN, and integer tensors
            are filled with the maximum value.

        Args:
            input (Tensor): the size of :attr:`input` will determine size of the output tensor.

        Keyword args:
            dtype (:class:`torch.dtype`, optional): the desired data type of returned Tensor.
                Default: if ``None``, defaults to the dtype of :attr:`input`.
            layout (:class:`torch.layout`, optional): the desired layout of returned tensor.
                Default: if ``None``, defaults to the layout of :attr:`input`.
            device (:class:`torch.device`, optional): the desired device of returned tensor.
                Default: if ``None``, defaults to the device of :attr:`input`.
            requires_grad (bool, optional): If autograd should record operations on the
                returned tensor. Default: ``False``.
            memory_format (:class:`torch.memory_format`, optional): the desired memory format of
                returned Tensor. Default: ``torch.preserve_format``.

        Example::

            >>> a=torch.empty((2,3), dtype=torch.int32, device = 'cuda')
            >>> torch.empty_like(a)
            tensor([[0, 0, 0],
                    [0, 0, 0]], device='cuda:0', dtype=torch.int32)
        """
    @staticmethod
    def empty_permuted(size, physical_layout, dtype=..., layout=..., device=..., requires_grad=..., pin_memory=...) -> Tensor:
        """
        empty_permuted(size, physical_layout, *, dtype=None, layout=None, device=None, requires_grad=False, pin_memory=False) -> Tensor

        Creates an uninitialized, non-overlapping and dense tensor with the
        specified :attr:`size`, with :attr:`physical_layout` specifying how the
        dimensions are physically laid out in memory (each logical dimension is listed
        from outermost to innermost).  :attr:`physical_layout` is a generalization
        of NCHW/NHWC notation: if each dimension is assigned a number according to
        what order they occur in size (N=0, C=1, H=2, W=3), then NCHW is ``(0, 1, 2, 3)``
        while NHWC is ``(0, 2, 3, 1)``.  Equivalently, the strides of the output
        tensor ``t`` are such that ``t.stride(physical_layout[i]) == contiguous_strides[i]``
        (notably, this function is *not* equivalent to ``torch.empty(size).permute(physical_layout)``).

        Unlike :func:`torch.empty_strided`, this is guaranteed to produce a dense
        tensor with no overlaps.  If possible, prefer using this function over
        :func:`torch.empty_strided` or manual use of :func:`torch.as_strided`.

        .. note::
            If :func:`torch.use_deterministic_algorithms()` and
            :attr:`torch.utils.deterministic.fill_uninitialized_memory` are both set to
            ``True``, the output tensor is initialized to prevent any possible
            nondeterministic behavior from using the data as an input to an operation.
            Floating point and complex tensors are filled with NaN, and integer tensors
            are filled with the maximum value.

        Args:
            size (tuple of int): the shape of the output tensor
            physical_layout (tuple of int): the ordering of dimensions physically in memory

        Keyword args:
            dtype (:class:`torch.dtype`, optional): the desired data type of returned tensor.
                Default: if ``None``, uses a global default (see :func:`torch.set_default_dtype`).
            layout (:class:`torch.layout`, optional): the desired layout of returned Tensor.
                Default: ``torch.strided``.
            device (:class:`torch.device`, optional): the desired device of returned tensor.
                Default: if ``None``, uses the current device for the default tensor type
                (see :func:`torch.set_default_device`). :attr:`device` will be the CPU
                for CPU tensor types and the current CUDA device for CUDA tensor types.
            requires_grad (bool, optional): If autograd should record operations on the
                returned tensor. Default: ``False``.
            pin_memory (bool, optional): If set, returned tensor would be allocated in
                the pinned memory. Works only for CPU tensors. Default: ``False``.

        Examples:

            >>> torch.empty((2, 3, 5, 7)).stride()
            (105, 35, 7, 1)
            >>> torch.empty_permuted((2, 3, 5, 7), (0, 1, 2, 3)).stride()
            (105, 35, 7, 1)
            >>> torch.empty((2, 3, 5, 7), memory_format=torch.channels_last).stride()
            (105, 1, 21, 3)
            >>> torch.empty_permuted((2, 3, 5, 7), (0, 2, 3, 1)).stride()
            (105, 1, 21, 3)
            >>> torch.empty_permuted((2, 3, 5, 7), (0, 2, 3, 1)).dim_order()
            (0, 2, 3, 1)
        """
    @staticmethod
    def empty_quantized(*args, **kwargs): ...
    @staticmethod
    def empty_strided(size, stride, dtype=..., layout=..., device=..., requires_grad=..., pin_memory=...) -> Tensor:
        '''
        empty_strided(size, stride, *, dtype=None, layout=None, device=None, requires_grad=False, pin_memory=False) -> Tensor

        Creates a tensor with the specified :attr:`size` and :attr:`stride` and filled with undefined data.

        .. warning::
            If the constructed tensor is "overlapped" (with multiple indices referring to the same element
            in memory) its behavior is undefined.

        .. note::
            If :func:`torch.use_deterministic_algorithms()` and
            :attr:`torch.utils.deterministic.fill_uninitialized_memory` are both set to
            ``True``, the output tensor is initialized to prevent any possible
            nondeterministic behavior from using the data as an input to an operation.
            Floating point and complex tensors are filled with NaN, and integer tensors
            are filled with the maximum value.

        Args:
            size (tuple of int): the shape of the output tensor
            stride (tuple of int): the strides of the output tensor

        Keyword args:
            dtype (:class:`torch.dtype`, optional): the desired data type of returned tensor.
                Default: if ``None``, uses a global default (see :func:`torch.set_default_dtype`).
            layout (:class:`torch.layout`, optional): the desired layout of returned Tensor.
                Default: ``torch.strided``.
            device (:class:`torch.device`, optional): the desired device of returned tensor.
                Default: if ``None``, uses the current device for the default tensor type
                (see :func:`torch.set_default_device`). :attr:`device` will be the CPU
                for CPU tensor types and the current CUDA device for CUDA tensor types.
            requires_grad (bool, optional): If autograd should record operations on the
                returned tensor. Default: ``False``.
            pin_memory (bool, optional): If set, returned tensor would be allocated in
                the pinned memory. Works only for CPU tensors. Default: ``False``.

        Example::

            >>> a = torch.empty_strided((2, 3), (1, 2))
            >>> a
            tensor([[8.9683e-44, 4.4842e-44, 5.1239e+07],
                    [0.0000e+00, 0.0000e+00, 3.0705e-41]])
            >>> a.stride()
            (1, 2)
            >>> a.size()
            torch.Size([2, 3])
        '''
    @staticmethod
    def eq(input, other, out=...) -> Tensor:
        """
        eq(input, other, *, out=None) -> Tensor

        Computes element-wise equality

        The second argument can be a number or a tensor whose shape is
        :ref:`broadcastable <broadcasting-semantics>` with the first argument.

        Args:
            input (Tensor): the tensor to compare
            other (Tensor or float): the tensor or value to compare

        Keyword args:
            out (Tensor, optional): the output tensor.

        Returns:
            A boolean tensor that is True where :attr:`input` is equal to :attr:`other` and False elsewhere

        Example::

            >>> torch.eq(torch.tensor([[1, 2], [3, 4]]), torch.tensor([[1, 1], [4, 4]]))
            tensor([[ True, False],
                    [False, True]])
        """
    @staticmethod
    def equal(input, other) -> bool:
        """
        equal(input, other) -> bool

        ``True`` if two tensors have the same size and elements, ``False`` otherwise.

        .. note::

            Tensors containing NaNs are never equal to each other. Additionally, this function does not
            differentiate between the data types of the tensors during comparison. For more thorough tensor checks,
            use :meth:`torch.testing.assert_close`.

        Example::

            >>> torch.equal(torch.tensor([1, 2]), torch.tensor([1, 2]))
            True
            >>> torch.equal(torch.tensor([3, torch.nan]), torch.tensor([3, torch.nan]))
            False
            >>> torch.equal(torch.tensor([1, 2, 3], dtype=torch.int32), torch.tensor([1, 2, 3], dtype=torch.float32))
            True
        """
    @staticmethod
    def erf(input, out=...) -> Tensor:
        """
        erf(input, *, out=None) -> Tensor

        Alias for :func:`torch.special.erf`.
        """
    @staticmethod
    def erf_(*args, **kwargs): ...
    @staticmethod
    def erfc(input, out=...) -> Tensor:
        """
        erfc(input, *, out=None) -> Tensor

        Alias for :func:`torch.special.erfc`.
        """
    @staticmethod
    def erfc_(*args, **kwargs): ...
    @staticmethod
    def erfinv(input, out=...) -> Tensor:
        """
        erfinv(input, *, out=None) -> Tensor

        Alias for :func:`torch.special.erfinv`.
        """
    @staticmethod
    def exp(input, out=...) -> Tensor:
        """
        exp(input, *, out=None) -> Tensor

        Returns a new tensor with the exponential of the elements
        of the input tensor :attr:`input`.

        .. math::
            y_{i} = e^{x_{i}}

        Args:
            input (Tensor): the input tensor.

        Keyword args:
            out (Tensor, optional): the output tensor.

        Example::

            >>> torch.exp(torch.tensor([0, math.log(2.)]))
            tensor([ 1.,  2.])
        """
    @staticmethod
    def exp2(input, out=...) -> Tensor:
        """
        exp2(input, *, out=None) -> Tensor

        Alias for :func:`torch.special.exp2`.
        """
    @staticmethod
    def exp2_(*args, **kwargs): ...
    @staticmethod
    def exp_(*args, **kwargs): ...
    @staticmethod
    def expand_copy(*args, **kwargs):
        """
        Performs the same operation as :func:`torch.Tensor.expand`, but all output tensors
        are freshly created instead of aliasing the input.
        """
    @staticmethod
    def expm1(input, out=...) -> Tensor:
        """
        expm1(input, *, out=None) -> Tensor

        Alias for :func:`torch.special.expm1`.
        """
    @staticmethod
    def expm1_(*args, **kwargs): ...
    @staticmethod
    def eye(n, m=..., out=..., dtype=..., layout=..., device=..., requires_grad=...) -> Tensor:
        """
        eye(n, m=None, *, out=None, dtype=None, layout=torch.strided, device=None, requires_grad=False) -> Tensor

        Returns a 2-D tensor with ones on the diagonal and zeros elsewhere.

        Args:
            n (int): the number of rows
            m (int, optional): the number of columns with default being :attr:`n`

        Keyword arguments:
            out (Tensor, optional): the output tensor.
            dtype (:class:`torch.dtype`, optional): the desired data type of returned tensor.
                Default: if ``None``, uses a global default (see :func:`torch.set_default_dtype`).
            layout (:class:`torch.layout`, optional): the desired layout of returned Tensor.
                Default: ``torch.strided``.
            device (:class:`torch.device`, optional): the desired device of returned tensor.
                Default: if ``None``, uses the current device for the default tensor type
                (see :func:`torch.set_default_device`). :attr:`device` will be the CPU
                for CPU tensor types and the current CUDA device for CUDA tensor types.
            requires_grad (bool, optional): If autograd should record operations on the
                returned tensor. Default: ``False``.

        Returns:
            Tensor: A 2-D tensor with ones on the diagonal and zeros elsewhere

        Example::

            >>> torch.eye(3)
            tensor([[ 1.,  0.,  0.],
                    [ 0.,  1.,  0.],
                    [ 0.,  0.,  1.]])
        """
    @staticmethod
    def fake_quantize_per_channel_affine(input, scale, zero_point, axis, quant_min, quant_max) -> Tensor:
        """
        fake_quantize_per_channel_affine(input, scale, zero_point, axis, quant_min, quant_max) -> Tensor

        Returns a new tensor with the data in :attr:`input` fake quantized per channel using :attr:`scale`,
        :attr:`zero_point`, :attr:`quant_min` and :attr:`quant_max`, across the channel specified by :attr:`axis`.

        .. math::
            \\text{output} = (
                min(
                    \\text{quant\\_max},
                    max(
                        \\text{quant\\_min},
                        \\text{std::nearby\\_int}(\\text{input} / \\text{scale}) + \\text{zero\\_point}
                    )
                ) - \\text{zero\\_point}
            ) \\times \\text{scale}

        Args:
            input (Tensor): the input value(s), in ``torch.float32``
            scale (Tensor): quantization scale, per channel in ``torch.float32``
            zero_point (Tensor): quantization zero_point, per channel in ``torch.int32`` or ``torch.half`` or ``torch.float32``
            axis (int32): channel axis
            quant_min (int64): lower bound of the quantized domain
            quant_max (int64): upper bound of the quantized domain

        Returns:
            Tensor: A newly fake_quantized per channel ``torch.float32`` tensor

        Example::

            >>> x = torch.randn(2, 2, 2)
            >>> x
            tensor([[[-0.2525, -0.0466],
                     [ 0.3491, -0.2168]],

                    [[-0.5906,  1.6258],
                     [ 0.6444, -0.0542]]])
            >>> scales = (torch.randn(2) + 1) * 0.05
            >>> scales
            tensor([0.0475, 0.0486])
            >>> zero_points = torch.zeros(2).to(torch.int32)
            >>> zero_points
            tensor([0, 0])
            >>> torch.fake_quantize_per_channel_affine(x, scales, zero_points, 1, 0, 255)
            tensor([[[0.0000, 0.0000],
                     [0.3405, 0.0000]],

                    [[0.0000, 1.6134],
                    [0.6323, 0.0000]]])
        """
    @staticmethod
    def fake_quantize_per_tensor_affine(input, scale, zero_point, quant_min, quant_max) -> Tensor:
        """
        fake_quantize_per_tensor_affine(input, scale, zero_point, quant_min, quant_max) -> Tensor

        Returns a new tensor with the data in :attr:`input` fake quantized using :attr:`scale`,
        :attr:`zero_point`, :attr:`quant_min` and :attr:`quant_max`.

        .. math::
            \\text{output} = (
                min(
                    \\text{quant\\_max},
                    max(
                        \\text{quant\\_min},
                        \\text{std::nearby\\_int}(\\text{input} / \\text{scale}) + \\text{zero\\_point}
                    )
                ) - \\text{zero\\_point}
            ) \\times \\text{scale}

        Args:
            input (Tensor): the input value(s), ``torch.float32`` tensor
            scale (double scalar or ``float32`` Tensor): quantization scale
            zero_point (int64 scalar or ``int32`` Tensor): quantization zero_point
            quant_min (int64): lower bound of the quantized domain
            quant_max (int64): upper bound of the quantized domain

        Returns:
            Tensor: A newly fake_quantized ``torch.float32`` tensor

        Example::

            >>> x = torch.randn(4)
            >>> x
            tensor([ 0.0552,  0.9730,  0.3973, -1.0780])
            >>> torch.fake_quantize_per_tensor_affine(x, 0.1, 0, 0, 255)
            tensor([0.1000, 1.0000, 0.4000, 0.0000])
            >>> torch.fake_quantize_per_tensor_affine(x, torch.tensor(0.1), torch.tensor(0), 0, 255)
            tensor([0.1000, 1.0000, 0.4000, 0.0000])
        """
    @staticmethod
    def fbgemm_linear_fp16_weight(*args, **kwargs): ...
    @staticmethod
    def fbgemm_linear_fp16_weight_fp32_activation(*args, **kwargs): ...
    @staticmethod
    def fbgemm_linear_int8_weight(*args, **kwargs): ...
    @staticmethod
    def fbgemm_linear_int8_weight_fp32_activation(*args, **kwargs): ...
    @staticmethod
    def fbgemm_linear_quantize_weight(*args, **kwargs): ...
    @staticmethod
    def fbgemm_pack_gemm_matrix_fp16(*args, **kwargs): ...
    @staticmethod
    def fbgemm_pack_quantized_matrix(*args, **kwargs): ...
    @staticmethod
    def feature_alpha_dropout(*args, **kwargs): ...
    @staticmethod
    def feature_alpha_dropout_(*args, **kwargs): ...
    @staticmethod
    def feature_dropout(*args, **kwargs): ...
    @staticmethod
    def feature_dropout_(*args, **kwargs): ...
    @staticmethod
    def fill(*args, **kwargs): ...
    @staticmethod
    def fill_(*args, **kwargs): ...
    @staticmethod
    def fix(input, out=...) -> Tensor:
        """
        fix(input, *, out=None) -> Tensor

        Alias for :func:`torch.trunc`
        """
    @staticmethod
    def fix_(*args, **kwargs): ...
    @staticmethod
    def flatten(input, start_dim=..., end_dim=...) -> Tensor:
        """
        flatten(input, start_dim=0, end_dim=-1) -> Tensor

        Flattens :attr:`input` by reshaping it into a one-dimensional tensor. If :attr:`start_dim` or :attr:`end_dim`
        are passed, only dimensions starting with :attr:`start_dim` and ending with :attr:`end_dim` are flattened.
        The order of elements in :attr:`input` is unchanged.

        Unlike NumPy's flatten, which always copies input's data, this function may return the original object, a view,
        or copy. If no dimensions are flattened, then the original object :attr:`input` is returned. Otherwise, if input can
        be viewed as the flattened shape, then that view is returned. Finally, only if the input cannot be viewed as the
        flattened shape is input's data copied. See :meth:`torch.Tensor.view` for details on when a view will be returned.

        .. note::
            Flattening a zero-dimensional tensor will return a one-dimensional view.

        Args:
            input (Tensor): the input tensor.
            start_dim (int): the first dim to flatten
            end_dim (int): the last dim to flatten

        Example::

            >>> t = torch.tensor([[[1, 2],
            ...                    [3, 4]],
            ...                   [[5, 6],
            ...                    [7, 8]]])
            >>> torch.flatten(t)
            tensor([1, 2, 3, 4, 5, 6, 7, 8])
            >>> torch.flatten(t, start_dim=1)
            tensor([[1, 2, 3, 4],
                    [5, 6, 7, 8]])
        """
    @staticmethod
    def flip(input, dims) -> Tensor:
        """
        flip(input, dims) -> Tensor

        Reverse the order of an n-D tensor along given axis in dims.

        .. note::
            `torch.flip` makes a copy of :attr:`input`'s data. This is different from NumPy's `np.flip`,
            which returns a view in constant time. Since copying a tensor's data is more work than viewing that data,
            `torch.flip` is expected to be slower than `np.flip`.

        Args:
            input (Tensor): the input tensor.
            dims (a list or tuple): axis to flip on

        Example::

            >>> x = torch.arange(8).view(2, 2, 2)
            >>> x
            tensor([[[ 0,  1],
                     [ 2,  3]],

                    [[ 4,  5],
                     [ 6,  7]]])
            >>> torch.flip(x, [0, 1])
            tensor([[[ 6,  7],
                     [ 4,  5]],

                    [[ 2,  3],
                     [ 0,  1]]])
        """
    @staticmethod
    def fliplr(input) -> Tensor:
        """
        fliplr(input) -> Tensor

        Flip tensor in the left/right direction, returning a new tensor.

        Flip the entries in each row in the left/right direction.
        Columns are preserved, but appear in a different order than before.

        Note:
            Requires the tensor to be at least 2-D.

        .. note::
            `torch.fliplr` makes a copy of :attr:`input`'s data. This is different from NumPy's `np.fliplr`,
            which returns a view in constant time. Since copying a tensor's data is more work than viewing that data,
            `torch.fliplr` is expected to be slower than `np.fliplr`.

        Args:
            input (Tensor): Must be at least 2-dimensional.

        Example::

            >>> x = torch.arange(4).view(2, 2)
            >>> x
            tensor([[0, 1],
                    [2, 3]])
            >>> torch.fliplr(x)
            tensor([[1, 0],
                    [3, 2]])
        """
    @staticmethod
    def flipud(input) -> Tensor:
        """
        flipud(input) -> Tensor

        Flip tensor in the up/down direction, returning a new tensor.

        Flip the entries in each column in the up/down direction.
        Rows are preserved, but appear in a different order than before.

        Note:
            Requires the tensor to be at least 1-D.

        .. note::
            `torch.flipud` makes a copy of :attr:`input`'s data. This is different from NumPy's `np.flipud`,
            which returns a view in constant time. Since copying a tensor's data is more work than viewing that data,
            `torch.flipud` is expected to be slower than `np.flipud`.

        Args:
            input (Tensor): Must be at least 1-dimensional.

        Example::

            >>> x = torch.arange(4).view(2, 2)
            >>> x
            tensor([[0, 1],
                    [2, 3]])
            >>> torch.flipud(x)
            tensor([[2, 3],
                    [0, 1]])
        """
    @overload
    @staticmethod
    def float_power(input, exponent, out=...) -> Tensor:
        """
        float_power(input, exponent, *, out=None) -> Tensor

        Raises :attr:`input` to the power of :attr:`exponent`, elementwise, in double precision.
        If neither input is complex returns a ``torch.float64`` tensor,
        and if one or more inputs is complex returns a ``torch.complex128`` tensor.

        .. note::
            This function always computes in double precision, unlike :func:`torch.pow`,
            which implements more typical :ref:`type promotion <type-promotion-doc>`.
            This is useful when the computation needs to be performed in a wider or more precise dtype,
            or the results of the computation may contain fractional values not representable in the input dtypes,
            like when an integer base is raised to a negative integer exponent.

        Args:
            input (Tensor or Number): the base value(s)
            exponent (Tensor or Number): the exponent value(s)

        Keyword args:
            out (Tensor, optional): the output tensor.

        Example::

            >>> a = torch.randint(10, (4,))
            >>> a
            tensor([6, 4, 7, 1])
            >>> torch.float_power(a, 2)
            tensor([36., 16., 49.,  1.], dtype=torch.float64)

            >>> a = torch.arange(1, 5)
            >>> a
            tensor([ 1,  2,  3,  4])
            >>> exp = torch.tensor([2, -3, 4, -5])
            >>> exp
            tensor([ 2, -3,  4, -5])
            >>> torch.float_power(a, exp)
            tensor([1.0000e+00, 1.2500e-01, 8.1000e+01, 9.7656e-04], dtype=torch.float64)
        """
    @overload
    @staticmethod
    def float_power(a, exp) -> Any:
        """
        float_power(input, exponent, *, out=None) -> Tensor

        Raises :attr:`input` to the power of :attr:`exponent`, elementwise, in double precision.
        If neither input is complex returns a ``torch.float64`` tensor,
        and if one or more inputs is complex returns a ``torch.complex128`` tensor.

        .. note::
            This function always computes in double precision, unlike :func:`torch.pow`,
            which implements more typical :ref:`type promotion <type-promotion-doc>`.
            This is useful when the computation needs to be performed in a wider or more precise dtype,
            or the results of the computation may contain fractional values not representable in the input dtypes,
            like when an integer base is raised to a negative integer exponent.

        Args:
            input (Tensor or Number): the base value(s)
            exponent (Tensor or Number): the exponent value(s)

        Keyword args:
            out (Tensor, optional): the output tensor.

        Example::

            >>> a = torch.randint(10, (4,))
            >>> a
            tensor([6, 4, 7, 1])
            >>> torch.float_power(a, 2)
            tensor([36., 16., 49.,  1.], dtype=torch.float64)

            >>> a = torch.arange(1, 5)
            >>> a
            tensor([ 1,  2,  3,  4])
            >>> exp = torch.tensor([2, -3, 4, -5])
            >>> exp
            tensor([ 2, -3,  4, -5])
            >>> torch.float_power(a, exp)
            tensor([1.0000e+00, 1.2500e-01, 8.1000e+01, 9.7656e-04], dtype=torch.float64)
        """
    @staticmethod
    def floor(input, out=...) -> Tensor:
        """
        floor(input, *, out=None) -> Tensor

        Returns a new tensor with the floor of the elements of :attr:`input`,
        the largest integer less than or equal to each element.

        For integer inputs, follows the array-api convention of returning a
        copy of the input tensor.

        .. math::
            \\text{out}_{i} = \\left\\lfloor \\text{input}_{i} \\right\\rfloor

        Args:
            input (Tensor): the input tensor.

        Keyword args:
            out (Tensor, optional): the output tensor.

        Example::

            >>> a = torch.randn(4)
            >>> a
            tensor([-0.8166,  1.5308, -0.2530, -0.2091])
            >>> torch.floor(a)
            tensor([-1.,  1., -1., -1.])
        """
    @staticmethod
    def floor_(*args, **kwargs): ...
    @staticmethod
    def floor_divide(input, other, out=...) -> Tensor:
        """
        floor_divide(input, other, *, out=None) -> Tensor

        .. note::

            Before PyTorch 1.13 :func:`torch.floor_divide` incorrectly performed
            truncation division. To restore the previous behavior use
            :func:`torch.div` with ``rounding_mode='trunc'``.

        Computes :attr:`input` divided by :attr:`other`, elementwise, and floors
        the result.

        .. math::
            \\text{{out}}_i = \\text{floor} \\left( \\frac{{\\text{{input}}_i}}{{\\text{{other}}_i}} \\right)



        Supports broadcasting to a common shape, type promotion, and integer and float inputs.

        Args:
            input (Tensor or Number): the dividend
            other (Tensor or Number): the divisor

        Keyword args:
            out (Tensor, optional): the output tensor.

        Example::

            >>> a = torch.tensor([4.0, 3.0])
            >>> b = torch.tensor([2.0, 2.0])
            >>> torch.floor_divide(a, b)
            tensor([2.0, 1.0])
            >>> torch.floor_divide(a, 1.4)
            tensor([2.0, 2.0])
        """
    @overload
    @staticmethod
    def fmax(input, other, out=...) -> Tensor:
        """
        fmax(input, other, *, out=None) -> Tensor

        Computes the element-wise maximum of :attr:`input` and :attr:`other`.

        This is like :func:`torch.maximum` except it handles NaNs differently:
        if exactly one of the two elements being compared is a NaN then the non-NaN element is taken as the maximum.
        Only if both elements are NaN is NaN propagated.

        This function is a wrapper around C++'s ``std::fmax`` and is similar to NumPy's ``fmax`` function.

        Supports :ref:`broadcasting to a common shape <broadcasting-semantics>`,
        :ref:`type promotion <type-promotion-doc>`, and integer and floating-point inputs.

        Args:
            input (Tensor): the input tensor.
            other (Tensor): the second input tensor

        Keyword args:
            out (Tensor, optional): the output tensor.

        Example::

            >>> a = torch.tensor([9.7, float('nan'), 3.1, float('nan')])
            >>> b = torch.tensor([-2.2, 0.5, float('nan'), float('nan')])
            >>> torch.fmax(a, b)
            tensor([9.7000, 0.5000, 3.1000,    nan])
        """
    @overload
    @staticmethod
    def fmax(a, b) -> Any:
        """
        fmax(input, other, *, out=None) -> Tensor

        Computes the element-wise maximum of :attr:`input` and :attr:`other`.

        This is like :func:`torch.maximum` except it handles NaNs differently:
        if exactly one of the two elements being compared is a NaN then the non-NaN element is taken as the maximum.
        Only if both elements are NaN is NaN propagated.

        This function is a wrapper around C++'s ``std::fmax`` and is similar to NumPy's ``fmax`` function.

        Supports :ref:`broadcasting to a common shape <broadcasting-semantics>`,
        :ref:`type promotion <type-promotion-doc>`, and integer and floating-point inputs.

        Args:
            input (Tensor): the input tensor.
            other (Tensor): the second input tensor

        Keyword args:
            out (Tensor, optional): the output tensor.

        Example::

            >>> a = torch.tensor([9.7, float('nan'), 3.1, float('nan')])
            >>> b = torch.tensor([-2.2, 0.5, float('nan'), float('nan')])
            >>> torch.fmax(a, b)
            tensor([9.7000, 0.5000, 3.1000,    nan])
        """
    @overload
    @staticmethod
    def fmin(input, other, out=...) -> Tensor:
        """
        fmin(input, other, *, out=None) -> Tensor

        Computes the element-wise minimum of :attr:`input` and :attr:`other`.

        This is like :func:`torch.minimum` except it handles NaNs differently:
        if exactly one of the two elements being compared is a NaN then the non-NaN element is taken as the minimum.
        Only if both elements are NaN is NaN propagated.

        This function is a wrapper around C++'s ``std::fmin`` and is similar to NumPy's ``fmin`` function.

        Supports :ref:`broadcasting to a common shape <broadcasting-semantics>`,
        :ref:`type promotion <type-promotion-doc>`, and integer and floating-point inputs.

        Args:
            input (Tensor): the input tensor.
            other (Tensor): the second input tensor

        Keyword args:
            out (Tensor, optional): the output tensor.

        Example::

            >>> a = torch.tensor([2.2, float('nan'), 2.1, float('nan')])
            >>> b = torch.tensor([-9.3, 0.1, float('nan'), float('nan')])
            >>> torch.fmin(a, b)
            tensor([-9.3000, 0.1000, 2.1000,    nan])
        """
    @overload
    @staticmethod
    def fmin(a, b) -> Any:
        """
        fmin(input, other, *, out=None) -> Tensor

        Computes the element-wise minimum of :attr:`input` and :attr:`other`.

        This is like :func:`torch.minimum` except it handles NaNs differently:
        if exactly one of the two elements being compared is a NaN then the non-NaN element is taken as the minimum.
        Only if both elements are NaN is NaN propagated.

        This function is a wrapper around C++'s ``std::fmin`` and is similar to NumPy's ``fmin`` function.

        Supports :ref:`broadcasting to a common shape <broadcasting-semantics>`,
        :ref:`type promotion <type-promotion-doc>`, and integer and floating-point inputs.

        Args:
            input (Tensor): the input tensor.
            other (Tensor): the second input tensor

        Keyword args:
            out (Tensor, optional): the output tensor.

        Example::

            >>> a = torch.tensor([2.2, float('nan'), 2.1, float('nan')])
            >>> b = torch.tensor([-9.3, 0.1, float('nan'), float('nan')])
            >>> torch.fmin(a, b)
            tensor([-9.3000, 0.1000, 2.1000,    nan])
        """
    @staticmethod
    def fmod(input, other, out=...) -> Tensor:
        '''
        fmod(input, other, *, out=None) -> Tensor

        Applies C++\'s `std::fmod <https://en.cppreference.com/w/cpp/numeric/math/fmod>`_ entrywise.
        The result has the same sign as the dividend :attr:`input` and its absolute value
        is less than that of :attr:`other`.

        This function may be defined in terms of :func:`torch.div` as

        .. code:: python

            torch.fmod(a, b) == a - a.div(b, rounding_mode="trunc") * b

        Supports :ref:`broadcasting to a common shape <broadcasting-semantics>`,
        :ref:`type promotion <type-promotion-doc>`, and integer and float inputs.

        .. note::

            When the divisor is zero, returns ``NaN`` for floating point dtypes
            on both CPU and GPU; raises ``RuntimeError`` for integer division by
            zero on CPU; Integer division by zero on GPU may return any value.

        .. note::

           Complex inputs are not supported. In some cases, it is not mathematically
           possible to satisfy the definition of a modulo operation with complex numbers.

        .. seealso::

            :func:`torch.remainder` which implements Python\'s modulus operator.
            This one is defined using division rounding down the result.

        Args:
            input (Tensor): the dividend
            other (Tensor or Scalar): the divisor

        Keyword args:
            out (Tensor, optional): the output tensor.

        Example::

            >>> torch.fmod(torch.tensor([-3., -2, -1, 1, 2, 3]), 2)
            tensor([-1., -0., -1.,  1.,  0.,  1.])
            >>> torch.fmod(torch.tensor([1, 2, 3, 4, 5]), -1.5)
            tensor([1.0000, 0.5000, 0.0000, 1.0000, 0.5000])

        '''
    @staticmethod
    def frac(input, out=...) -> Tensor:
        """
        frac(input, *, out=None) -> Tensor

        Computes the fractional portion of each element in :attr:`input`.

        .. math::
            \\text{out}_{i} = \\text{input}_{i} - \\left\\lfloor |\\text{input}_{i}| \\right\\rfloor * \\operatorname{sgn}(\\text{input}_{i})

        Example::

            >>> torch.frac(torch.tensor([1, 2.5, -3.2]))
            tensor([ 0.0000,  0.5000, -0.2000])
        """
    @staticmethod
    def frac_(*args, **kwargs): ...
    @staticmethod
    def frexp(*args, **kwargs):
        """
        frexp(input, *, out=None) -> (Tensor mantissa, Tensor exponent)

        Decomposes :attr:`input` into mantissa and exponent tensors
        such that :math:`\\text{input} = \\text{mantissa} \\times 2^{\\text{exponent}}`.

        The range of mantissa is the open interval (-1, 1).

        Supports float inputs.

        Args:
            input (Tensor): the input tensor


        Keyword args:
            out (tuple, optional): the output tensors

        Example::

            >>> x = torch.arange(9.)
            >>> mantissa, exponent = torch.frexp(x)
            >>> mantissa
            tensor([0.0000, 0.5000, 0.5000, 0.7500, 0.5000, 0.6250, 0.7500, 0.8750, 0.5000])
            >>> exponent
            tensor([0, 1, 2, 2, 3, 3, 3, 3, 4], dtype=torch.int32)
            >>> torch.ldexp(mantissa, exponent)
            tensor([0., 1., 2., 3., 4., 5., 6., 7., 8.])
        """
    @staticmethod
    def frobenius_norm(*args, **kwargs): ...
    @staticmethod
    def from_file(filename, shared=..., size=..., dtype=..., layout=..., device=..., pin_memory=...) -> Any:
        """
        from_file(filename, shared=None, size=0, *, dtype=None, layout=None, device=None, pin_memory=False)

        Creates a CPU tensor with a storage backed by a memory-mapped file.

        If ``shared`` is True, then memory is shared between processes. All changes are written to the file.
        If ``shared`` is False, then changes to the tensor do not affect the file.

        ``size`` is the number of elements in the Tensor. If ``shared`` is ``False``, then the file must contain
        at least ``size * sizeof(dtype)`` bytes. If ``shared`` is ``True`` the file will be created if needed.

        .. note::
            Only CPU tensors can be mapped to files.

        .. note::
            For now, tensors with storages backed by a memory-mapped file cannot be created in pinned memory.


        Args:
            filename (str): file name to map
            shared (bool): whether to share memory (whether ``MAP_SHARED`` or ``MAP_PRIVATE`` is passed to the
                            underlying `mmap(2) call <https://man7.org/linux/man-pages/man2/mmap.2.html>`_)
            size (int): number of elements in the tensor

        Keyword args:
            dtype (:class:`torch.dtype`, optional): the desired data type of returned tensor.
                Default: if ``None``, uses a global default (see :func:`torch.set_default_dtype`).
            layout (:class:`torch.layout`, optional): the desired layout of returned Tensor.
                Default: ``torch.strided``.
            device (:class:`torch.device`, optional): the desired device of returned tensor.
                Default: if ``None``, uses the current device for the default tensor type
                (see :func:`torch.set_default_device`). :attr:`device` will be the CPU
                for CPU tensor types and the current CUDA device for CUDA tensor types.
            pin_memory (bool, optional): If set, returned tensor would be allocated in
                the pinned memory. Works only for CPU tensors. Default: ``False``.

        Example::

            >>> t = torch.randn(2, 5, dtype=torch.float64)
            >>> t.numpy().tofile('storage.pt')
            >>> t_mapped = torch.from_file('storage.pt', shared=False, size=10, dtype=torch.float64)
    """
    @overload
    @staticmethod
    def from_numpy(ndarray) -> Tensor:
        """
        from_numpy(ndarray) -> Tensor

        Creates a :class:`Tensor` from a :class:`numpy.ndarray`.

        The returned tensor and :attr:`ndarray` share the same memory. Modifications to
        the tensor will be reflected in the :attr:`ndarray` and vice versa. The returned
        tensor is not resizable.

        It currently accepts :attr:`ndarray` with dtypes of ``numpy.float64``,
        ``numpy.float32``, ``numpy.float16``, ``numpy.complex64``, ``numpy.complex128``,
        ``numpy.int64``, ``numpy.int32``, ``numpy.int16``, ``numpy.int8``, ``numpy.uint8``,
        and ``bool``.

        .. warning::
            Writing to a tensor created from a read-only NumPy array is not supported and will result in undefined behavior.

        Example::

            >>> a = numpy.array([1, 2, 3])
            >>> t = torch.from_numpy(a)
            >>> t
            tensor([ 1,  2,  3])
            >>> t[0] = -1
            >>> a
            array([-1,  2,  3])
        """
    @overload
    @staticmethod
    def from_numpy(a) -> Any:
        """
        from_numpy(ndarray) -> Tensor

        Creates a :class:`Tensor` from a :class:`numpy.ndarray`.

        The returned tensor and :attr:`ndarray` share the same memory. Modifications to
        the tensor will be reflected in the :attr:`ndarray` and vice versa. The returned
        tensor is not resizable.

        It currently accepts :attr:`ndarray` with dtypes of ``numpy.float64``,
        ``numpy.float32``, ``numpy.float16``, ``numpy.complex64``, ``numpy.complex128``,
        ``numpy.int64``, ``numpy.int32``, ``numpy.int16``, ``numpy.int8``, ``numpy.uint8``,
        and ``bool``.

        .. warning::
            Writing to a tensor created from a read-only NumPy array is not supported and will result in undefined behavior.

        Example::

            >>> a = numpy.array([1, 2, 3])
            >>> t = torch.from_numpy(a)
            >>> t
            tensor([ 1,  2,  3])
            >>> t[0] = -1
            >>> a
            array([-1,  2,  3])
        """
    @staticmethod
    def frombuffer(buffer, dtype, count=..., offset=..., requires_grad=...) -> Tensor:
        """
        frombuffer(buffer, *, dtype, count=-1, offset=0, requires_grad=False) -> Tensor

        Creates a 1-dimensional :class:`Tensor` from an object that implements
        the Python buffer protocol.

        Skips the first :attr:`offset` bytes in the buffer, and interprets the rest of
        the raw bytes as a 1-dimensional tensor of type :attr:`dtype` with :attr:`count`
        elements.

        Note that either of the following must be true:

        1. :attr:`count` is a positive non-zero number, and the total number of bytes
        in the buffer is more than :attr:`offset` plus :attr:`count` times the size
        (in bytes) of :attr:`dtype`.

        2. :attr:`count` is negative, and the length (number of bytes) of the buffer
        subtracted by the :attr:`offset` is a multiple of the size (in bytes) of
        :attr:`dtype`.

        The returned tensor and buffer share the same memory. Modifications to
        the tensor will be reflected in the buffer and vice versa. The returned
        tensor is not resizable.

        .. note::
            This function increments the reference count for the object that
            owns the shared memory. Therefore, such memory will not be deallocated
            before the returned tensor goes out of scope.

        .. warning::
            This function's behavior is undefined when passed an object implementing
            the buffer protocol whose data is not on the CPU. Doing so is likely to
            cause a segmentation fault.

        .. warning::
            This function does not try to infer the :attr:`dtype` (hence, it is not
            optional). Passing a different :attr:`dtype` than its source may result
            in unexpected behavior.

        Args:
            buffer (object): a Python object that exposes the buffer interface.

        Keyword args:
            dtype (:class:`torch.dtype`): the desired data type of returned tensor.
            count (int, optional): the number of desired elements to be read.
                If negative, all the elements (until the end of the buffer) will be
                read. Default: -1.
            offset (int, optional): the number of bytes to skip at the start of
                the buffer. Default: 0.
            requires_grad (bool, optional): If autograd should record operations on the
                returned tensor. Default: ``False``.

        Example::

            >>> import array
            >>> a = array.array('i', [1, 2, 3])
            >>> t = torch.frombuffer(a, dtype=torch.int32)
            >>> t
            tensor([ 1,  2,  3])
            >>> t[0] = -1
            >>> a
            array([-1,  2,  3])

            >>> # Interprets the signed char bytes as 32-bit integers.
            >>> # Each 4 signed char elements will be interpreted as
            >>> # 1 signed 32-bit integer.
            >>> import array
            >>> a = array.array('b', [-1, 0, 0, 0])
            >>> torch.frombuffer(a, dtype=torch.int32)
            tensor([255], dtype=torch.int32)
        """
    @staticmethod
    def full(size, fill_value, out=..., dtype=..., layout=..., device=..., requires_grad=...) -> Tensor:
        """
        full(size, fill_value, *, out=None, dtype=None, layout=torch.strided, device=None, requires_grad=False) -> Tensor

        Creates a tensor of size :attr:`size` filled with :attr:`fill_value`. The
        tensor's dtype is inferred from :attr:`fill_value`.

        Args:
            size (int...): a list, tuple, or :class:`torch.Size` of integers defining the
                shape of the output tensor.
            fill_value (Scalar): the value to fill the output tensor with.

        Keyword args:
            out (Tensor, optional): the output tensor.
            dtype (:class:`torch.dtype`, optional): the desired data type of returned tensor.
                Default: if ``None``, uses a global default (see :func:`torch.set_default_dtype`).
            layout (:class:`torch.layout`, optional): the desired layout of returned Tensor.
                Default: ``torch.strided``.
            device (:class:`torch.device`, optional): the desired device of returned tensor.
                Default: if ``None``, uses the current device for the default tensor type
                (see :func:`torch.set_default_device`). :attr:`device` will be the CPU
                for CPU tensor types and the current CUDA device for CUDA tensor types.
            requires_grad (bool, optional): If autograd should record operations on the
                returned tensor. Default: ``False``.

        Example::

            >>> torch.full((2, 3), 3.141592)
            tensor([[ 3.1416,  3.1416,  3.1416],
                    [ 3.1416,  3.1416,  3.1416]])
        """
    @staticmethod
    def full_like(*args, **kwargs):
        """
        full_like(input, fill_value, \\*, dtype=None, layout=torch.strided, device=None, requires_grad=False, memory_format=torch.preserve_format) -> Tensor

        Returns a tensor with the same size as :attr:`input` filled with :attr:`fill_value`.
        ``torch.full_like(input, fill_value)`` is equivalent to
        ``torch.full(input.size(), fill_value, dtype=input.dtype, layout=input.layout, device=input.device)``.

        Args:
            input (Tensor): the size of :attr:`input` will determine size of the output tensor.
            fill_value: the number to fill the output tensor with.

        Keyword args:
            dtype (:class:`torch.dtype`, optional): the desired data type of returned Tensor.
                Default: if ``None``, defaults to the dtype of :attr:`input`.
            layout (:class:`torch.layout`, optional): the desired layout of returned tensor.
                Default: if ``None``, defaults to the layout of :attr:`input`.
            device (:class:`torch.device`, optional): the desired device of returned tensor.
                Default: if ``None``, defaults to the device of :attr:`input`.
            requires_grad (bool, optional): If autograd should record operations on the
                returned tensor. Default: ``False``.
            memory_format (:class:`torch.memory_format`, optional): the desired memory format of
                returned Tensor. Default: ``torch.preserve_format``.
        """
    @staticmethod
    def fused_moving_avg_obs_fake_quant(*args, **kwargs): ...
    @staticmethod
    def gather(input, dim, index, sparse_grad=..., out=...) -> Tensor:
        """
        gather(input, dim, index, *, sparse_grad=False, out=None) -> Tensor

        Gathers values along an axis specified by `dim`.

        For a 3-D tensor the output is specified by::

            out[i][j][k] = input[index[i][j][k]][j][k]  # if dim == 0
            out[i][j][k] = input[i][index[i][j][k]][k]  # if dim == 1
            out[i][j][k] = input[i][j][index[i][j][k]]  # if dim == 2

        :attr:`input` and :attr:`index` must have the same number of dimensions.
        It is also required that ``index.size(d) <= input.size(d)`` for all
        dimensions ``d != dim``.  :attr:`out` will have the same shape as :attr:`index`.
        Note that ``input`` and ``index`` do not broadcast against each other.

        Args:
            input (Tensor): the source tensor
            dim (int): the axis along which to index
            index (LongTensor): the indices of elements to gather

        Keyword arguments:
            sparse_grad (bool, optional): If ``True``, gradient w.r.t. :attr:`input` will be a sparse tensor.
            out (Tensor, optional): the destination tensor

        Example::

            >>> t = torch.tensor([[1, 2], [3, 4]])
            >>> torch.gather(t, 1, torch.tensor([[0, 0], [1, 0]]))
            tensor([[ 1,  1],
                    [ 4,  3]])
        """
    @overload
    @staticmethod
    def gcd(input, other, out=...) -> Tensor:
        """
        gcd(input, other, *, out=None) -> Tensor

        Computes the element-wise greatest common divisor (GCD) of :attr:`input` and :attr:`other`.

        Both :attr:`input` and :attr:`other` must have integer types.

        .. note::
            This defines :math:`gcd(0, 0) = 0`.

        Args:
            input (Tensor): the input tensor.
            other (Tensor): the second input tensor

        Keyword arguments:
            out (Tensor, optional): the output tensor.

        Example::

            >>> a = torch.tensor([5, 10, 15])
            >>> b = torch.tensor([3, 4, 5])
            >>> torch.gcd(a, b)
            tensor([1, 2, 5])
            >>> c = torch.tensor([3])
            >>> torch.gcd(a, c)
            tensor([1, 1, 3])
        """
    @overload
    @staticmethod
    def gcd(a, b) -> Any:
        """
        gcd(input, other, *, out=None) -> Tensor

        Computes the element-wise greatest common divisor (GCD) of :attr:`input` and :attr:`other`.

        Both :attr:`input` and :attr:`other` must have integer types.

        .. note::
            This defines :math:`gcd(0, 0) = 0`.

        Args:
            input (Tensor): the input tensor.
            other (Tensor): the second input tensor

        Keyword arguments:
            out (Tensor, optional): the output tensor.

        Example::

            >>> a = torch.tensor([5, 10, 15])
            >>> b = torch.tensor([3, 4, 5])
            >>> torch.gcd(a, b)
            tensor([1, 2, 5])
            >>> c = torch.tensor([3])
            >>> torch.gcd(a, c)
            tensor([1, 1, 3])
        """
    @overload
    @staticmethod
    def gcd(a, c) -> Any:
        """
        gcd(input, other, *, out=None) -> Tensor

        Computes the element-wise greatest common divisor (GCD) of :attr:`input` and :attr:`other`.

        Both :attr:`input` and :attr:`other` must have integer types.

        .. note::
            This defines :math:`gcd(0, 0) = 0`.

        Args:
            input (Tensor): the input tensor.
            other (Tensor): the second input tensor

        Keyword arguments:
            out (Tensor, optional): the output tensor.

        Example::

            >>> a = torch.tensor([5, 10, 15])
            >>> b = torch.tensor([3, 4, 5])
            >>> torch.gcd(a, b)
            tensor([1, 2, 5])
            >>> c = torch.tensor([3])
            >>> torch.gcd(a, c)
            tensor([1, 1, 3])
        """
    @staticmethod
    def gcd_(*args, **kwargs): ...
    @staticmethod
    def ge(input, other, out=...) -> Tensor:
        """
        ge(input, other, *, out=None) -> Tensor

        Computes :math:`\\text{input} \\geq \\text{other}` element-wise.


        The second argument can be a number or a tensor whose shape is
        :ref:`broadcastable <broadcasting-semantics>` with the first argument.

        Args:
            input (Tensor): the tensor to compare
            other (Tensor or float): the tensor or value to compare

        Keyword args:
            out (Tensor, optional): the output tensor.

        Returns:
            A boolean tensor that is True where :attr:`input` is greater than or equal to :attr:`other` and False elsewhere

        Example::

            >>> torch.ge(torch.tensor([[1, 2], [3, 4]]), torch.tensor([[1, 1], [4, 4]]))
            tensor([[True, True], [False, True]])
        """
    @staticmethod
    def geqrf(*args, **kwargs):
        '''
        geqrf(input, *, out=None) -> (Tensor, Tensor)

        This is a low-level function for calling LAPACK\'s geqrf directly. This function
        returns a namedtuple (a, tau) as defined in `LAPACK documentation for geqrf`_ .

        Computes a QR decomposition of :attr:`input`.
        Both `Q` and `R` matrices are stored in the same output tensor `a`.
        The elements of `R` are stored on and above the diagonal.
        Elementary reflectors (or Householder vectors) implicitly defining matrix `Q`
        are stored below the diagonal.
        The results of this function can be used together with :func:`torch.linalg.householder_product`
        to obtain the `Q` matrix or
        with :func:`torch.ormqr`, which uses an implicit representation of the `Q` matrix,
        for an efficient matrix-matrix multiplication.

        See `LAPACK documentation for geqrf`_ for further details.

        .. note::
            See also :func:`torch.linalg.qr`, which computes Q and R matrices, and :func:`torch.linalg.lstsq`
            with the ``driver="gels"`` option for a function that can solve matrix equations using a QR decomposition.

        Args:
            input (Tensor): the input matrix

        Keyword args:
            out (tuple, optional): the output tuple of (Tensor, Tensor). Ignored if `None`. Default: `None`.

        .. _LAPACK documentation for geqrf:
            http://www.netlib.org/lapack/explore-html/df/dc5/group__variants_g_ecomputational_ga3766ea903391b5cf9008132f7440ec7b.html

        '''
    @staticmethod
    def ger(input, vec2, out=...) -> Tensor:
        """
        ger(input, vec2, *, out=None) -> Tensor

        Alias of :func:`torch.outer`.

        .. warning::
            This function is deprecated and will be removed in a future PyTorch release.
            Use :func:`torch.outer` instead.
        """
    @staticmethod
    def get_device(*args, **kwargs): ...
    @staticmethod
    def gradient(input, spacing=..., dim=..., edge_order=...) -> ListofTensors:
        '''
        gradient(input, *, spacing=1, dim=None, edge_order=1) -> List of Tensors

        Estimates the gradient of a function :math:`g : \\mathbb{R}^n \\rightarrow \\mathbb{R}` in
        one or more dimensions using the `second-order accurate central differences method
        <https://www.ams.org/journals/mcom/1988-51-184/S0025-5718-1988-0935077-0/S0025-5718-1988-0935077-0.pdf>`_ and
        either first or second order estimates at the boundaries.

        The gradient of :math:`g` is estimated using samples. By default, when :attr:`spacing` is not
        specified, the samples are entirely described by :attr:`input`, and the mapping of input coordinates
        to an output is the same as the tensor\'s mapping of indices to values. For example, for a three-dimensional
        :attr:`input` the function described is :math:`g : \\mathbb{R}^3 \\rightarrow \\mathbb{R}`, and
        :math:`g(1, 2, 3)\\ == input[1, 2, 3]`.

        When :attr:`spacing` is specified, it modifies the relationship between :attr:`input` and input coordinates.
        This is detailed in the "Keyword Arguments" section below.

        The gradient is estimated by estimating each partial derivative of :math:`g` independently. This estimation is
        accurate if :math:`g` is in :math:`C^3` (it has at least 3 continuous derivatives), and the estimation can be
        improved by providing closer samples. Mathematically, the value at each interior point of a partial derivative
        is estimated using `Taylor\'s theorem with remainder <https://en.wikipedia.org/wiki/Taylor%27s_theorem>`_.
        Letting :math:`x` be an interior point with :math:`x-h_l` and :math:`x+h_r` be points neighboring
        it to the left and right respectively, :math:`f(x+h_r)` and :math:`f(x-h_l)` can be estimated using:

        .. math::
            \\begin{aligned}
                f(x+h_r) = f(x) + h_r f\'(x) + {h_r}^2  \\frac{f\'\'(x)}{2} + {h_r}^3 \\frac{f\'\'\'(\\xi_1)}{6}, \\xi_1 \\in (x, x+h_r) \\\\\n                f(x-h_l) = f(x) - h_l f\'(x) + {h_l}^2  \\frac{f\'\'(x)}{2} - {h_l}^3 \\frac{f\'\'\'(\\xi_2)}{6}, \\xi_2 \\in (x, x-h_l) \\\\\n            \\end{aligned}

        Using the fact that :math:`f \\in C^3` and solving the linear system, we derive:

        .. math::
            f\'(x) \\approx \\frac{ {h_l}^2 f(x+h_r) - {h_r}^2 f(x-h_l)
                  + ({h_r}^2-{h_l}^2 ) f(x) }{ {h_r} {h_l}^2 + {h_r}^2 {h_l} }

        .. note::
            We estimate the gradient of functions in complex domain
            :math:`g : \\mathbb{C}^n \\rightarrow \\mathbb{C}` in the same way.

        The value of each partial derivative at the boundary points is computed differently. See edge_order below.

        Args:
            input (``Tensor``): the tensor that represents the values of the function

        Keyword args:
            spacing (``scalar``, ``list of scalar``, ``list of Tensor``, optional): :attr:`spacing` can be used to modify
                how the :attr:`input` tensor\'s indices relate to sample coordinates. If :attr:`spacing` is a scalar then
                the indices are multiplied by the scalar to produce the coordinates. For example, if :attr:`spacing=2` the
                indices (1, 2, 3) become coordinates (2, 4, 6). If :attr:`spacing` is a list of scalars then the corresponding
                indices are multiplied. For example, if :attr:`spacing=(2, -1, 3)` the indices (1, 2, 3) become coordinates (2, -2, 9).
                Finally, if :attr:`spacing` is a list of one-dimensional tensors then each tensor specifies the coordinates for
                the corresponding dimension. For example, if the indices are (1, 2, 3) and the tensors are (t0, t1, t2), then
                the coordinates are (t0[1], t1[2], t2[3])

            dim (``int``, ``list of int``, optional): the dimension or dimensions to approximate the gradient over.  By default
                the partial  gradient in every dimension is computed. Note that when :attr:`dim` is  specified the elements of
                the :attr:`spacing` argument must correspond with the specified dims."

            edge_order (``int``, optional): 1 or 2, for `first-order
                <https://www.ams.org/journals/mcom/1988-51-184/S0025-5718-1988-0935077-0/S0025-5718-1988-0935077-0.pdf>`_ or
                `second-order <https://www.ams.org/journals/mcom/1988-51-184/S0025-5718-1988-0935077-0/S0025-5718-1988-0935077-0.pdf>`_
                estimation of the boundary ("edge") values, respectively.

        Examples::

            >>> # Estimates the gradient of f(x)=x^2 at points [-2, -1, 2, 4]
            >>> coordinates = (torch.tensor([-2., -1., 1., 4.]),)
            >>> values = torch.tensor([4., 1., 1., 16.], )
            >>> torch.gradient(values, spacing = coordinates)
            (tensor([-3., -2., 2., 5.]),)

            >>> # Estimates the gradient of the R^2 -> R function whose samples are
            >>> # described by the tensor t. Implicit coordinates are [0, 1] for the outermost
            >>> # dimension and [0, 1, 2, 3] for the innermost dimension, and function estimates
            >>> # partial derivative for both dimensions.
            >>> t = torch.tensor([[1, 2, 4, 8], [10, 20, 40, 80]])
            >>> torch.gradient(t)
            (tensor([[ 9., 18., 36., 72.],
                     [ 9., 18., 36., 72.]]),
             tensor([[ 1.0000, 1.5000, 3.0000, 4.0000],
                     [10.0000, 15.0000, 30.0000, 40.0000]]))

            >>> # A scalar value for spacing modifies the relationship between tensor indices
            >>> # and input coordinates by multiplying the indices to find the
            >>> # coordinates. For example, below the indices of the innermost
            >>> # 0, 1, 2, 3 translate to coordinates of [0, 2, 4, 6], and the indices of
            >>> # the outermost dimension 0, 1 translate to coordinates of [0, 2].
            >>> torch.gradient(t, spacing = 2.0) # dim = None (implicitly [0, 1])
            (tensor([[ 4.5000, 9.0000, 18.0000, 36.0000],
                      [ 4.5000, 9.0000, 18.0000, 36.0000]]),
             tensor([[ 0.5000, 0.7500, 1.5000, 2.0000],
                      [ 5.0000, 7.5000, 15.0000, 20.0000]]))
            >>> # doubling the spacing between samples halves the estimated partial gradients.

            >>>
            >>> # Estimates only the partial derivative for dimension 1
            >>> torch.gradient(t, dim = 1) # spacing = None (implicitly 1.)
            (tensor([[ 1.0000, 1.5000, 3.0000, 4.0000],
                     [10.0000, 15.0000, 30.0000, 40.0000]]),)

            >>> # When spacing is a list of scalars, the relationship between the tensor
            >>> # indices and input coordinates changes based on dimension.
            >>> # For example, below, the indices of the innermost dimension 0, 1, 2, 3 translate
            >>> # to coordinates of [0, 3, 6, 9], and the indices of the outermost dimension
            >>> # 0, 1 translate to coordinates of [0, 2].
            >>> torch.gradient(t, spacing = [3., 2.])
            (tensor([[ 4.5000, 9.0000, 18.0000, 36.0000],
                     [ 4.5000, 9.0000, 18.0000, 36.0000]]),
             tensor([[ 0.3333, 0.5000, 1.0000, 1.3333],
                     [ 3.3333, 5.0000, 10.0000, 13.3333]]))

            >>> # The following example is a replication of the previous one with explicit
            >>> # coordinates.
            >>> coords = (torch.tensor([0, 2]), torch.tensor([0, 3, 6, 9]))
            >>> torch.gradient(t, spacing = coords)
            (tensor([[ 4.5000, 9.0000, 18.0000, 36.0000],
                     [ 4.5000, 9.0000, 18.0000, 36.0000]]),
             tensor([[ 0.3333, 0.5000, 1.0000, 1.3333],
                     [ 3.3333, 5.0000, 10.0000, 13.3333]]))

        '''
    @staticmethod
    def greater(input, other, out=...) -> Tensor:
        """
        greater(input, other, *, out=None) -> Tensor

        Alias for :func:`torch.gt`.
        """
    @staticmethod
    def greater_equal(input, other, out=...) -> Tensor:
        """
        greater_equal(input, other, *, out=None) -> Tensor

        Alias for :func:`torch.ge`.
        """
    @staticmethod
    def grid_sampler(*args, **kwargs): ...
    @staticmethod
    def grid_sampler_2d(*args, **kwargs): ...
    @staticmethod
    def grid_sampler_3d(*args, **kwargs): ...
    @staticmethod
    def group_norm(*args, **kwargs): ...
    @staticmethod
    def gru(*args, **kwargs): ...
    @staticmethod
    def gru_cell(*args, **kwargs): ...
    @staticmethod
    def gt(input, other, out=...) -> Tensor:
        """
        gt(input, other, *, out=None) -> Tensor

        Computes :math:`\\text{input} > \\text{other}` element-wise.


        The second argument can be a number or a tensor whose shape is
        :ref:`broadcastable <broadcasting-semantics>` with the first argument.

        Args:
            input (Tensor): the tensor to compare
            other (Tensor or float): the tensor or value to compare

        Keyword args:
            out (Tensor, optional): the output tensor.

        Returns:
            A boolean tensor that is True where :attr:`input` is greater than :attr:`other` and False elsewhere

        Example::

            >>> torch.gt(torch.tensor([[1, 2], [3, 4]]), torch.tensor([[1, 1], [4, 4]]))
            tensor([[False, True], [False, False]])
        """
    @staticmethod
    def hamming_window(window_length, periodic=..., alpha=..., beta=..., dtype=..., layout=..., device=..., requires_grad=...) -> Tensor:
        """
        hamming_window(window_length, periodic=True, alpha=0.54, beta=0.46, *, dtype=None, layout=torch.strided, device=None, requires_grad=False) -> Tensor

        Hamming window function.

        .. math::
            w[n] = \\alpha - \\beta\\ \\cos \\left( \\frac{2 \\pi n}{N - 1} \\right),

        where :math:`N` is the full window size.

        The input :attr:`window_length` is a positive integer controlling the
        returned window size. :attr:`periodic` flag determines whether the returned
        window trims off the last duplicate value from the symmetric window and is
        ready to be used as a periodic window with functions like
        :meth:`torch.stft`. Therefore, if :attr:`periodic` is true, the :math:`N` in
        above formula is in fact :math:`\\text{window\\_length} + 1`. Also, we always have
        ``torch.hamming_window(L, periodic=True)`` equal to
        ``torch.hamming_window(L + 1, periodic=False)[:-1])``.

        .. note::
            If :attr:`window_length` :math:`=1`, the returned window contains a single value 1.

        .. note::
            This is a generalized version of :meth:`torch.hann_window`.

        Arguments:
            window_length (int): the size of returned window
            periodic (bool, optional): If True, returns a window to be used as periodic
                function. If False, return a symmetric window.
            alpha (float, optional): The coefficient :math:`\\alpha` in the equation above
            beta (float, optional): The coefficient :math:`\\beta` in the equation above

        Keyword args:
            dtype (:class:`torch.dtype`, optional): the desired data type of returned tensor.
                Default: if ``None``, uses a global default (see :func:`torch.set_default_dtype`). Only floating point types are supported.
            layout (:class:`torch.layout`, optional): the desired layout of returned window tensor. Only
                  ``torch.strided`` (dense layout) is supported.
            device (:class:`torch.device`, optional): the desired device of returned tensor.
                Default: if ``None``, uses the current device for the default tensor type
                (see :func:`torch.set_default_device`). :attr:`device` will be the CPU
                for CPU tensor types and the current CUDA device for CUDA tensor types.
            requires_grad (bool, optional): If autograd should record operations on the
                returned tensor. Default: ``False``.

        Returns:
            Tensor: A 1-D tensor of size :math:`(\\text{window\\_length},)` containing the window.

        """
    @staticmethod
    def hann_window(window_length, periodic=..., dtype=..., layout=..., device=..., requires_grad=...) -> Tensor:
        """
        hann_window(window_length, periodic=True, *, dtype=None, layout=torch.strided, device=None, requires_grad=False) -> Tensor

        Hann window function.

        .. math::
            w[n] = \\frac{1}{2}\\ \\left[1 - \\cos \\left( \\frac{2 \\pi n}{N - 1} \\right)\\right] =
                    \\sin^2 \\left( \\frac{\\pi n}{N - 1} \\right),

        where :math:`N` is the full window size.

        The input :attr:`window_length` is a positive integer controlling the
        returned window size. :attr:`periodic` flag determines whether the returned
        window trims off the last duplicate value from the symmetric window and is
        ready to be used as a periodic window with functions like
        :meth:`torch.stft`. Therefore, if :attr:`periodic` is true, the :math:`N` in
        above formula is in fact :math:`\\text{window\\_length} + 1`. Also, we always have
        ``torch.hann_window(L, periodic=True)`` equal to
        ``torch.hann_window(L + 1, periodic=False)[:-1])``.

        .. note::
            If :attr:`window_length` :math:`=1`, the returned window contains a single value 1.

        Arguments:
            window_length (int): the size of returned window
            periodic (bool, optional): If True, returns a window to be used as periodic
                function. If False, return a symmetric window.

        Keyword args:
            dtype (:class:`torch.dtype`, optional): the desired data type of returned tensor.
                Default: if ``None``, uses a global default (see :func:`torch.set_default_dtype`). Only floating point types are supported.
            layout (:class:`torch.layout`, optional): the desired layout of returned window tensor. Only
                  ``torch.strided`` (dense layout) is supported.
            device (:class:`torch.device`, optional): the desired device of returned tensor.
                Default: if ``None``, uses the current device for the default tensor type
                (see :func:`torch.set_default_device`). :attr:`device` will be the CPU
                for CPU tensor types and the current CUDA device for CUDA tensor types.
            requires_grad (bool, optional): If autograd should record operations on the
                returned tensor. Default: ``False``.

        Returns:
            Tensor: A 1-D tensor of size :math:`(\\text{window\\_length},)` containing the window

        """
    @staticmethod
    def hardshrink(input, lambd=...) -> Tensor:
        """
        hardshrink(input, lambd=0.5) -> Tensor

        Applies the hard shrinkage function element-wise

        See :class:`~torch.nn.Hardshrink` for more details.
        """
    @staticmethod
    def heaviside(input, values, out=...) -> Tensor:
        """
        heaviside(input, values, *, out=None) -> Tensor

        Computes the Heaviside step function for each element in :attr:`input`.
        The Heaviside step function is defined as:

        .. math::
            \\text{{heaviside}}(input, values) = \\begin{cases}
                0, & \\text{if input < 0}\\\\\n                values, & \\text{if input == 0}\\\\\n                1, & \\text{if input > 0}
            \\end{cases}


        Args:
            input (Tensor): the input tensor.
            values (Tensor): The values to use where :attr:`input` is zero.

        Keyword arguments:
            out (Tensor, optional): the output tensor.

        Example::

            >>> input = torch.tensor([-1.5, 0, 2.0])
            >>> values = torch.tensor([0.5])
            >>> torch.heaviside(input, values)
            tensor([0.0000, 0.5000, 1.0000])
            >>> values = torch.tensor([1.2, -2.0, 3.5])
            >>> torch.heaviside(input, values)
            tensor([0., -2., 1.])

        """
    @staticmethod
    def hinge_embedding_loss(*args, **kwargs): ...
    @staticmethod
    def histc(input, bins=..., min=..., max=..., out=...) -> Tensor:
        """
        histc(input, bins=100, min=0, max=0, *, out=None) -> Tensor

        Computes the histogram of a tensor.

        The elements are sorted into equal width bins between :attr:`min` and
        :attr:`max`. If :attr:`min` and :attr:`max` are both zero, the minimum and
        maximum values of the data are used.

        Elements lower than min and higher than max and ``NaN`` elements are ignored.

        Args:
            input (Tensor): the input tensor.
            bins (int): number of histogram bins
            min (Scalar): lower end of the range (inclusive)
            max (Scalar): upper end of the range (inclusive)

        Keyword args:
            out (Tensor, optional): the output tensor.

        Returns:
            Tensor: Histogram represented as a tensor

        Example::

            >>> torch.histc(torch.tensor([1., 2, 1]), bins=4, min=0, max=3)
            tensor([ 0.,  2.,  1.,  0.])
        """
    @staticmethod
    def histogram(*args, **kwargs):
        """
        histogram(input, bins, *, range=None, weight=None, density=False, out=None) -> (Tensor, Tensor)

        Computes a histogram of the values in a tensor.

        :attr:`bins` can be an integer or a 1D tensor.

        If :attr:`bins` is an int, it specifies the number of equal-width bins.
        By default, the lower and upper range of the bins is determined by the
        minimum and maximum elements of the input tensor. The :attr:`range`
        argument can be provided to specify a range for the bins.

        If :attr:`bins` is a 1D tensor, it specifies the sequence of bin edges
        including the rightmost edge. It should contain at least 2 elements
        and its elements should be increasing.

        Args:
            input (Tensor): the input tensor.
            bins: int or 1D Tensor. If int, defines the number of equal-width bins. If tensor,
                  defines the sequence of bin edges including the rightmost edge.

        Keyword args:
            range (tuple of float): Defines the range of the bins.
            weight (Tensor): If provided, weight should have the same shape as input. Each value in
                             input contributes its associated weight towards its bin's result.
            density (bool): If False, the result will contain the count (or total weight) in each bin.
                            If True, the result is the value of the probability density function over the bins,
                            normalized such that the integral over the range of the bins is 1.
            out (Tensor, optional): the output tensor. (tuple, optional): The result tuple of two output tensors (hist, bin_edges).

        Returns:
            hist (Tensor): 1D Tensor containing the values of the histogram.
            bin_edges(Tensor): 1D Tensor containing the edges of the histogram bins.

        Example::

            >>> torch.histogram(torch.tensor([1., 2, 1]), bins=4, range=(0., 3.), weight=torch.tensor([1., 2., 4.]))
            (tensor([ 0.,  5.,  2.,  0.]), tensor([0., 0.75, 1.5, 2.25, 3.]))
            >>> torch.histogram(torch.tensor([1., 2, 1]), bins=4, range=(0., 3.), weight=torch.tensor([1., 2., 4.]), density=True)
            (tensor([ 0.,  0.9524,  0.3810,  0.]), tensor([0., 0.75, 1.5, 2.25, 3.]))
        """
    @staticmethod
    def histogramdd(*args, **kwargs):
        """
        histogramdd(input, bins, *, range=None, weight=None, density=False, out=None) -> (Tensor, Tensor[])

        Computes a multi-dimensional histogram of the values in a tensor.

        Interprets the elements of an input tensor whose innermost dimension has size N
        as a collection of N-dimensional points. Maps each of the points into a set of
        N-dimensional bins and returns the number of points (or total weight) in each bin.

        :attr:`input` must be a tensor with at least 2 dimensions.
        If input has shape (M, N), each of its M rows defines a point in N-dimensional space.
        If input has three or more dimensions, all but the last dimension are flattened.

        Each dimension is independently associated with its own strictly increasing sequence
        of bin edges. Bin edges may be specified explicitly by passing a sequence of 1D
        tensors. Alternatively, bin edges may be constructed automatically by passing a
        sequence of integers specifying the number of equal-width bins in each dimension.

        For each N-dimensional point in input:
            - Each of its coordinates is binned independently among the bin edges
                corresponding to its dimension
            - Binning results are combined to identify the N-dimensional bin (if any)
                into which the point falls
            - If the point falls into a bin, the bin's count (or total weight) is incremented
            - Points which do not fall into any bin do not contribute to the output

        :attr:`bins` can be a sequence of N 1D tensors, a sequence of N ints, or a single int.

        If :attr:`bins` is a sequence of N 1D tensors, it explicitly specifies the N sequences
        of bin edges. Each 1D tensor should contain a strictly increasing sequence with at
        least one element. A sequence of K bin edges defines K-1 bins, explicitly specifying
        the left and right edges of all bins. Every bin is exclusive of its left edge. Only
        the rightmost bin is inclusive of its right edge.

        If :attr:`bins` is a sequence of N ints, it specifies the number of equal-width bins
        in each dimension. By default, the leftmost and rightmost bin edges in each dimension
        are determined by the minimum and maximum elements of the input tensor in the
        corresponding dimension. The :attr:`range` argument can be provided to manually
        specify the leftmost and rightmost bin edges in each dimension.

        If :attr:`bins` is an int, it specifies the number of equal-width bins for all dimensions.

        .. note::
            See also :func:`torch.histogram`, which specifically computes 1D histograms.
            While :func:`torch.histogramdd` infers the dimensionality of its bins and
            binned values from the shape of :attr:`input`, :func:`torch.histogram`
            accepts and flattens :attr:`input` of any shape.

        Args:
            input (Tensor): the input tensor.
            bins: Tensor[], int[], or int.
                    If Tensor[], defines the sequences of bin edges.
                    If int[], defines the number of equal-width bins in each dimension.
                    If int, defines the number of equal-width bins for all dimensions.
        Keyword args:
            range (sequence of float): Defines the leftmost and rightmost bin edges
                                        in each dimension.
            weight (Tensor): By default, each value in the input has weight 1. If a weight
                                tensor is passed, each N-dimensional coordinate in input
                                contributes its associated weight towards its bin's result.
                                The weight tensor should have the same shape as the :attr:`input`
                                tensor excluding its innermost dimension N.
            density (bool): If False (default), the result will contain the count (or total weight)
                            in each bin. If True, each count (weight) is divided by the total count
                            (total weight), then divided by the volume of its associated bin.
        Returns:
            hist (Tensor): N-dimensional Tensor containing the values of the histogram.
            bin_edges(Tensor[]): sequence of N 1D Tensors containing the bin edges.

        Example::

            >>> torch.histogramdd(torch.tensor([[0., 1.], [1., 0.], [2., 0.], [2., 2.]]), bins=[3, 3],
            ...                   weight=torch.tensor([1., 2., 4., 8.]))
                torch.return_types.histogramdd(
                    hist=tensor([[0., 1., 0.],
                                 [2., 0., 0.],
                                 [4., 0., 8.]]),
                    bin_edges=(tensor([0.0000, 0.6667, 1.3333, 2.0000]),
                               tensor([0.0000, 0.6667, 1.3333, 2.0000])))

            >>> torch.histogramdd(torch.tensor([[0., 0.], [1., 1.], [2., 2.]]), bins=[2, 2],
            ...                   range=[0., 1., 0., 1.], density=True)
                torch.return_types.histogramdd(
                   hist=tensor([[2., 0.],
                                [0., 2.]]),
                   bin_edges=(tensor([0.0000, 0.5000, 1.0000]),
                              tensor([0.0000, 0.5000, 1.0000])))

        """
    @staticmethod
    def hsmm(*args, **kwargs): ...
    @staticmethod
    def hsplit(input, indices_or_sections) -> ListofTensors:
        """
        hsplit(input, indices_or_sections) -> List of Tensors

        Splits :attr:`input`, a tensor with one or more dimensions, into multiple tensors
        horizontally according to :attr:`indices_or_sections`. Each split is a view of
        :attr:`input`.

        If :attr:`input` is one dimensional this is equivalent to calling
        torch.tensor_split(input, indices_or_sections, dim=0) (the split dimension is
        zero), and if :attr:`input` has two or more dimensions it's equivalent to calling
        torch.tensor_split(input, indices_or_sections, dim=1) (the split dimension is 1),
        except that if :attr:`indices_or_sections` is an integer it must evenly divide
        the split dimension or a runtime error will be thrown.

        This function is based on NumPy's :func:`numpy.hsplit`.

        Args:
            input (Tensor): tensor to split.
            indices_or_sections (int or list or tuple of ints): See argument in :func:`torch.tensor_split`.

        Example::

            >>> t = torch.arange(16.0).reshape(4,4)
            >>> t
            tensor([[ 0.,  1.,  2.,  3.],
                    [ 4.,  5.,  6.,  7.],
                    [ 8.,  9., 10., 11.],
                    [12., 13., 14., 15.]])
            >>> torch.hsplit(t, 2)
            (tensor([[ 0.,  1.],
                     [ 4.,  5.],
                     [ 8.,  9.],
                     [12., 13.]]),
             tensor([[ 2.,  3.],
                     [ 6.,  7.],
                     [10., 11.],
                     [14., 15.]]))
            >>> torch.hsplit(t, [3, 6])
            (tensor([[ 0.,  1.,  2.],
                     [ 4.,  5.,  6.],
                     [ 8.,  9., 10.],
                     [12., 13., 14.]]),
             tensor([[ 3.],
                     [ 7.],
                     [11.],
                     [15.]]),
             tensor([], size=(4, 0)))

        """
    @staticmethod
    def hspmm(mat1, mat2, out=...) -> Tensor:
        """
        hspmm(mat1, mat2, *, out=None) -> Tensor

        Performs a matrix multiplication of a :ref:`sparse COO matrix
        <sparse-coo-docs>` :attr:`mat1` and a strided matrix :attr:`mat2`. The
        result is a (1 + 1)-dimensional :ref:`hybrid COO matrix
        <sparse-hybrid-coo-docs>`.

        Args:
            mat1 (Tensor): the first sparse matrix to be matrix multiplied
            mat2 (Tensor): the second strided matrix to be matrix multiplied

        Keyword args:
            out (Tensor, optional): the output tensor.
        """
    @staticmethod
    def hstack(tensors, out=...) -> Tensor:
        """
        hstack(tensors, *, out=None) -> Tensor

        Stack tensors in sequence horizontally (column wise).

        This is equivalent to concatenation along the first axis for 1-D tensors, and along the second axis for all other tensors.

        Args:
            tensors (sequence of Tensors): sequence of tensors to concatenate

        Keyword args:
            out (Tensor, optional): the output tensor.

        Example::

            >>> a = torch.tensor([1, 2, 3])
            >>> b = torch.tensor([4, 5, 6])
            >>> torch.hstack((a,b))
            tensor([1, 2, 3, 4, 5, 6])
            >>> a = torch.tensor([[1],[2],[3]])
            >>> b = torch.tensor([[4],[5],[6]])
            >>> torch.hstack((a,b))
            tensor([[1, 4],
                    [2, 5],
                    [3, 6]])

        """
    @staticmethod
    def hypot(input, other, out=...) -> Tensor:
        """
        hypot(input, other, *, out=None) -> Tensor

        Given the legs of a right triangle, return its hypotenuse.

        .. math::
            \\text{out}_{i} = \\sqrt{\\text{input}_{i}^{2} + \\text{other}_{i}^{2}}

        The shapes of ``input`` and ``other`` must be
        :ref:`broadcastable <broadcasting-semantics>`.

        Args:
            input (Tensor): the first input tensor
            other (Tensor): the second input tensor

        Keyword args:
            out (Tensor, optional): the output tensor.

        Example::

            >>> a = torch.hypot(torch.tensor([4.0]), torch.tensor([3.0, 4.0, 5.0]))
            tensor([5.0000, 5.6569, 6.4031])

        """
    @staticmethod
    def i0(input, out=...) -> Tensor:
        """
        i0(input, *, out=None) -> Tensor

        Alias for :func:`torch.special.i0`.
        """
    @staticmethod
    def i0_(*args, **kwargs): ...
    @staticmethod
    def igamma(input, other, out=...) -> Tensor:
        """
        igamma(input, other, *, out=None) -> Tensor

        Alias for :func:`torch.special.gammainc`.
        """
    @staticmethod
    def igammac(input, other, out=...) -> Tensor:
        """
        igammac(input, other, *, out=None) -> Tensor

        Alias for :func:`torch.special.gammaincc`.
        """
    @staticmethod
    def imag(input) -> Tensor:
        """
        imag(input) -> Tensor

        Returns a new tensor containing imaginary values of the :attr:`self` tensor.
        The returned tensor and :attr:`self` share the same underlying storage.

        .. warning::
            :func:`imag` is only supported for tensors with complex dtypes.

        Args:
            input (Tensor): the input tensor.

        Example::

            >>> x=torch.randn(4, dtype=torch.cfloat)
            >>> x
            tensor([(0.3100+0.3553j), (-0.5445-0.7896j), (-1.6492-0.0633j), (-0.0638-0.8119j)])
            >>> x.imag
            tensor([ 0.3553, -0.7896, -0.0633, -0.8119])

        """
    @staticmethod
    def index_add(*args, **kwargs):
        """
        index_add(input: Tensor, dim: int, index: Tensor, source: Tensor, *, alpha: Union[Number, _complex] = 1, out: Optional[Tensor]) -> Tensor # noqa: B950

        See :meth:`~Tensor.index_add_` for function description.
        """
    @staticmethod
    def index_copy(input: Tensor, dim: int, index: Tensor, source: Tensor, out: Tensor | None) -> Tensor:
        """
        index_copy(input: Tensor, dim: int, index: Tensor, source: Tensor, *, out: Optional[Tensor]) -> Tensor

        See :meth:`~Tensor.index_add_` for function description.
        """
    @staticmethod
    def index_fill(*args, **kwargs): ...
    @staticmethod
    def index_put(*args, **kwargs): ...
    @staticmethod
    def index_put_(*args, **kwargs): ...
    @staticmethod
    def index_reduce(*args, **kwargs):
        """
        index_reduce(input: Tensor, dim: int, index: Tensor, source: Tensor, reduce: str, *, include_self: bool = True, out: Optional[Tensor]) -> Tensor # noqa: B950

        See :meth:`~Tensor.index_reduce_` for function description.
        """
    @staticmethod
    def index_select(input, dim, index, out=...) -> Tensor:
        """
        index_select(input, dim, index, *, out=None) -> Tensor

        Returns a new tensor which indexes the :attr:`input` tensor along dimension
        :attr:`dim` using the entries in :attr:`index` which is a `LongTensor`.

        The returned tensor has the same number of dimensions as the original tensor
        (:attr:`input`).  The :attr:`dim`\\ th dimension has the same size as the length
        of :attr:`index`; other dimensions have the same size as in the original tensor.

        .. note:: The returned tensor does **not** use the same storage as the original
                  tensor.  If :attr:`out` has a different shape than expected, we
                  silently change it to the correct shape, reallocating the underlying
                  storage if necessary.

        Args:
            input (Tensor): the input tensor.
            dim (int): the dimension in which we index
            index (IntTensor or LongTensor): the 1-D tensor containing the indices to index

        Keyword args:
            out (Tensor, optional): the output tensor.

        Example::

            >>> x = torch.randn(3, 4)
            >>> x
            tensor([[ 0.1427,  0.0231, -0.5414, -1.0009],
                    [-0.4664,  0.2647, -0.1228, -1.1068],
                    [-1.1734, -0.6571,  0.7230, -0.6004]])
            >>> indices = torch.tensor([0, 2])
            >>> torch.index_select(x, 0, indices)
            tensor([[ 0.1427,  0.0231, -0.5414, -1.0009],
                    [-1.1734, -0.6571,  0.7230, -0.6004]])
            >>> torch.index_select(x, 1, indices)
            tensor([[ 0.1427, -0.5414],
                    [-0.4664, -0.1228],
                    [-1.1734,  0.7230]])
        """
    @staticmethod
    def indices_copy(*args, **kwargs):
        """
        Performs the same operation as :func:`torch.indices`, but all output tensors
        are freshly created instead of aliasing the input.
        """
    @overload
    @staticmethod
    def inner(input, other, out=...) -> Tensor:
        """
        inner(input, other, *, out=None) -> Tensor

        Computes the dot product for 1D tensors. For higher dimensions, sums the product
        of elements from :attr:`input` and :attr:`other` along their last dimension.

        .. note::

            If either :attr:`input` or :attr:`other` is a scalar, the result is equivalent
            to `torch.mul(input, other)`.

            If both :attr:`input` and :attr:`other` are non-scalars, the size of their last
            dimension must match and the result is equivalent to `torch.tensordot(input,
            other, dims=([-1], [-1]))`

        Args:
            input (Tensor): First input tensor
            other (Tensor): Second input tensor

        Keyword args:
            out (Tensor, optional): Optional output tensor to write result into. The output
                                    shape is `input.shape[:-1] + other.shape[:-1]`.

        Example::

            # Dot product
            >>> torch.inner(torch.tensor([1, 2, 3]), torch.tensor([0, 2, 1]))
            tensor(7)

            # Multidimensional input tensors
            >>> a = torch.randn(2, 3)
            >>> a
            tensor([[0.8173, 1.0874, 1.1784],
                    [0.3279, 0.1234, 2.7894]])
            >>> b = torch.randn(2, 4, 3)
            >>> b
            tensor([[[-0.4682, -0.7159,  0.1506],
                    [ 0.4034, -0.3657,  1.0387],
                    [ 0.9892, -0.6684,  0.1774],
                    [ 0.9482,  1.3261,  0.3917]],

                    [[ 0.4537,  0.7493,  1.1724],
                    [ 0.2291,  0.5749, -0.2267],
                    [-0.7920,  0.3607, -0.3701],
                    [ 1.3666, -0.5850, -1.7242]]])
            >>> torch.inner(a, b)
            tensor([[[-0.9837,  1.1560,  0.2907,  2.6785],
                    [ 2.5671,  0.5452, -0.6912, -1.5509]],

                    [[ 0.1782,  2.9843,  0.7366,  1.5672],
                    [ 3.5115, -0.4864, -1.2476, -4.4337]]])

            # Scalar input
            >>> torch.inner(a, torch.tensor(2))
            tensor([[1.6347, 2.1748, 2.3567],
                    [0.6558, 0.2469, 5.5787]])
        """
    @overload
    @staticmethod
    def inner(a, b) -> Any:
        """
        inner(input, other, *, out=None) -> Tensor

        Computes the dot product for 1D tensors. For higher dimensions, sums the product
        of elements from :attr:`input` and :attr:`other` along their last dimension.

        .. note::

            If either :attr:`input` or :attr:`other` is a scalar, the result is equivalent
            to `torch.mul(input, other)`.

            If both :attr:`input` and :attr:`other` are non-scalars, the size of their last
            dimension must match and the result is equivalent to `torch.tensordot(input,
            other, dims=([-1], [-1]))`

        Args:
            input (Tensor): First input tensor
            other (Tensor): Second input tensor

        Keyword args:
            out (Tensor, optional): Optional output tensor to write result into. The output
                                    shape is `input.shape[:-1] + other.shape[:-1]`.

        Example::

            # Dot product
            >>> torch.inner(torch.tensor([1, 2, 3]), torch.tensor([0, 2, 1]))
            tensor(7)

            # Multidimensional input tensors
            >>> a = torch.randn(2, 3)
            >>> a
            tensor([[0.8173, 1.0874, 1.1784],
                    [0.3279, 0.1234, 2.7894]])
            >>> b = torch.randn(2, 4, 3)
            >>> b
            tensor([[[-0.4682, -0.7159,  0.1506],
                    [ 0.4034, -0.3657,  1.0387],
                    [ 0.9892, -0.6684,  0.1774],
                    [ 0.9482,  1.3261,  0.3917]],

                    [[ 0.4537,  0.7493,  1.1724],
                    [ 0.2291,  0.5749, -0.2267],
                    [-0.7920,  0.3607, -0.3701],
                    [ 1.3666, -0.5850, -1.7242]]])
            >>> torch.inner(a, b)
            tensor([[[-0.9837,  1.1560,  0.2907,  2.6785],
                    [ 2.5671,  0.5452, -0.6912, -1.5509]],

                    [[ 0.1782,  2.9843,  0.7366,  1.5672],
                    [ 3.5115, -0.4864, -1.2476, -4.4337]]])

            # Scalar input
            >>> torch.inner(a, torch.tensor(2))
            tensor([[1.6347, 2.1748, 2.3567],
                    [0.6558, 0.2469, 5.5787]])
        """
    @staticmethod
    def instance_norm(*args, **kwargs): ...
    @staticmethod
    def int_repr(*args, **kwargs): ...
    @staticmethod
    def inverse(input, out=...) -> Tensor:
        """
        inverse(input, *, out=None) -> Tensor

        Alias for :func:`torch.linalg.inv`
        """
    @staticmethod
    def is_complex(*args, **kwargs):
        """
        is_complex(input) -> (bool)

        Returns True if the data type of :attr:`input` is a complex data type i.e.,
        one of ``torch.complex64``, and ``torch.complex128``.

        Args:
            input (Tensor): the input tensor.
        """
    @staticmethod
    def is_conj(*args, **kwargs):
        """
        is_conj(input) -> (bool)

        Returns True if the :attr:`input` is a conjugated tensor, i.e. its conjugate bit is set to `True`.

        Args:
            input (Tensor): the input tensor.
        """
    @staticmethod
    def is_distributed(*args, **kwargs): ...
    @staticmethod
    def is_floating_point(*args, **kwargs):
        """
        is_floating_point(input) -> (bool)

        Returns True if the data type of :attr:`input` is a floating point data type i.e.,
        one of ``torch.float64``, ``torch.float32``, ``torch.float16``, and ``torch.bfloat16``.

        Args:
            input (Tensor): the input tensor.
        """
    @staticmethod
    def is_inference(*args, **kwargs):
        """
        is_inference(input) -> (bool)

        Returns True if :attr:`input` is an inference tensor.

        A non-view tensor is an inference tensor if and only if it was
        allocated during inference mode. A view tensor is an inference
        tensor if and only if the tensor it is a view of is an inference tensor.

        For details on inference mode please see
        `Inference Mode <https://pytorch.org/cppdocs/notes/inference_mode.html>`_.

        Args:
            input (Tensor): the input tensor.
        """
    @staticmethod
    def is_neg(*args, **kwargs): ...
    @staticmethod
    def is_nonzero(*args, **kwargs):
        """
        is_nonzero(input) -> (bool)

        Returns True if the :attr:`input` is a single element tensor which is not equal to zero
        after type conversions.
        i.e. not equal to ``torch.tensor([0.])`` or ``torch.tensor([0])`` or
        ``torch.tensor([False])``.
        Throws a ``RuntimeError`` if ``torch.numel() != 1`` (even in case
        of sparse tensors).

        Args:
            input (Tensor): the input tensor.

        Examples::

            >>> torch.is_nonzero(torch.tensor([0.]))
            False
            >>> torch.is_nonzero(torch.tensor([1.5]))
            True
            >>> torch.is_nonzero(torch.tensor([False]))
            False
            >>> torch.is_nonzero(torch.tensor([3]))
            True
            >>> torch.is_nonzero(torch.tensor([1, 3, 5]))
            Traceback (most recent call last):
            ...
            RuntimeError: bool value of Tensor with more than one value is ambiguous
            >>> torch.is_nonzero(torch.tensor([]))
            Traceback (most recent call last):
            ...
            RuntimeError: bool value of Tensor with no values is ambiguous
        """
    @staticmethod
    def is_same_size(*args, **kwargs): ...
    @staticmethod
    def is_signed(*args, **kwargs): ...
    @staticmethod
    def is_vulkan_available(*args, **kwargs): ...
    @staticmethod
    def isclose(input, other, rtol=..., atol=..., equal_nan=...) -> Tensor:
        '''
        isclose(input, other, rtol=1e-05, atol=1e-08, equal_nan=False) -> Tensor

        Returns a new tensor with boolean elements representing if each element of
        :attr:`input` is "close" to the corresponding element of :attr:`other`.
        Closeness is defined as:

        .. math::
            \\lvert \\text{input}_i - \\text{other}_i \\rvert \\leq \\texttt{rtol} \\times \\lvert \\text{other}_i \\rvert + \\texttt{atol}


        where :attr:`input` and :attr:`other` are finite. Where :attr:`input`
        and/or :attr:`other` are nonfinite they are close if and only if
        they are equal, with NaNs being considered equal to each other when
        :attr:`equal_nan` is True.

        Args:
            input (Tensor): first tensor to compare
            other (Tensor): second tensor to compare
            rtol (float, optional): relative tolerance. Default: 1e-05
            atol (float, optional): absolute tolerance. Default: 1e-08
            equal_nan (bool, optional): if ``True``, then two ``NaN`` s will be considered equal. Default: ``False``

        Examples::

            >>> torch.isclose(torch.tensor((1., 2, 3)), torch.tensor((1 + 1e-10, 3, 4)))
            tensor([ True, False, False])
            >>> torch.isclose(torch.tensor((float(\'inf\'), 4)), torch.tensor((float(\'inf\'), 6)), rtol=.5)
            tensor([True, True])
        '''
    @staticmethod
    def isfinite(input) -> Tensor:
        """
        isfinite(input) -> Tensor

        Returns a new tensor with boolean elements representing if each element is `finite` or not.

        Real values are finite when they are not NaN, negative infinity, or infinity.
        Complex values are finite when both their real and imaginary parts are finite.

        Args:
            input (Tensor): the input tensor.

        Returns:
            A boolean tensor that is True where :attr:`input` is finite and False elsewhere

        Example::

            >>> torch.isfinite(torch.tensor([1, float('inf'), 2, float('-inf'), float('nan')]))
            tensor([True,  False,  True,  False,  False])
        """
    @staticmethod
    def isin(elements, test_elements, assume_unique=..., invert=...) -> Tensor:
        """
        isin(elements, test_elements, *, assume_unique=False, invert=False) -> Tensor

        Tests if each element of :attr:`elements` is in :attr:`test_elements`. Returns
        a boolean tensor of the same shape as :attr:`elements` that is True for elements
        in :attr:`test_elements` and False otherwise.

        .. note::
            One of :attr:`elements` or :attr:`test_elements` can be a scalar, but not both.

        Args:
            elements (Tensor or Scalar): Input elements
            test_elements (Tensor or Scalar): Values against which to test for each input element
            assume_unique (bool, optional): If True, assumes both :attr:`elements` and
                :attr:`test_elements` contain unique elements, which can speed up the
                calculation. Default: False
            invert (bool, optional): If True, inverts the boolean return tensor, resulting in True
                values for elements *not* in :attr:`test_elements`. Default: False

        Returns:
            A boolean tensor of the same shape as :attr:`elements` that is True for elements in
            :attr:`test_elements` and False otherwise

        Example:
            >>> torch.isin(torch.tensor([[1, 2], [3, 4]]), torch.tensor([2, 3]))
            tensor([[False,  True],
                    [ True, False]])
        """
    @staticmethod
    def isinf(input) -> Tensor:
        """
        isinf(input) -> Tensor

        Tests if each element of :attr:`input` is infinite
        (positive or negative infinity) or not.

        .. note::
            Complex values are infinite when their real or imaginary part is
            infinite.

        Args:
            input (Tensor): the input tensor.

        Returns:
            A boolean tensor that is True where :attr:`input` is infinite and False elsewhere

        Example::

            >>> torch.isinf(torch.tensor([1, float('inf'), 2, float('-inf'), float('nan')]))
            tensor([False,  True,  False,  True,  False])
        """
    @staticmethod
    def isnan(input) -> Tensor:
        """
        isnan(input) -> Tensor

        Returns a new tensor with boolean elements representing if each element of :attr:`input`
        is NaN or not. Complex values are considered NaN when either their real
        and/or imaginary part is NaN.

        Arguments:
            input (Tensor): the input tensor.

        Returns:
            A boolean tensor that is True where :attr:`input` is NaN and False elsewhere

        Example::

            >>> torch.isnan(torch.tensor([1, float('nan'), 2]))
            tensor([False, True, False])
        """
    @overload
    @staticmethod
    def isneginf(input, out=...) -> Tensor:
        """
        isneginf(input, *, out=None) -> Tensor
        Tests if each element of :attr:`input` is negative infinity or not.

        Args:
          input (Tensor): the input tensor.

        Keyword args:
          out (Tensor, optional): the output tensor.

        Example::

            >>> a = torch.tensor([-float('inf'), float('inf'), 1.2])
            >>> torch.isneginf(a)
            tensor([ True, False, False])
        """
    @overload
    @staticmethod
    def isneginf(a) -> Any:
        """
        isneginf(input, *, out=None) -> Tensor
        Tests if each element of :attr:`input` is negative infinity or not.

        Args:
          input (Tensor): the input tensor.

        Keyword args:
          out (Tensor, optional): the output tensor.

        Example::

            >>> a = torch.tensor([-float('inf'), float('inf'), 1.2])
            >>> torch.isneginf(a)
            tensor([ True, False, False])
        """
    @overload
    @staticmethod
    def isposinf(input, out=...) -> Tensor:
        """
        isposinf(input, *, out=None) -> Tensor
        Tests if each element of :attr:`input` is positive infinity or not.

        Args:
          input (Tensor): the input tensor.

        Keyword args:
          out (Tensor, optional): the output tensor.

        Example::

            >>> a = torch.tensor([-float('inf'), float('inf'), 1.2])
            >>> torch.isposinf(a)
            tensor([False,  True, False])
        """
    @overload
    @staticmethod
    def isposinf(a) -> Any:
        """
        isposinf(input, *, out=None) -> Tensor
        Tests if each element of :attr:`input` is positive infinity or not.

        Args:
          input (Tensor): the input tensor.

        Keyword args:
          out (Tensor, optional): the output tensor.

        Example::

            >>> a = torch.tensor([-float('inf'), float('inf'), 1.2])
            >>> torch.isposinf(a)
            tensor([False,  True, False])
        """
    @staticmethod
    def isreal(input) -> Tensor:
        """
        isreal(input) -> Tensor

        Returns a new tensor with boolean elements representing if each element of :attr:`input` is real-valued or not.
        All real-valued types are considered real. Complex values are considered real when their imaginary part is 0.

        Arguments:
            input (Tensor): the input tensor.

        Returns:
            A boolean tensor that is True where :attr:`input` is real and False elsewhere

        Example::

            >>> torch.isreal(torch.tensor([1, 1+1j, 2+0j]))
            tensor([True, False, True])
        """
    @staticmethod
    def istft(*args, **kwargs):
        '''istft(input, n_fft, hop_length=None, win_length=None, window=None, center=True, normalized=False, onesided=None, length=None, return_complex=False) -> Tensor:

        Inverse short time Fourier Transform. This is expected to be the inverse of :func:`~torch.stft`.

        .. warning::
            From version 2.1, a warning will be provided if a :attr:`window` is
            not specified. In a future release, this attribute will be required.
            Please provide the same window used in the stft call.

        It has the same parameters (+ additional optional parameter of :attr:`length`) and it should return the
        least squares estimation of the original signal. The algorithm will check using the NOLA condition (
        nonzero overlap).

        Important consideration in the parameters :attr:`window` and :attr:`center` so that the envelope
        created by the summation of all the windows is never zero at certain point in time. Specifically,
        :math:`\\sum_{t=-\\infty}^{\\infty} |w|^2[n-t\\times hop\\_length] \\cancel{=} 0`.

        Since :func:`~torch.stft` discards elements at the end of the signal if they do not fit in a frame,
        ``istft`` may return a shorter signal than the original signal (can occur if :attr:`center` is False
        since the signal isn\'t padded). If `length` is given in the arguments and is longer than expected,
        ``istft`` will pad zeros to the end of the returned signal.

        If :attr:`center` is ``True``, then there will be padding e.g. ``\'constant\'``, ``\'reflect\'``, etc.
        Left padding can be trimmed off exactly because they can be calculated but right padding cannot be
        calculated without additional information.

        Example: Suppose the last window is:
        ``[17, 18, 0, 0, 0]`` vs ``[18, 0, 0, 0, 0]``

        The :attr:`n_fft`, :attr:`hop_length`, :attr:`win_length` are all the same which prevents the calculation
        of right padding. These additional values could be zeros or a reflection of the signal so providing
        :attr:`length` could be useful. If :attr:`length` is ``None`` then padding will be aggressively removed
        (some loss of signal).

        [1] D. W. Griffin and J. S. Lim, "Signal estimation from modified short-time Fourier transform,"
        IEEE Trans. ASSP, vol.32, no.2, pp.236-243, Apr. 1984.

        Args:
            input (Tensor): The input tensor. Expected to be in the format of :func:`~torch.stft`,
                output. That is a complex tensor of shape `(B?, N, T)` where

                - `B?` is an optional batch dimension
                - `N` is the number of frequency samples, `(n_fft // 2) + 1`
                  for onesided input, or otherwise `n_fft`.
                - `T` is the number of frames, `1 + length // hop_length` for centered stft,
                  or `1 + (length - n_fft) // hop_length` otherwise.

                .. versionchanged:: 2.0
                    Real datatype inputs are no longer supported. Input must now have a
                    complex datatype, as returned by ``stft(..., return_complex=True)``.
            n_fft (int): Size of Fourier transform
            hop_length (Optional[int]): The distance between neighboring sliding window frames.
                (Default: ``n_fft // 4``)
            win_length (Optional[int]): The size of window frame and STFT filter. (Default: ``n_fft``)
            window (Optional[torch.Tensor]): The optional window function.
                Shape must be 1d and `<= n_fft`
                (Default: ``torch.ones(win_length)``)
            center (bool): Whether :attr:`input` was padded on both sides so that the :math:`t`-th frame is
                centered at time :math:`t \\times \\text{hop\\_length}`.
                (Default: ``True``)
            normalized (bool): Whether the STFT was normalized. (Default: ``False``)
            onesided (Optional[bool]): Whether the STFT was onesided.
                (Default: ``True`` if `n_fft != fft_size` in the input size)
            length (Optional[int]): The amount to trim the signal by (i.e. the
                original signal length). Defaults to `(T - 1) * hop_length` for
                centered stft, or `n_fft + (T - 1) * hop_length` otherwise, where `T`
                is the number of input frames.
            return_complex (Optional[bool]):
                Whether the output should be complex, or if the input should be
                assumed to derive from a real signal and window.
                Note that this is incompatible with ``onesided=True``.
                (Default: ``False``)

        Returns:
            Tensor: Least squares estimation of the original signal of shape `(B?, length)` where
                `B?` is an optional batch dimension from the input tensor.
        '''
    @staticmethod
    def kaiser_window(window_length, periodic=..., beta=..., dtype=..., layout=..., device=..., requires_grad=...) -> Tensor:
        """
        kaiser_window(window_length, periodic=True, beta=12.0, *, dtype=None, layout=torch.strided, device=None, requires_grad=False) -> Tensor

        Computes the Kaiser window with window length :attr:`window_length` and shape parameter :attr:`beta`.

        Let I_0 be the zeroth order modified Bessel function of the first kind (see :func:`torch.i0`) and
        ``N = L - 1`` if :attr:`periodic` is False and ``L`` if :attr:`periodic` is True,
        where ``L`` is the :attr:`window_length`. This function computes:

        .. math::
            out_i = I_0 \\left( \\beta \\sqrt{1 - \\left( {\\frac{i - N/2}{N/2}} \\right) ^2 } \\right) / I_0( \\beta )

        Calling ``torch.kaiser_window(L, B, periodic=True)`` is equivalent to calling
        ``torch.kaiser_window(L + 1, B, periodic=False)[:-1])``.
        The :attr:`periodic` argument is intended as a helpful shorthand
        to produce a periodic window as input to functions like :func:`torch.stft`.

        .. note::
            If :attr:`window_length` is one, then the returned window is a single element tensor containing a one.


        Args:
            window_length (int): length of the window.
            periodic (bool, optional): If True, returns a periodic window suitable for use in spectral analysis.
                If False, returns a symmetric window suitable for use in filter design.
            beta (float, optional): shape parameter for the window.

        Keyword args:
            dtype (:class:`torch.dtype`, optional): the desired data type of returned tensor.
                Default: if ``None``, uses a global default (see :func:`torch.set_default_dtype`).
            layout (:class:`torch.layout`, optional): the desired layout of returned window tensor. Only
                  ``torch.strided`` (dense layout) is supported.
            device (:class:`torch.device`, optional): the desired device of returned tensor.
                Default: if ``None``, uses the current device for the default tensor type
                (see :func:`torch.set_default_device`). :attr:`device` will be the CPU
                for CPU tensor types and the current CUDA device for CUDA tensor types.
            requires_grad (bool, optional): If autograd should record operations on the
                returned tensor. Default: ``False``.

        """
    @staticmethod
    def kl_div(*args, **kwargs): ...
    @staticmethod
    def kron(input, other, out=...) -> Tensor:
        """
        kron(input, other, *, out=None) -> Tensor

        Computes the Kronecker product, denoted by :math:`\\otimes`, of :attr:`input` and :attr:`other`.

        If :attr:`input` is a :math:`(a_0 \\times a_1 \\times \\dots \\times a_n)` tensor and :attr:`other` is a
        :math:`(b_0 \\times b_1 \\times \\dots \\times b_n)` tensor, the result will be a
        :math:`(a_0*b_0 \\times a_1*b_1 \\times \\dots \\times a_n*b_n)` tensor with the following entries:

        .. math::
            (\\text{input} \\otimes \\text{other})_{k_0, k_1, \\dots, k_n} =
                \\text{input}_{i_0, i_1, \\dots, i_n} * \\text{other}_{j_0, j_1, \\dots, j_n},

        where :math:`k_t = i_t * b_t + j_t` for :math:`0 \\leq t \\leq n`.
        If one tensor has fewer dimensions than the other it is unsqueezed until it has the same number of dimensions.

        Supports real-valued and complex-valued inputs.

        .. note::
            This function generalizes the typical definition of the Kronecker product for two matrices to two tensors,
            as described above. When :attr:`input` is a :math:`(m \\times n)` matrix and :attr:`other` is a
            :math:`(p \\times q)` matrix, the result will be a :math:`(p*m \\times q*n)` block matrix:

            .. math::
                \\mathbf{A} \\otimes \\mathbf{B}=\\begin{bmatrix}
                a_{11} \\mathbf{B} & \\cdots & a_{1 n} \\mathbf{B} \\\\\n                \\vdots & \\ddots & \\vdots \\\\\n                a_{m 1} \\mathbf{B} & \\cdots & a_{m n} \\mathbf{B} \\end{bmatrix}

            where :attr:`input` is :math:`\\mathbf{A}` and :attr:`other` is :math:`\\mathbf{B}`.

        Arguments:
            input (Tensor)
            other (Tensor)

        Keyword args:
            out (Tensor, optional): The output tensor. Ignored if ``None``. Default: ``None``

        Examples::

            >>> mat1 = torch.eye(2)
            >>> mat2 = torch.ones(2, 2)
            >>> torch.kron(mat1, mat2)
            tensor([[1., 1., 0., 0.],
                    [1., 1., 0., 0.],
                    [0., 0., 1., 1.],
                    [0., 0., 1., 1.]])

            >>> mat1 = torch.eye(2)
            >>> mat2 = torch.arange(1, 5).reshape(2, 2)
            >>> torch.kron(mat1, mat2)
            tensor([[1., 2., 0., 0.],
                    [3., 4., 0., 0.],
                    [0., 0., 1., 2.],
                    [0., 0., 3., 4.]])
        """
    @overload
    @staticmethod
    def kthvalue(values=..., indices=...) -> Any:
        """
        kthvalue(input, k, dim=None, keepdim=False, *, out=None) -> (Tensor, LongTensor)

        Returns a namedtuple ``(values, indices)`` where ``values`` is the :attr:`k` th
        smallest element of each row of the :attr:`input` tensor in the given dimension
        :attr:`dim`. And ``indices`` is the index location of each element found.

        If :attr:`dim` is not given, the last dimension of the `input` is chosen.

        If :attr:`keepdim` is ``True``, both the :attr:`values` and :attr:`indices` tensors
        are the same size as :attr:`input`, except in the dimension :attr:`dim` where
        they are of size 1. Otherwise, :attr:`dim` is squeezed
        (see :func:`torch.squeeze`), resulting in both the :attr:`values` and
        :attr:`indices` tensors having 1 fewer dimension than the :attr:`input` tensor.

        .. note::
            When :attr:`input` is a CUDA tensor and there are multiple valid
            :attr:`k` th values, this function may nondeterministically return
            :attr:`indices` for any of them.

        Args:
            input (Tensor): the input tensor.
            k (int): k for the k-th smallest element
            dim (int, optional): the dimension to find the kth value along
    
            keepdim (bool, optional): whether the output tensor has :attr:`dim` retained or not. Default: ``False``.


        Keyword args:
            out (tuple, optional): the output tuple of (Tensor, LongTensor)
                                   can be optionally given to be used as output buffers

        Example::

            >>> x = torch.arange(1., 6.)
            >>> x
            tensor([ 1.,  2.,  3.,  4.,  5.])
            >>> torch.kthvalue(x, 4)
            torch.return_types.kthvalue(values=tensor(4.), indices=tensor(3))

            >>> x=torch.arange(1.,7.).resize_(2,3)
            >>> x
            tensor([[ 1.,  2.,  3.],
                    [ 4.,  5.,  6.]])
            >>> torch.kthvalue(x, 2, 0, True)
            torch.return_types.kthvalue(values=tensor([[4., 5., 6.]]), indices=tensor([[1, 1, 1]]))
        """
    @overload
    @staticmethod
    def kthvalue(values=..., indices=...) -> Any:
        """
        kthvalue(input, k, dim=None, keepdim=False, *, out=None) -> (Tensor, LongTensor)

        Returns a namedtuple ``(values, indices)`` where ``values`` is the :attr:`k` th
        smallest element of each row of the :attr:`input` tensor in the given dimension
        :attr:`dim`. And ``indices`` is the index location of each element found.

        If :attr:`dim` is not given, the last dimension of the `input` is chosen.

        If :attr:`keepdim` is ``True``, both the :attr:`values` and :attr:`indices` tensors
        are the same size as :attr:`input`, except in the dimension :attr:`dim` where
        they are of size 1. Otherwise, :attr:`dim` is squeezed
        (see :func:`torch.squeeze`), resulting in both the :attr:`values` and
        :attr:`indices` tensors having 1 fewer dimension than the :attr:`input` tensor.

        .. note::
            When :attr:`input` is a CUDA tensor and there are multiple valid
            :attr:`k` th values, this function may nondeterministically return
            :attr:`indices` for any of them.

        Args:
            input (Tensor): the input tensor.
            k (int): k for the k-th smallest element
            dim (int, optional): the dimension to find the kth value along
    
            keepdim (bool, optional): whether the output tensor has :attr:`dim` retained or not. Default: ``False``.


        Keyword args:
            out (tuple, optional): the output tuple of (Tensor, LongTensor)
                                   can be optionally given to be used as output buffers

        Example::

            >>> x = torch.arange(1., 6.)
            >>> x
            tensor([ 1.,  2.,  3.,  4.,  5.])
            >>> torch.kthvalue(x, 4)
            torch.return_types.kthvalue(values=tensor(4.), indices=tensor(3))

            >>> x=torch.arange(1.,7.).resize_(2,3)
            >>> x
            tensor([[ 1.,  2.,  3.],
                    [ 4.,  5.,  6.]])
            >>> torch.kthvalue(x, 2, 0, True)
            torch.return_types.kthvalue(values=tensor([[4., 5., 6.]]), indices=tensor([[1, 1, 1]]))
        """
    @staticmethod
    def layer_norm(*args, **kwargs): ...
    @overload
    @staticmethod
    def lcm(input, other, out=...) -> Tensor:
        """
        lcm(input, other, *, out=None) -> Tensor

        Computes the element-wise least common multiple (LCM) of :attr:`input` and :attr:`other`.

        Both :attr:`input` and :attr:`other` must have integer types.

        .. note::
            This defines :math:`lcm(0, 0) = 0` and :math:`lcm(0, a) = 0`.

        Args:
            input (Tensor): the input tensor.
            other (Tensor): the second input tensor

        Keyword arguments:
            out (Tensor, optional): the output tensor.

        Example::

            >>> a = torch.tensor([5, 10, 15])
            >>> b = torch.tensor([3, 4, 5])
            >>> torch.lcm(a, b)
            tensor([15, 20, 15])
            >>> c = torch.tensor([3])
            >>> torch.lcm(a, c)
            tensor([15, 30, 15])
        """
    @overload
    @staticmethod
    def lcm(a, b) -> Any:
        """
        lcm(input, other, *, out=None) -> Tensor

        Computes the element-wise least common multiple (LCM) of :attr:`input` and :attr:`other`.

        Both :attr:`input` and :attr:`other` must have integer types.

        .. note::
            This defines :math:`lcm(0, 0) = 0` and :math:`lcm(0, a) = 0`.

        Args:
            input (Tensor): the input tensor.
            other (Tensor): the second input tensor

        Keyword arguments:
            out (Tensor, optional): the output tensor.

        Example::

            >>> a = torch.tensor([5, 10, 15])
            >>> b = torch.tensor([3, 4, 5])
            >>> torch.lcm(a, b)
            tensor([15, 20, 15])
            >>> c = torch.tensor([3])
            >>> torch.lcm(a, c)
            tensor([15, 30, 15])
        """
    @overload
    @staticmethod
    def lcm(a, c) -> Any:
        """
        lcm(input, other, *, out=None) -> Tensor

        Computes the element-wise least common multiple (LCM) of :attr:`input` and :attr:`other`.

        Both :attr:`input` and :attr:`other` must have integer types.

        .. note::
            This defines :math:`lcm(0, 0) = 0` and :math:`lcm(0, a) = 0`.

        Args:
            input (Tensor): the input tensor.
            other (Tensor): the second input tensor

        Keyword arguments:
            out (Tensor, optional): the output tensor.

        Example::

            >>> a = torch.tensor([5, 10, 15])
            >>> b = torch.tensor([3, 4, 5])
            >>> torch.lcm(a, b)
            tensor([15, 20, 15])
            >>> c = torch.tensor([3])
            >>> torch.lcm(a, c)
            tensor([15, 30, 15])
        """
    @staticmethod
    def lcm_(*args, **kwargs): ...
    @staticmethod
    def ldexp(input, other, out=...) -> Tensor:
        """
        ldexp(input, other, *, out=None) -> Tensor

        Multiplies :attr:`input` by 2 ** :attr:`other`.

        .. math::
            \\text{{out}}_i = \\text{{input}}_i * 2^\\text{{other}}_i


        Typically this function is used to construct floating point numbers by multiplying
        mantissas in :attr:`input` with integral powers of two created from the exponents
        in :attr:`other`.

        Args:
            input (Tensor): the input tensor.
            other (Tensor): a tensor of exponents, typically integers.

        Keyword args:
            out (Tensor, optional): the output tensor.

        Example::

            >>> torch.ldexp(torch.tensor([1.]), torch.tensor([1]))
            tensor([2.])
            >>> torch.ldexp(torch.tensor([1.0]), torch.tensor([1, 2, 3, 4]))
            tensor([ 2.,  4.,  8., 16.])


        """
    @staticmethod
    def ldexp_(*args, **kwargs): ...
    @staticmethod
    def le(input, other, out=...) -> Tensor:
        """
        le(input, other, *, out=None) -> Tensor

        Computes :math:`\\text{input} \\leq \\text{other}` element-wise.


        The second argument can be a number or a tensor whose shape is
        :ref:`broadcastable <broadcasting-semantics>` with the first argument.

        Args:
            input (Tensor): the tensor to compare
            other (Tensor or Scalar): the tensor or value to compare

        Keyword args:
            out (Tensor, optional): the output tensor.

        Returns:
            A boolean tensor that is True where :attr:`input` is less than or equal to
            :attr:`other` and False elsewhere

        Example::

            >>> torch.le(torch.tensor([[1, 2], [3, 4]]), torch.tensor([[1, 1], [4, 4]]))
            tensor([[True, False], [True, True]])
        """
    @staticmethod
    def lerp(input, end, weight, out=...) -> Any:
        """
        lerp(input, end, weight, *, out=None)

        Does a linear interpolation of two tensors :attr:`start` (given by :attr:`input`) and :attr:`end` based
        on a scalar or tensor :attr:`weight` and returns the resulting :attr:`out` tensor.

        .. math::
            \\text{out}_i = \\text{start}_i + \\text{weight}_i \\times (\\text{end}_i - \\text{start}_i)

        The shapes of :attr:`start` and :attr:`end` must be
        :ref:`broadcastable <broadcasting-semantics>`. If :attr:`weight` is a tensor, then
        the shapes of :attr:`weight`, :attr:`start`, and :attr:`end` must be :ref:`broadcastable <broadcasting-semantics>`.

        Args:
            input (Tensor): the tensor with the starting points
            end (Tensor): the tensor with the ending points
            weight (float or tensor): the weight for the interpolation formula

        Keyword args:
            out (Tensor, optional): the output tensor.

        Example::

            >>> start = torch.arange(1., 5.)
            >>> end = torch.empty(4).fill_(10)
            >>> start
            tensor([ 1.,  2.,  3.,  4.])
            >>> end
            tensor([ 10.,  10.,  10.,  10.])
            >>> torch.lerp(start, end, 0.5)
            tensor([ 5.5000,  6.0000,  6.5000,  7.0000])
            >>> torch.lerp(start, end, torch.full_like(start, 0.5))
            tensor([ 5.5000,  6.0000,  6.5000,  7.0000])
        """
    @staticmethod
    def less(input, other, out=...) -> Tensor:
        """
        less(input, other, *, out=None) -> Tensor

        Alias for :func:`torch.lt`.
        """
    @staticmethod
    def less_equal(input, other, out=...) -> Tensor:
        """
        less_equal(input, other, *, out=None) -> Tensor

        Alias for :func:`torch.le`.
        """
    @staticmethod
    def lgamma(input, out=...) -> Tensor:
        """
        lgamma(input, *, out=None) -> Tensor

        Computes the natural logarithm of the absolute value of the gamma function on :attr:`input`.

        .. math::
            \\text{out}_{i} = \\ln |\\Gamma(\\text{input}_{i})|

        Args:
            input (Tensor): the input tensor.

        Keyword args:
            out (Tensor, optional): the output tensor.

        Example::

            >>> a = torch.arange(0.5, 2, 0.5)
            >>> torch.lgamma(a)
            tensor([ 0.5724,  0.0000, -0.1208])
        """
    @staticmethod
    def linspace(start, end, steps, out=..., dtype=..., layout=..., device=..., requires_grad=...) -> Tensor:
        """
        linspace(start, end, steps, *, out=None, dtype=None, layout=torch.strided, device=None, requires_grad=False) -> Tensor

        Creates a one-dimensional tensor of size :attr:`steps` whose values are evenly
        spaced from :attr:`start` to :attr:`end`, inclusive. That is, the value are:

        .. math::
            (\\text{start},
            \\text{start} + \\frac{\\text{end} - \\text{start}}{\\text{steps} - 1},
            \\ldots,
            \\text{start} + (\\text{steps} - 2) * \\frac{\\text{end} - \\text{start}}{\\text{steps} - 1},
            \\text{end})


        From PyTorch 1.11 linspace requires the steps argument. Use steps=100 to restore the previous behavior.

        Args:
            start (float or Tensor): the starting value for the set of points. If `Tensor`, it must be 0-dimensional
            end (float or Tensor): the ending value for the set of points. If `Tensor`, it must be 0-dimensional
            steps (int): size of the constructed tensor

        Keyword arguments:
            out (Tensor, optional): the output tensor.
            dtype (torch.dtype, optional): the data type to perform the computation in.
                Default: if None, uses the global default dtype (see torch.get_default_dtype())
                when both :attr:`start` and :attr:`end` are real,
                and corresponding complex dtype when either is complex.
            layout (:class:`torch.layout`, optional): the desired layout of returned Tensor.
                Default: ``torch.strided``.
            device (:class:`torch.device`, optional): the desired device of returned tensor.
                Default: if ``None``, uses the current device for the default tensor type
                (see :func:`torch.set_default_device`). :attr:`device` will be the CPU
                for CPU tensor types and the current CUDA device for CUDA tensor types.
            requires_grad (bool, optional): If autograd should record operations on the
                returned tensor. Default: ``False``.


        Example::

            >>> torch.linspace(3, 10, steps=5)
            tensor([  3.0000,   4.7500,   6.5000,   8.2500,  10.0000])
            >>> torch.linspace(-10, 10, steps=5)
            tensor([-10.,  -5.,   0.,   5.,  10.])
            >>> torch.linspace(start=-10, end=10, steps=5)
            tensor([-10.,  -5.,   0.,   5.,  10.])
            >>> torch.linspace(start=-10, end=10, steps=1)
            tensor([-10.])
        """
    @staticmethod
    def log(input, out=...) -> Tensor:
        """
        log(input, *, out=None) -> Tensor

        Returns a new tensor with the natural logarithm of the elements
        of :attr:`input`.

        .. math::
            y_{i} = \\log_{e} (x_{i})


        Args:
            input (Tensor): the input tensor.

        Keyword args:
            out (Tensor, optional): the output tensor.

        Example::

            >>> a = torch.rand(5) * 5
            >>> a
            tensor([4.7767, 4.3234, 1.2156, 0.2411, 4.5739])
            >>> torch.log(a)
            tensor([ 1.5637,  1.4640,  0.1952, -1.4226,  1.5204])
        """
    @staticmethod
    def log10(input: Tensor, out: Tensor | None) -> Tensor:
        """
        log10(input: Tensor, *, out: Optional[Tensor]) -> Tensor

        Returns a new tensor with the logarithm to the base 10 of the elements
        of :attr:`input`.

        .. math::
            y_{i} = \\log_{10} (x_{i})


        Args:
            input (Tensor): the input tensor.

        Keyword args:
            out (Tensor, optional): the output tensor.

        Example::

            >>> a = torch.rand(5)
            >>> a
            tensor([ 0.5224,  0.9354,  0.7257,  0.1301,  0.2251])


            >>> torch.log10(a)
            tensor([-0.2820, -0.0290, -0.1392, -0.8857, -0.6476])

        """
    @staticmethod
    def log10_(*args, **kwargs): ...
    @staticmethod
    def log1p(input, out=...) -> Tensor:
        """
        log1p(input, *, out=None) -> Tensor

        Returns a new tensor with the natural logarithm of (1 + :attr:`input`).

        .. math::
            y_i = \\log_{e} (x_i + 1)

        .. note:: This function is more accurate than :func:`torch.log` for small
                  values of :attr:`input`

        Args:
            input (Tensor): the input tensor.

        Keyword args:
            out (Tensor, optional): the output tensor.

        Example::

            >>> a = torch.randn(5)
            >>> a
            tensor([-1.0090, -0.9923,  1.0249, -0.5372,  0.2492])
            >>> torch.log1p(a)
            tensor([    nan, -4.8653,  0.7055, -0.7705,  0.2225])
        """
    @staticmethod
    def log1p_(*args, **kwargs): ...
    @staticmethod
    def log2(input: Tensor, out: Tensor | None) -> Tensor:
        """
        log2(input: Tensor, *, out: Optional[Tensor]) -> Tensor

        Returns a new tensor with the logarithm to the base 2 of the elements
        of :attr:`input`.

        .. math::
            y_{i} = \\log_{2} (x_{i})


        Args:
            input (Tensor): the input tensor.

        Keyword args:
            out (Tensor, optional): the output tensor.

        Example::

            >>> a = torch.rand(5)
            >>> a
            tensor([ 0.8419,  0.8003,  0.9971,  0.5287,  0.0490])


            >>> torch.log2(a)
            tensor([-0.2483, -0.3213, -0.0042, -0.9196, -4.3504])

        """
    @staticmethod
    def log2_(*args, **kwargs): ...
    @staticmethod
    def log_(*args, **kwargs): ...
    @staticmethod
    def log_softmax(*args, **kwargs): ...
    @staticmethod
    def logaddexp(input, other, out=...) -> Tensor:
        """
        logaddexp(input, other, *, out=None) -> Tensor

        Logarithm of the sum of exponentiations of the inputs.

        Calculates pointwise :math:`\\log\\left(e^x + e^y\\right)`. This function is useful
        in statistics where the calculated probabilities of events may be so small as to
        exceed the range of normal floating point numbers. In such cases the logarithm
        of the calculated probability is stored. This function allows adding
        probabilities stored in such a fashion.

        This op should be disambiguated with :func:`torch.logsumexp` which performs a
        reduction on a single tensor.

        Args:
            input (Tensor): the input tensor.
            other (Tensor): the second input tensor

        Keyword arguments:
            out (Tensor, optional): the output tensor.

        Example::

            >>> torch.logaddexp(torch.tensor([-1.0]), torch.tensor([-1.0, -2, -3]))
            tensor([-0.3069, -0.6867, -0.8731])
            >>> torch.logaddexp(torch.tensor([-100.0, -200, -300]), torch.tensor([-1.0, -2, -3]))
            tensor([-1., -2., -3.])
            >>> torch.logaddexp(torch.tensor([1.0, 2000, 30000]), torch.tensor([-1.0, -2, -3]))
            tensor([1.1269e+00, 2.0000e+03, 3.0000e+04])
        """
    @staticmethod
    def logaddexp2(input, other, out=...) -> Tensor:
        """
        logaddexp2(input, other, *, out=None) -> Tensor

        Logarithm of the sum of exponentiations of the inputs in base-2.

        Calculates pointwise :math:`\\log_2\\left(2^x + 2^y\\right)`. See
        :func:`torch.logaddexp` for more details.

        Args:
            input (Tensor): the input tensor.
            other (Tensor): the second input tensor

        Keyword arguments:
            out (Tensor, optional): the output tensor.
        """
    @staticmethod
    def logcumsumexp(input, dim, out=...) -> Tensor:
        """
        logcumsumexp(input, dim, *, out=None) -> Tensor
        Returns the logarithm of the cumulative summation of the exponentiation of
        elements of :attr:`input` in the dimension :attr:`dim`.

        For summation index :math:`j` given by `dim` and other indices :math:`i`, the result is

            .. math::
                \\text{logcumsumexp}(x)_{ij} = \\log \\sum\\limits_{k=0}^{j} \\exp(x_{ik})

        Args:
            input (Tensor): the input tensor.
            dim  (int): the dimension to do the operation over

        Keyword args:
            out (Tensor, optional): the output tensor.

        Example::

            >>> a = torch.randn(10)
            >>> torch.logcumsumexp(a, dim=0)
            tensor([-0.42296738, -0.04462666,  0.86278635,  0.94622083,  1.05277811,
                     1.39202815,  1.83525007,  1.84492621,  2.06084887,  2.06844475]))
        """
    @staticmethod
    def logdet(input) -> Tensor:
        """
        logdet(input) -> Tensor

        Calculates log determinant of a square matrix or batches of square matrices.

        It returns ``-inf`` if the input has a determinant of zero, and ``NaN`` if it has
        a negative determinant.

        .. note::
            Backward through :meth:`logdet` internally uses SVD results when :attr:`input`
            is not invertible. In this case, double backward through :meth:`logdet` will
            be unstable in when :attr:`input` doesn't have distinct singular values. See
            :func:`torch.linalg.svd` for details.

        .. seealso::

                :func:`torch.linalg.slogdet` computes the sign (resp. angle) and natural logarithm of the
                absolute value of the determinant of real-valued (resp. complex) square matrices.

        Arguments:
            input (Tensor): the input tensor of size ``(*, n, n)`` where ``*`` is zero or more
                        batch dimensions.

        Example::

            >>> A = torch.randn(3, 3)
            >>> torch.det(A)
            tensor(0.2611)
            >>> torch.logdet(A)
            tensor(-1.3430)
            >>> A
            tensor([[[ 0.9254, -0.6213],
                     [-0.5787,  1.6843]],

                    [[ 0.3242, -0.9665],
                     [ 0.4539, -0.0887]],

                    [[ 1.1336, -0.4025],
                     [-0.7089,  0.9032]]])
            >>> A.det()
            tensor([1.1990, 0.4099, 0.7386])
            >>> A.det().log()
            tensor([ 0.1815, -0.8917, -0.3031])
        """
    @overload
    @staticmethod
    def logical_and(input, other, out=...) -> Tensor:
        """
        logical_and(input, other, *, out=None) -> Tensor

        Computes the element-wise logical AND of the given input tensors. Zeros are treated as ``False`` and nonzeros are
        treated as ``True``.

        Args:
            input (Tensor): the input tensor.
            other (Tensor): the tensor to compute AND with

        Keyword args:
            out (Tensor, optional): the output tensor.

        Example::

            >>> torch.logical_and(torch.tensor([True, False, True]), torch.tensor([True, False, False]))
            tensor([ True, False, False])
            >>> a = torch.tensor([0, 1, 10, 0], dtype=torch.int8)
            >>> b = torch.tensor([4, 0, 1, 0], dtype=torch.int8)
            >>> torch.logical_and(a, b)
            tensor([False, False,  True, False])
            >>> torch.logical_and(a.double(), b.double())
            tensor([False, False,  True, False])
            >>> torch.logical_and(a.double(), b)
            tensor([False, False,  True, False])
            >>> torch.logical_and(a, b, out=torch.empty(4, dtype=torch.bool))
            tensor([False, False,  True, False])
        """
    @overload
    @staticmethod
    def logical_and(a, b) -> Any:
        """
        logical_and(input, other, *, out=None) -> Tensor

        Computes the element-wise logical AND of the given input tensors. Zeros are treated as ``False`` and nonzeros are
        treated as ``True``.

        Args:
            input (Tensor): the input tensor.
            other (Tensor): the tensor to compute AND with

        Keyword args:
            out (Tensor, optional): the output tensor.

        Example::

            >>> torch.logical_and(torch.tensor([True, False, True]), torch.tensor([True, False, False]))
            tensor([ True, False, False])
            >>> a = torch.tensor([0, 1, 10, 0], dtype=torch.int8)
            >>> b = torch.tensor([4, 0, 1, 0], dtype=torch.int8)
            >>> torch.logical_and(a, b)
            tensor([False, False,  True, False])
            >>> torch.logical_and(a.double(), b.double())
            tensor([False, False,  True, False])
            >>> torch.logical_and(a.double(), b)
            tensor([False, False,  True, False])
            >>> torch.logical_and(a, b, out=torch.empty(4, dtype=torch.bool))
            tensor([False, False,  True, False])
        """
    @overload
    @staticmethod
    def logical_and(a, b, out=...) -> Any:
        """
        logical_and(input, other, *, out=None) -> Tensor

        Computes the element-wise logical AND of the given input tensors. Zeros are treated as ``False`` and nonzeros are
        treated as ``True``.

        Args:
            input (Tensor): the input tensor.
            other (Tensor): the tensor to compute AND with

        Keyword args:
            out (Tensor, optional): the output tensor.

        Example::

            >>> torch.logical_and(torch.tensor([True, False, True]), torch.tensor([True, False, False]))
            tensor([ True, False, False])
            >>> a = torch.tensor([0, 1, 10, 0], dtype=torch.int8)
            >>> b = torch.tensor([4, 0, 1, 0], dtype=torch.int8)
            >>> torch.logical_and(a, b)
            tensor([False, False,  True, False])
            >>> torch.logical_and(a.double(), b.double())
            tensor([False, False,  True, False])
            >>> torch.logical_and(a.double(), b)
            tensor([False, False,  True, False])
            >>> torch.logical_and(a, b, out=torch.empty(4, dtype=torch.bool))
            tensor([False, False,  True, False])
        """
    @staticmethod
    def logical_not(input, out=...) -> Tensor:
        """
        logical_not(input, *, out=None) -> Tensor

        Computes the element-wise logical NOT of the given input tensor. If not specified, the output tensor will have the bool
        dtype. If the input tensor is not a bool tensor, zeros are treated as ``False`` and non-zeros are treated as ``True``.

        Args:
            input (Tensor): the input tensor.

        Keyword args:
            out (Tensor, optional): the output tensor.

        Example::

            >>> torch.logical_not(torch.tensor([True, False]))
            tensor([False,  True])
            >>> torch.logical_not(torch.tensor([0, 1, -10], dtype=torch.int8))
            tensor([ True, False, False])
            >>> torch.logical_not(torch.tensor([0., 1.5, -10.], dtype=torch.double))
            tensor([ True, False, False])
            >>> torch.logical_not(torch.tensor([0., 1., -10.], dtype=torch.double), out=torch.empty(3, dtype=torch.int16))
            tensor([1, 0, 0], dtype=torch.int16)
        """
    @overload
    @staticmethod
    def logical_or(input, other, out=...) -> Tensor:
        """
        logical_or(input, other, *, out=None) -> Tensor

        Computes the element-wise logical OR of the given input tensors. Zeros are treated as ``False`` and nonzeros are
        treated as ``True``.

        Args:
            input (Tensor): the input tensor.
            other (Tensor): the tensor to compute OR with

        Keyword args:
            out (Tensor, optional): the output tensor.

        Example::

            >>> torch.logical_or(torch.tensor([True, False, True]), torch.tensor([True, False, False]))
            tensor([ True, False,  True])
            >>> a = torch.tensor([0, 1, 10, 0], dtype=torch.int8)
            >>> b = torch.tensor([4, 0, 1, 0], dtype=torch.int8)
            >>> torch.logical_or(a, b)
            tensor([ True,  True,  True, False])
            >>> torch.logical_or(a.double(), b.double())
            tensor([ True,  True,  True, False])
            >>> torch.logical_or(a.double(), b)
            tensor([ True,  True,  True, False])
            >>> torch.logical_or(a, b, out=torch.empty(4, dtype=torch.bool))
            tensor([ True,  True,  True, False])
        """
    @overload
    @staticmethod
    def logical_or(a, b) -> Any:
        """
        logical_or(input, other, *, out=None) -> Tensor

        Computes the element-wise logical OR of the given input tensors. Zeros are treated as ``False`` and nonzeros are
        treated as ``True``.

        Args:
            input (Tensor): the input tensor.
            other (Tensor): the tensor to compute OR with

        Keyword args:
            out (Tensor, optional): the output tensor.

        Example::

            >>> torch.logical_or(torch.tensor([True, False, True]), torch.tensor([True, False, False]))
            tensor([ True, False,  True])
            >>> a = torch.tensor([0, 1, 10, 0], dtype=torch.int8)
            >>> b = torch.tensor([4, 0, 1, 0], dtype=torch.int8)
            >>> torch.logical_or(a, b)
            tensor([ True,  True,  True, False])
            >>> torch.logical_or(a.double(), b.double())
            tensor([ True,  True,  True, False])
            >>> torch.logical_or(a.double(), b)
            tensor([ True,  True,  True, False])
            >>> torch.logical_or(a, b, out=torch.empty(4, dtype=torch.bool))
            tensor([ True,  True,  True, False])
        """
    @overload
    @staticmethod
    def logical_or(a, b, out=...) -> Any:
        """
        logical_or(input, other, *, out=None) -> Tensor

        Computes the element-wise logical OR of the given input tensors. Zeros are treated as ``False`` and nonzeros are
        treated as ``True``.

        Args:
            input (Tensor): the input tensor.
            other (Tensor): the tensor to compute OR with

        Keyword args:
            out (Tensor, optional): the output tensor.

        Example::

            >>> torch.logical_or(torch.tensor([True, False, True]), torch.tensor([True, False, False]))
            tensor([ True, False,  True])
            >>> a = torch.tensor([0, 1, 10, 0], dtype=torch.int8)
            >>> b = torch.tensor([4, 0, 1, 0], dtype=torch.int8)
            >>> torch.logical_or(a, b)
            tensor([ True,  True,  True, False])
            >>> torch.logical_or(a.double(), b.double())
            tensor([ True,  True,  True, False])
            >>> torch.logical_or(a.double(), b)
            tensor([ True,  True,  True, False])
            >>> torch.logical_or(a, b, out=torch.empty(4, dtype=torch.bool))
            tensor([ True,  True,  True, False])
        """
    @overload
    @staticmethod
    def logical_xor(input: Tensor, other: Tensor, out: Tensor | None) -> Tensor:
        """
        logical_xor(input: Tensor, other: Tensor, *, out: Optional[Tensor]) -> Tensor

        Computes the element-wise logical XOR of the given input tensors. Zeros are treated as ``False`` and nonzeros are
        treated as ``True``.

        Args:
            input (Tensor): the input tensor.
            other (Tensor): the tensor to compute XOR with

        Keyword args:
            out (Tensor, optional): the output tensor.

        Example::

            >>> torch.logical_xor(torch.tensor([True, False, True]), torch.tensor([True, False, False]))
            tensor([False, False,  True])
            >>> a = torch.tensor([0, 1, 10, 0], dtype=torch.int8)
            >>> b = torch.tensor([4, 0, 1, 0], dtype=torch.int8)
            >>> torch.logical_xor(a, b)
            tensor([ True,  True, False, False])
            >>> torch.logical_xor(a.double(), b.double())
            tensor([ True,  True, False, False])
            >>> torch.logical_xor(a.double(), b)
            tensor([ True,  True, False, False])
            >>> torch.logical_xor(a, b, out=torch.empty(4, dtype=torch.bool))
            tensor([ True,  True, False, False])
        """
    @overload
    @staticmethod
    def logical_xor(a, b) -> Any:
        """
        logical_xor(input: Tensor, other: Tensor, *, out: Optional[Tensor]) -> Tensor

        Computes the element-wise logical XOR of the given input tensors. Zeros are treated as ``False`` and nonzeros are
        treated as ``True``.

        Args:
            input (Tensor): the input tensor.
            other (Tensor): the tensor to compute XOR with

        Keyword args:
            out (Tensor, optional): the output tensor.

        Example::

            >>> torch.logical_xor(torch.tensor([True, False, True]), torch.tensor([True, False, False]))
            tensor([False, False,  True])
            >>> a = torch.tensor([0, 1, 10, 0], dtype=torch.int8)
            >>> b = torch.tensor([4, 0, 1, 0], dtype=torch.int8)
            >>> torch.logical_xor(a, b)
            tensor([ True,  True, False, False])
            >>> torch.logical_xor(a.double(), b.double())
            tensor([ True,  True, False, False])
            >>> torch.logical_xor(a.double(), b)
            tensor([ True,  True, False, False])
            >>> torch.logical_xor(a, b, out=torch.empty(4, dtype=torch.bool))
            tensor([ True,  True, False, False])
        """
    @overload
    @staticmethod
    def logical_xor(a, b, out=...) -> Any:
        """
        logical_xor(input: Tensor, other: Tensor, *, out: Optional[Tensor]) -> Tensor

        Computes the element-wise logical XOR of the given input tensors. Zeros are treated as ``False`` and nonzeros are
        treated as ``True``.

        Args:
            input (Tensor): the input tensor.
            other (Tensor): the tensor to compute XOR with

        Keyword args:
            out (Tensor, optional): the output tensor.

        Example::

            >>> torch.logical_xor(torch.tensor([True, False, True]), torch.tensor([True, False, False]))
            tensor([False, False,  True])
            >>> a = torch.tensor([0, 1, 10, 0], dtype=torch.int8)
            >>> b = torch.tensor([4, 0, 1, 0], dtype=torch.int8)
            >>> torch.logical_xor(a, b)
            tensor([ True,  True, False, False])
            >>> torch.logical_xor(a.double(), b.double())
            tensor([ True,  True, False, False])
            >>> torch.logical_xor(a.double(), b)
            tensor([ True,  True, False, False])
            >>> torch.logical_xor(a, b, out=torch.empty(4, dtype=torch.bool))
            tensor([ True,  True, False, False])
        """
    @staticmethod
    def logit(input, eps=..., out=...) -> Tensor:
        """
        logit(input, eps=None, *, out=None) -> Tensor

        Alias for :func:`torch.special.logit`.
        """
    @staticmethod
    def logit_(*args, **kwargs): ...
    @staticmethod
    def logspace(start, end, steps, base=..., out=..., dtype=..., layout=..., device=..., requires_grad=...) -> Tensor:
        """
        logspace(start, end, steps, base=10.0, *,          out=None, dtype=None, layout=torch.strided, device=None, requires_grad=False) -> Tensor


        Creates a one-dimensional tensor of size :attr:`steps` whose values are evenly
        spaced from :math:`{{\\text{{base}}}}^{{\\text{{start}}}}` to
        :math:`{{\\text{{base}}}}^{{\\text{{end}}}}`, inclusive, on a logarithmic scale
        with base :attr:`base`. That is, the values are:

        .. math::
            (\\text{base}^{\\text{start}},
            \\text{base}^{(\\text{start} + \\frac{\\text{end} - \\text{start}}{ \\text{steps} - 1})},
            \\ldots,
            \\text{base}^{(\\text{start} + (\\text{steps} - 2) * \\frac{\\text{end} - \\text{start}}{ \\text{steps} - 1})},
            \\text{base}^{\\text{end}})



        From PyTorch 1.11 logspace requires the steps argument. Use steps=100 to restore the previous behavior.

        Args:
            start (float or Tensor): the starting value for the set of points. If `Tensor`, it must be 0-dimensional
            end (float or Tensor): the ending value for the set of points. If `Tensor`, it must be 0-dimensional
            steps (int): size of the constructed tensor
            base (float, optional): base of the logarithm function. Default: ``10.0``.

        Keyword arguments:
            out (Tensor, optional): the output tensor.
            dtype (torch.dtype, optional): the data type to perform the computation in.
                Default: if None, uses the global default dtype (see torch.get_default_dtype())
                when both :attr:`start` and :attr:`end` are real,
                and corresponding complex dtype when either is complex.
            layout (:class:`torch.layout`, optional): the desired layout of returned Tensor.
                Default: ``torch.strided``.
            device (:class:`torch.device`, optional): the desired device of returned tensor.
                Default: if ``None``, uses the current device for the default tensor type
                (see :func:`torch.set_default_device`). :attr:`device` will be the CPU
                for CPU tensor types and the current CUDA device for CUDA tensor types.
            requires_grad (bool, optional): If autograd should record operations on the
                returned tensor. Default: ``False``.

        Example::

            >>> torch.logspace(start=-10, end=10, steps=5)
            tensor([ 1.0000e-10,  1.0000e-05,  1.0000e+00,  1.0000e+05,  1.0000e+10])
            >>> torch.logspace(start=0.1, end=1.0, steps=5)
            tensor([  1.2589,   2.1135,   3.5481,   5.9566,  10.0000])
            >>> torch.logspace(start=0.1, end=1.0, steps=1)
            tensor([1.2589])
            >>> torch.logspace(start=2, end=2, steps=1, base=2)
            tensor([4.0])
        """
    @staticmethod
    def logsumexp(input, dim, keepdim=..., out=...) -> Any:
        """
        logsumexp(input, dim, keepdim=False, *, out=None)

        Returns the log of summed exponentials of each row of the :attr:`input`
        tensor in the given dimension :attr:`dim`. The computation is numerically
        stabilized.

        For summation index :math:`j` given by `dim` and other indices :math:`i`, the result is

            .. math::
                \\text{logsumexp}(x)_{i} = \\log \\sum_j \\exp(x_{ij})


        If :attr:`keepdim` is ``True``, the output tensor is of the same size
        as :attr:`input` except in the dimension(s) :attr:`dim` where it is of size 1.
        Otherwise, :attr:`dim` is squeezed (see :func:`torch.squeeze`), resulting in the
        output tensor having 1 (or ``len(dim)``) fewer dimension(s).


        Args:
            input (Tensor): the input tensor.
            dim (int or tuple of ints): the dimension or dimensions to reduce.
    
            keepdim (bool, optional): whether the output tensor has :attr:`dim` retained or not. Default: ``False``.


        Keyword args:
            out (Tensor, optional): the output tensor.

        Example::

            >>> a = torch.randn(3, 3)
            >>> torch.logsumexp(a, 1)
            tensor([1.4907, 1.0593, 1.5696])
            >>> torch.dist(torch.logsumexp(a, 1), torch.log(torch.sum(torch.exp(a), 1)))
            tensor(1.6859e-07)
        """
    @staticmethod
    def lstm(*args, **kwargs): ...
    @staticmethod
    def lstm_cell(*args, **kwargs): ...
    @staticmethod
    def lt(input, other, out=...) -> Tensor:
        """
        lt(input, other, *, out=None) -> Tensor

        Computes :math:`\\text{input} < \\text{other}` element-wise.


        The second argument can be a number or a tensor whose shape is
        :ref:`broadcastable <broadcasting-semantics>` with the first argument.

        Args:
            input (Tensor): the tensor to compare
            other (Tensor or float): the tensor or value to compare

        Keyword args:
            out (Tensor, optional): the output tensor.

        Returns:
            A boolean tensor that is True where :attr:`input` is less than :attr:`other` and False elsewhere

        Example::

            >>> torch.lt(torch.tensor([[1, 2], [3, 4]]), torch.tensor([[1, 1], [4, 4]]))
            tensor([[False, False], [True, False]])
        """
    @overload
    @staticmethod
    def lu_solve(b, LU_data, LU_pivots, out=...) -> Tensor:
        """
        lu_solve(b, LU_data, LU_pivots, *, out=None) -> Tensor

        Returns the LU solve of the linear system :math:`Ax = b` using the partially pivoted
        LU factorization of A from :func:`~linalg.lu_factor`.

        This function supports ``float``, ``double``, ``cfloat`` and ``cdouble`` dtypes for :attr:`input`.

        .. warning::

            :func:`torch.lu_solve` is deprecated in favor of :func:`torch.linalg.lu_solve`.
            :func:`torch.lu_solve` will be removed in a future PyTorch release.
            ``X = torch.lu_solve(B, LU, pivots)`` should be replaced with

            .. code:: python

                X = linalg.lu_solve(LU, pivots, B)

        Arguments:
            b (Tensor): the RHS tensor of size :math:`(*, m, k)`, where :math:`*`
                        is zero or more batch dimensions.
            LU_data (Tensor): the pivoted LU factorization of A from :meth:`~linalg.lu_factor` of size :math:`(*, m, m)`,
                               where :math:`*` is zero or more batch dimensions.
            LU_pivots (IntTensor): the pivots of the LU factorization from :meth:`~linalg.lu_factor` of size :math:`(*, m)`,
                                   where :math:`*` is zero or more batch dimensions.
                                   The batch dimensions of :attr:`LU_pivots` must be equal to the batch dimensions of
                                   :attr:`LU_data`.

        Keyword args:
            out (Tensor, optional): the output tensor.

        Example::

            >>> A = torch.randn(2, 3, 3)
            >>> b = torch.randn(2, 3, 1)
            >>> LU, pivots = torch.linalg.lu_factor(A)
            >>> x = torch.lu_solve(b, LU, pivots)
            >>> torch.dist(A @ x, b)
            tensor(1.00000e-07 *
                   2.8312)
        """
    @overload
    @staticmethod
    def lu_solve(B, LU, pivots) -> Any:
        """
        lu_solve(b, LU_data, LU_pivots, *, out=None) -> Tensor

        Returns the LU solve of the linear system :math:`Ax = b` using the partially pivoted
        LU factorization of A from :func:`~linalg.lu_factor`.

        This function supports ``float``, ``double``, ``cfloat`` and ``cdouble`` dtypes for :attr:`input`.

        .. warning::

            :func:`torch.lu_solve` is deprecated in favor of :func:`torch.linalg.lu_solve`.
            :func:`torch.lu_solve` will be removed in a future PyTorch release.
            ``X = torch.lu_solve(B, LU, pivots)`` should be replaced with

            .. code:: python

                X = linalg.lu_solve(LU, pivots, B)

        Arguments:
            b (Tensor): the RHS tensor of size :math:`(*, m, k)`, where :math:`*`
                        is zero or more batch dimensions.
            LU_data (Tensor): the pivoted LU factorization of A from :meth:`~linalg.lu_factor` of size :math:`(*, m, m)`,
                               where :math:`*` is zero or more batch dimensions.
            LU_pivots (IntTensor): the pivots of the LU factorization from :meth:`~linalg.lu_factor` of size :math:`(*, m)`,
                                   where :math:`*` is zero or more batch dimensions.
                                   The batch dimensions of :attr:`LU_pivots` must be equal to the batch dimensions of
                                   :attr:`LU_data`.

        Keyword args:
            out (Tensor, optional): the output tensor.

        Example::

            >>> A = torch.randn(2, 3, 3)
            >>> b = torch.randn(2, 3, 1)
            >>> LU, pivots = torch.linalg.lu_factor(A)
            >>> x = torch.lu_solve(b, LU, pivots)
            >>> torch.dist(A @ x, b)
            tensor(1.00000e-07 *
                   2.8312)
        """
    @overload
    @staticmethod
    def lu_solve(LU, pivots, B) -> Any:
        """
        lu_solve(b, LU_data, LU_pivots, *, out=None) -> Tensor

        Returns the LU solve of the linear system :math:`Ax = b` using the partially pivoted
        LU factorization of A from :func:`~linalg.lu_factor`.

        This function supports ``float``, ``double``, ``cfloat`` and ``cdouble`` dtypes for :attr:`input`.

        .. warning::

            :func:`torch.lu_solve` is deprecated in favor of :func:`torch.linalg.lu_solve`.
            :func:`torch.lu_solve` will be removed in a future PyTorch release.
            ``X = torch.lu_solve(B, LU, pivots)`` should be replaced with

            .. code:: python

                X = linalg.lu_solve(LU, pivots, B)

        Arguments:
            b (Tensor): the RHS tensor of size :math:`(*, m, k)`, where :math:`*`
                        is zero or more batch dimensions.
            LU_data (Tensor): the pivoted LU factorization of A from :meth:`~linalg.lu_factor` of size :math:`(*, m, m)`,
                               where :math:`*` is zero or more batch dimensions.
            LU_pivots (IntTensor): the pivots of the LU factorization from :meth:`~linalg.lu_factor` of size :math:`(*, m)`,
                                   where :math:`*` is zero or more batch dimensions.
                                   The batch dimensions of :attr:`LU_pivots` must be equal to the batch dimensions of
                                   :attr:`LU_data`.

        Keyword args:
            out (Tensor, optional): the output tensor.

        Example::

            >>> A = torch.randn(2, 3, 3)
            >>> b = torch.randn(2, 3, 1)
            >>> LU, pivots = torch.linalg.lu_factor(A)
            >>> x = torch.lu_solve(b, LU, pivots)
            >>> torch.dist(A @ x, b)
            tensor(1.00000e-07 *
                   2.8312)
        """
    @overload
    @staticmethod
    def lu_solve(b, LU, pivots) -> Any:
        """
        lu_solve(b, LU_data, LU_pivots, *, out=None) -> Tensor

        Returns the LU solve of the linear system :math:`Ax = b` using the partially pivoted
        LU factorization of A from :func:`~linalg.lu_factor`.

        This function supports ``float``, ``double``, ``cfloat`` and ``cdouble`` dtypes for :attr:`input`.

        .. warning::

            :func:`torch.lu_solve` is deprecated in favor of :func:`torch.linalg.lu_solve`.
            :func:`torch.lu_solve` will be removed in a future PyTorch release.
            ``X = torch.lu_solve(B, LU, pivots)`` should be replaced with

            .. code:: python

                X = linalg.lu_solve(LU, pivots, B)

        Arguments:
            b (Tensor): the RHS tensor of size :math:`(*, m, k)`, where :math:`*`
                        is zero or more batch dimensions.
            LU_data (Tensor): the pivoted LU factorization of A from :meth:`~linalg.lu_factor` of size :math:`(*, m, m)`,
                               where :math:`*` is zero or more batch dimensions.
            LU_pivots (IntTensor): the pivots of the LU factorization from :meth:`~linalg.lu_factor` of size :math:`(*, m)`,
                                   where :math:`*` is zero or more batch dimensions.
                                   The batch dimensions of :attr:`LU_pivots` must be equal to the batch dimensions of
                                   :attr:`LU_data`.

        Keyword args:
            out (Tensor, optional): the output tensor.

        Example::

            >>> A = torch.randn(2, 3, 3)
            >>> b = torch.randn(2, 3, 1)
            >>> LU, pivots = torch.linalg.lu_factor(A)
            >>> x = torch.lu_solve(b, LU, pivots)
            >>> torch.dist(A @ x, b)
            tensor(1.00000e-07 *
                   2.8312)
        """
    @overload
    @staticmethod
    def lu_unpack(LU, pivots) -> Any:
        """
        lu_unpack(LU_data, LU_pivots, unpack_data=True, unpack_pivots=True, *, out=None) -> (Tensor, Tensor, Tensor)

        Unpacks the LU decomposition returned by :func:`~linalg.lu_factor` into the `P, L, U` matrices.

        .. seealso::

            :func:`~linalg.lu` returns the matrices from the LU decomposition. Its gradient formula is more efficient
            than that of doing :func:`~linalg.lu_factor` followed by :func:`~linalg.lu_unpack`.

        Args:
            LU_data (Tensor): the packed LU factorization data
            LU_pivots (Tensor): the packed LU factorization pivots
            unpack_data (bool): flag indicating if the data should be unpacked.
                                If ``False``, then the returned ``L`` and ``U`` are empty tensors.
                                Default: ``True``
            unpack_pivots (bool): flag indicating if the pivots should be unpacked into a permutation matrix ``P``.
                                  If ``False``, then the returned ``P`` is  an empty tensor.
                                  Default: ``True``

        Keyword args:
            out (tuple, optional): output tuple of three tensors. Ignored if `None`.

        Returns:
            A namedtuple ``(P, L, U)``

        Examples::

            >>> A = torch.randn(2, 3, 3)
            >>> LU, pivots = torch.linalg.lu_factor(A)
            >>> P, L, U = torch.lu_unpack(LU, pivots)
            >>> # We can recover A from the factorization
            >>> A_ = P @ L @ U
            >>> torch.allclose(A, A_)
            True

            >>> # LU factorization of a rectangular matrix:
            >>> A = torch.randn(2, 3, 2)
            >>> LU, pivots = torch.linalg.lu_factor(A)
            >>> P, L, U = torch.lu_unpack(LU, pivots)
            >>> # P, L, U are the same as returned by linalg.lu
            >>> P_, L_, U_ = torch.linalg.lu(A)
            >>> torch.allclose(P, P_) and torch.allclose(L, L_) and torch.allclose(U, U_)
            True

        """
    @overload
    @staticmethod
    def lu_unpack(LU, pivots) -> Any:
        """
        lu_unpack(LU_data, LU_pivots, unpack_data=True, unpack_pivots=True, *, out=None) -> (Tensor, Tensor, Tensor)

        Unpacks the LU decomposition returned by :func:`~linalg.lu_factor` into the `P, L, U` matrices.

        .. seealso::

            :func:`~linalg.lu` returns the matrices from the LU decomposition. Its gradient formula is more efficient
            than that of doing :func:`~linalg.lu_factor` followed by :func:`~linalg.lu_unpack`.

        Args:
            LU_data (Tensor): the packed LU factorization data
            LU_pivots (Tensor): the packed LU factorization pivots
            unpack_data (bool): flag indicating if the data should be unpacked.
                                If ``False``, then the returned ``L`` and ``U`` are empty tensors.
                                Default: ``True``
            unpack_pivots (bool): flag indicating if the pivots should be unpacked into a permutation matrix ``P``.
                                  If ``False``, then the returned ``P`` is  an empty tensor.
                                  Default: ``True``

        Keyword args:
            out (tuple, optional): output tuple of three tensors. Ignored if `None`.

        Returns:
            A namedtuple ``(P, L, U)``

        Examples::

            >>> A = torch.randn(2, 3, 3)
            >>> LU, pivots = torch.linalg.lu_factor(A)
            >>> P, L, U = torch.lu_unpack(LU, pivots)
            >>> # We can recover A from the factorization
            >>> A_ = P @ L @ U
            >>> torch.allclose(A, A_)
            True

            >>> # LU factorization of a rectangular matrix:
            >>> A = torch.randn(2, 3, 2)
            >>> LU, pivots = torch.linalg.lu_factor(A)
            >>> P, L, U = torch.lu_unpack(LU, pivots)
            >>> # P, L, U are the same as returned by linalg.lu
            >>> P_, L_, U_ = torch.linalg.lu(A)
            >>> torch.allclose(P, P_) and torch.allclose(L, L_) and torch.allclose(U, U_)
            True

        """
    @staticmethod
    def margin_ranking_loss(*args, **kwargs): ...
    @staticmethod
    def masked_fill(*args, **kwargs): ...
    @staticmethod
    def masked_scatter(*args, **kwargs): ...
    @staticmethod
    def masked_select(input, mask, out=...) -> Tensor:
        """
        masked_select(input, mask, *, out=None) -> Tensor

        Returns a new 1-D tensor which indexes the :attr:`input` tensor according to
        the boolean mask :attr:`mask` which is a `BoolTensor`.

        The shapes of the :attr:`mask` tensor and the :attr:`input` tensor don't need
        to match, but they must be :ref:`broadcastable <broadcasting-semantics>`.

        .. note:: The returned tensor does **not** use the same storage
                  as the original tensor

        Args:
            input (Tensor): the input tensor.
            mask  (BoolTensor): the tensor containing the binary mask to index with

        Keyword args:
            out (Tensor, optional): the output tensor.

        Example::

            >>> x = torch.randn(3, 4)
            >>> x
            tensor([[ 0.3552, -2.3825, -0.8297,  0.3477],
                    [-1.2035,  1.2252,  0.5002,  0.6248],
                    [ 0.1307, -2.0608,  0.1244,  2.0139]])
            >>> mask = x.ge(0.5)
            >>> mask
            tensor([[False, False, False, False],
                    [False, True, True, True],
                    [False, False, False, True]])
            >>> torch.masked_select(x, mask)
            tensor([ 1.2252,  0.5002,  0.6248,  2.0139])
        """
    @staticmethod
    def matmul(input, other, out=...) -> Tensor:
        """
        matmul(input, other, *, out=None) -> Tensor

        Matrix product of two tensors.

        The behavior depends on the dimensionality of the tensors as follows:

        - If both tensors are 1-dimensional, the dot product (scalar) is returned.
        - If both arguments are 2-dimensional, the matrix-matrix product is returned.
        - If the first argument is 1-dimensional and the second argument is 2-dimensional,
          a 1 is prepended to its dimension for the purpose of the matrix multiply.
          After the matrix multiply, the prepended dimension is removed.
        - If the first argument is 2-dimensional and the second argument is 1-dimensional,
          the matrix-vector product is returned.
        - If both arguments are at least 1-dimensional and at least one argument is
          N-dimensional (where N > 2), then a batched matrix multiply is returned.  If the first
          argument is 1-dimensional, a 1 is prepended to its dimension for the purpose of the
          batched matrix multiply and removed after.  If the second argument is 1-dimensional, a
          1 is appended to its dimension for the purpose of the batched matrix multiple and removed after.
          The non-matrix (i.e. batch) dimensions are :ref:`broadcasted <broadcasting-semantics>` (and thus
          must be broadcastable).  For example, if :attr:`input` is a
          :math:`(j \\times 1 \\times n \\times n)` tensor and :attr:`other` is a :math:`(k \\times n \\times n)`
          tensor, :attr:`out` will be a :math:`(j \\times k \\times n \\times n)` tensor.

          Note that the broadcasting logic only looks at the batch dimensions when determining if the inputs
          are broadcastable, and not the matrix dimensions. For example, if :attr:`input` is a
          :math:`(j \\times 1 \\times n \\times m)` tensor and :attr:`other` is a :math:`(k \\times m \\times p)`
          tensor, these inputs are valid for broadcasting even though the final two dimensions (i.e. the
          matrix dimensions) are different. :attr:`out` will be a :math:`(j \\times k \\times n \\times p)` tensor.

        This operation has support for arguments with :ref:`sparse layouts<sparse-docs>`. In particular the
        matrix-matrix (both arguments 2-dimensional) supports sparse arguments with the same restrictions
        as :func:`torch.mm`


        .. warning::
            Sparse support is a beta feature and some layout(s)/dtype/device combinations may not be supported,
            or may not have autograd support. If you notice missing functionality please
            open a feature request.

        This operator supports :ref:`TensorFloat32<tf32_on_ampere>`.

        On certain ROCm devices, when using float16 inputs this module will use :ref:`different precision<fp16_on_mi200>` for backward.

        .. note::

            The 1-dimensional dot product version of this function does not support an :attr:`out` parameter.

        Arguments:
            input (Tensor): the first tensor to be multiplied
            other (Tensor): the second tensor to be multiplied

        Keyword args:
            out (Tensor, optional): the output tensor.

        Example::

            >>> # vector x vector
            >>> tensor1 = torch.randn(3)
            >>> tensor2 = torch.randn(3)
            >>> torch.matmul(tensor1, tensor2).size()
            torch.Size([])
            >>> # matrix x vector
            >>> tensor1 = torch.randn(3, 4)
            >>> tensor2 = torch.randn(4)
            >>> torch.matmul(tensor1, tensor2).size()
            torch.Size([3])
            >>> # batched matrix x broadcasted vector
            >>> tensor1 = torch.randn(10, 3, 4)
            >>> tensor2 = torch.randn(4)
            >>> torch.matmul(tensor1, tensor2).size()
            torch.Size([10, 3])
            >>> # batched matrix x batched matrix
            >>> tensor1 = torch.randn(10, 3, 4)
            >>> tensor2 = torch.randn(10, 4, 5)
            >>> torch.matmul(tensor1, tensor2).size()
            torch.Size([10, 3, 5])
            >>> # batched matrix x broadcasted matrix
            >>> tensor1 = torch.randn(10, 3, 4)
            >>> tensor2 = torch.randn(4, 5)
            >>> torch.matmul(tensor1, tensor2).size()
            torch.Size([10, 3, 5])

        """
    @staticmethod
    def matrix_exp(A) -> Tensor:
        """
        matrix_exp(A) -> Tensor

        Alias for :func:`torch.linalg.matrix_exp`.
        """
    @staticmethod
    def matrix_power(input, n, out=...) -> Tensor:
        """
        matrix_power(input, n, *, out=None) -> Tensor

        Alias for :func:`torch.linalg.matrix_power`
        """
    @overload
    @staticmethod
    def max(input, out=...) -> Tensor:
        """
        max(input, *, out=None) -> Tensor

        Returns the maximum value of all elements in the ``input`` tensor.

        Args:
            input (Tensor): the input tensor.

        Keyword args:
            out (Tensor, optional): the output tensor.

        Example::

            >>> a = torch.randn(1, 3)
            >>> a
            tensor([[ 0.6763,  0.7445, -2.2369]])
            >>> torch.max(a)
            tensor(0.7445)

        .. function:: max(input, dim, keepdim=False, *, out=None) -> (Tensor, LongTensor)
           :noindex:

        Returns a namedtuple ``(values, indices)`` where ``values`` is the maximum
        value of each row of the :attr:`input` tensor in the given dimension
        :attr:`dim`. And ``indices`` is the index location of each maximum value found
        (argmax).

        If ``keepdim`` is ``True``, the output tensors are of the same size
        as ``input`` except in the dimension ``dim`` where they are of size 1.
        Otherwise, ``dim`` is squeezed (see :func:`torch.squeeze`), resulting
        in the output tensors having 1 fewer dimension than ``input``.

        .. note:: If there are multiple maximal values in a reduced row then
                  the indices of the first maximal value are returned.

        Args:
            input (Tensor): the input tensor.
    
            dim (int or tuple of ints, optional): the dimension or dimensions to reduce.
                If ``None``, all dimensions are reduced.

    
            keepdim (bool, optional): whether the output tensor has :attr:`dim` retained or not. Default: ``False``.


        Keyword args:
            out (tuple, optional): the result tuple of two output tensors (max, max_indices)

        Example::

            >>> a = torch.randn(4, 4)
            >>> a
            tensor([[-1.2360, -0.2942, -0.1222,  0.8475],
                    [ 1.1949, -1.1127, -2.2379, -0.6702],
                    [ 1.5717, -0.9207,  0.1297, -1.8768],
                    [-0.6172,  1.0036, -0.6060, -0.2432]])
            >>> torch.max(a, 1)
            torch.return_types.max(values=tensor([0.8475, 1.1949, 1.5717, 1.0036]), indices=tensor([3, 0, 0, 1]))
            >>> a = torch.tensor([[1.0, 2.0], [3.0, 4.0]])
            >>> a.max(dim=1, keepdim=True)
            torch.return_types.max(
            values=tensor([[2.], [4.]]),
            indices=tensor([[1], [1]]))
            >>> a.max(dim=1, keepdim=False)
            torch.return_types.max(
            values=tensor([2., 4.]),
            indices=tensor([1, 1]))

        .. function:: max(input, other, *, out=None) -> Tensor
           :noindex:

        See :func:`torch.maximum`.

        """
    @overload
    @staticmethod
    def max(a) -> Any:
        """
        max(input, *, out=None) -> Tensor

        Returns the maximum value of all elements in the ``input`` tensor.

        Args:
            input (Tensor): the input tensor.

        Keyword args:
            out (Tensor, optional): the output tensor.

        Example::

            >>> a = torch.randn(1, 3)
            >>> a
            tensor([[ 0.6763,  0.7445, -2.2369]])
            >>> torch.max(a)
            tensor(0.7445)

        .. function:: max(input, dim, keepdim=False, *, out=None) -> (Tensor, LongTensor)
           :noindex:

        Returns a namedtuple ``(values, indices)`` where ``values`` is the maximum
        value of each row of the :attr:`input` tensor in the given dimension
        :attr:`dim`. And ``indices`` is the index location of each maximum value found
        (argmax).

        If ``keepdim`` is ``True``, the output tensors are of the same size
        as ``input`` except in the dimension ``dim`` where they are of size 1.
        Otherwise, ``dim`` is squeezed (see :func:`torch.squeeze`), resulting
        in the output tensors having 1 fewer dimension than ``input``.

        .. note:: If there are multiple maximal values in a reduced row then
                  the indices of the first maximal value are returned.

        Args:
            input (Tensor): the input tensor.
    
            dim (int or tuple of ints, optional): the dimension or dimensions to reduce.
                If ``None``, all dimensions are reduced.

    
            keepdim (bool, optional): whether the output tensor has :attr:`dim` retained or not. Default: ``False``.


        Keyword args:
            out (tuple, optional): the result tuple of two output tensors (max, max_indices)

        Example::

            >>> a = torch.randn(4, 4)
            >>> a
            tensor([[-1.2360, -0.2942, -0.1222,  0.8475],
                    [ 1.1949, -1.1127, -2.2379, -0.6702],
                    [ 1.5717, -0.9207,  0.1297, -1.8768],
                    [-0.6172,  1.0036, -0.6060, -0.2432]])
            >>> torch.max(a, 1)
            torch.return_types.max(values=tensor([0.8475, 1.1949, 1.5717, 1.0036]), indices=tensor([3, 0, 0, 1]))
            >>> a = torch.tensor([[1.0, 2.0], [3.0, 4.0]])
            >>> a.max(dim=1, keepdim=True)
            torch.return_types.max(
            values=tensor([[2.], [4.]]),
            indices=tensor([[1], [1]]))
            >>> a.max(dim=1, keepdim=False)
            torch.return_types.max(
            values=tensor([2., 4.]),
            indices=tensor([1, 1]))

        .. function:: max(input, other, *, out=None) -> Tensor
           :noindex:

        See :func:`torch.maximum`.

        """
    @overload
    @staticmethod
    def max(values=..., indices=...) -> Any:
        """
        max(input, *, out=None) -> Tensor

        Returns the maximum value of all elements in the ``input`` tensor.

        Args:
            input (Tensor): the input tensor.

        Keyword args:
            out (Tensor, optional): the output tensor.

        Example::

            >>> a = torch.randn(1, 3)
            >>> a
            tensor([[ 0.6763,  0.7445, -2.2369]])
            >>> torch.max(a)
            tensor(0.7445)

        .. function:: max(input, dim, keepdim=False, *, out=None) -> (Tensor, LongTensor)
           :noindex:

        Returns a namedtuple ``(values, indices)`` where ``values`` is the maximum
        value of each row of the :attr:`input` tensor in the given dimension
        :attr:`dim`. And ``indices`` is the index location of each maximum value found
        (argmax).

        If ``keepdim`` is ``True``, the output tensors are of the same size
        as ``input`` except in the dimension ``dim`` where they are of size 1.
        Otherwise, ``dim`` is squeezed (see :func:`torch.squeeze`), resulting
        in the output tensors having 1 fewer dimension than ``input``.

        .. note:: If there are multiple maximal values in a reduced row then
                  the indices of the first maximal value are returned.

        Args:
            input (Tensor): the input tensor.
    
            dim (int or tuple of ints, optional): the dimension or dimensions to reduce.
                If ``None``, all dimensions are reduced.

    
            keepdim (bool, optional): whether the output tensor has :attr:`dim` retained or not. Default: ``False``.


        Keyword args:
            out (tuple, optional): the result tuple of two output tensors (max, max_indices)

        Example::

            >>> a = torch.randn(4, 4)
            >>> a
            tensor([[-1.2360, -0.2942, -0.1222,  0.8475],
                    [ 1.1949, -1.1127, -2.2379, -0.6702],
                    [ 1.5717, -0.9207,  0.1297, -1.8768],
                    [-0.6172,  1.0036, -0.6060, -0.2432]])
            >>> torch.max(a, 1)
            torch.return_types.max(values=tensor([0.8475, 1.1949, 1.5717, 1.0036]), indices=tensor([3, 0, 0, 1]))
            >>> a = torch.tensor([[1.0, 2.0], [3.0, 4.0]])
            >>> a.max(dim=1, keepdim=True)
            torch.return_types.max(
            values=tensor([[2.], [4.]]),
            indices=tensor([[1], [1]]))
            >>> a.max(dim=1, keepdim=False)
            torch.return_types.max(
            values=tensor([2., 4.]),
            indices=tensor([1, 1]))

        .. function:: max(input, other, *, out=None) -> Tensor
           :noindex:

        See :func:`torch.maximum`.

        """
    @overload
    @staticmethod
    def max(dim=..., keepdim=...) -> Any:
        """
        max(input, *, out=None) -> Tensor

        Returns the maximum value of all elements in the ``input`` tensor.

        Args:
            input (Tensor): the input tensor.

        Keyword args:
            out (Tensor, optional): the output tensor.

        Example::

            >>> a = torch.randn(1, 3)
            >>> a
            tensor([[ 0.6763,  0.7445, -2.2369]])
            >>> torch.max(a)
            tensor(0.7445)

        .. function:: max(input, dim, keepdim=False, *, out=None) -> (Tensor, LongTensor)
           :noindex:

        Returns a namedtuple ``(values, indices)`` where ``values`` is the maximum
        value of each row of the :attr:`input` tensor in the given dimension
        :attr:`dim`. And ``indices`` is the index location of each maximum value found
        (argmax).

        If ``keepdim`` is ``True``, the output tensors are of the same size
        as ``input`` except in the dimension ``dim`` where they are of size 1.
        Otherwise, ``dim`` is squeezed (see :func:`torch.squeeze`), resulting
        in the output tensors having 1 fewer dimension than ``input``.

        .. note:: If there are multiple maximal values in a reduced row then
                  the indices of the first maximal value are returned.

        Args:
            input (Tensor): the input tensor.
    
            dim (int or tuple of ints, optional): the dimension or dimensions to reduce.
                If ``None``, all dimensions are reduced.

    
            keepdim (bool, optional): whether the output tensor has :attr:`dim` retained or not. Default: ``False``.


        Keyword args:
            out (tuple, optional): the result tuple of two output tensors (max, max_indices)

        Example::

            >>> a = torch.randn(4, 4)
            >>> a
            tensor([[-1.2360, -0.2942, -0.1222,  0.8475],
                    [ 1.1949, -1.1127, -2.2379, -0.6702],
                    [ 1.5717, -0.9207,  0.1297, -1.8768],
                    [-0.6172,  1.0036, -0.6060, -0.2432]])
            >>> torch.max(a, 1)
            torch.return_types.max(values=tensor([0.8475, 1.1949, 1.5717, 1.0036]), indices=tensor([3, 0, 0, 1]))
            >>> a = torch.tensor([[1.0, 2.0], [3.0, 4.0]])
            >>> a.max(dim=1, keepdim=True)
            torch.return_types.max(
            values=tensor([[2.], [4.]]),
            indices=tensor([[1], [1]]))
            >>> a.max(dim=1, keepdim=False)
            torch.return_types.max(
            values=tensor([2., 4.]),
            indices=tensor([1, 1]))

        .. function:: max(input, other, *, out=None) -> Tensor
           :noindex:

        See :func:`torch.maximum`.

        """
    @overload
    @staticmethod
    def max(
values=..., 
indices=...) -> Any:
        """
        max(input, *, out=None) -> Tensor

        Returns the maximum value of all elements in the ``input`` tensor.

        Args:
            input (Tensor): the input tensor.

        Keyword args:
            out (Tensor, optional): the output tensor.

        Example::

            >>> a = torch.randn(1, 3)
            >>> a
            tensor([[ 0.6763,  0.7445, -2.2369]])
            >>> torch.max(a)
            tensor(0.7445)

        .. function:: max(input, dim, keepdim=False, *, out=None) -> (Tensor, LongTensor)
           :noindex:

        Returns a namedtuple ``(values, indices)`` where ``values`` is the maximum
        value of each row of the :attr:`input` tensor in the given dimension
        :attr:`dim`. And ``indices`` is the index location of each maximum value found
        (argmax).

        If ``keepdim`` is ``True``, the output tensors are of the same size
        as ``input`` except in the dimension ``dim`` where they are of size 1.
        Otherwise, ``dim`` is squeezed (see :func:`torch.squeeze`), resulting
        in the output tensors having 1 fewer dimension than ``input``.

        .. note:: If there are multiple maximal values in a reduced row then
                  the indices of the first maximal value are returned.

        Args:
            input (Tensor): the input tensor.
    
            dim (int or tuple of ints, optional): the dimension or dimensions to reduce.
                If ``None``, all dimensions are reduced.

    
            keepdim (bool, optional): whether the output tensor has :attr:`dim` retained or not. Default: ``False``.


        Keyword args:
            out (tuple, optional): the result tuple of two output tensors (max, max_indices)

        Example::

            >>> a = torch.randn(4, 4)
            >>> a
            tensor([[-1.2360, -0.2942, -0.1222,  0.8475],
                    [ 1.1949, -1.1127, -2.2379, -0.6702],
                    [ 1.5717, -0.9207,  0.1297, -1.8768],
                    [-0.6172,  1.0036, -0.6060, -0.2432]])
            >>> torch.max(a, 1)
            torch.return_types.max(values=tensor([0.8475, 1.1949, 1.5717, 1.0036]), indices=tensor([3, 0, 0, 1]))
            >>> a = torch.tensor([[1.0, 2.0], [3.0, 4.0]])
            >>> a.max(dim=1, keepdim=True)
            torch.return_types.max(
            values=tensor([[2.], [4.]]),
            indices=tensor([[1], [1]]))
            >>> a.max(dim=1, keepdim=False)
            torch.return_types.max(
            values=tensor([2., 4.]),
            indices=tensor([1, 1]))

        .. function:: max(input, other, *, out=None) -> Tensor
           :noindex:

        See :func:`torch.maximum`.

        """
    @overload
    @staticmethod
    def max(dim=..., keepdim=...) -> Any:
        """
        max(input, *, out=None) -> Tensor

        Returns the maximum value of all elements in the ``input`` tensor.

        Args:
            input (Tensor): the input tensor.

        Keyword args:
            out (Tensor, optional): the output tensor.

        Example::

            >>> a = torch.randn(1, 3)
            >>> a
            tensor([[ 0.6763,  0.7445, -2.2369]])
            >>> torch.max(a)
            tensor(0.7445)

        .. function:: max(input, dim, keepdim=False, *, out=None) -> (Tensor, LongTensor)
           :noindex:

        Returns a namedtuple ``(values, indices)`` where ``values`` is the maximum
        value of each row of the :attr:`input` tensor in the given dimension
        :attr:`dim`. And ``indices`` is the index location of each maximum value found
        (argmax).

        If ``keepdim`` is ``True``, the output tensors are of the same size
        as ``input`` except in the dimension ``dim`` where they are of size 1.
        Otherwise, ``dim`` is squeezed (see :func:`torch.squeeze`), resulting
        in the output tensors having 1 fewer dimension than ``input``.

        .. note:: If there are multiple maximal values in a reduced row then
                  the indices of the first maximal value are returned.

        Args:
            input (Tensor): the input tensor.
    
            dim (int or tuple of ints, optional): the dimension or dimensions to reduce.
                If ``None``, all dimensions are reduced.

    
            keepdim (bool, optional): whether the output tensor has :attr:`dim` retained or not. Default: ``False``.


        Keyword args:
            out (tuple, optional): the result tuple of two output tensors (max, max_indices)

        Example::

            >>> a = torch.randn(4, 4)
            >>> a
            tensor([[-1.2360, -0.2942, -0.1222,  0.8475],
                    [ 1.1949, -1.1127, -2.2379, -0.6702],
                    [ 1.5717, -0.9207,  0.1297, -1.8768],
                    [-0.6172,  1.0036, -0.6060, -0.2432]])
            >>> torch.max(a, 1)
            torch.return_types.max(values=tensor([0.8475, 1.1949, 1.5717, 1.0036]), indices=tensor([3, 0, 0, 1]))
            >>> a = torch.tensor([[1.0, 2.0], [3.0, 4.0]])
            >>> a.max(dim=1, keepdim=True)
            torch.return_types.max(
            values=tensor([[2.], [4.]]),
            indices=tensor([[1], [1]]))
            >>> a.max(dim=1, keepdim=False)
            torch.return_types.max(
            values=tensor([2., 4.]),
            indices=tensor([1, 1]))

        .. function:: max(input, other, *, out=None) -> Tensor
           :noindex:

        See :func:`torch.maximum`.

        """
    @overload
    @staticmethod
    def max(
values=..., 
indices=...) -> Any:
        """
        max(input, *, out=None) -> Tensor

        Returns the maximum value of all elements in the ``input`` tensor.

        Args:
            input (Tensor): the input tensor.

        Keyword args:
            out (Tensor, optional): the output tensor.

        Example::

            >>> a = torch.randn(1, 3)
            >>> a
            tensor([[ 0.6763,  0.7445, -2.2369]])
            >>> torch.max(a)
            tensor(0.7445)

        .. function:: max(input, dim, keepdim=False, *, out=None) -> (Tensor, LongTensor)
           :noindex:

        Returns a namedtuple ``(values, indices)`` where ``values`` is the maximum
        value of each row of the :attr:`input` tensor in the given dimension
        :attr:`dim`. And ``indices`` is the index location of each maximum value found
        (argmax).

        If ``keepdim`` is ``True``, the output tensors are of the same size
        as ``input`` except in the dimension ``dim`` where they are of size 1.
        Otherwise, ``dim`` is squeezed (see :func:`torch.squeeze`), resulting
        in the output tensors having 1 fewer dimension than ``input``.

        .. note:: If there are multiple maximal values in a reduced row then
                  the indices of the first maximal value are returned.

        Args:
            input (Tensor): the input tensor.
    
            dim (int or tuple of ints, optional): the dimension or dimensions to reduce.
                If ``None``, all dimensions are reduced.

    
            keepdim (bool, optional): whether the output tensor has :attr:`dim` retained or not. Default: ``False``.


        Keyword args:
            out (tuple, optional): the result tuple of two output tensors (max, max_indices)

        Example::

            >>> a = torch.randn(4, 4)
            >>> a
            tensor([[-1.2360, -0.2942, -0.1222,  0.8475],
                    [ 1.1949, -1.1127, -2.2379, -0.6702],
                    [ 1.5717, -0.9207,  0.1297, -1.8768],
                    [-0.6172,  1.0036, -0.6060, -0.2432]])
            >>> torch.max(a, 1)
            torch.return_types.max(values=tensor([0.8475, 1.1949, 1.5717, 1.0036]), indices=tensor([3, 0, 0, 1]))
            >>> a = torch.tensor([[1.0, 2.0], [3.0, 4.0]])
            >>> a.max(dim=1, keepdim=True)
            torch.return_types.max(
            values=tensor([[2.], [4.]]),
            indices=tensor([[1], [1]]))
            >>> a.max(dim=1, keepdim=False)
            torch.return_types.max(
            values=tensor([2., 4.]),
            indices=tensor([1, 1]))

        .. function:: max(input, other, *, out=None) -> Tensor
           :noindex:

        See :func:`torch.maximum`.

        """
    @staticmethod
    def max_pool1d(*args, **kwargs): ...
    @staticmethod
    def max_pool1d_with_indices(*args, **kwargs): ...
    @staticmethod
    def max_pool2d(*args, **kwargs): ...
    @staticmethod
    def max_pool3d(*args, **kwargs): ...
    @overload
    @staticmethod
    def maximum(input, other, out=...) -> Tensor:
        """
        maximum(input, other, *, out=None) -> Tensor

        Computes the element-wise maximum of :attr:`input` and :attr:`other`.

        .. note::
            If one of the elements being compared is a NaN, then that element is returned.
            :func:`maximum` is not supported for tensors with complex dtypes.

        Args:
            input (Tensor): the input tensor.
            other (Tensor): the second input tensor

        Keyword args:
            out (Tensor, optional): the output tensor.

        Example::

            >>> a = torch.tensor((1, 2, -1))
            >>> b = torch.tensor((3, 0, 4))
            >>> torch.maximum(a, b)
            tensor([3, 2, 4])
        """
    @overload
    @staticmethod
    def maximum(a, b) -> Any:
        """
        maximum(input, other, *, out=None) -> Tensor

        Computes the element-wise maximum of :attr:`input` and :attr:`other`.

        .. note::
            If one of the elements being compared is a NaN, then that element is returned.
            :func:`maximum` is not supported for tensors with complex dtypes.

        Args:
            input (Tensor): the input tensor.
            other (Tensor): the second input tensor

        Keyword args:
            out (Tensor, optional): the output tensor.

        Example::

            >>> a = torch.tensor((1, 2, -1))
            >>> b = torch.tensor((3, 0, 4))
            >>> torch.maximum(a, b)
            tensor([3, 2, 4])
        """
    @overload
    @staticmethod
    def mean(input, dtype=...) -> Tensor:
        """
        mean(input, *, dtype=None) -> Tensor

        .. note::
            If the `input` tensor is empty, ``torch.mean()`` returns ``nan``.
            This behavior is consistent with NumPy and follows the definition
            that the mean over an empty set is undefined.


        Returns the mean value of all elements in the :attr:`input` tensor. Input must be floating point or complex.

        Args:
            input (Tensor):
              the input tensor, either of floating point or complex dtype

        Keyword args:
            dtype (:class:`torch.dtype`, optional): the desired data type of returned tensor.
                If specified, the input tensor is casted to :attr:`dtype` before the operation
                is performed. This is useful for preventing data type overflows. Default: None.

        Example::

            >>> a = torch.randn(1, 3)
            >>> a
            tensor([[ 0.2294, -0.5481,  1.3288]])
            >>> torch.mean(a)
            tensor(0.3367)

        .. function:: mean(input, dim, keepdim=False, *, dtype=None, out=None) -> Tensor
           :noindex:

        Returns the mean value of each row of the :attr:`input` tensor in the given
        dimension :attr:`dim`. If :attr:`dim` is a list of dimensions,
        reduce over all of them.


        If :attr:`keepdim` is ``True``, the output tensor is of the same size
        as :attr:`input` except in the dimension(s) :attr:`dim` where it is of size 1.
        Otherwise, :attr:`dim` is squeezed (see :func:`torch.squeeze`), resulting in the
        output tensor having 1 (or ``len(dim)``) fewer dimension(s).


        Args:
            input (Tensor): the input tensor.
    
            dim (int or tuple of ints, optional): the dimension or dimensions to reduce.
                If ``None``, all dimensions are reduced.

    
            keepdim (bool, optional): whether the output tensor has :attr:`dim` retained or not. Default: ``False``.


        Keyword args:
            dtype (:class:`torch.dtype`, optional): the desired data type of returned tensor.
                If specified, the input tensor is casted to :attr:`dtype` before the operation
                is performed. This is useful for preventing data type overflows. Default: None.
            out (Tensor, optional): the output tensor.

        .. seealso::

            :func:`torch.nanmean` computes the mean value of `non-NaN` elements.

        Example::

            >>> a = torch.randn(4, 4)
            >>> a
            tensor([[-0.3841,  0.6320,  0.4254, -0.7384],
                    [-0.9644,  1.0131, -0.6549, -1.4279],
                    [-0.2951, -1.3350, -0.7694,  0.5600],
                    [ 1.0842, -0.9580,  0.3623,  0.2343]])
            >>> torch.mean(a, 1)
            tensor([-0.0163, -0.5085, -0.4599,  0.1807])
            >>> torch.mean(a, 1, True)
            tensor([[-0.0163],
                    [-0.5085],
                    [-0.4599],
                    [ 0.1807]])
        """
    @overload
    @staticmethod
    def mean() -> Any:
        """
        mean(input, *, dtype=None) -> Tensor

        .. note::
            If the `input` tensor is empty, ``torch.mean()`` returns ``nan``.
            This behavior is consistent with NumPy and follows the definition
            that the mean over an empty set is undefined.


        Returns the mean value of all elements in the :attr:`input` tensor. Input must be floating point or complex.

        Args:
            input (Tensor):
              the input tensor, either of floating point or complex dtype

        Keyword args:
            dtype (:class:`torch.dtype`, optional): the desired data type of returned tensor.
                If specified, the input tensor is casted to :attr:`dtype` before the operation
                is performed. This is useful for preventing data type overflows. Default: None.

        Example::

            >>> a = torch.randn(1, 3)
            >>> a
            tensor([[ 0.2294, -0.5481,  1.3288]])
            >>> torch.mean(a)
            tensor(0.3367)

        .. function:: mean(input, dim, keepdim=False, *, dtype=None, out=None) -> Tensor
           :noindex:

        Returns the mean value of each row of the :attr:`input` tensor in the given
        dimension :attr:`dim`. If :attr:`dim` is a list of dimensions,
        reduce over all of them.


        If :attr:`keepdim` is ``True``, the output tensor is of the same size
        as :attr:`input` except in the dimension(s) :attr:`dim` where it is of size 1.
        Otherwise, :attr:`dim` is squeezed (see :func:`torch.squeeze`), resulting in the
        output tensor having 1 (or ``len(dim)``) fewer dimension(s).


        Args:
            input (Tensor): the input tensor.
    
            dim (int or tuple of ints, optional): the dimension or dimensions to reduce.
                If ``None``, all dimensions are reduced.

    
            keepdim (bool, optional): whether the output tensor has :attr:`dim` retained or not. Default: ``False``.


        Keyword args:
            dtype (:class:`torch.dtype`, optional): the desired data type of returned tensor.
                If specified, the input tensor is casted to :attr:`dtype` before the operation
                is performed. This is useful for preventing data type overflows. Default: None.
            out (Tensor, optional): the output tensor.

        .. seealso::

            :func:`torch.nanmean` computes the mean value of `non-NaN` elements.

        Example::

            >>> a = torch.randn(4, 4)
            >>> a
            tensor([[-0.3841,  0.6320,  0.4254, -0.7384],
                    [-0.9644,  1.0131, -0.6549, -1.4279],
                    [-0.2951, -1.3350, -0.7694,  0.5600],
                    [ 1.0842, -0.9580,  0.3623,  0.2343]])
            >>> torch.mean(a, 1)
            tensor([-0.0163, -0.5085, -0.4599,  0.1807])
            >>> torch.mean(a, 1, True)
            tensor([[-0.0163],
                    [-0.5085],
                    [-0.4599],
                    [ 0.1807]])
        """
    @overload
    @staticmethod
    def mean(a) -> Any:
        """
        mean(input, *, dtype=None) -> Tensor

        .. note::
            If the `input` tensor is empty, ``torch.mean()`` returns ``nan``.
            This behavior is consistent with NumPy and follows the definition
            that the mean over an empty set is undefined.


        Returns the mean value of all elements in the :attr:`input` tensor. Input must be floating point or complex.

        Args:
            input (Tensor):
              the input tensor, either of floating point or complex dtype

        Keyword args:
            dtype (:class:`torch.dtype`, optional): the desired data type of returned tensor.
                If specified, the input tensor is casted to :attr:`dtype` before the operation
                is performed. This is useful for preventing data type overflows. Default: None.

        Example::

            >>> a = torch.randn(1, 3)
            >>> a
            tensor([[ 0.2294, -0.5481,  1.3288]])
            >>> torch.mean(a)
            tensor(0.3367)

        .. function:: mean(input, dim, keepdim=False, *, dtype=None, out=None) -> Tensor
           :noindex:

        Returns the mean value of each row of the :attr:`input` tensor in the given
        dimension :attr:`dim`. If :attr:`dim` is a list of dimensions,
        reduce over all of them.


        If :attr:`keepdim` is ``True``, the output tensor is of the same size
        as :attr:`input` except in the dimension(s) :attr:`dim` where it is of size 1.
        Otherwise, :attr:`dim` is squeezed (see :func:`torch.squeeze`), resulting in the
        output tensor having 1 (or ``len(dim)``) fewer dimension(s).


        Args:
            input (Tensor): the input tensor.
    
            dim (int or tuple of ints, optional): the dimension or dimensions to reduce.
                If ``None``, all dimensions are reduced.

    
            keepdim (bool, optional): whether the output tensor has :attr:`dim` retained or not. Default: ``False``.


        Keyword args:
            dtype (:class:`torch.dtype`, optional): the desired data type of returned tensor.
                If specified, the input tensor is casted to :attr:`dtype` before the operation
                is performed. This is useful for preventing data type overflows. Default: None.
            out (Tensor, optional): the output tensor.

        .. seealso::

            :func:`torch.nanmean` computes the mean value of `non-NaN` elements.

        Example::

            >>> a = torch.randn(4, 4)
            >>> a
            tensor([[-0.3841,  0.6320,  0.4254, -0.7384],
                    [-0.9644,  1.0131, -0.6549, -1.4279],
                    [-0.2951, -1.3350, -0.7694,  0.5600],
                    [ 1.0842, -0.9580,  0.3623,  0.2343]])
            >>> torch.mean(a, 1)
            tensor([-0.0163, -0.5085, -0.4599,  0.1807])
            >>> torch.mean(a, 1, True)
            tensor([[-0.0163],
                    [-0.5085],
                    [-0.4599],
                    [ 0.1807]])
        """
    @overload
    @staticmethod
    def median(input) -> Tensor:
        """
        median(input) -> Tensor

        Returns the median of the values in :attr:`input`.

        .. note::
            The median is not unique for :attr:`input` tensors with an even number
            of elements. In this case the lower of the two medians is returned. To
            compute the mean of both medians, use :func:`torch.quantile` with ``q=0.5`` instead.

        .. warning::
            This function produces deterministic (sub)gradients unlike ``median(dim=0)``

        Args:
            input (Tensor): the input tensor.

        Example::

            >>> a = torch.randn(1, 3)
            >>> a
            tensor([[ 1.5219, -1.5212,  0.2202]])
            >>> torch.median(a)
            tensor(0.2202)

        .. function:: median(input, dim=-1, keepdim=False, *, out=None) -> (Tensor, LongTensor)
           :noindex:

        Returns a namedtuple ``(values, indices)`` where ``values`` contains the median of each row of :attr:`input`
        in the dimension :attr:`dim`, and ``indices`` contains the index of the median values found in the dimension :attr:`dim`.

        By default, :attr:`dim` is the last dimension of the :attr:`input` tensor.

        If :attr:`keepdim` is ``True``, the output tensors are of the same size
        as :attr:`input` except in the dimension :attr:`dim` where they are of size 1.
        Otherwise, :attr:`dim` is squeezed (see :func:`torch.squeeze`), resulting in
        the outputs tensor having 1 fewer dimension than :attr:`input`.

        .. note::
            The median is not unique for :attr:`input` tensors with an even number
            of elements in the dimension :attr:`dim`. In this case the lower of the
            two medians is returned. To compute the mean of both medians in
            :attr:`input`, use :func:`torch.quantile` with ``q=0.5`` instead.

        .. warning::
            ``indices`` does not necessarily contain the first occurrence of each
            median value found, unless it is unique.
            The exact implementation details are device-specific.
            Do not expect the same result when run on CPU and GPU in general.
            For the same reason do not expect the gradients to be deterministic.

        Args:
            input (Tensor): the input tensor.
    
            dim (int, optional): the dimension to reduce.
                If ``None``, all dimensions are reduced.

    
            keepdim (bool, optional): whether the output tensor has :attr:`dim` retained or not. Default: ``False``.


        Keyword args:
            out ((Tensor, Tensor), optional): The first tensor will be populated with the median values and the second
                                              tensor, which must have dtype long, with their indices in the dimension
                                              :attr:`dim` of :attr:`input`.

        Example::

            >>> a = torch.randn(4, 5)
            >>> a
            tensor([[ 0.2505, -0.3982, -0.9948,  0.3518, -1.3131],
                    [ 0.3180, -0.6993,  1.0436,  0.0438,  0.2270],
                    [-0.2751,  0.7303,  0.2192,  0.3321,  0.2488],
                    [ 1.0778, -1.9510,  0.7048,  0.4742, -0.7125]])
            >>> torch.median(a, 1)
            torch.return_types.median(values=tensor([-0.3982,  0.2270,  0.2488,  0.4742]), indices=tensor([1, 4, 4, 3]))
        """
    @overload
    @staticmethod
    def median(dim=...) -> Any:
        """
        median(input) -> Tensor

        Returns the median of the values in :attr:`input`.

        .. note::
            The median is not unique for :attr:`input` tensors with an even number
            of elements. In this case the lower of the two medians is returned. To
            compute the mean of both medians, use :func:`torch.quantile` with ``q=0.5`` instead.

        .. warning::
            This function produces deterministic (sub)gradients unlike ``median(dim=0)``

        Args:
            input (Tensor): the input tensor.

        Example::

            >>> a = torch.randn(1, 3)
            >>> a
            tensor([[ 1.5219, -1.5212,  0.2202]])
            >>> torch.median(a)
            tensor(0.2202)

        .. function:: median(input, dim=-1, keepdim=False, *, out=None) -> (Tensor, LongTensor)
           :noindex:

        Returns a namedtuple ``(values, indices)`` where ``values`` contains the median of each row of :attr:`input`
        in the dimension :attr:`dim`, and ``indices`` contains the index of the median values found in the dimension :attr:`dim`.

        By default, :attr:`dim` is the last dimension of the :attr:`input` tensor.

        If :attr:`keepdim` is ``True``, the output tensors are of the same size
        as :attr:`input` except in the dimension :attr:`dim` where they are of size 1.
        Otherwise, :attr:`dim` is squeezed (see :func:`torch.squeeze`), resulting in
        the outputs tensor having 1 fewer dimension than :attr:`input`.

        .. note::
            The median is not unique for :attr:`input` tensors with an even number
            of elements in the dimension :attr:`dim`. In this case the lower of the
            two medians is returned. To compute the mean of both medians in
            :attr:`input`, use :func:`torch.quantile` with ``q=0.5`` instead.

        .. warning::
            ``indices`` does not necessarily contain the first occurrence of each
            median value found, unless it is unique.
            The exact implementation details are device-specific.
            Do not expect the same result when run on CPU and GPU in general.
            For the same reason do not expect the gradients to be deterministic.

        Args:
            input (Tensor): the input tensor.
    
            dim (int, optional): the dimension to reduce.
                If ``None``, all dimensions are reduced.

    
            keepdim (bool, optional): whether the output tensor has :attr:`dim` retained or not. Default: ``False``.


        Keyword args:
            out ((Tensor, Tensor), optional): The first tensor will be populated with the median values and the second
                                              tensor, which must have dtype long, with their indices in the dimension
                                              :attr:`dim` of :attr:`input`.

        Example::

            >>> a = torch.randn(4, 5)
            >>> a
            tensor([[ 0.2505, -0.3982, -0.9948,  0.3518, -1.3131],
                    [ 0.3180, -0.6993,  1.0436,  0.0438,  0.2270],
                    [-0.2751,  0.7303,  0.2192,  0.3321,  0.2488],
                    [ 1.0778, -1.9510,  0.7048,  0.4742, -0.7125]])
            >>> torch.median(a, 1)
            torch.return_types.median(values=tensor([-0.3982,  0.2270,  0.2488,  0.4742]), indices=tensor([1, 4, 4, 3]))
        """
    @overload
    @staticmethod
    def median(a) -> Any:
        """
        median(input) -> Tensor

        Returns the median of the values in :attr:`input`.

        .. note::
            The median is not unique for :attr:`input` tensors with an even number
            of elements. In this case the lower of the two medians is returned. To
            compute the mean of both medians, use :func:`torch.quantile` with ``q=0.5`` instead.

        .. warning::
            This function produces deterministic (sub)gradients unlike ``median(dim=0)``

        Args:
            input (Tensor): the input tensor.

        Example::

            >>> a = torch.randn(1, 3)
            >>> a
            tensor([[ 1.5219, -1.5212,  0.2202]])
            >>> torch.median(a)
            tensor(0.2202)

        .. function:: median(input, dim=-1, keepdim=False, *, out=None) -> (Tensor, LongTensor)
           :noindex:

        Returns a namedtuple ``(values, indices)`` where ``values`` contains the median of each row of :attr:`input`
        in the dimension :attr:`dim`, and ``indices`` contains the index of the median values found in the dimension :attr:`dim`.

        By default, :attr:`dim` is the last dimension of the :attr:`input` tensor.

        If :attr:`keepdim` is ``True``, the output tensors are of the same size
        as :attr:`input` except in the dimension :attr:`dim` where they are of size 1.
        Otherwise, :attr:`dim` is squeezed (see :func:`torch.squeeze`), resulting in
        the outputs tensor having 1 fewer dimension than :attr:`input`.

        .. note::
            The median is not unique for :attr:`input` tensors with an even number
            of elements in the dimension :attr:`dim`. In this case the lower of the
            two medians is returned. To compute the mean of both medians in
            :attr:`input`, use :func:`torch.quantile` with ``q=0.5`` instead.

        .. warning::
            ``indices`` does not necessarily contain the first occurrence of each
            median value found, unless it is unique.
            The exact implementation details are device-specific.
            Do not expect the same result when run on CPU and GPU in general.
            For the same reason do not expect the gradients to be deterministic.

        Args:
            input (Tensor): the input tensor.
    
            dim (int, optional): the dimension to reduce.
                If ``None``, all dimensions are reduced.

    
            keepdim (bool, optional): whether the output tensor has :attr:`dim` retained or not. Default: ``False``.


        Keyword args:
            out ((Tensor, Tensor), optional): The first tensor will be populated with the median values and the second
                                              tensor, which must have dtype long, with their indices in the dimension
                                              :attr:`dim` of :attr:`input`.

        Example::

            >>> a = torch.randn(4, 5)
            >>> a
            tensor([[ 0.2505, -0.3982, -0.9948,  0.3518, -1.3131],
                    [ 0.3180, -0.6993,  1.0436,  0.0438,  0.2270],
                    [-0.2751,  0.7303,  0.2192,  0.3321,  0.2488],
                    [ 1.0778, -1.9510,  0.7048,  0.4742, -0.7125]])
            >>> torch.median(a, 1)
            torch.return_types.median(values=tensor([-0.3982,  0.2270,  0.2488,  0.4742]), indices=tensor([1, 4, 4, 3]))
        """
    @overload
    @staticmethod
    def median(values=..., indices=...) -> Any:
        """
        median(input) -> Tensor

        Returns the median of the values in :attr:`input`.

        .. note::
            The median is not unique for :attr:`input` tensors with an even number
            of elements. In this case the lower of the two medians is returned. To
            compute the mean of both medians, use :func:`torch.quantile` with ``q=0.5`` instead.

        .. warning::
            This function produces deterministic (sub)gradients unlike ``median(dim=0)``

        Args:
            input (Tensor): the input tensor.

        Example::

            >>> a = torch.randn(1, 3)
            >>> a
            tensor([[ 1.5219, -1.5212,  0.2202]])
            >>> torch.median(a)
            tensor(0.2202)

        .. function:: median(input, dim=-1, keepdim=False, *, out=None) -> (Tensor, LongTensor)
           :noindex:

        Returns a namedtuple ``(values, indices)`` where ``values`` contains the median of each row of :attr:`input`
        in the dimension :attr:`dim`, and ``indices`` contains the index of the median values found in the dimension :attr:`dim`.

        By default, :attr:`dim` is the last dimension of the :attr:`input` tensor.

        If :attr:`keepdim` is ``True``, the output tensors are of the same size
        as :attr:`input` except in the dimension :attr:`dim` where they are of size 1.
        Otherwise, :attr:`dim` is squeezed (see :func:`torch.squeeze`), resulting in
        the outputs tensor having 1 fewer dimension than :attr:`input`.

        .. note::
            The median is not unique for :attr:`input` tensors with an even number
            of elements in the dimension :attr:`dim`. In this case the lower of the
            two medians is returned. To compute the mean of both medians in
            :attr:`input`, use :func:`torch.quantile` with ``q=0.5`` instead.

        .. warning::
            ``indices`` does not necessarily contain the first occurrence of each
            median value found, unless it is unique.
            The exact implementation details are device-specific.
            Do not expect the same result when run on CPU and GPU in general.
            For the same reason do not expect the gradients to be deterministic.

        Args:
            input (Tensor): the input tensor.
    
            dim (int, optional): the dimension to reduce.
                If ``None``, all dimensions are reduced.

    
            keepdim (bool, optional): whether the output tensor has :attr:`dim` retained or not. Default: ``False``.


        Keyword args:
            out ((Tensor, Tensor), optional): The first tensor will be populated with the median values and the second
                                              tensor, which must have dtype long, with their indices in the dimension
                                              :attr:`dim` of :attr:`input`.

        Example::

            >>> a = torch.randn(4, 5)
            >>> a
            tensor([[ 0.2505, -0.3982, -0.9948,  0.3518, -1.3131],
                    [ 0.3180, -0.6993,  1.0436,  0.0438,  0.2270],
                    [-0.2751,  0.7303,  0.2192,  0.3321,  0.2488],
                    [ 1.0778, -1.9510,  0.7048,  0.4742, -0.7125]])
            >>> torch.median(a, 1)
            torch.return_types.median(values=tensor([-0.3982,  0.2270,  0.2488,  0.4742]), indices=tensor([1, 4, 4, 3]))
        """
    @staticmethod
    def meshgrid(*args, **kwargs): ...
    @overload
    @staticmethod
    def min(input, out=...) -> Tensor:
        """
        min(input, *, out=None) -> Tensor

        Returns the minimum value of all elements in the :attr:`input` tensor.

        Args:
            input (Tensor): the input tensor.

        Keyword args:
            out (Tensor, optional): the output tensor.

        Example::

            >>> a = torch.randn(1, 3)
            >>> a
            tensor([[ 0.6750,  1.0857,  1.7197]])
            >>> torch.min(a)
            tensor(0.6750)

        .. function:: min(input, dim, keepdim=False, *, out=None) -> (Tensor, LongTensor)
           :noindex:

        Returns a namedtuple ``(values, indices)`` where ``values`` is the minimum
        value of each row of the :attr:`input` tensor in the given dimension
        :attr:`dim`. And ``indices`` is the index location of each minimum value found
        (argmin).

        If :attr:`keepdim` is ``True``, the output tensors are of the same size as
        :attr:`input` except in the dimension :attr:`dim` where they are of size 1.
        Otherwise, :attr:`dim` is squeezed (see :func:`torch.squeeze`), resulting in
        the output tensors having 1 fewer dimension than :attr:`input`.

        .. note:: If there are multiple minimal values in a reduced row then
                  the indices of the first minimal value are returned.

        Args:
            input (Tensor): the input tensor.
    
            dim (int, optional): the dimension to reduce.
                If ``None``, all dimensions are reduced.

    
            keepdim (bool, optional): whether the output tensor has :attr:`dim` retained or not. Default: ``False``.


        Keyword args:
            out (tuple, optional): the tuple of two output tensors (min, min_indices)

        Example::

            >>> a = torch.randn(4, 4)
            >>> a
            tensor([[-0.6248,  1.1334, -1.1899, -0.2803],
                    [-1.4644, -0.2635, -0.3651,  0.6134],
                    [ 0.2457,  0.0384,  1.0128,  0.7015],
                    [-0.1153,  2.9849,  2.1458,  0.5788]])
            >>> torch.min(a, 1)
            torch.return_types.min(values=tensor([-1.1899, -1.4644,  0.0384, -0.1153]), indices=tensor([2, 0, 1, 0]))

        .. function:: min(input, other, *, out=None) -> Tensor
           :noindex:

        See :func:`torch.minimum`.
        """
    @overload
    @staticmethod
    def min(a) -> Any:
        """
        min(input, *, out=None) -> Tensor

        Returns the minimum value of all elements in the :attr:`input` tensor.

        Args:
            input (Tensor): the input tensor.

        Keyword args:
            out (Tensor, optional): the output tensor.

        Example::

            >>> a = torch.randn(1, 3)
            >>> a
            tensor([[ 0.6750,  1.0857,  1.7197]])
            >>> torch.min(a)
            tensor(0.6750)

        .. function:: min(input, dim, keepdim=False, *, out=None) -> (Tensor, LongTensor)
           :noindex:

        Returns a namedtuple ``(values, indices)`` where ``values`` is the minimum
        value of each row of the :attr:`input` tensor in the given dimension
        :attr:`dim`. And ``indices`` is the index location of each minimum value found
        (argmin).

        If :attr:`keepdim` is ``True``, the output tensors are of the same size as
        :attr:`input` except in the dimension :attr:`dim` where they are of size 1.
        Otherwise, :attr:`dim` is squeezed (see :func:`torch.squeeze`), resulting in
        the output tensors having 1 fewer dimension than :attr:`input`.

        .. note:: If there are multiple minimal values in a reduced row then
                  the indices of the first minimal value are returned.

        Args:
            input (Tensor): the input tensor.
    
            dim (int, optional): the dimension to reduce.
                If ``None``, all dimensions are reduced.

    
            keepdim (bool, optional): whether the output tensor has :attr:`dim` retained or not. Default: ``False``.


        Keyword args:
            out (tuple, optional): the tuple of two output tensors (min, min_indices)

        Example::

            >>> a = torch.randn(4, 4)
            >>> a
            tensor([[-0.6248,  1.1334, -1.1899, -0.2803],
                    [-1.4644, -0.2635, -0.3651,  0.6134],
                    [ 0.2457,  0.0384,  1.0128,  0.7015],
                    [-0.1153,  2.9849,  2.1458,  0.5788]])
            >>> torch.min(a, 1)
            torch.return_types.min(values=tensor([-1.1899, -1.4644,  0.0384, -0.1153]), indices=tensor([2, 0, 1, 0]))

        .. function:: min(input, other, *, out=None) -> Tensor
           :noindex:

        See :func:`torch.minimum`.
        """
    @overload
    @staticmethod
    def min(values=..., indices=...) -> Any:
        """
        min(input, *, out=None) -> Tensor

        Returns the minimum value of all elements in the :attr:`input` tensor.

        Args:
            input (Tensor): the input tensor.

        Keyword args:
            out (Tensor, optional): the output tensor.

        Example::

            >>> a = torch.randn(1, 3)
            >>> a
            tensor([[ 0.6750,  1.0857,  1.7197]])
            >>> torch.min(a)
            tensor(0.6750)

        .. function:: min(input, dim, keepdim=False, *, out=None) -> (Tensor, LongTensor)
           :noindex:

        Returns a namedtuple ``(values, indices)`` where ``values`` is the minimum
        value of each row of the :attr:`input` tensor in the given dimension
        :attr:`dim`. And ``indices`` is the index location of each minimum value found
        (argmin).

        If :attr:`keepdim` is ``True``, the output tensors are of the same size as
        :attr:`input` except in the dimension :attr:`dim` where they are of size 1.
        Otherwise, :attr:`dim` is squeezed (see :func:`torch.squeeze`), resulting in
        the output tensors having 1 fewer dimension than :attr:`input`.

        .. note:: If there are multiple minimal values in a reduced row then
                  the indices of the first minimal value are returned.

        Args:
            input (Tensor): the input tensor.
    
            dim (int, optional): the dimension to reduce.
                If ``None``, all dimensions are reduced.

    
            keepdim (bool, optional): whether the output tensor has :attr:`dim` retained or not. Default: ``False``.


        Keyword args:
            out (tuple, optional): the tuple of two output tensors (min, min_indices)

        Example::

            >>> a = torch.randn(4, 4)
            >>> a
            tensor([[-0.6248,  1.1334, -1.1899, -0.2803],
                    [-1.4644, -0.2635, -0.3651,  0.6134],
                    [ 0.2457,  0.0384,  1.0128,  0.7015],
                    [-0.1153,  2.9849,  2.1458,  0.5788]])
            >>> torch.min(a, 1)
            torch.return_types.min(values=tensor([-1.1899, -1.4644,  0.0384, -0.1153]), indices=tensor([2, 0, 1, 0]))

        .. function:: min(input, other, *, out=None) -> Tensor
           :noindex:

        See :func:`torch.minimum`.
        """
    @overload
    @staticmethod
    def minimum(input, other, out=...) -> Tensor:
        """
        minimum(input, other, *, out=None) -> Tensor

        Computes the element-wise minimum of :attr:`input` and :attr:`other`.

        .. note::
            If one of the elements being compared is a NaN, then that element is returned.
            :func:`minimum` is not supported for tensors with complex dtypes.

        Args:
            input (Tensor): the input tensor.
            other (Tensor): the second input tensor

        Keyword args:
            out (Tensor, optional): the output tensor.

        Example::

            >>> a = torch.tensor((1, 2, -1))
            >>> b = torch.tensor((3, 0, 4))
            >>> torch.minimum(a, b)
            tensor([1, 0, -1])
        """
    @overload
    @staticmethod
    def minimum(a, b) -> Any:
        """
        minimum(input, other, *, out=None) -> Tensor

        Computes the element-wise minimum of :attr:`input` and :attr:`other`.

        .. note::
            If one of the elements being compared is a NaN, then that element is returned.
            :func:`minimum` is not supported for tensors with complex dtypes.

        Args:
            input (Tensor): the input tensor.
            other (Tensor): the second input tensor

        Keyword args:
            out (Tensor, optional): the output tensor.

        Example::

            >>> a = torch.tensor((1, 2, -1))
            >>> b = torch.tensor((3, 0, 4))
            >>> torch.minimum(a, b)
            tensor([1, 0, -1])
        """
    @staticmethod
    def miopen_batch_norm(*args, **kwargs): ...
    @staticmethod
    def miopen_convolution(*args, **kwargs): ...
    @staticmethod
    def miopen_convolution_add_relu(*args, **kwargs): ...
    @staticmethod
    def miopen_convolution_relu(*args, **kwargs): ...
    @staticmethod
    def miopen_convolution_transpose(*args, **kwargs): ...
    @staticmethod
    def miopen_depthwise_convolution(*args, **kwargs): ...
    @staticmethod
    def miopen_rnn(*args, **kwargs): ...
    @staticmethod
    def mkldnn_adaptive_avg_pool2d(*args, **kwargs): ...
    @staticmethod
    def mkldnn_convolution(*args, **kwargs): ...
    @staticmethod
    def mkldnn_linear_backward_weights(*args, **kwargs): ...
    @staticmethod
    def mkldnn_max_pool2d(*args, **kwargs): ...
    @staticmethod
    def mkldnn_max_pool3d(*args, **kwargs): ...
    @staticmethod
    def mkldnn_rnn_layer(*args, **kwargs): ...
    @staticmethod
    def mm(input, mat2, out_dtype=..., out=...) -> Tensor:
        """
        mm(input, mat2, out_dtype=None, *, out=None) -> Tensor

        Performs a matrix multiplication of the matrices :attr:`input` and :attr:`mat2`.

        If :attr:`input` is a :math:`(n \\times m)` tensor, :attr:`mat2` is a
        :math:`(m \\times p)` tensor, :attr:`out` will be a :math:`(n \\times p)` tensor.

        .. note:: This function does not :ref:`broadcast <broadcasting-semantics>`.
                  For broadcasting matrix products, see :func:`torch.matmul`.

        Supports strided and sparse 2-D tensors as inputs, autograd with
        respect to strided inputs.

        This operation has support for arguments with :ref:`sparse layouts<sparse-docs>`.
        If :attr:`out` is provided its layout will be used. Otherwise, the result
        layout will be deduced from that of :attr:`input`.


        .. warning::
            Sparse support is a beta feature and some layout(s)/dtype/device combinations may not be supported,
            or may not have autograd support. If you notice missing functionality please
            open a feature request.

        This operator supports :ref:`TensorFloat32<tf32_on_ampere>`.

        On certain ROCm devices, when using float16 inputs this module will use :ref:`different precision<fp16_on_mi200>` for backward.

        Args:
            input (Tensor): the first matrix to be matrix multiplied
            mat2 (Tensor): the second matrix to be matrix multiplied
            out_dtype (dtype, optional): the dtype of the output tensor,
                Supported only on CUDA and for torch.float32 given
                torch.float16/torch.bfloat16 input dtypes

        Keyword args:
            out (Tensor, optional): the output tensor.

        Example::

            >>> mat1 = torch.randn(2, 3)
            >>> mat2 = torch.randn(3, 3)
            >>> torch.mm(mat1, mat2)
            tensor([[ 0.4851,  0.5037, -0.3633],
                    [-0.0760, -3.6705,  2.4784]])
        """
    @staticmethod
    def mode(
values=..., 
indices=...) -> Any:
        """
        mode(input, dim=-1, keepdim=False, *, out=None) -> (Tensor, LongTensor)

        Returns a namedtuple ``(values, indices)`` where ``values`` is the mode
        value of each row of the :attr:`input` tensor in the given dimension
        :attr:`dim`, i.e. a value which appears most often
        in that row, and ``indices`` is the index location of each mode value found.

        By default, :attr:`dim` is the last dimension of the :attr:`input` tensor.

        If :attr:`keepdim` is ``True``, the output tensors are of the same size as
        :attr:`input` except in the dimension :attr:`dim` where they are of size 1.
        Otherwise, :attr:`dim` is squeezed (see :func:`torch.squeeze`), resulting
        in the output tensors having 1 fewer dimension than :attr:`input`.

        .. note:: This function is not defined for ``torch.cuda.Tensor`` yet.

        Args:
            input (Tensor): the input tensor.
    
            dim (int, optional): the dimension to reduce.

    
            keepdim (bool, optional): whether the output tensor has :attr:`dim` retained or not. Default: ``False``.


        Keyword args:
            out (tuple, optional): the result tuple of two output tensors (values, indices)

        Example::

            >>> b = torch.tensor([[0, 0, 0, 2, 0, 0, 2],
            ...                   [0, 3, 0, 0, 2, 0, 1],
            ...                   [2, 2, 2, 0, 0, 0, 3],
            ...                   [2, 2, 3, 0, 1, 1, 0],
            ...                   [1, 1, 0, 0, 2, 0, 2]])
            >>> torch.mode(b, 0)
            torch.return_types.mode(
            values=tensor([0, 2, 0, 0, 0, 0, 2]),
            indices=tensor([1, 3, 4, 4, 2, 4, 4]))
        """
    @staticmethod
    def moveaxis(input, source, destination) -> Tensor:
        """
        moveaxis(input, source, destination) -> Tensor

        Alias for :func:`torch.movedim`.

        This function is equivalent to NumPy's moveaxis function.

        Examples::

            >>> t = torch.randn(3,2,1)
            >>> t
            tensor([[[-0.3362],
                    [-0.8437]],

                    [[-0.9627],
                    [ 0.1727]],

                    [[ 0.5173],
                    [-0.1398]]])
            >>> torch.moveaxis(t, 1, 0).shape
            torch.Size([2, 3, 1])
            >>> torch.moveaxis(t, 1, 0)
            tensor([[[-0.3362],
                    [-0.9627],
                    [ 0.5173]],

                    [[-0.8437],
                    [ 0.1727],
                    [-0.1398]]])
            >>> torch.moveaxis(t, (1, 2), (0, 1)).shape
            torch.Size([2, 1, 3])
            >>> torch.moveaxis(t, (1, 2), (0, 1))
            tensor([[[-0.3362, -0.9627,  0.5173]],

                    [[-0.8437,  0.1727, -0.1398]]])
        """
    @staticmethod
    def movedim(input, source, destination) -> Tensor:
        """
        movedim(input, source, destination) -> Tensor

        Moves the dimension(s) of :attr:`input` at the position(s) in :attr:`source`
        to the position(s) in :attr:`destination`.

        Other dimensions of :attr:`input` that are not explicitly moved remain in
        their original order and appear at the positions not specified in :attr:`destination`.

        Args:
            input (Tensor): the input tensor.
            source (int or tuple of ints): Original positions of the dims to move. These must be unique.
            destination (int or tuple of ints): Destination positions for each of the original dims. These must also be unique.

        Examples::

            >>> t = torch.randn(3,2,1)
            >>> t
            tensor([[[-0.3362],
                    [-0.8437]],

                    [[-0.9627],
                    [ 0.1727]],

                    [[ 0.5173],
                    [-0.1398]]])
            >>> torch.movedim(t, 1, 0).shape
            torch.Size([2, 3, 1])
            >>> torch.movedim(t, 1, 0)
            tensor([[[-0.3362],
                    [-0.9627],
                    [ 0.5173]],

                    [[-0.8437],
                    [ 0.1727],
                    [-0.1398]]])
            >>> torch.movedim(t, (1, 2), (0, 1)).shape
            torch.Size([2, 1, 3])
            >>> torch.movedim(t, (1, 2), (0, 1))
            tensor([[[-0.3362, -0.9627,  0.5173]],

                    [[-0.8437,  0.1727, -0.1398]]])
        """
    @overload
    @staticmethod
    def msort(input: Tensor, out: Tensor | None) -> Tensor:
        """
        msort(input: Tensor, *, out: Optional[Tensor]) -> Tensor

        Sorts the elements of the :attr:`input` tensor along its first dimension
        in ascending order by value.

        .. note:: `torch.msort(t)` is equivalent to `torch.sort(t, dim=0)[0]`.
                  See also :func:`torch.sort`.

        Args:
            input (Tensor): the input tensor.

        Keyword args:
            out (Tensor, optional): the output tensor.

        Example::

            >>> t = torch.randn(3, 4)
            >>> t
            tensor([[-0.1321,  0.4370, -1.2631, -1.1289],
                    [-2.0527, -1.1250,  0.2275,  0.3077],
                    [-0.0881, -0.1259, -0.5495,  1.0284]])
            >>> torch.msort(t)
            tensor([[-2.0527, -1.1250, -1.2631, -1.1289],
                    [-0.1321, -0.1259, -0.5495,  0.3077],
                    [-0.0881,  0.4370,  0.2275,  1.0284]])
        """
    @overload
    @staticmethod
    def msort(t) -> Any:
        """
        msort(input: Tensor, *, out: Optional[Tensor]) -> Tensor

        Sorts the elements of the :attr:`input` tensor along its first dimension
        in ascending order by value.

        .. note:: `torch.msort(t)` is equivalent to `torch.sort(t, dim=0)[0]`.
                  See also :func:`torch.sort`.

        Args:
            input (Tensor): the input tensor.

        Keyword args:
            out (Tensor, optional): the output tensor.

        Example::

            >>> t = torch.randn(3, 4)
            >>> t
            tensor([[-0.1321,  0.4370, -1.2631, -1.1289],
                    [-2.0527, -1.1250,  0.2275,  0.3077],
                    [-0.0881, -0.1259, -0.5495,  1.0284]])
            >>> torch.msort(t)
            tensor([[-2.0527, -1.1250, -1.2631, -1.1289],
                    [-0.1321, -0.1259, -0.5495,  0.3077],
                    [-0.0881,  0.4370,  0.2275,  1.0284]])
        """
    @overload
    @staticmethod
    def msort(t) -> Any:
        """
        msort(input: Tensor, *, out: Optional[Tensor]) -> Tensor

        Sorts the elements of the :attr:`input` tensor along its first dimension
        in ascending order by value.

        .. note:: `torch.msort(t)` is equivalent to `torch.sort(t, dim=0)[0]`.
                  See also :func:`torch.sort`.

        Args:
            input (Tensor): the input tensor.

        Keyword args:
            out (Tensor, optional): the output tensor.

        Example::

            >>> t = torch.randn(3, 4)
            >>> t
            tensor([[-0.1321,  0.4370, -1.2631, -1.1289],
                    [-2.0527, -1.1250,  0.2275,  0.3077],
                    [-0.0881, -0.1259, -0.5495,  1.0284]])
            >>> torch.msort(t)
            tensor([[-2.0527, -1.1250, -1.2631, -1.1289],
                    [-0.1321, -0.1259, -0.5495,  0.3077],
                    [-0.0881,  0.4370,  0.2275,  1.0284]])
        """
    @staticmethod
    def mul(input, other, out=...) -> Tensor:
        """
        mul(input, other, *, out=None) -> Tensor

        Multiplies :attr:`input` by :attr:`other`.


        .. math::
            \\text{out}_i = \\text{input}_i \\times \\text{other}_i


        Supports :ref:`broadcasting to a common shape <broadcasting-semantics>`,
        :ref:`type promotion <type-promotion-doc>`, and integer, float, and complex inputs.

        Args:
            input (Tensor): the input tensor.
            other (Tensor or Number) - the tensor or number to multiply input by.

        Keyword args:
            out (Tensor, optional): the output tensor.

        Examples::

            >>> a = torch.randn(3)
            >>> a
            tensor([ 0.2015, -0.4255,  2.6087])
            >>> torch.mul(a, 100)
            tensor([  20.1494,  -42.5491,  260.8663])

            >>> b = torch.randn(4, 1)
            >>> b
            tensor([[ 1.1207],
                    [-0.3137],
                    [ 0.0700],
                    [ 0.8378]])
            >>> c = torch.randn(1, 4)
            >>> c
            tensor([[ 0.5146,  0.1216, -0.5244,  2.2382]])
            >>> torch.mul(b, c)
            tensor([[ 0.5767,  0.1363, -0.5877,  2.5083],
                    [-0.1614, -0.0382,  0.1645, -0.7021],
                    [ 0.0360,  0.0085, -0.0367,  0.1567],
                    [ 0.4312,  0.1019, -0.4394,  1.8753]])
        """
    @overload
    @staticmethod
    def multinomial(input, num_samples, replacement=..., generator=..., out=...) -> LongTensor:
        """
        multinomial(input, num_samples, replacement=False, *, generator=None, out=None) -> LongTensor

        Returns a tensor where each row contains :attr:`num_samples` indices sampled
        from the multinomial (a stricter definition would be multivariate,
        refer to :class:`torch.distributions.multinomial.Multinomial` for more details)
        probability distribution located in the corresponding row
        of tensor :attr:`input`.

        .. note::
            The rows of :attr:`input` do not need to sum to one (in which case we use
            the values as weights), but must be non-negative, finite and have
            a non-zero sum.

        Indices are ordered from left to right according to when each was sampled
        (first samples are placed in first column).

        If :attr:`input` is a vector, :attr:`out` is a vector of size :attr:`num_samples`.

        If :attr:`input` is a matrix with `m` rows, :attr:`out` is an matrix of shape
        :math:`(m \\times \\text{num\\_samples})`.

        If replacement is ``True``, samples are drawn with replacement.

        If not, they are drawn without replacement, which means that when a
        sample index is drawn for a row, it cannot be drawn again for that row.

        .. note::
            When drawn without replacement, :attr:`num_samples` must be lower than
            number of non-zero elements in :attr:`input` (or the min number of non-zero
            elements in each row of :attr:`input` if it is a matrix).

        Args:
            input (Tensor): the input tensor containing probabilities
            num_samples (int): number of samples to draw
            replacement (bool, optional): whether to draw with replacement or not

        Keyword args:
            generator (:class:`torch.Generator`, optional): a pseudorandom number generator for sampling
            out (Tensor, optional): the output tensor.

        Example::

            >>> weights = torch.tensor([0, 10, 3, 0], dtype=torch.float) # create a tensor of weights
            >>> torch.multinomial(weights, 2)
            tensor([1, 2])
            >>> torch.multinomial(weights, 5) # ERROR!
            RuntimeError: cannot sample n_sample > prob_dist.size(-1) samples without replacement
            >>> torch.multinomial(weights, 4, replacement=True)
            tensor([ 2,  1,  1,  1])
        """
    @overload
    @staticmethod
    def multinomial(astricterdefinitionwouldbemultivariate, 
referto) -> Any:
        """
        multinomial(input, num_samples, replacement=False, *, generator=None, out=None) -> LongTensor

        Returns a tensor where each row contains :attr:`num_samples` indices sampled
        from the multinomial (a stricter definition would be multivariate,
        refer to :class:`torch.distributions.multinomial.Multinomial` for more details)
        probability distribution located in the corresponding row
        of tensor :attr:`input`.

        .. note::
            The rows of :attr:`input` do not need to sum to one (in which case we use
            the values as weights), but must be non-negative, finite and have
            a non-zero sum.

        Indices are ordered from left to right according to when each was sampled
        (first samples are placed in first column).

        If :attr:`input` is a vector, :attr:`out` is a vector of size :attr:`num_samples`.

        If :attr:`input` is a matrix with `m` rows, :attr:`out` is an matrix of shape
        :math:`(m \\times \\text{num\\_samples})`.

        If replacement is ``True``, samples are drawn with replacement.

        If not, they are drawn without replacement, which means that when a
        sample index is drawn for a row, it cannot be drawn again for that row.

        .. note::
            When drawn without replacement, :attr:`num_samples` must be lower than
            number of non-zero elements in :attr:`input` (or the min number of non-zero
            elements in each row of :attr:`input` if it is a matrix).

        Args:
            input (Tensor): the input tensor containing probabilities
            num_samples (int): number of samples to draw
            replacement (bool, optional): whether to draw with replacement or not

        Keyword args:
            generator (:class:`torch.Generator`, optional): a pseudorandom number generator for sampling
            out (Tensor, optional): the output tensor.

        Example::

            >>> weights = torch.tensor([0, 10, 3, 0], dtype=torch.float) # create a tensor of weights
            >>> torch.multinomial(weights, 2)
            tensor([1, 2])
            >>> torch.multinomial(weights, 5) # ERROR!
            RuntimeError: cannot sample n_sample > prob_dist.size(-1) samples without replacement
            >>> torch.multinomial(weights, 4, replacement=True)
            tensor([ 2,  1,  1,  1])
        """
    @staticmethod
    def multiply(input, other, out=...) -> Any:
        """
        multiply(input, other, *, out=None)

        Alias for :func:`torch.mul`.
        """
    @staticmethod
    def mv(input, vec, out=...) -> Tensor:
        """
        mv(input, vec, *, out=None) -> Tensor

        Performs a matrix-vector product of the matrix :attr:`input` and the vector
        :attr:`vec`.

        If :attr:`input` is a :math:`(n \\times m)` tensor, :attr:`vec` is a 1-D tensor of
        size :math:`m`, :attr:`out` will be 1-D of size :math:`n`.

        .. note:: This function does not :ref:`broadcast <broadcasting-semantics>`.

        Args:
            input (Tensor): matrix to be multiplied
            vec (Tensor): vector to be multiplied

        Keyword args:
            out (Tensor, optional): the output tensor.

        Example::

            >>> mat = torch.randn(2, 3)
            >>> vec = torch.randn(3)
            >>> torch.mv(mat, vec)
            tensor([ 1.0404, -0.6361])
        """
    @staticmethod
    def mvlgamma(input, p, out=...) -> Tensor:
        """
        mvlgamma(input, p, *, out=None) -> Tensor

        Alias for :func:`torch.special.multigammaln`.
        """
    @staticmethod
    def nan_to_num(input, nan=..., posinf=..., neginf=..., out=...) -> Tensor:
        """
        nan_to_num(input, nan=0.0, posinf=None, neginf=None, *, out=None) -> Tensor

        Replaces :literal:`NaN`, positive infinity, and negative infinity values in :attr:`input`
        with the values specified by :attr:`nan`, :attr:`posinf`, and :attr:`neginf`, respectively.
        By default, :literal:`NaN`\\ s are replaced with zero, positive infinity is replaced with the
        greatest finite value representable by :attr:`input`'s dtype, and negative infinity
        is replaced with the least finite value representable by :attr:`input`'s dtype.

        Args:
            input (Tensor): the input tensor.
            nan (Number, optional): the value to replace :literal:`NaN`\\s with. Default is zero.
            posinf (Number, optional): if a Number, the value to replace positive infinity values with.
                If None, positive infinity values are replaced with the greatest finite value representable by :attr:`input`'s dtype.
                Default is None.
            neginf (Number, optional): if a Number, the value to replace negative infinity values with.
                If None, negative infinity values are replaced with the lowest finite value representable by :attr:`input`'s dtype.
                Default is None.

        Keyword args:
            out (Tensor, optional): the output tensor.

        Example::

            >>> x = torch.tensor([float('nan'), float('inf'), -float('inf'), 3.14])
            >>> torch.nan_to_num(x)
            tensor([ 0.0000e+00,  3.4028e+38, -3.4028e+38,  3.1400e+00])
            >>> torch.nan_to_num(x, nan=2.0)
            tensor([ 2.0000e+00,  3.4028e+38, -3.4028e+38,  3.1400e+00])
            >>> torch.nan_to_num(x, nan=2.0, posinf=1.0)
            tensor([ 2.0000e+00,  1.0000e+00, -3.4028e+38,  3.1400e+00])

        """
    @staticmethod
    def nan_to_num_(*args, **kwargs): ...
    @overload
    @staticmethod
    def nanmean(input, dim=..., keepdim=..., dtype=..., out=...) -> Tensor:
        """
        nanmean(input, dim=None, keepdim=False, *, dtype=None, out=None) -> Tensor

        Computes the mean of all `non-NaN` elements along the specified dimensions.
        Input must be floating point or complex.

        This function is identical to :func:`torch.mean` when there are no `NaN` values
        in the :attr:`input` tensor. In the presence of `NaN`, :func:`torch.mean` will
        propagate the `NaN` to the output whereas :func:`torch.nanmean` will ignore the
        `NaN` values (`torch.nanmean(a)` is equivalent to `torch.mean(a[~a.isnan()])`).


        If :attr:`keepdim` is ``True``, the output tensor is of the same size
        as :attr:`input` except in the dimension(s) :attr:`dim` where it is of size 1.
        Otherwise, :attr:`dim` is squeezed (see :func:`torch.squeeze`), resulting in the
        output tensor having 1 (or ``len(dim)``) fewer dimension(s).


        Args:
            input (Tensor): the input tensor, either of floating point or complex dtype
    
            dim (int or tuple of ints, optional): the dimension or dimensions to reduce.
                If ``None``, all dimensions are reduced.

    
            keepdim (bool, optional): whether the output tensor has :attr:`dim` retained or not. Default: ``False``.


        Keyword args:
            dtype (:class:`torch.dtype`, optional): the desired data type of returned tensor.
                If specified, the input tensor is casted to :attr:`dtype` before the operation
                is performed. This is useful for preventing data type overflows. Default: None.
            out (Tensor, optional): the output tensor.

        .. seealso::

            :func:`torch.mean` computes the mean value, propagating `NaN`.

        Example::

            >>> x = torch.tensor([[torch.nan, 1, 2], [1, 2, 3]])
            >>> x.mean()
            tensor(nan)
            >>> x.nanmean()
            tensor(1.8000)
            >>> x.mean(dim=0)
            tensor([   nan, 1.5000, 2.5000])
            >>> x.nanmean(dim=0)
            tensor([1.0000, 1.5000, 2.5000])

            # If all elements in the reduced dimensions are NaN then the result is NaN
            >>> torch.tensor([torch.nan]).nanmean()
            tensor(nan)
        """
    @overload
    @staticmethod
    def nanmean(a) -> Any:
        """
        nanmean(input, dim=None, keepdim=False, *, dtype=None, out=None) -> Tensor

        Computes the mean of all `non-NaN` elements along the specified dimensions.
        Input must be floating point or complex.

        This function is identical to :func:`torch.mean` when there are no `NaN` values
        in the :attr:`input` tensor. In the presence of `NaN`, :func:`torch.mean` will
        propagate the `NaN` to the output whereas :func:`torch.nanmean` will ignore the
        `NaN` values (`torch.nanmean(a)` is equivalent to `torch.mean(a[~a.isnan()])`).


        If :attr:`keepdim` is ``True``, the output tensor is of the same size
        as :attr:`input` except in the dimension(s) :attr:`dim` where it is of size 1.
        Otherwise, :attr:`dim` is squeezed (see :func:`torch.squeeze`), resulting in the
        output tensor having 1 (or ``len(dim)``) fewer dimension(s).


        Args:
            input (Tensor): the input tensor, either of floating point or complex dtype
    
            dim (int or tuple of ints, optional): the dimension or dimensions to reduce.
                If ``None``, all dimensions are reduced.

    
            keepdim (bool, optional): whether the output tensor has :attr:`dim` retained or not. Default: ``False``.


        Keyword args:
            dtype (:class:`torch.dtype`, optional): the desired data type of returned tensor.
                If specified, the input tensor is casted to :attr:`dtype` before the operation
                is performed. This is useful for preventing data type overflows. Default: None.
            out (Tensor, optional): the output tensor.

        .. seealso::

            :func:`torch.mean` computes the mean value, propagating `NaN`.

        Example::

            >>> x = torch.tensor([[torch.nan, 1, 2], [1, 2, 3]])
            >>> x.mean()
            tensor(nan)
            >>> x.nanmean()
            tensor(1.8000)
            >>> x.mean(dim=0)
            tensor([   nan, 1.5000, 2.5000])
            >>> x.nanmean(dim=0)
            tensor([1.0000, 1.5000, 2.5000])

            # If all elements in the reduced dimensions are NaN then the result is NaN
            >>> torch.tensor([torch.nan]).nanmean()
            tensor(nan)
        """
    @overload
    @staticmethod
    def nanmean() -> Any:
        """
        nanmean(input, dim=None, keepdim=False, *, dtype=None, out=None) -> Tensor

        Computes the mean of all `non-NaN` elements along the specified dimensions.
        Input must be floating point or complex.

        This function is identical to :func:`torch.mean` when there are no `NaN` values
        in the :attr:`input` tensor. In the presence of `NaN`, :func:`torch.mean` will
        propagate the `NaN` to the output whereas :func:`torch.nanmean` will ignore the
        `NaN` values (`torch.nanmean(a)` is equivalent to `torch.mean(a[~a.isnan()])`).


        If :attr:`keepdim` is ``True``, the output tensor is of the same size
        as :attr:`input` except in the dimension(s) :attr:`dim` where it is of size 1.
        Otherwise, :attr:`dim` is squeezed (see :func:`torch.squeeze`), resulting in the
        output tensor having 1 (or ``len(dim)``) fewer dimension(s).


        Args:
            input (Tensor): the input tensor, either of floating point or complex dtype
    
            dim (int or tuple of ints, optional): the dimension or dimensions to reduce.
                If ``None``, all dimensions are reduced.

    
            keepdim (bool, optional): whether the output tensor has :attr:`dim` retained or not. Default: ``False``.


        Keyword args:
            dtype (:class:`torch.dtype`, optional): the desired data type of returned tensor.
                If specified, the input tensor is casted to :attr:`dtype` before the operation
                is performed. This is useful for preventing data type overflows. Default: None.
            out (Tensor, optional): the output tensor.

        .. seealso::

            :func:`torch.mean` computes the mean value, propagating `NaN`.

        Example::

            >>> x = torch.tensor([[torch.nan, 1, 2], [1, 2, 3]])
            >>> x.mean()
            tensor(nan)
            >>> x.nanmean()
            tensor(1.8000)
            >>> x.mean(dim=0)
            tensor([   nan, 1.5000, 2.5000])
            >>> x.nanmean(dim=0)
            tensor([1.0000, 1.5000, 2.5000])

            # If all elements in the reduced dimensions are NaN then the result is NaN
            >>> torch.tensor([torch.nan]).nanmean()
            tensor(nan)
        """
    @overload
    @staticmethod
    def nanmean(dim=...) -> Any:
        """
        nanmean(input, dim=None, keepdim=False, *, dtype=None, out=None) -> Tensor

        Computes the mean of all `non-NaN` elements along the specified dimensions.
        Input must be floating point or complex.

        This function is identical to :func:`torch.mean` when there are no `NaN` values
        in the :attr:`input` tensor. In the presence of `NaN`, :func:`torch.mean` will
        propagate the `NaN` to the output whereas :func:`torch.nanmean` will ignore the
        `NaN` values (`torch.nanmean(a)` is equivalent to `torch.mean(a[~a.isnan()])`).


        If :attr:`keepdim` is ``True``, the output tensor is of the same size
        as :attr:`input` except in the dimension(s) :attr:`dim` where it is of size 1.
        Otherwise, :attr:`dim` is squeezed (see :func:`torch.squeeze`), resulting in the
        output tensor having 1 (or ``len(dim)``) fewer dimension(s).


        Args:
            input (Tensor): the input tensor, either of floating point or complex dtype
    
            dim (int or tuple of ints, optional): the dimension or dimensions to reduce.
                If ``None``, all dimensions are reduced.

    
            keepdim (bool, optional): whether the output tensor has :attr:`dim` retained or not. Default: ``False``.


        Keyword args:
            dtype (:class:`torch.dtype`, optional): the desired data type of returned tensor.
                If specified, the input tensor is casted to :attr:`dtype` before the operation
                is performed. This is useful for preventing data type overflows. Default: None.
            out (Tensor, optional): the output tensor.

        .. seealso::

            :func:`torch.mean` computes the mean value, propagating `NaN`.

        Example::

            >>> x = torch.tensor([[torch.nan, 1, 2], [1, 2, 3]])
            >>> x.mean()
            tensor(nan)
            >>> x.nanmean()
            tensor(1.8000)
            >>> x.mean(dim=0)
            tensor([   nan, 1.5000, 2.5000])
            >>> x.nanmean(dim=0)
            tensor([1.0000, 1.5000, 2.5000])

            # If all elements in the reduced dimensions are NaN then the result is NaN
            >>> torch.tensor([torch.nan]).nanmean()
            tensor(nan)
        """
    @overload
    @staticmethod
    def nanmean() -> Any:
        """
        nanmean(input, dim=None, keepdim=False, *, dtype=None, out=None) -> Tensor

        Computes the mean of all `non-NaN` elements along the specified dimensions.
        Input must be floating point or complex.

        This function is identical to :func:`torch.mean` when there are no `NaN` values
        in the :attr:`input` tensor. In the presence of `NaN`, :func:`torch.mean` will
        propagate the `NaN` to the output whereas :func:`torch.nanmean` will ignore the
        `NaN` values (`torch.nanmean(a)` is equivalent to `torch.mean(a[~a.isnan()])`).


        If :attr:`keepdim` is ``True``, the output tensor is of the same size
        as :attr:`input` except in the dimension(s) :attr:`dim` where it is of size 1.
        Otherwise, :attr:`dim` is squeezed (see :func:`torch.squeeze`), resulting in the
        output tensor having 1 (or ``len(dim)``) fewer dimension(s).


        Args:
            input (Tensor): the input tensor, either of floating point or complex dtype
    
            dim (int or tuple of ints, optional): the dimension or dimensions to reduce.
                If ``None``, all dimensions are reduced.

    
            keepdim (bool, optional): whether the output tensor has :attr:`dim` retained or not. Default: ``False``.


        Keyword args:
            dtype (:class:`torch.dtype`, optional): the desired data type of returned tensor.
                If specified, the input tensor is casted to :attr:`dtype` before the operation
                is performed. This is useful for preventing data type overflows. Default: None.
            out (Tensor, optional): the output tensor.

        .. seealso::

            :func:`torch.mean` computes the mean value, propagating `NaN`.

        Example::

            >>> x = torch.tensor([[torch.nan, 1, 2], [1, 2, 3]])
            >>> x.mean()
            tensor(nan)
            >>> x.nanmean()
            tensor(1.8000)
            >>> x.mean(dim=0)
            tensor([   nan, 1.5000, 2.5000])
            >>> x.nanmean(dim=0)
            tensor([1.0000, 1.5000, 2.5000])

            # If all elements in the reduced dimensions are NaN then the result is NaN
            >>> torch.tensor([torch.nan]).nanmean()
            tensor(nan)
        """
    @overload
    @staticmethod
    def nanmedian(input) -> Tensor:
        """
        nanmedian(input) -> Tensor

        Returns the median of the values in :attr:`input`, ignoring ``NaN`` values.

        This function is identical to :func:`torch.median` when there are no ``NaN`` values in :attr:`input`.
        When :attr:`input` has one or more ``NaN`` values, :func:`torch.median` will always return ``NaN``,
        while this function will return the median of the non-``NaN`` elements in :attr:`input`.
        If all the elements in :attr:`input` are ``NaN`` it will also return ``NaN``.

        Args:
            input (Tensor): the input tensor.

        Example::

            >>> a = torch.tensor([1, float('nan'), 3, 2])
            >>> a.median()
            tensor(nan)
            >>> a.nanmedian()
            tensor(2.)

        .. function:: nanmedian(input, dim=-1, keepdim=False, *, out=None) -> (Tensor, LongTensor)
           :noindex:

        Returns a namedtuple ``(values, indices)`` where ``values`` contains the median of each row of :attr:`input`
        in the dimension :attr:`dim`, ignoring ``NaN`` values, and ``indices`` contains the index of the median values
        found in the dimension :attr:`dim`.

        This function is identical to :func:`torch.median` when there are no ``NaN`` values in a reduced row. When a reduced row has
        one or more ``NaN`` values, :func:`torch.median` will always reduce it to ``NaN``, while this function will reduce it to the
        median of the non-``NaN`` elements. If all the elements in a reduced row are ``NaN`` then it will be reduced to ``NaN``, too.

        Args:
            input (Tensor): the input tensor.
    
            dim (int, optional): the dimension to reduce.
                If ``None``, all dimensions are reduced.

    
            keepdim (bool, optional): whether the output tensor has :attr:`dim` retained or not. Default: ``False``.


        Keyword args:
            out ((Tensor, Tensor), optional): The first tensor will be populated with the median values and the second
                                              tensor, which must have dtype long, with their indices in the dimension
                                              :attr:`dim` of :attr:`input`.

        Example::

            >>> a = torch.tensor([[2, 3, 1], [float('nan'), 1, float('nan')]])
            >>> a
            tensor([[2., 3., 1.],
                    [nan, 1., nan]])
            >>> a.median(0)
            torch.return_types.median(values=tensor([nan, 1., nan]), indices=tensor([1, 1, 1]))
            >>> a.nanmedian(0)
            torch.return_types.nanmedian(values=tensor([2., 1., 1.]), indices=tensor([0, 1, 0]))
        """
    @overload
    @staticmethod
    def nanmedian() -> Any:
        """
        nanmedian(input) -> Tensor

        Returns the median of the values in :attr:`input`, ignoring ``NaN`` values.

        This function is identical to :func:`torch.median` when there are no ``NaN`` values in :attr:`input`.
        When :attr:`input` has one or more ``NaN`` values, :func:`torch.median` will always return ``NaN``,
        while this function will return the median of the non-``NaN`` elements in :attr:`input`.
        If all the elements in :attr:`input` are ``NaN`` it will also return ``NaN``.

        Args:
            input (Tensor): the input tensor.

        Example::

            >>> a = torch.tensor([1, float('nan'), 3, 2])
            >>> a.median()
            tensor(nan)
            >>> a.nanmedian()
            tensor(2.)

        .. function:: nanmedian(input, dim=-1, keepdim=False, *, out=None) -> (Tensor, LongTensor)
           :noindex:

        Returns a namedtuple ``(values, indices)`` where ``values`` contains the median of each row of :attr:`input`
        in the dimension :attr:`dim`, ignoring ``NaN`` values, and ``indices`` contains the index of the median values
        found in the dimension :attr:`dim`.

        This function is identical to :func:`torch.median` when there are no ``NaN`` values in a reduced row. When a reduced row has
        one or more ``NaN`` values, :func:`torch.median` will always reduce it to ``NaN``, while this function will reduce it to the
        median of the non-``NaN`` elements. If all the elements in a reduced row are ``NaN`` then it will be reduced to ``NaN``, too.

        Args:
            input (Tensor): the input tensor.
    
            dim (int, optional): the dimension to reduce.
                If ``None``, all dimensions are reduced.

    
            keepdim (bool, optional): whether the output tensor has :attr:`dim` retained or not. Default: ``False``.


        Keyword args:
            out ((Tensor, Tensor), optional): The first tensor will be populated with the median values and the second
                                              tensor, which must have dtype long, with their indices in the dimension
                                              :attr:`dim` of :attr:`input`.

        Example::

            >>> a = torch.tensor([[2, 3, 1], [float('nan'), 1, float('nan')]])
            >>> a
            tensor([[2., 3., 1.],
                    [nan, 1., nan]])
            >>> a.median(0)
            torch.return_types.median(values=tensor([nan, 1., nan]), indices=tensor([1, 1, 1]))
            >>> a.nanmedian(0)
            torch.return_types.nanmedian(values=tensor([2., 1., 1.]), indices=tensor([0, 1, 0]))
        """
    @overload
    @staticmethod
    def nanmedian(values=..., indices=...) -> Any:
        """
        nanmedian(input) -> Tensor

        Returns the median of the values in :attr:`input`, ignoring ``NaN`` values.

        This function is identical to :func:`torch.median` when there are no ``NaN`` values in :attr:`input`.
        When :attr:`input` has one or more ``NaN`` values, :func:`torch.median` will always return ``NaN``,
        while this function will return the median of the non-``NaN`` elements in :attr:`input`.
        If all the elements in :attr:`input` are ``NaN`` it will also return ``NaN``.

        Args:
            input (Tensor): the input tensor.

        Example::

            >>> a = torch.tensor([1, float('nan'), 3, 2])
            >>> a.median()
            tensor(nan)
            >>> a.nanmedian()
            tensor(2.)

        .. function:: nanmedian(input, dim=-1, keepdim=False, *, out=None) -> (Tensor, LongTensor)
           :noindex:

        Returns a namedtuple ``(values, indices)`` where ``values`` contains the median of each row of :attr:`input`
        in the dimension :attr:`dim`, ignoring ``NaN`` values, and ``indices`` contains the index of the median values
        found in the dimension :attr:`dim`.

        This function is identical to :func:`torch.median` when there are no ``NaN`` values in a reduced row. When a reduced row has
        one or more ``NaN`` values, :func:`torch.median` will always reduce it to ``NaN``, while this function will reduce it to the
        median of the non-``NaN`` elements. If all the elements in a reduced row are ``NaN`` then it will be reduced to ``NaN``, too.

        Args:
            input (Tensor): the input tensor.
    
            dim (int, optional): the dimension to reduce.
                If ``None``, all dimensions are reduced.

    
            keepdim (bool, optional): whether the output tensor has :attr:`dim` retained or not. Default: ``False``.


        Keyword args:
            out ((Tensor, Tensor), optional): The first tensor will be populated with the median values and the second
                                              tensor, which must have dtype long, with their indices in the dimension
                                              :attr:`dim` of :attr:`input`.

        Example::

            >>> a = torch.tensor([[2, 3, 1], [float('nan'), 1, float('nan')]])
            >>> a
            tensor([[2., 3., 1.],
                    [nan, 1., nan]])
            >>> a.median(0)
            torch.return_types.median(values=tensor([nan, 1., nan]), indices=tensor([1, 1, 1]))
            >>> a.nanmedian(0)
            torch.return_types.nanmedian(values=tensor([2., 1., 1.]), indices=tensor([0, 1, 0]))
        """
    @staticmethod
    def nanquantile(input, q, dim=..., keepdim=..., interpolation=..., out=...) -> Tensor:
        '''
        nanquantile(input, q, dim=None, keepdim=False, *, interpolation=\'linear\', out=None) -> Tensor

        This is a variant of :func:`torch.quantile` that "ignores" ``NaN`` values,
        computing the quantiles :attr:`q` as if ``NaN`` values in :attr:`input` did
        not exist. If all values in a reduced row are ``NaN`` then the quantiles for
        that reduction will be ``NaN``. See the documentation for :func:`torch.quantile`.

        Args:
            input (Tensor): the input tensor.
            q (float or Tensor): a scalar or 1D tensor of quantile values in the range [0, 1]
    
            dim (int, optional): the dimension to reduce.
                If ``None``, all dimensions are reduced.

    
            keepdim (bool, optional): whether the output tensor has :attr:`dim` retained or not. Default: ``False``.


        Keyword arguments:
            interpolation (str): interpolation method to use when the desired quantile lies between two data points.
                                    Can be ``linear``, ``lower``, ``higher``, ``midpoint`` and ``nearest``.
                                    Default is ``linear``.
            out (Tensor, optional): the output tensor.

        Example::

            >>> t = torch.tensor([float(\'nan\'), 1, 2])
            >>> t.quantile(0.5)
            tensor(nan)
            >>> t.nanquantile(0.5)
            tensor(1.5000)
            >>> t = torch.tensor([[float(\'nan\'), float(\'nan\')], [1, 2]])
            >>> t
            tensor([[nan, nan],
                    [1., 2.]])
            >>> t.nanquantile(0.5, dim=0)
            tensor([1., 2.])
            >>> t.nanquantile(0.5, dim=1)
            tensor([   nan, 1.5000])
        '''
    @overload
    @staticmethod
    def nansum(input, dtype=...) -> Tensor:
        '''
        nansum(input, *, dtype=None) -> Tensor

        Returns the sum of all elements, treating Not a Numbers (NaNs) as zero.

        Args:
            input (Tensor): the input tensor.

        Keyword args:
            dtype (:class:`torch.dtype`, optional): the desired data type of returned tensor.
                If specified, the input tensor is casted to :attr:`dtype` before the operation
                is performed. This is useful for preventing data type overflows. Default: None.

        Example::

            >>> a = torch.tensor([1., 2., float(\'nan\'), 4.])
            >>> torch.nansum(a)
            tensor(7.)

        .. function:: nansum(input, dim, keepdim=False, *, dtype=None) -> Tensor
           :noindex:

        Returns the sum of each row of the :attr:`input` tensor in the given
        dimension :attr:`dim`, treating Not a Numbers (NaNs) as zero.
        If :attr:`dim` is a list of dimensions, reduce over all of them.


        If :attr:`keepdim` is ``True``, the output tensor is of the same size
        as :attr:`input` except in the dimension(s) :attr:`dim` where it is of size 1.
        Otherwise, :attr:`dim` is squeezed (see :func:`torch.squeeze`), resulting in the
        output tensor having 1 (or ``len(dim)``) fewer dimension(s).


        Args:
            input (Tensor): the input tensor.
    
            dim (int or tuple of ints, optional): the dimension or dimensions to reduce.
                If ``None``, all dimensions are reduced.

    
            keepdim (bool, optional): whether the output tensor has :attr:`dim` retained or not. Default: ``False``.


        Keyword args:
            dtype (:class:`torch.dtype`, optional): the desired data type of returned tensor.
                If specified, the input tensor is casted to :attr:`dtype` before the operation
                is performed. This is useful for preventing data type overflows. Default: None.

        Example::

            >>> torch.nansum(torch.tensor([1., float("nan")]))
            tensor(1.)
            >>> a = torch.tensor([[1, 2], [3., float("nan")]])
            >>> torch.nansum(a)
            tensor(6.)
            >>> torch.nansum(a, dim=0)
            tensor([4., 2.])
            >>> torch.nansum(a, dim=1)
            tensor([3., 3.])
        '''
    @overload
    @staticmethod
    def nansum(a) -> Any:
        '''
        nansum(input, *, dtype=None) -> Tensor

        Returns the sum of all elements, treating Not a Numbers (NaNs) as zero.

        Args:
            input (Tensor): the input tensor.

        Keyword args:
            dtype (:class:`torch.dtype`, optional): the desired data type of returned tensor.
                If specified, the input tensor is casted to :attr:`dtype` before the operation
                is performed. This is useful for preventing data type overflows. Default: None.

        Example::

            >>> a = torch.tensor([1., 2., float(\'nan\'), 4.])
            >>> torch.nansum(a)
            tensor(7.)

        .. function:: nansum(input, dim, keepdim=False, *, dtype=None) -> Tensor
           :noindex:

        Returns the sum of each row of the :attr:`input` tensor in the given
        dimension :attr:`dim`, treating Not a Numbers (NaNs) as zero.
        If :attr:`dim` is a list of dimensions, reduce over all of them.


        If :attr:`keepdim` is ``True``, the output tensor is of the same size
        as :attr:`input` except in the dimension(s) :attr:`dim` where it is of size 1.
        Otherwise, :attr:`dim` is squeezed (see :func:`torch.squeeze`), resulting in the
        output tensor having 1 (or ``len(dim)``) fewer dimension(s).


        Args:
            input (Tensor): the input tensor.
    
            dim (int or tuple of ints, optional): the dimension or dimensions to reduce.
                If ``None``, all dimensions are reduced.

    
            keepdim (bool, optional): whether the output tensor has :attr:`dim` retained or not. Default: ``False``.


        Keyword args:
            dtype (:class:`torch.dtype`, optional): the desired data type of returned tensor.
                If specified, the input tensor is casted to :attr:`dtype` before the operation
                is performed. This is useful for preventing data type overflows. Default: None.

        Example::

            >>> torch.nansum(torch.tensor([1., float("nan")]))
            tensor(1.)
            >>> a = torch.tensor([[1, 2], [3., float("nan")]])
            >>> torch.nansum(a)
            tensor(6.)
            >>> torch.nansum(a, dim=0)
            tensor([4., 2.])
            >>> torch.nansum(a, dim=1)
            tensor([3., 3.])
        '''
    @overload
    @staticmethod
    def nansum(a) -> Any:
        '''
        nansum(input, *, dtype=None) -> Tensor

        Returns the sum of all elements, treating Not a Numbers (NaNs) as zero.

        Args:
            input (Tensor): the input tensor.

        Keyword args:
            dtype (:class:`torch.dtype`, optional): the desired data type of returned tensor.
                If specified, the input tensor is casted to :attr:`dtype` before the operation
                is performed. This is useful for preventing data type overflows. Default: None.

        Example::

            >>> a = torch.tensor([1., 2., float(\'nan\'), 4.])
            >>> torch.nansum(a)
            tensor(7.)

        .. function:: nansum(input, dim, keepdim=False, *, dtype=None) -> Tensor
           :noindex:

        Returns the sum of each row of the :attr:`input` tensor in the given
        dimension :attr:`dim`, treating Not a Numbers (NaNs) as zero.
        If :attr:`dim` is a list of dimensions, reduce over all of them.


        If :attr:`keepdim` is ``True``, the output tensor is of the same size
        as :attr:`input` except in the dimension(s) :attr:`dim` where it is of size 1.
        Otherwise, :attr:`dim` is squeezed (see :func:`torch.squeeze`), resulting in the
        output tensor having 1 (or ``len(dim)``) fewer dimension(s).


        Args:
            input (Tensor): the input tensor.
    
            dim (int or tuple of ints, optional): the dimension or dimensions to reduce.
                If ``None``, all dimensions are reduced.

    
            keepdim (bool, optional): whether the output tensor has :attr:`dim` retained or not. Default: ``False``.


        Keyword args:
            dtype (:class:`torch.dtype`, optional): the desired data type of returned tensor.
                If specified, the input tensor is casted to :attr:`dtype` before the operation
                is performed. This is useful for preventing data type overflows. Default: None.

        Example::

            >>> torch.nansum(torch.tensor([1., float("nan")]))
            tensor(1.)
            >>> a = torch.tensor([[1, 2], [3., float("nan")]])
            >>> torch.nansum(a)
            tensor(6.)
            >>> torch.nansum(a, dim=0)
            tensor([4., 2.])
            >>> torch.nansum(a, dim=1)
            tensor([3., 3.])
        '''
    @overload
    @staticmethod
    def nansum(a, dim=...) -> Any:
        '''
        nansum(input, *, dtype=None) -> Tensor

        Returns the sum of all elements, treating Not a Numbers (NaNs) as zero.

        Args:
            input (Tensor): the input tensor.

        Keyword args:
            dtype (:class:`torch.dtype`, optional): the desired data type of returned tensor.
                If specified, the input tensor is casted to :attr:`dtype` before the operation
                is performed. This is useful for preventing data type overflows. Default: None.

        Example::

            >>> a = torch.tensor([1., 2., float(\'nan\'), 4.])
            >>> torch.nansum(a)
            tensor(7.)

        .. function:: nansum(input, dim, keepdim=False, *, dtype=None) -> Tensor
           :noindex:

        Returns the sum of each row of the :attr:`input` tensor in the given
        dimension :attr:`dim`, treating Not a Numbers (NaNs) as zero.
        If :attr:`dim` is a list of dimensions, reduce over all of them.


        If :attr:`keepdim` is ``True``, the output tensor is of the same size
        as :attr:`input` except in the dimension(s) :attr:`dim` where it is of size 1.
        Otherwise, :attr:`dim` is squeezed (see :func:`torch.squeeze`), resulting in the
        output tensor having 1 (or ``len(dim)``) fewer dimension(s).


        Args:
            input (Tensor): the input tensor.
    
            dim (int or tuple of ints, optional): the dimension or dimensions to reduce.
                If ``None``, all dimensions are reduced.

    
            keepdim (bool, optional): whether the output tensor has :attr:`dim` retained or not. Default: ``False``.


        Keyword args:
            dtype (:class:`torch.dtype`, optional): the desired data type of returned tensor.
                If specified, the input tensor is casted to :attr:`dtype` before the operation
                is performed. This is useful for preventing data type overflows. Default: None.

        Example::

            >>> torch.nansum(torch.tensor([1., float("nan")]))
            tensor(1.)
            >>> a = torch.tensor([[1, 2], [3., float("nan")]])
            >>> torch.nansum(a)
            tensor(6.)
            >>> torch.nansum(a, dim=0)
            tensor([4., 2.])
            >>> torch.nansum(a, dim=1)
            tensor([3., 3.])
        '''
    @overload
    @staticmethod
    def nansum(a, dim=...) -> Any:
        '''
        nansum(input, *, dtype=None) -> Tensor

        Returns the sum of all elements, treating Not a Numbers (NaNs) as zero.

        Args:
            input (Tensor): the input tensor.

        Keyword args:
            dtype (:class:`torch.dtype`, optional): the desired data type of returned tensor.
                If specified, the input tensor is casted to :attr:`dtype` before the operation
                is performed. This is useful for preventing data type overflows. Default: None.

        Example::

            >>> a = torch.tensor([1., 2., float(\'nan\'), 4.])
            >>> torch.nansum(a)
            tensor(7.)

        .. function:: nansum(input, dim, keepdim=False, *, dtype=None) -> Tensor
           :noindex:

        Returns the sum of each row of the :attr:`input` tensor in the given
        dimension :attr:`dim`, treating Not a Numbers (NaNs) as zero.
        If :attr:`dim` is a list of dimensions, reduce over all of them.


        If :attr:`keepdim` is ``True``, the output tensor is of the same size
        as :attr:`input` except in the dimension(s) :attr:`dim` where it is of size 1.
        Otherwise, :attr:`dim` is squeezed (see :func:`torch.squeeze`), resulting in the
        output tensor having 1 (or ``len(dim)``) fewer dimension(s).


        Args:
            input (Tensor): the input tensor.
    
            dim (int or tuple of ints, optional): the dimension or dimensions to reduce.
                If ``None``, all dimensions are reduced.

    
            keepdim (bool, optional): whether the output tensor has :attr:`dim` retained or not. Default: ``False``.


        Keyword args:
            dtype (:class:`torch.dtype`, optional): the desired data type of returned tensor.
                If specified, the input tensor is casted to :attr:`dtype` before the operation
                is performed. This is useful for preventing data type overflows. Default: None.

        Example::

            >>> torch.nansum(torch.tensor([1., float("nan")]))
            tensor(1.)
            >>> a = torch.tensor([[1, 2], [3., float("nan")]])
            >>> torch.nansum(a)
            tensor(6.)
            >>> torch.nansum(a, dim=0)
            tensor([4., 2.])
            >>> torch.nansum(a, dim=1)
            tensor([3., 3.])
        '''
    @staticmethod
    def narrow(input, dim, start, length) -> Tensor:
        """
        narrow(input, dim, start, length) -> Tensor

        Returns a new tensor that is a narrowed version of :attr:`input` tensor. The
        dimension :attr:`dim` is input from :attr:`start` to ``start + length``. The
        returned tensor and :attr:`input` tensor share the same underlying storage.

        Args:
            input (Tensor): the tensor to narrow
            dim (int): the dimension along which to narrow
            start (int or Tensor): index of the element to start the narrowed dimension
                from. Can be negative, which means indexing from the end of `dim`. If
                `Tensor`, it must be an 0-dim integral `Tensor` (bools not allowed)
            length (int): length of the narrowed dimension, must be weakly positive

        Example::

            >>> x = torch.tensor([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
            >>> torch.narrow(x, 0, 0, 2)
            tensor([[ 1,  2,  3],
                    [ 4,  5,  6]])
            >>> torch.narrow(x, 1, 1, 2)
            tensor([[ 2,  3],
                    [ 5,  6],
                    [ 8,  9]])
            >>> torch.narrow(x, -1, torch.tensor(-1), 1)
            tensor([[3],
                    [6],
                    [9]])
        """
    @staticmethod
    def narrow_copy(input, dim, start, length, out=...) -> Tensor:
        """
        narrow_copy(input, dim, start, length, *, out=None) -> Tensor

        Same as :meth:`Tensor.narrow` except this returns a copy rather
        than shared storage. This is primarily for sparse tensors, which
        do not have a shared-storage narrow method.

        Args:
            input (Tensor): the tensor to narrow
            dim (int): the dimension along which to narrow
            start (int): index of the element to start the narrowed dimension from. Can
                be negative, which means indexing from the end of `dim`
            length (int): length of the narrowed dimension, must be weakly positive

        Keyword args:
            out (Tensor, optional): the output tensor.

        Example::

            >>> x = torch.tensor([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
            >>> torch.narrow_copy(x, 0, 0, 2)
            tensor([[ 1,  2,  3],
                    [ 4,  5,  6]])
            >>> torch.narrow_copy(x, 1, 1, 2)
            tensor([[ 2,  3],
                    [ 5,  6],
                    [ 8,  9]])
            >>> s = torch.arange(16).reshape(2, 2, 2, 2).to_sparse(2)
            >>> torch.narrow_copy(s, 0, 0, 1)
            tensor(indices=tensor([[0, 0],
                                   [0, 1]]),
                   values=tensor([[[0, 1],
                                   [2, 3]],

                                  [[4, 5],
                                   [6, 7]]]),
                   size=(1, 2, 2, 2), nnz=2, layout=torch.sparse_coo)

        .. seealso::

                :func:`torch.narrow` for a non copy variant

        """
    @staticmethod
    def native_batch_norm(*args, **kwargs): ...
    @staticmethod
    def native_channel_shuffle(input, groups) -> Tensor:
        """
        native_channel_shuffle(input, groups) -> Tensor

        Native kernel level implementation of the `channel_shuffle`.
        This function might become private in future releases, use with caution.

        Divide the channels in a tensor of shape :math:`(*, C , H, W)`
        into g groups and rearrange them as :math:`(*, C \\frac g, g, H, W)`,
        while keeping the original tensor shape.

        See :class:`~torch.nn.ChannelShuffle` for details.

        Args:
            input (Tensor): the input tensor
            groups (int): number of groups to divide channels in and rearrange.

        Examples::

            >>> input = torch.randn(1, 4, 2, 2)
            >>> print(input)
            [[[[1, 2],
               [3, 4]],
              [[5, 6],
               [7, 8]],
              [[9, 10],
               [11, 12]],
              [[13, 14],
               [15, 16]],
             ]]
            >>> output = torch.nn.functional.native_channel_shuffle(input, 2)
            >>> print(output)
            [[[[1, 2],
               [3, 4]],
              [[9, 10],
               [11, 12]],
              [[5, 6],
               [7, 8]],
              [[13, 14],
               [15, 16]],
             ]]
        """
    @staticmethod
    def native_dropout(*args, **kwargs): ...
    @staticmethod
    def native_group_norm(*args, **kwargs): ...
    @staticmethod
    def native_layer_norm(*args, **kwargs): ...
    @staticmethod
    def native_norm(*args, **kwargs): ...
    @staticmethod
    def ne(input, other, out=...) -> Tensor:
        """
        ne(input, other, *, out=None) -> Tensor

        Computes :math:`\\text{input} \\neq \\text{other}` element-wise.


        The second argument can be a number or a tensor whose shape is
        :ref:`broadcastable <broadcasting-semantics>` with the first argument.

        Args:
            input (Tensor): the tensor to compare
            other (Tensor or float): the tensor or value to compare

        Keyword args:
            out (Tensor, optional): the output tensor.

        Returns:
            A boolean tensor that is True where :attr:`input` is not equal to :attr:`other` and False elsewhere

        Example::

            >>> torch.ne(torch.tensor([[1, 2], [3, 4]]), torch.tensor([[1, 1], [4, 4]]))
            tensor([[False, True], [True, False]])
        """
    @staticmethod
    def neg(input, out=...) -> Tensor:
        """
        neg(input, *, out=None) -> Tensor

        Returns a new tensor with the negative of the elements of :attr:`input`.

        .. math::
            \\text{out} = -1 \\times \\text{input}

        Args:
            input (Tensor): the input tensor.

        Keyword args:
            out (Tensor, optional): the output tensor.

        Example::

            >>> a = torch.randn(5)
            >>> a
            tensor([ 0.0090, -0.2262, -0.0682, -0.2866,  0.3940])
            >>> torch.neg(a)
            tensor([-0.0090,  0.2262,  0.0682,  0.2866, -0.3940])
        """
    @staticmethod
    def neg_(*args, **kwargs): ...
    @staticmethod
    def negative(input, out=...) -> Tensor:
        """
        negative(input, *, out=None) -> Tensor

        Alias for :func:`torch.neg`
        """
    @staticmethod
    def negative_(*args, **kwargs): ...
    @staticmethod
    def nextafter(input, other, out=...) -> Tensor:
        """
        nextafter(input, other, *, out=None) -> Tensor

        Return the next floating-point value after :attr:`input` towards :attr:`other`, elementwise.

        The shapes of ``input`` and ``other`` must be
        :ref:`broadcastable <broadcasting-semantics>`.

        Args:
            input (Tensor): the first input tensor
            other (Tensor): the second input tensor

        Keyword args:
            out (Tensor, optional): the output tensor.

        Example::

            >>> eps = torch.finfo(torch.float32).eps
            >>> torch.nextafter(torch.tensor([1.0, 2.0]), torch.tensor([2.0, 1.0])) == torch.tensor([eps + 1, 2 - eps])
            tensor([True, True])

        """
    @overload
    @staticmethod
    def nonzero(input, out=..., as_tuple=...) -> LongTensorortupleofLongTensors:
        """
        nonzero(input, *, out=None, as_tuple=False) -> LongTensor or tuple of LongTensors

        .. note::
            :func:`torch.nonzero(..., as_tuple=False) <torch.nonzero>` (default) returns a
            2-D tensor where each row is the index for a nonzero value.

            :func:`torch.nonzero(..., as_tuple=True) <torch.nonzero>` returns a tuple of 1-D
            index tensors, allowing for advanced indexing, so ``x[x.nonzero(as_tuple=True)]``
            gives all nonzero values of tensor ``x``. Of the returned tuple, each index tensor
            contains nonzero indices for a certain dimension.

            See below for more details on the two behaviors.

            When :attr:`input` is on CUDA, :func:`torch.nonzero() <torch.nonzero>` causes
            host-device synchronization.

        **When** :attr:`as_tuple` **is** ``False`` **(default)**:

        Returns a tensor containing the indices of all non-zero elements of
        :attr:`input`.  Each row in the result contains the indices of a non-zero
        element in :attr:`input`. The result is sorted lexicographically, with
        the last index changing the fastest (C-style).

        If :attr:`input` has :math:`n` dimensions, then the resulting indices tensor
        :attr:`out` is of size :math:`(z \\times n)`, where :math:`z` is the total number of
        non-zero elements in the :attr:`input` tensor.

        **When** :attr:`as_tuple` **is** ``True``:

        Returns a tuple of 1-D tensors, one for each dimension in :attr:`input`,
        each containing the indices (in that dimension) of all non-zero elements of
        :attr:`input` .

        If :attr:`input` has :math:`n` dimensions, then the resulting tuple contains :math:`n`
        tensors of size :math:`z`, where :math:`z` is the total number of
        non-zero elements in the :attr:`input` tensor.

        As a special case, when :attr:`input` has zero dimensions and a nonzero scalar
        value, it is treated as a one-dimensional tensor with one element.

        Args:
            input (Tensor): the input tensor.

        Keyword args:
            out (LongTensor, optional): the output tensor containing indices

        Returns:
            LongTensor or tuple of LongTensor: If :attr:`as_tuple` is ``False``, the output
            tensor containing indices. If :attr:`as_tuple` is ``True``, one 1-D tensor for
            each dimension, containing the indices of each nonzero element along that
            dimension.

        Example::

            >>> torch.nonzero(torch.tensor([1, 1, 1, 0, 1]))
            tensor([[ 0],
                    [ 1],
                    [ 2],
                    [ 4]])
            >>> torch.nonzero(torch.tensor([[0.6, 0.0, 0.0, 0.0],
            ...                             [0.0, 0.4, 0.0, 0.0],
            ...                             [0.0, 0.0, 1.2, 0.0],
            ...                             [0.0, 0.0, 0.0,-0.4]]))
            tensor([[ 0,  0],
                    [ 1,  1],
                    [ 2,  2],
                    [ 3,  3]])
            >>> torch.nonzero(torch.tensor([1, 1, 1, 0, 1]), as_tuple=True)
            (tensor([0, 1, 2, 4]),)
            >>> torch.nonzero(torch.tensor([[0.6, 0.0, 0.0, 0.0],
            ...                             [0.0, 0.4, 0.0, 0.0],
            ...                             [0.0, 0.0, 1.2, 0.0],
            ...                             [0.0, 0.0, 0.0,-0.4]]), as_tuple=True)
            (tensor([0, 1, 2, 3]), tensor([0, 1, 2, 3]))
            >>> torch.nonzero(torch.tensor(5), as_tuple=True)
            (tensor([0]),)
        """
    @overload
    @staticmethod
    def nonzero(as_tuple=...) -> Any:
        """
        nonzero(input, *, out=None, as_tuple=False) -> LongTensor or tuple of LongTensors

        .. note::
            :func:`torch.nonzero(..., as_tuple=False) <torch.nonzero>` (default) returns a
            2-D tensor where each row is the index for a nonzero value.

            :func:`torch.nonzero(..., as_tuple=True) <torch.nonzero>` returns a tuple of 1-D
            index tensors, allowing for advanced indexing, so ``x[x.nonzero(as_tuple=True)]``
            gives all nonzero values of tensor ``x``. Of the returned tuple, each index tensor
            contains nonzero indices for a certain dimension.

            See below for more details on the two behaviors.

            When :attr:`input` is on CUDA, :func:`torch.nonzero() <torch.nonzero>` causes
            host-device synchronization.

        **When** :attr:`as_tuple` **is** ``False`` **(default)**:

        Returns a tensor containing the indices of all non-zero elements of
        :attr:`input`.  Each row in the result contains the indices of a non-zero
        element in :attr:`input`. The result is sorted lexicographically, with
        the last index changing the fastest (C-style).

        If :attr:`input` has :math:`n` dimensions, then the resulting indices tensor
        :attr:`out` is of size :math:`(z \\times n)`, where :math:`z` is the total number of
        non-zero elements in the :attr:`input` tensor.

        **When** :attr:`as_tuple` **is** ``True``:

        Returns a tuple of 1-D tensors, one for each dimension in :attr:`input`,
        each containing the indices (in that dimension) of all non-zero elements of
        :attr:`input` .

        If :attr:`input` has :math:`n` dimensions, then the resulting tuple contains :math:`n`
        tensors of size :math:`z`, where :math:`z` is the total number of
        non-zero elements in the :attr:`input` tensor.

        As a special case, when :attr:`input` has zero dimensions and a nonzero scalar
        value, it is treated as a one-dimensional tensor with one element.

        Args:
            input (Tensor): the input tensor.

        Keyword args:
            out (LongTensor, optional): the output tensor containing indices

        Returns:
            LongTensor or tuple of LongTensor: If :attr:`as_tuple` is ``False``, the output
            tensor containing indices. If :attr:`as_tuple` is ``True``, one 1-D tensor for
            each dimension, containing the indices of each nonzero element along that
            dimension.

        Example::

            >>> torch.nonzero(torch.tensor([1, 1, 1, 0, 1]))
            tensor([[ 0],
                    [ 1],
                    [ 2],
                    [ 4]])
            >>> torch.nonzero(torch.tensor([[0.6, 0.0, 0.0, 0.0],
            ...                             [0.0, 0.4, 0.0, 0.0],
            ...                             [0.0, 0.0, 1.2, 0.0],
            ...                             [0.0, 0.0, 0.0,-0.4]]))
            tensor([[ 0,  0],
                    [ 1,  1],
                    [ 2,  2],
                    [ 3,  3]])
            >>> torch.nonzero(torch.tensor([1, 1, 1, 0, 1]), as_tuple=True)
            (tensor([0, 1, 2, 4]),)
            >>> torch.nonzero(torch.tensor([[0.6, 0.0, 0.0, 0.0],
            ...                             [0.0, 0.4, 0.0, 0.0],
            ...                             [0.0, 0.0, 1.2, 0.0],
            ...                             [0.0, 0.0, 0.0,-0.4]]), as_tuple=True)
            (tensor([0, 1, 2, 3]), tensor([0, 1, 2, 3]))
            >>> torch.nonzero(torch.tensor(5), as_tuple=True)
            (tensor([0]),)
        """
    @overload
    @staticmethod
    def nonzero() -> Any:
        """
        nonzero(input, *, out=None, as_tuple=False) -> LongTensor or tuple of LongTensors

        .. note::
            :func:`torch.nonzero(..., as_tuple=False) <torch.nonzero>` (default) returns a
            2-D tensor where each row is the index for a nonzero value.

            :func:`torch.nonzero(..., as_tuple=True) <torch.nonzero>` returns a tuple of 1-D
            index tensors, allowing for advanced indexing, so ``x[x.nonzero(as_tuple=True)]``
            gives all nonzero values of tensor ``x``. Of the returned tuple, each index tensor
            contains nonzero indices for a certain dimension.

            See below for more details on the two behaviors.

            When :attr:`input` is on CUDA, :func:`torch.nonzero() <torch.nonzero>` causes
            host-device synchronization.

        **When** :attr:`as_tuple` **is** ``False`` **(default)**:

        Returns a tensor containing the indices of all non-zero elements of
        :attr:`input`.  Each row in the result contains the indices of a non-zero
        element in :attr:`input`. The result is sorted lexicographically, with
        the last index changing the fastest (C-style).

        If :attr:`input` has :math:`n` dimensions, then the resulting indices tensor
        :attr:`out` is of size :math:`(z \\times n)`, where :math:`z` is the total number of
        non-zero elements in the :attr:`input` tensor.

        **When** :attr:`as_tuple` **is** ``True``:

        Returns a tuple of 1-D tensors, one for each dimension in :attr:`input`,
        each containing the indices (in that dimension) of all non-zero elements of
        :attr:`input` .

        If :attr:`input` has :math:`n` dimensions, then the resulting tuple contains :math:`n`
        tensors of size :math:`z`, where :math:`z` is the total number of
        non-zero elements in the :attr:`input` tensor.

        As a special case, when :attr:`input` has zero dimensions and a nonzero scalar
        value, it is treated as a one-dimensional tensor with one element.

        Args:
            input (Tensor): the input tensor.

        Keyword args:
            out (LongTensor, optional): the output tensor containing indices

        Returns:
            LongTensor or tuple of LongTensor: If :attr:`as_tuple` is ``False``, the output
            tensor containing indices. If :attr:`as_tuple` is ``True``, one 1-D tensor for
            each dimension, containing the indices of each nonzero element along that
            dimension.

        Example::

            >>> torch.nonzero(torch.tensor([1, 1, 1, 0, 1]))
            tensor([[ 0],
                    [ 1],
                    [ 2],
                    [ 4]])
            >>> torch.nonzero(torch.tensor([[0.6, 0.0, 0.0, 0.0],
            ...                             [0.0, 0.4, 0.0, 0.0],
            ...                             [0.0, 0.0, 1.2, 0.0],
            ...                             [0.0, 0.0, 0.0,-0.4]]))
            tensor([[ 0,  0],
                    [ 1,  1],
                    [ 2,  2],
                    [ 3,  3]])
            >>> torch.nonzero(torch.tensor([1, 1, 1, 0, 1]), as_tuple=True)
            (tensor([0, 1, 2, 4]),)
            >>> torch.nonzero(torch.tensor([[0.6, 0.0, 0.0, 0.0],
            ...                             [0.0, 0.4, 0.0, 0.0],
            ...                             [0.0, 0.0, 1.2, 0.0],
            ...                             [0.0, 0.0, 0.0,-0.4]]), as_tuple=True)
            (tensor([0, 1, 2, 3]), tensor([0, 1, 2, 3]))
            >>> torch.nonzero(torch.tensor(5), as_tuple=True)
            (tensor([0]),)
        """
    @staticmethod
    def nonzero_static(*args, **kwargs): ...
    @staticmethod
    def norm(*args, **kwargs): ...
    @staticmethod
    def norm_except_dim(*args, **kwargs): ...
    @staticmethod
    def normal(mean, std, generator=..., out=...) -> Tensor:
        """
        normal(mean, std, *, generator=None, out=None) -> Tensor

        Returns a tensor of random numbers drawn from separate normal distributions
        whose mean and standard deviation are given.

        The :attr:`mean` is a tensor with the mean of
        each output element's normal distribution

        The :attr:`std` is a tensor with the standard deviation of
        each output element's normal distribution

        The shapes of :attr:`mean` and :attr:`std` don't need to match, but the
        total number of elements in each tensor need to be the same.

        .. note:: When the shapes do not match, the shape of :attr:`mean`
                  is used as the shape for the returned output tensor

        .. note:: When :attr:`std` is a CUDA tensor, this function synchronizes
                  its device with the CPU.

        Args:
            mean (Tensor): the tensor of per-element means
            std (Tensor): the tensor of per-element standard deviations

        Keyword args:
            generator (:class:`torch.Generator`, optional): a pseudorandom number generator for sampling
            out (Tensor, optional): the output tensor.

        Example::

            >>> torch.normal(mean=torch.arange(1., 11.), std=torch.arange(1, 0, -0.1))
            tensor([  1.0425,   3.5672,   2.7969,   4.2925,   4.7229,   6.2134,
                      8.0505,   8.1408,   9.0563,  10.0566])

        .. function:: normal(mean=0.0, std, *, out=None) -> Tensor
           :noindex:

        Similar to the function above, but the means are shared among all drawn
        elements.

        Args:
            mean (float, optional): the mean for all distributions
            std (Tensor): the tensor of per-element standard deviations

        Keyword args:
            out (Tensor, optional): the output tensor.

        Example::

            >>> torch.normal(mean=0.5, std=torch.arange(1., 6.))
            tensor([-1.2793, -1.0732, -2.0687,  5.1177, -1.2303])

        .. function:: normal(mean, std=1.0, *, out=None) -> Tensor
           :noindex:

        Similar to the function above, but the standard deviations are shared among
        all drawn elements.

        Args:
            mean (Tensor): the tensor of per-element means
            std (float, optional): the standard deviation for all distributions

        Keyword args:
            out (Tensor, optional): the output tensor

        Example::

            >>> torch.normal(mean=torch.arange(1., 6.))
            tensor([ 1.1552,  2.6148,  2.6535,  5.8318,  4.2361])

        .. function:: normal(mean, std, size, *, out=None) -> Tensor
           :noindex:

        Similar to the function above, but the means and standard deviations are shared
        among all drawn elements. The resulting tensor has size given by :attr:`size`.

        Args:
            mean (float): the mean for all distributions
            std (float): the standard deviation for all distributions
            size (int...): a sequence of integers defining the shape of the output tensor.

        Keyword args:
            out (Tensor, optional): the output tensor.

        Example::

            >>> torch.normal(2, 3, size=(1, 4))
            tensor([[-1.3987, -1.9544,  3.6048,  0.7909]])
        """
    @staticmethod
    def not_equal(input, other, out=...) -> Tensor:
        """
        not_equal(input, other, *, out=None) -> Tensor

        Alias for :func:`torch.ne`.
        """
    @staticmethod
    def nuclear_norm(*args, **kwargs): ...
    @overload
    @staticmethod
    def numel(input: Tensor) -> int:
        """
        numel(input: Tensor) -> int

        Returns the total number of elements in the :attr:`input` tensor.

        Args:
            input (Tensor): the input tensor.

        Example::

            >>> a = torch.randn(1, 2, 3, 4, 5)
            >>> torch.numel(a)
            120
            >>> a = torch.zeros(4,4)
            >>> torch.numel(a)
            16

        """
    @overload
    @staticmethod
    def numel(a) -> Any:
        """
        numel(input: Tensor) -> int

        Returns the total number of elements in the :attr:`input` tensor.

        Args:
            input (Tensor): the input tensor.

        Example::

            >>> a = torch.randn(1, 2, 3, 4, 5)
            >>> torch.numel(a)
            120
            >>> a = torch.zeros(4,4)
            >>> torch.numel(a)
            16

        """
    @overload
    @staticmethod
    def numel(a) -> Any:
        """
        numel(input: Tensor) -> int

        Returns the total number of elements in the :attr:`input` tensor.

        Args:
            input (Tensor): the input tensor.

        Example::

            >>> a = torch.randn(1, 2, 3, 4, 5)
            >>> torch.numel(a)
            120
            >>> a = torch.zeros(4,4)
            >>> torch.numel(a)
            16

        """
    @staticmethod
    def ones(*args, **kwargs):
        """
        ones(*size, *, out=None, dtype=None, layout=torch.strided, device=None, requires_grad=False) -> Tensor

        Returns a tensor filled with the scalar value `1`, with the shape defined
        by the variable argument :attr:`size`.

        Args:
            size (int...): a sequence of integers defining the shape of the output tensor.
                Can be a variable number of arguments or a collection like a list or tuple.

        Keyword arguments:
            out (Tensor, optional): the output tensor.
            dtype (:class:`torch.dtype`, optional): the desired data type of returned tensor.
                Default: if ``None``, uses a global default (see :func:`torch.set_default_dtype`).
            layout (:class:`torch.layout`, optional): the desired layout of returned Tensor.
                Default: ``torch.strided``.
            device (:class:`torch.device`, optional): the desired device of returned tensor.
                Default: if ``None``, uses the current device for the default tensor type
                (see :func:`torch.set_default_device`). :attr:`device` will be the CPU
                for CPU tensor types and the current CUDA device for CUDA tensor types.
            requires_grad (bool, optional): If autograd should record operations on the
                returned tensor. Default: ``False``.

        Example::

            >>> torch.ones(2, 3)
            tensor([[ 1.,  1.,  1.],
                    [ 1.,  1.,  1.]])

            >>> torch.ones(5)
            tensor([ 1.,  1.,  1.,  1.,  1.])

        """
    @overload
    @staticmethod
    def ones_like(input, dtype=..., layout=..., device=..., requires_grad=..., memory_format=...) -> Tensor:
        """
        ones_like(input, *, dtype=None, layout=None, device=None, requires_grad=False, memory_format=torch.preserve_format) -> Tensor

        Returns a tensor filled with the scalar value `1`, with the same size as
        :attr:`input`. ``torch.ones_like(input)`` is equivalent to
        ``torch.ones(input.size(), dtype=input.dtype, layout=input.layout, device=input.device)``.

        .. warning::
            As of 0.4, this function does not support an :attr:`out` keyword. As an alternative,
            the old ``torch.ones_like(input, out=output)`` is equivalent to
            ``torch.ones(input.size(), out=output)``.

        Args:
            input (Tensor): the size of :attr:`input` will determine size of the output tensor.

        Keyword arguments:
            dtype (:class:`torch.dtype`, optional): the desired data type of returned Tensor.
                Default: if ``None``, defaults to the dtype of :attr:`input`.
            layout (:class:`torch.layout`, optional): the desired layout of returned tensor.
                Default: if ``None``, defaults to the layout of :attr:`input`.
            device (:class:`torch.device`, optional): the desired device of returned tensor.
                Default: if ``None``, defaults to the device of :attr:`input`.
            requires_grad (bool, optional): If autograd should record operations on the
                returned tensor. Default: ``False``.
            memory_format (:class:`torch.memory_format`, optional): the desired memory format of
                returned Tensor. Default: ``torch.preserve_format``.

        Example::

            >>> input = torch.empty(2, 3)
            >>> torch.ones_like(input)
            tensor([[ 1.,  1.,  1.],
                    [ 1.,  1.,  1.]])
        """
    @overload
    @staticmethod
    def ones_like(input) -> Any:
        """
        ones_like(input, *, dtype=None, layout=None, device=None, requires_grad=False, memory_format=torch.preserve_format) -> Tensor

        Returns a tensor filled with the scalar value `1`, with the same size as
        :attr:`input`. ``torch.ones_like(input)`` is equivalent to
        ``torch.ones(input.size(), dtype=input.dtype, layout=input.layout, device=input.device)``.

        .. warning::
            As of 0.4, this function does not support an :attr:`out` keyword. As an alternative,
            the old ``torch.ones_like(input, out=output)`` is equivalent to
            ``torch.ones(input.size(), out=output)``.

        Args:
            input (Tensor): the size of :attr:`input` will determine size of the output tensor.

        Keyword arguments:
            dtype (:class:`torch.dtype`, optional): the desired data type of returned Tensor.
                Default: if ``None``, defaults to the dtype of :attr:`input`.
            layout (:class:`torch.layout`, optional): the desired layout of returned tensor.
                Default: if ``None``, defaults to the layout of :attr:`input`.
            device (:class:`torch.device`, optional): the desired device of returned tensor.
                Default: if ``None``, defaults to the device of :attr:`input`.
            requires_grad (bool, optional): If autograd should record operations on the
                returned tensor. Default: ``False``.
            memory_format (:class:`torch.memory_format`, optional): the desired memory format of
                returned Tensor. Default: ``torch.preserve_format``.

        Example::

            >>> input = torch.empty(2, 3)
            >>> torch.ones_like(input)
            tensor([[ 1.,  1.,  1.],
                    [ 1.,  1.,  1.]])
        """
    @overload
    @staticmethod
    def ones_like(input, out=...) -> Any:
        """
        ones_like(input, *, dtype=None, layout=None, device=None, requires_grad=False, memory_format=torch.preserve_format) -> Tensor

        Returns a tensor filled with the scalar value `1`, with the same size as
        :attr:`input`. ``torch.ones_like(input)`` is equivalent to
        ``torch.ones(input.size(), dtype=input.dtype, layout=input.layout, device=input.device)``.

        .. warning::
            As of 0.4, this function does not support an :attr:`out` keyword. As an alternative,
            the old ``torch.ones_like(input, out=output)`` is equivalent to
            ``torch.ones(input.size(), out=output)``.

        Args:
            input (Tensor): the size of :attr:`input` will determine size of the output tensor.

        Keyword arguments:
            dtype (:class:`torch.dtype`, optional): the desired data type of returned Tensor.
                Default: if ``None``, defaults to the dtype of :attr:`input`.
            layout (:class:`torch.layout`, optional): the desired layout of returned tensor.
                Default: if ``None``, defaults to the layout of :attr:`input`.
            device (:class:`torch.device`, optional): the desired device of returned tensor.
                Default: if ``None``, defaults to the device of :attr:`input`.
            requires_grad (bool, optional): If autograd should record operations on the
                returned tensor. Default: ``False``.
            memory_format (:class:`torch.memory_format`, optional): the desired memory format of
                returned Tensor. Default: ``torch.preserve_format``.

        Example::

            >>> input = torch.empty(2, 3)
            >>> torch.ones_like(input)
            tensor([[ 1.,  1.,  1.],
                    [ 1.,  1.,  1.]])
        """
    @overload
    @staticmethod
    def ones_like(input) -> Any:
        """
        ones_like(input, *, dtype=None, layout=None, device=None, requires_grad=False, memory_format=torch.preserve_format) -> Tensor

        Returns a tensor filled with the scalar value `1`, with the same size as
        :attr:`input`. ``torch.ones_like(input)`` is equivalent to
        ``torch.ones(input.size(), dtype=input.dtype, layout=input.layout, device=input.device)``.

        .. warning::
            As of 0.4, this function does not support an :attr:`out` keyword. As an alternative,
            the old ``torch.ones_like(input, out=output)`` is equivalent to
            ``torch.ones(input.size(), out=output)``.

        Args:
            input (Tensor): the size of :attr:`input` will determine size of the output tensor.

        Keyword arguments:
            dtype (:class:`torch.dtype`, optional): the desired data type of returned Tensor.
                Default: if ``None``, defaults to the dtype of :attr:`input`.
            layout (:class:`torch.layout`, optional): the desired layout of returned tensor.
                Default: if ``None``, defaults to the layout of :attr:`input`.
            device (:class:`torch.device`, optional): the desired device of returned tensor.
                Default: if ``None``, defaults to the device of :attr:`input`.
            requires_grad (bool, optional): If autograd should record operations on the
                returned tensor. Default: ``False``.
            memory_format (:class:`torch.memory_format`, optional): the desired memory format of
                returned Tensor. Default: ``torch.preserve_format``.

        Example::

            >>> input = torch.empty(2, 3)
            >>> torch.ones_like(input)
            tensor([[ 1.,  1.,  1.],
                    [ 1.,  1.,  1.]])
        """
    @staticmethod
    def orgqr(input, tau) -> Tensor:
        """
        orgqr(input, tau) -> Tensor

        Alias for :func:`torch.linalg.householder_product`.
        """
    @staticmethod
    def ormqr(input, tau, other, left=..., transpose=..., out=...) -> Tensor:
        """
        ormqr(input, tau, other, left=True, transpose=False, *, out=None) -> Tensor

        Computes the matrix-matrix multiplication of a product of Householder matrices with a general matrix.

        Multiplies a :math:`m \\times n` matrix `C` (given by :attr:`other`) with a matrix `Q`,
        where `Q` is represented using Householder reflectors `(input, tau)`.
        See `Representation of Orthogonal or Unitary Matrices`_ for further details.

        If :attr:`left` is `True` then `op(Q)` times `C` is computed, otherwise the result is `C` times `op(Q)`.
        When :attr:`left` is `True`, the implicit matrix `Q` has size :math:`m \\times m`.
        It has size :math:`n \\times n` otherwise.
        If :attr:`transpose` is `True` then `op` is the conjugate transpose operation, otherwise it's a no-op.

        Supports inputs of float, double, cfloat and cdouble dtypes.
        Also supports batched inputs, and, if the input is batched, the output is batched with the same dimensions.

        .. seealso::
                :func:`torch.geqrf` can be used to form the Householder representation `(input, tau)` of matrix `Q`
                from the QR decomposition.

        .. note::
                This function supports backward but it is only fast when ``(input, tau)`` do not require gradients
                and/or ``tau.size(-1)`` is very small.
                ``

        Args:
            input (Tensor): tensor of shape `(*, mn, k)` where `*` is zero or more batch dimensions
                            and `mn` equals to `m` or `n` depending on the :attr:`left`.
            tau (Tensor): tensor of shape `(*, min(mn, k))` where `*` is zero or more batch dimensions.
            other (Tensor): tensor of shape `(*, m, n)` where `*` is zero or more batch dimensions.
            left (bool): controls the order of multiplication.
            transpose (bool): controls whether the matrix `Q` is conjugate transposed or not.

        Keyword args:
            out (Tensor, optional): the output Tensor. Ignored if `None`. Default: `None`.

        .. _Representation of Orthogonal or Unitary Matrices:
            https://www.netlib.org/lapack/lug/node128.html
        """
    @staticmethod
    def outer(input, vec2, out=...) -> Tensor:
        """
        outer(input, vec2, *, out=None) -> Tensor

        Outer product of :attr:`input` and :attr:`vec2`.
        If :attr:`input` is a vector of size :math:`n` and :attr:`vec2` is a vector of
        size :math:`m`, then :attr:`out` must be a matrix of size :math:`(n \\times m)`.

        .. note:: This function does not :ref:`broadcast <broadcasting-semantics>`.

        Args:
            input (Tensor): 1-D input vector
            vec2 (Tensor): 1-D input vector

        Keyword args:
            out (Tensor, optional): optional output matrix

        Example::

            >>> v1 = torch.arange(1., 5.)
            >>> v2 = torch.arange(1., 4.)
            >>> torch.outer(v1, v2)
            tensor([[  1.,   2.,   3.],
                    [  2.,   4.,   6.],
                    [  3.,   6.,   9.],
                    [  4.,   8.,  12.]])
        """
    @staticmethod
    def pairwise_distance(x1, x2, p=..., eps=..., keepdim=...) -> Tensor:
        """
        pairwise_distance(x1, x2, p=2.0, eps=1e-6, keepdim=False) -> Tensor

        See :class:`torch.nn.PairwiseDistance` for details
        """
    @staticmethod
    def pdist(input, p=...) -> Tensor:
        """
        pdist(input, p=2) -> Tensor

        Computes the p-norm distance between every pair of row vectors in the input.
        This is identical to the upper triangular portion, excluding the diagonal, of
        `torch.norm(input[:, None] - input, dim=2, p=p)`. This function will be faster
        if the rows are contiguous.

        If input has shape :math:`N \\times M` then the output will have shape
        :math:`\\frac{1}{2} N (N - 1)`.

        This function is equivalent to ``scipy.spatial.distance.pdist(input,
        'minkowski', p=p)`` if :math:`p \\in (0, \\infty)`. When :math:`p = 0` it is
        equivalent to ``scipy.spatial.distance.pdist(input, 'hamming') * M``.
        When :math:`p = \\infty`, the closest scipy function is
        ``scipy.spatial.distance.pdist(xn, lambda x, y: np.abs(x - y).max())``.

        Args:
            input: input tensor of shape :math:`N \\times M`.
            p: p value for the p-norm distance to calculate between each vector pair
                :math:`\\in [0, \\infty]`.
        """
    @staticmethod
    def permute(input, dims) -> Tensor:
        """
        permute(input, dims) -> Tensor

        Returns a view of the original tensor :attr:`input` with its dimensions permuted.

        Args:
            input (Tensor): the input tensor.
            dims (tuple of int): The desired ordering of dimensions

        Example:
            >>> x = torch.randn(2, 3, 5)
            >>> x.size()
            torch.Size([2, 3, 5])
            >>> torch.permute(x, (2, 0, 1)).size()
            torch.Size([5, 2, 3])
        """
    @staticmethod
    def permute_copy(*args, **kwargs):
        """
        Performs the same operation as :func:`torch.permute`, but all output tensors
        are freshly created instead of aliasing the input.
        """
    @staticmethod
    def pinverse(input, rcond=...) -> Tensor:
        """
        pinverse(input, rcond=1e-15) -> Tensor

        Alias for :func:`torch.linalg.pinv`
        """
    @staticmethod
    def pixel_shuffle(input, upscale_factor) -> Tensor:
        """
        pixel_shuffle(input, upscale_factor) -> Tensor

        Rearranges elements in a tensor of shape :math:`(*, C \\times r^2, H, W)` to a
        tensor of shape :math:`(*, C, H \\times r, W \\times r)`, where r is the :attr:`upscale_factor`.

        See :class:`~torch.nn.PixelShuffle` for details.

        Args:
            input (Tensor): the input tensor
            upscale_factor (int): factor to increase spatial resolution by

        Examples::

            >>> input = torch.randn(1, 9, 4, 4)
            >>> output = torch.nn.functional.pixel_shuffle(input, 3)
            >>> print(output.size())
            torch.Size([1, 1, 12, 12])
        """
    @staticmethod
    def pixel_unshuffle(input, downscale_factor) -> Tensor:
        """
        pixel_unshuffle(input, downscale_factor) -> Tensor

        Reverses the :class:`~torch.nn.PixelShuffle` operation by rearranging elements in a
        tensor of shape :math:`(*, C, H \\times r, W \\times r)` to a tensor of shape
        :math:`(*, C \\times r^2, H, W)`, where r is the :attr:`downscale_factor`.

        See :class:`~torch.nn.PixelUnshuffle` for details.

        Args:
            input (Tensor): the input tensor
            downscale_factor (int): factor to increase spatial resolution by

        Examples::

            >>> input = torch.randn(1, 1, 12, 12)
            >>> output = torch.nn.functional.pixel_unshuffle(input, 3)
            >>> print(output.size())
            torch.Size([1, 9, 4, 4])
        """
    @staticmethod
    def poisson(input, generator=...) -> Tensor:
        """
        poisson(input, generator=None) -> Tensor

        Returns a tensor of the same size as :attr:`input` with each element
        sampled from a Poisson distribution with rate parameter given by the corresponding
        element in :attr:`input` i.e.,

        .. math::
            \\text{out}_i \\sim \\text{Poisson}(\\text{input}_i)

        :attr:`input` must be non-negative.

        Args:
            input (Tensor): the input tensor containing the rates of the Poisson distribution

        Keyword args:
            generator (:class:`torch.Generator`, optional): a pseudorandom number generator for sampling

        Example::

            >>> rates = torch.rand(4, 4) * 5  # rate parameter between 0 and 5
            >>> torch.poisson(rates)
            tensor([[9., 1., 3., 5.],
                    [8., 6., 6., 0.],
                    [0., 4., 5., 3.],
                    [2., 1., 4., 2.]])
        """
    @staticmethod
    def poisson_nll_loss(*args, **kwargs): ...
    @staticmethod
    def polar(abs, angle, out=...) -> Tensor:
        """
        polar(abs, angle, *, out=None) -> Tensor

        Constructs a complex tensor whose elements are Cartesian coordinates
        corresponding to the polar coordinates with absolute value :attr:`abs` and angle
        :attr:`angle`.

        .. math::
            \\text{out} = \\text{abs} \\cdot \\cos(\\text{angle}) + \\text{abs} \\cdot \\sin(\\text{angle}) \\cdot j

        .. note::
            `torch.polar` is similar to
            `std::polar <https://en.cppreference.com/w/cpp/numeric/complex/polar>`_
            and does not compute the polar decomposition
            of a complex tensor like Python's `cmath.polar` and SciPy's `linalg.polar` do.
            The behavior of this function is undefined if `abs` is negative or NaN, or if `angle` is
            infinite.


        Args:
            abs (Tensor): The absolute value the complex tensor. Must be float or double.
            angle (Tensor): The angle of the complex tensor. Must be same dtype as
                :attr:`abs`.

        Keyword args:
            out (Tensor): If the inputs are ``torch.float32``, must be
                ``torch.complex64``. If the inputs are ``torch.float64``, must be
                ``torch.complex128``.

        Example::

            >>> import numpy as np
            >>> abs = torch.tensor([1, 2], dtype=torch.float64)
            >>> angle = torch.tensor([np.pi / 2, 5 * np.pi / 4], dtype=torch.float64)
            >>> z = torch.polar(abs, angle)
            >>> z
            tensor([(0.0000+1.0000j), (-1.4142-1.4142j)], dtype=torch.complex128)
        """
    @staticmethod
    def polygamma(n, input, out=...) -> Tensor:
        """
        polygamma(n, input, *, out=None) -> Tensor

        Alias for :func:`torch.special.polygamma`.
        """
    @overload
    @staticmethod
    def positive(input) -> Tensor:
        """
        positive(input) -> Tensor

        Returns :attr:`input`.
        Throws a runtime error if :attr:`input` is a bool tensor.

        Args:
            input (Tensor): the input tensor.

        Example::

            >>> t = torch.randn(5)
            >>> t
            tensor([ 0.0090, -0.2262, -0.0682, -0.2866,  0.3940])
            >>> torch.positive(t)
            tensor([ 0.0090, -0.2262, -0.0682, -0.2866,  0.3940])
        """
    @overload
    @staticmethod
    def positive(t) -> Any:
        """
        positive(input) -> Tensor

        Returns :attr:`input`.
        Throws a runtime error if :attr:`input` is a bool tensor.

        Args:
            input (Tensor): the input tensor.

        Example::

            >>> t = torch.randn(5)
            >>> t
            tensor([ 0.0090, -0.2262, -0.0682, -0.2866,  0.3940])
            >>> torch.positive(t)
            tensor([ 0.0090, -0.2262, -0.0682, -0.2866,  0.3940])
        """
    @staticmethod
    def pow(input, exponent, out=...) -> Tensor:
        """
        pow(input, exponent, *, out=None) -> Tensor

        Takes the power of each element in :attr:`input` with :attr:`exponent` and
        returns a tensor with the result.

        :attr:`exponent` can be either a single ``float`` number or a `Tensor`
        with the same number of elements as :attr:`input`.

        When :attr:`exponent` is a scalar value, the operation applied is:

        .. math::
            \\text{out}_i = x_i ^ \\text{exponent}

        When :attr:`exponent` is a tensor, the operation applied is:

        .. math::
            \\text{out}_i = x_i ^ {\\text{exponent}_i}

        When :attr:`exponent` is a tensor, the shapes of :attr:`input`
        and :attr:`exponent` must be :ref:`broadcastable <broadcasting-semantics>`.

        Args:
            input (Tensor): the input tensor.
            exponent (float or tensor): the exponent value

        Keyword args:
            out (Tensor, optional): the output tensor.

        Example::

            >>> a = torch.randn(4)
            >>> a
            tensor([ 0.4331,  1.2475,  0.6834, -0.2791])
            >>> torch.pow(a, 2)
            tensor([ 0.1875,  1.5561,  0.4670,  0.0779])
            >>> exp = torch.arange(1., 5.)

            >>> a = torch.arange(1., 5.)
            >>> a
            tensor([ 1.,  2.,  3.,  4.])
            >>> exp
            tensor([ 1.,  2.,  3.,  4.])
            >>> torch.pow(a, exp)
            tensor([   1.,    4.,   27.,  256.])

        .. function:: pow(self, exponent, *, out=None) -> Tensor
           :noindex:

        :attr:`self` is a scalar ``float`` value, and :attr:`exponent` is a tensor.
        The returned tensor :attr:`out` is of the same shape as :attr:`exponent`

        The operation applied is:

        .. math::
            \\text{out}_i = \\text{self} ^ {\\text{exponent}_i}

        Args:
            self (float): the scalar base value for the power operation
            exponent (Tensor): the exponent tensor

        Keyword args:
            out (Tensor, optional): the output tensor.

        Example::

            >>> exp = torch.arange(1., 5.)
            >>> base = 2
            >>> torch.pow(base, exp)
            tensor([  2.,   4.,   8.,  16.])
        """
    @staticmethod
    def prelu(input, weight) -> Tensor:
        """prelu(input, weight) -> Tensor

        Applies element-wise the function
        :math:`\\text{PReLU}(x) = \\max(0,x) + \\text{weight} * \\min(0,x)` where weight is a
        learnable parameter.

        .. note::
            `weight` is expected to be a scalar or 1-D tensor. If `weight` is 1-D,
            its size must match the number of input channels, determined by
            `input.size(1)` when `input.dim() >= 2`, otherwise 1.
            In the 1-D case, note that when `input` has dim > 2, `weight` can be expanded
            to the shape of `input` in a way that is not possible using normal
            :ref:`broadcasting semantics<broadcasting-semantics>`.

        See :class:`~torch.nn.PReLU` for more details.
        """
    @overload
    @staticmethod
    def prod(input: Tensor, dtype: _dtype | None) -> Tensor:
        """
        prod(input: Tensor, *, dtype: Optional[_dtype]) -> Tensor

        Returns the product of all elements in the :attr:`input` tensor.

        Args:
            input (Tensor): the input tensor.

        Keyword args:
            dtype (:class:`torch.dtype`, optional): the desired data type of returned tensor.
                If specified, the input tensor is casted to :attr:`dtype` before the operation
                is performed. This is useful for preventing data type overflows. Default: None.

        Example::

            >>> a = torch.randn(1, 3)
            >>> a
            tensor([[-0.8020,  0.5428, -1.5854]])
            >>> torch.prod(a)
            tensor(0.6902)

        .. function:: prod(input, dim, keepdim=False, *, dtype=None) -> Tensor
           :noindex:

        Returns the product of each row of the :attr:`input` tensor in the given
        dimension :attr:`dim`.

        If :attr:`keepdim` is ``True``, the output tensor is of the same size
        as :attr:`input` except in the dimension :attr:`dim` where it is of size 1.
        Otherwise, :attr:`dim` is squeezed (see :func:`torch.squeeze`), resulting in
        the output tensor having 1 fewer dimension than :attr:`input`.

        Args:
            input (Tensor): the input tensor.
    
            dim (int, optional): the dimension to reduce.
                If ``None``, all dimensions are reduced.

    
            keepdim (bool, optional): whether the output tensor has :attr:`dim` retained or not. Default: ``False``.


        Keyword args:
            dtype (:class:`torch.dtype`, optional): the desired data type of returned tensor.
                If specified, the input tensor is casted to :attr:`dtype` before the operation
                is performed. This is useful for preventing data type overflows. Default: None.

        Example::

            >>> a = torch.randn(4, 2)
            >>> a
            tensor([[ 0.5261, -0.3837],
                    [ 1.1857, -0.2498],
                    [-1.1646,  0.0705],
                    [ 1.1131, -1.0629]])
            >>> torch.prod(a, 1)
            tensor([-0.2018, -0.2962, -0.0821, -1.1831])
        """
    @overload
    @staticmethod
    def prod(a) -> Any:
        """
        prod(input: Tensor, *, dtype: Optional[_dtype]) -> Tensor

        Returns the product of all elements in the :attr:`input` tensor.

        Args:
            input (Tensor): the input tensor.

        Keyword args:
            dtype (:class:`torch.dtype`, optional): the desired data type of returned tensor.
                If specified, the input tensor is casted to :attr:`dtype` before the operation
                is performed. This is useful for preventing data type overflows. Default: None.

        Example::

            >>> a = torch.randn(1, 3)
            >>> a
            tensor([[-0.8020,  0.5428, -1.5854]])
            >>> torch.prod(a)
            tensor(0.6902)

        .. function:: prod(input, dim, keepdim=False, *, dtype=None) -> Tensor
           :noindex:

        Returns the product of each row of the :attr:`input` tensor in the given
        dimension :attr:`dim`.

        If :attr:`keepdim` is ``True``, the output tensor is of the same size
        as :attr:`input` except in the dimension :attr:`dim` where it is of size 1.
        Otherwise, :attr:`dim` is squeezed (see :func:`torch.squeeze`), resulting in
        the output tensor having 1 fewer dimension than :attr:`input`.

        Args:
            input (Tensor): the input tensor.
    
            dim (int, optional): the dimension to reduce.
                If ``None``, all dimensions are reduced.

    
            keepdim (bool, optional): whether the output tensor has :attr:`dim` retained or not. Default: ``False``.


        Keyword args:
            dtype (:class:`torch.dtype`, optional): the desired data type of returned tensor.
                If specified, the input tensor is casted to :attr:`dtype` before the operation
                is performed. This is useful for preventing data type overflows. Default: None.

        Example::

            >>> a = torch.randn(4, 2)
            >>> a
            tensor([[ 0.5261, -0.3837],
                    [ 1.1857, -0.2498],
                    [-1.1646,  0.0705],
                    [ 1.1131, -1.0629]])
            >>> torch.prod(a, 1)
            tensor([-0.2018, -0.2962, -0.0821, -1.1831])
        """
    @staticmethod
    def promote_types(type1, type2) -> dtype:
        """
        promote_types(type1, type2) -> dtype

        Returns the :class:`torch.dtype` with the smallest size and scalar kind that is
        not smaller nor of lower kind than either `type1` or `type2`. See type promotion
        :ref:`documentation <type-promotion-doc>` for more information on the type
        promotion logic.

        Args:
            type1 (:class:`torch.dtype`)
            type2 (:class:`torch.dtype`)

        Example::

            >>> torch.promote_types(torch.int32, torch.float32)
            torch.float32
            >>> torch.promote_types(torch.uint8, torch.long)
            torch.long
        """
    @staticmethod
    def put(*args, **kwargs): ...
    @staticmethod
    def q_per_channel_axis(*args, **kwargs): ...
    @staticmethod
    def q_per_channel_scales(*args, **kwargs): ...
    @staticmethod
    def q_per_channel_zero_points(*args, **kwargs): ...
    @staticmethod
    def q_scale(*args, **kwargs): ...
    @staticmethod
    def q_zero_point(*args, **kwargs): ...
    @staticmethod
    def qr(*args, **kwargs):
        '''
        qr(input: Tensor, some: bool = True, *, out: Union[Tensor, Tuple[Tensor, ...], List[Tensor], None]) -> (Tensor, Tensor)

        Computes the QR decomposition of a matrix or a batch of matrices :attr:`input`,
        and returns a namedtuple (Q, R) of tensors such that :math:`\\text{input} = Q R`
        with :math:`Q` being an orthogonal matrix or batch of orthogonal matrices and
        :math:`R` being an upper triangular matrix or batch of upper triangular matrices.

        If :attr:`some` is ``True``, then this function returns the thin (reduced) QR factorization.
        Otherwise, if :attr:`some` is ``False``, this function returns the complete QR factorization.

        .. warning::

            :func:`torch.qr` is deprecated in favor of :func:`torch.linalg.qr`
            and will be removed in a future PyTorch release. The boolean parameter :attr:`some` has been
            replaced with a string parameter :attr:`mode`.

            ``Q, R = torch.qr(A)`` should be replaced with

            .. code:: python

                Q, R = torch.linalg.qr(A)

            ``Q, R = torch.qr(A, some=False)`` should be replaced with

            .. code:: python

                Q, R = torch.linalg.qr(A, mode="complete")

        .. warning::
                  If you plan to backpropagate through QR, note that the current backward implementation
                  is only well-defined when the first :math:`\\min(input.size(-1), input.size(-2))`
                  columns of :attr:`input` are linearly independent.
                  This behavior will probably change once QR supports pivoting.

        .. note:: This function uses LAPACK for CPU inputs and MAGMA for CUDA inputs,
                  and may produce different (valid) decompositions on different device types
                  or different platforms.

        Args:
            input (Tensor): the input tensor of size :math:`(*, m, n)` where `*` is zero or more
                        batch dimensions consisting of matrices of dimension :math:`m \\times n`.
            some (bool, optional): Set to ``True`` for reduced QR decomposition and ``False`` for
                        complete QR decomposition. If `k = min(m, n)` then:

                          * ``some=True`` : returns `(Q, R)` with dimensions (m, k), (k, n) (default)

                          * ``\'some=False\'``: returns `(Q, R)` with dimensions (m, m), (m, n)

        Keyword args:
            out (tuple, optional): tuple of `Q` and `R` tensors.
                        The dimensions of `Q` and `R` are detailed in the description of :attr:`some` above.

        Example::

            >>> a = torch.tensor([[12., -51, 4], [6, 167, -68], [-4, 24, -41]])
            >>> q, r = torch.qr(a)
            >>> q
            tensor([[-0.8571,  0.3943,  0.3314],
                    [-0.4286, -0.9029, -0.0343],
                    [ 0.2857, -0.1714,  0.9429]])
            >>> r
            tensor([[ -14.0000,  -21.0000,   14.0000],
                    [   0.0000, -175.0000,   70.0000],
                    [   0.0000,    0.0000,  -35.0000]])
            >>> torch.mm(q, r).round()
            tensor([[  12.,  -51.,    4.],
                    [   6.,  167.,  -68.],
                    [  -4.,   24.,  -41.]])
            >>> torch.mm(q.t(), q).round()
            tensor([[ 1.,  0.,  0.],
                    [ 0.,  1., -0.],
                    [ 0., -0.,  1.]])
            >>> a = torch.randn(3, 4, 5)
            >>> q, r = torch.qr(a, some=False)
            >>> torch.allclose(torch.matmul(q, r), a)
            True
            >>> torch.allclose(torch.matmul(q.mT, q), torch.eye(5))
            True
        '''
    @staticmethod
    def quantile(input, q, dim=..., keepdim=..., interpolation=..., out=...) -> Tensor:
        """
        quantile(input, q, dim=None, keepdim=False, *, interpolation='linear', out=None) -> Tensor

        Computes the q-th quantiles of each row of the :attr:`input` tensor along the dimension :attr:`dim`.

        To compute the quantile, we map q in [0, 1] to the range of indices [0, n] to find the location
        of the quantile in the sorted input. If the quantile lies between two data points ``a < b`` with
        indices ``i`` and ``j`` in the sorted order, result is computed according to the given
        :attr:`interpolation` method as follows:

        - ``linear``: ``a + (b - a) * fraction``, where ``fraction`` is the fractional part of the computed quantile index.
        - ``lower``: ``a``.
        - ``higher``: ``b``.
        - ``nearest``: ``a`` or ``b``, whichever's index is closer to the computed quantile index (rounding down for .5 fractions).
        - ``midpoint``: ``(a + b) / 2``.

        If :attr:`q` is a 1D tensor, the first dimension of the output represents the quantiles and has size
        equal to the size of :attr:`q`, the remaining dimensions are what remains from the reduction.

        .. note::
            By default :attr:`dim` is ``None`` resulting in the :attr:`input` tensor being flattened before computation.

        Args:
            input (Tensor): the input tensor.
            q (float or Tensor): a scalar or 1D tensor of values in the range [0, 1].
    
            dim (int, optional): the dimension to reduce.

    
            keepdim (bool, optional): whether the output tensor has :attr:`dim` retained or not. Default: ``False``.


        Keyword arguments:
            interpolation (str): interpolation method to use when the desired quantile lies between two data points.
                                    Can be ``linear``, ``lower``, ``higher``, ``midpoint`` and ``nearest``.
                                    Default is ``linear``.
            out (Tensor, optional): the output tensor.

        Example::

            >>> a = torch.randn(2, 3)
            >>> a
            tensor([[ 0.0795, -1.2117,  0.9765],
                    [ 1.1707,  0.6706,  0.4884]])
            >>> q = torch.tensor([0.25, 0.5, 0.75])
            >>> torch.quantile(a, q, dim=1, keepdim=True)
            tensor([[[-0.5661],
                    [ 0.5795]],

                    [[ 0.0795],
                    [ 0.6706]],

                    [[ 0.5280],
                    [ 0.9206]]])
            >>> torch.quantile(a, q, dim=1, keepdim=True).shape
            torch.Size([3, 2, 1])
            >>> a = torch.arange(4.)
            >>> a
            tensor([0., 1., 2., 3.])
            >>> torch.quantile(a, 0.6, interpolation='linear')
            tensor(1.8000)
            >>> torch.quantile(a, 0.6, interpolation='lower')
            tensor(1.)
            >>> torch.quantile(a, 0.6, interpolation='higher')
            tensor(2.)
            >>> torch.quantile(a, 0.6, interpolation='midpoint')
            tensor(1.5000)
            >>> torch.quantile(a, 0.6, interpolation='nearest')
            tensor(2.)
            >>> torch.quantile(a, 0.4, interpolation='nearest')
            tensor(1.)
        """
    @staticmethod
    def quantize_per_channel(input, scales, zero_points, axis, dtype) -> Tensor:
        """
        quantize_per_channel(input, scales, zero_points, axis, dtype) -> Tensor

        Converts a float tensor to a per-channel quantized tensor with given scales and zero points.

        Arguments:
            input (Tensor): float tensor to quantize
            scales (Tensor): float 1D tensor of scales to use, size should match ``input.size(axis)``
            zero_points (int): integer 1D tensor of offset to use, size should match ``input.size(axis)``
            axis (int): dimension on which apply per-channel quantization
            dtype (:class:`torch.dtype`): the desired data type of returned tensor.
                Has to be one of the quantized dtypes: ``torch.quint8``, ``torch.qint8``, ``torch.qint32``

        Returns:
            Tensor: A newly quantized tensor

        Example::

            >>> x = torch.tensor([[-1.0, 0.0], [1.0, 2.0]])
            >>> torch.quantize_per_channel(x, torch.tensor([0.1, 0.01]), torch.tensor([10, 0]), 0, torch.quint8)
            tensor([[-1.,  0.],
                    [ 1.,  2.]], size=(2, 2), dtype=torch.quint8,
                   quantization_scheme=torch.per_channel_affine,
                   scale=tensor([0.1000, 0.0100], dtype=torch.float64),
                   zero_point=tensor([10,  0]), axis=0)
            >>> torch.quantize_per_channel(x, torch.tensor([0.1, 0.01]), torch.tensor([10, 0]), 0, torch.quint8).int_repr()
            tensor([[  0,  10],
                    [100, 200]], dtype=torch.uint8)
        """
    @staticmethod
    def quantize_per_tensor(input, scale, zero_point, dtype) -> Tensor:
        """
        quantize_per_tensor(input, scale, zero_point, dtype) -> Tensor

        Converts a float tensor to a quantized tensor with given scale and zero point.

        Arguments:
            input (Tensor): float tensor or list of tensors to quantize
            scale (float or Tensor): scale to apply in quantization formula
            zero_point (int or Tensor): offset in integer value that maps to float zero
            dtype (:class:`torch.dtype`): the desired data type of returned tensor.
                Has to be one of the quantized dtypes: ``torch.quint8``, ``torch.qint8``, ``torch.qint32``

        Returns:
            Tensor: A newly quantized tensor or list of quantized tensors.

        Example::

            >>> torch.quantize_per_tensor(torch.tensor([-1.0, 0.0, 1.0, 2.0]), 0.1, 10, torch.quint8)
            tensor([-1.,  0.,  1.,  2.], size=(4,), dtype=torch.quint8,
                   quantization_scheme=torch.per_tensor_affine, scale=0.1, zero_point=10)
            >>> torch.quantize_per_tensor(torch.tensor([-1.0, 0.0, 1.0, 2.0]), 0.1, 10, torch.quint8).int_repr()
            tensor([ 0, 10, 20, 30], dtype=torch.uint8)
            >>> torch.quantize_per_tensor([torch.tensor([-1.0, 0.0]), torch.tensor([-2.0, 2.0])],
            >>> torch.tensor([0.1, 0.2]), torch.tensor([10, 20]), torch.quint8)
            (tensor([-1.,  0.], size=(2,), dtype=torch.quint8,
                quantization_scheme=torch.per_tensor_affine, scale=0.1, zero_point=10),
                tensor([-2.,  2.], size=(2,), dtype=torch.quint8,
                quantization_scheme=torch.per_tensor_affine, scale=0.2, zero_point=20))
            >>> torch.quantize_per_tensor(torch.tensor([-1.0, 0.0, 1.0, 2.0]), torch.tensor(0.1), torch.tensor(10), torch.quint8)
            tensor([-1.,  0.,  1.,  2.], size=(4,), dtype=torch.quint8,
               quantization_scheme=torch.per_tensor_affine, scale=0.10, zero_point=10)
        """
    @staticmethod
    def quantize_per_tensor_dynamic(input, dtype, reduce_range) -> Tensor:
        """
        quantize_per_tensor_dynamic(input, dtype, reduce_range) -> Tensor

        Converts a float tensor to a quantized tensor with scale and zero_point calculated
        dynamically based on the input.

        Arguments:
            input (Tensor): float tensor or list of tensors to quantize
            dtype (:class:`torch.dtype`): the desired data type of returned tensor.
                Has to be one of the quantized dtypes: ``torch.quint8``, ``torch.qint8``
            reduce_range (bool): a flag to indicate whether to reduce the range of quantized
            data by 1 bit, it's required to avoid instruction overflow for some hardwares

        Returns:
            Tensor: A newly (dynamically) quantized tensor

        Example::

            >>> t = torch.quantize_per_tensor_dynamic(torch.tensor([-1.0, 0.0, 1.0, 2.0]), torch.quint8, False)
            >>> print(t)
            tensor([-1.,  0.,  1.,  2.], size=(4,), dtype=torch.quint8,
                   quantization_scheme=torch.per_tensor_affine, scale=0.011764705882352941,
                   zero_point=85)
            >>> t.int_repr()
            tensor([  0,  85, 170, 255], dtype=torch.uint8)
        """
    @staticmethod
    def quantized_batch_norm(input, weight=..., bias=..., mean, var, eps, output_scale, output_zero_point) -> Tensor:
        """
        quantized_batch_norm(input, weight=None, bias=None, mean, var, eps, output_scale, output_zero_point) -> Tensor

        Applies batch normalization on a 4D (NCHW) quantized tensor.

        .. math::

                y = \\frac{x - \\mathrm{E}[x]}{\\sqrt{\\mathrm{Var}[x] + \\epsilon}} * \\gamma + \\beta

        Arguments:
            input (Tensor): quantized tensor
            weight (Tensor): float tensor that corresponds to the gamma, size C
            bias (Tensor):  float tensor that corresponds to the beta, size C
            mean (Tensor): float mean value in batch normalization, size C
            var (Tensor): float tensor for variance, size C
            eps (float): a value added to the denominator for numerical stability.
            output_scale (float): output quantized tensor scale
            output_zero_point (int): output quantized tensor zero_point

        Returns:
            Tensor: A quantized tensor with batch normalization applied.

        Example::

            >>> qx = torch.quantize_per_tensor(torch.rand(2, 2, 2, 2), 1.5, 3, torch.quint8)
            >>> torch.quantized_batch_norm(qx, torch.ones(2), torch.zeros(2), torch.rand(2), torch.rand(2), 0.00001, 0.2, 2)
            tensor([[[[-0.2000, -0.2000],
                  [ 1.6000, -0.2000]],

                 [[-0.4000, -0.4000],
                  [-0.4000,  0.6000]]],


                [[[-0.2000, -0.2000],
                  [-0.2000, -0.2000]],

                 [[ 0.6000, -0.4000],
                  [ 0.6000, -0.4000]]]], size=(2, 2, 2, 2), dtype=torch.quint8,
               quantization_scheme=torch.per_tensor_affine, scale=0.2, zero_point=2)
        """
    @staticmethod
    def quantized_gru_cell(*args, **kwargs): ...
    @staticmethod
    def quantized_lstm_cell(*args, **kwargs): ...
    @staticmethod
    def quantized_max_pool1d(input, kernel_size, stride=..., padding=..., dilation=..., ceil_mode=...) -> Tensor:
        """
        quantized_max_pool1d(input, kernel_size, stride=[], padding=0, dilation=1, ceil_mode=False) -> Tensor

        Applies a 1D max pooling over an input quantized tensor composed of several input planes.

        Arguments:
            input (Tensor): quantized tensor
            kernel_size (list of int): the size of the sliding window
            stride (``list of int``, optional): the stride of the sliding window
            padding (``list of int``, optional): padding to be added on both sides, must be >= 0 and <= kernel_size / 2
            dilation (``list of int``, optional): The stride between elements within a sliding window, must be > 0. Default 1
            ceil_mode (bool, optional):  If True, will use ceil instead of floor to compute the output shape.
                Defaults to False.


        Returns:
            Tensor: A quantized tensor with max_pool1d applied.

        Example::

            >>> qx = torch.quantize_per_tensor(torch.rand(2, 2), 1.5, 3, torch.quint8)
            >>> torch.quantized_max_pool1d(qx, [2])
            tensor([[0.0000],
                    [1.5000]], size=(2, 1), dtype=torch.quint8,
                quantization_scheme=torch.per_tensor_affine, scale=1.5, zero_point=3)
        """
    @staticmethod
    def quantized_max_pool2d(input, kernel_size, stride=..., padding=..., dilation=..., ceil_mode=...) -> Tensor:
        """
        quantized_max_pool2d(input, kernel_size, stride=[], padding=0, dilation=1, ceil_mode=False) -> Tensor

        Applies a 2D max pooling over an input quantized tensor composed of several input planes.

        Arguments:
            input (Tensor): quantized tensor
            kernel_size (``list of int``): the size of the sliding window
            stride (``list of int``, optional): the stride of the sliding window
            padding (``list of int``, optional): padding to be added on both sides, must be >= 0 and <= kernel_size / 2
            dilation (``list of int``, optional): The stride between elements within a sliding window, must be > 0. Default 1
            ceil_mode (bool, optional):  If True, will use ceil instead of floor to compute the output shape.
                Defaults to False.


        Returns:
            Tensor: A quantized tensor with max_pool2d applied.

        Example::

            >>> qx = torch.quantize_per_tensor(torch.rand(2, 2, 2, 2), 1.5, 3, torch.quint8)
            >>> torch.quantized_max_pool2d(qx, [2,2])
            tensor([[[[1.5000]],

                    [[1.5000]]],


                    [[[0.0000]],

                    [[0.0000]]]], size=(2, 2, 1, 1), dtype=torch.quint8,
                quantization_scheme=torch.per_tensor_affine, scale=1.5, zero_point=3)
        """
    @staticmethod
    def quantized_max_pool3d(*args, **kwargs): ...
    @staticmethod
    def quantized_rnn_relu_cell(*args, **kwargs): ...
    @staticmethod
    def quantized_rnn_tanh_cell(*args, **kwargs): ...
    @overload
    @staticmethod
    def rad2deg(input: Tensor, out: Tensor | None) -> Tensor:
        """
        rad2deg(input: Tensor, *, out: Optional[Tensor]) -> Tensor

        Returns a new tensor with each of the elements of :attr:`input`
        converted from angles in radians to degrees.

        Args:
            input (Tensor): the input tensor.

        Keyword arguments:
            out (Tensor, optional): the output tensor.

        Example::

            >>> a = torch.tensor([[3.142, -3.142], [6.283, -6.283], [1.570, -1.570]])
            >>> torch.rad2deg(a)
            tensor([[ 180.0233, -180.0233],
                    [ 359.9894, -359.9894],
                    [  89.9544,  -89.9544]])

        """
    @overload
    @staticmethod
    def rad2deg(a) -> Any:
        """
        rad2deg(input: Tensor, *, out: Optional[Tensor]) -> Tensor

        Returns a new tensor with each of the elements of :attr:`input`
        converted from angles in radians to degrees.

        Args:
            input (Tensor): the input tensor.

        Keyword arguments:
            out (Tensor, optional): the output tensor.

        Example::

            >>> a = torch.tensor([[3.142, -3.142], [6.283, -6.283], [1.570, -1.570]])
            >>> torch.rad2deg(a)
            tensor([[ 180.0233, -180.0233],
                    [ 359.9894, -359.9894],
                    [  89.9544,  -89.9544]])

        """
    @staticmethod
    def rad2deg_(*args, **kwargs): ...
    @staticmethod
    def rand(*args, **kwargs):
        """
        rand(*size, *, generator=None, out=None, dtype=None, layout=torch.strided, device=None, requires_grad=False, pin_memory=False) -> Tensor

        Returns a tensor filled with random numbers from a uniform distribution
        on the interval :math:`[0, 1)`

        The shape of the tensor is defined by the variable argument :attr:`size`.

        Args:
            size (int...): a sequence of integers defining the shape of the output tensor.
                Can be a variable number of arguments or a collection like a list or tuple.

        Keyword args:
            generator (:class:`torch.Generator`, optional): a pseudorandom number generator for sampling
            out (Tensor, optional): the output tensor.
            dtype (:class:`torch.dtype`, optional): the desired data type of returned tensor.
                Default: if ``None``, uses a global default (see :func:`torch.set_default_dtype`).
            layout (:class:`torch.layout`, optional): the desired layout of returned Tensor.
                Default: ``torch.strided``.
            device (:class:`torch.device`, optional): the desired device of returned tensor.
                Default: if ``None``, uses the current device for the default tensor type
                (see :func:`torch.set_default_device`). :attr:`device` will be the CPU
                for CPU tensor types and the current CUDA device for CUDA tensor types.
            requires_grad (bool, optional): If autograd should record operations on the
                returned tensor. Default: ``False``.
            pin_memory (bool, optional): If set, returned tensor would be allocated in
                the pinned memory. Works only for CPU tensors. Default: ``False``.

        Example::

            >>> torch.rand(4)
            tensor([ 0.5204,  0.2503,  0.3525,  0.5673])
            >>> torch.rand(2, 3)
            tensor([[ 0.8237,  0.5781,  0.6879],
                    [ 0.3816,  0.7249,  0.0998]])
        """
    @overload
    @staticmethod
    def rand_like(input, dtype=..., layout=..., device=..., requires_grad=..., memory_format=...) -> Tensor:
        """
        rand_like(input, *, dtype=None, layout=None, device=None, requires_grad=False, memory_format=torch.preserve_format) -> Tensor

        Returns a tensor with the same size as :attr:`input` that is filled with
        random numbers from a uniform distribution on the interval :math:`[0, 1)`.
        ``torch.rand_like(input)`` is equivalent to
        ``torch.rand(input.size(), dtype=input.dtype, layout=input.layout, device=input.device)``.

        Args:
            input (Tensor): the size of :attr:`input` will determine size of the output tensor.

        Keyword args:
            dtype (:class:`torch.dtype`, optional): the desired data type of returned Tensor.
                Default: if ``None``, defaults to the dtype of :attr:`input`.
            layout (:class:`torch.layout`, optional): the desired layout of returned tensor.
                Default: if ``None``, defaults to the layout of :attr:`input`.
            device (:class:`torch.device`, optional): the desired device of returned tensor.
                Default: if ``None``, defaults to the device of :attr:`input`.
            requires_grad (bool, optional): If autograd should record operations on the
                returned tensor. Default: ``False``.
            memory_format (:class:`torch.memory_format`, optional): the desired memory format of
                returned Tensor. Default: ``torch.preserve_format``.

        """
    @overload
    @staticmethod
    def rand_like(input) -> Any:
        """
        rand_like(input, *, dtype=None, layout=None, device=None, requires_grad=False, memory_format=torch.preserve_format) -> Tensor

        Returns a tensor with the same size as :attr:`input` that is filled with
        random numbers from a uniform distribution on the interval :math:`[0, 1)`.
        ``torch.rand_like(input)`` is equivalent to
        ``torch.rand(input.size(), dtype=input.dtype, layout=input.layout, device=input.device)``.

        Args:
            input (Tensor): the size of :attr:`input` will determine size of the output tensor.

        Keyword args:
            dtype (:class:`torch.dtype`, optional): the desired data type of returned Tensor.
                Default: if ``None``, defaults to the dtype of :attr:`input`.
            layout (:class:`torch.layout`, optional): the desired layout of returned tensor.
                Default: if ``None``, defaults to the layout of :attr:`input`.
            device (:class:`torch.device`, optional): the desired device of returned tensor.
                Default: if ``None``, defaults to the device of :attr:`input`.
            requires_grad (bool, optional): If autograd should record operations on the
                returned tensor. Default: ``False``.
            memory_format (:class:`torch.memory_format`, optional): the desired memory format of
                returned Tensor. Default: ``torch.preserve_format``.

        """
    @staticmethod
    def randint(*args, **kwargs):
        """
        randint(low=0, high, size, \\*, generator=None, out=None, dtype=None, layout=torch.strided, device=None, requires_grad=False) -> Tensor

        Returns a tensor filled with random integers generated uniformly
        between :attr:`low` (inclusive) and :attr:`high` (exclusive).

        The shape of the tensor is defined by the variable argument :attr:`size`.

        .. note::
            With the global dtype default (``torch.float32``), this function returns
            a tensor with dtype ``torch.int64``.

        Args:
            low (int, optional): Lowest integer to be drawn from the distribution. Default: 0.
            high (int): One above the highest integer to be drawn from the distribution.
            size (tuple): a tuple defining the shape of the output tensor.

        Keyword args:
            generator (:class:`torch.Generator`, optional): a pseudorandom number generator for sampling
            out (Tensor, optional): the output tensor.
            dtype (`torch.dtype`, optional) - the desired data type of returned tensor. Default: if ``None``,
                this function returns a tensor with dtype ``torch.int64``.
            layout (:class:`torch.layout`, optional): the desired layout of returned Tensor.
                Default: ``torch.strided``.
            device (:class:`torch.device`, optional): the desired device of returned tensor.
                Default: if ``None``, uses the current device for the default tensor type
                (see :func:`torch.set_default_device`). :attr:`device` will be the CPU
                for CPU tensor types and the current CUDA device for CUDA tensor types.
            requires_grad (bool, optional): If autograd should record operations on the
                returned tensor. Default: ``False``.

        Example::

            >>> torch.randint(3, 5, (3,))
            tensor([4, 3, 4])


            >>> torch.randint(10, (2, 2))
            tensor([[0, 2],
                    [5, 5]])


            >>> torch.randint(3, 10, (2, 2))
            tensor([[4, 5],
                    [6, 7]])


        """
    @staticmethod
    def randint_like(*args, **kwargs):
        """
        randint_like(input, low=0, high, \\*, dtype=None, layout=torch.strided, device=None, requires_grad=False, memory_format=torch.preserve_format) -> Tensor

        Returns a tensor with the same shape as Tensor :attr:`input` filled with
        random integers generated uniformly between :attr:`low` (inclusive) and
        :attr:`high` (exclusive).

        .. note:
            With the global dtype default (``torch.float32``), this function returns
            a tensor with dtype ``torch.int64``.

        Args:
            input (Tensor): the size of :attr:`input` will determine size of the output tensor.
            low (int, optional): Lowest integer to be drawn from the distribution. Default: 0.
            high (int): One above the highest integer to be drawn from the distribution.

        Keyword args:
            dtype (:class:`torch.dtype`, optional): the desired data type of returned Tensor.
                Default: if ``None``, defaults to the dtype of :attr:`input`.
            layout (:class:`torch.layout`, optional): the desired layout of returned tensor.
                Default: if ``None``, defaults to the layout of :attr:`input`.
            device (:class:`torch.device`, optional): the desired device of returned tensor.
                Default: if ``None``, defaults to the device of :attr:`input`.
            requires_grad (bool, optional): If autograd should record operations on the
                returned tensor. Default: ``False``.
            memory_format (:class:`torch.memory_format`, optional): the desired memory format of
                returned Tensor. Default: ``torch.preserve_format``.

        """
    @staticmethod
    def randn(*args, **kwargs):
        """
        randn(*size, *, generator=None, out=None, dtype=None, layout=torch.strided, device=None, requires_grad=False, pin_memory=False) -> Tensor


        Returns a tensor filled with random numbers from a normal distribution
        with mean `0` and variance `1` (also called the standard normal
        distribution).

        .. math::
            \\text{out}_{i} \\sim \\mathcal{N}(0, 1)

        For complex dtypes, the tensor is i.i.d. sampled from a `complex normal distribution`_ with zero mean and
        unit variance as

        .. math::
            \\text{out}_{i} \\sim \\mathcal{CN}(0, 1)

        This is equivalent to separately sampling the real :math:`(\\operatorname{Re})` and imaginary
        :math:`(\\operatorname{Im})` part of :math:`\\text{out}_i` as

        .. math::
            \\operatorname{Re}(\\text{out}_{i}) \\sim \\mathcal{N}(0, \\frac{1}{2}),\\quad
            \\operatorname{Im}(\\text{out}_{i}) \\sim \\mathcal{N}(0, \\frac{1}{2})

        The shape of the tensor is defined by the variable argument :attr:`size`.


        Args:
            size (int...): a sequence of integers defining the shape of the output tensor.
                Can be a variable number of arguments or a collection like a list or tuple.

        Keyword args:
            generator (:class:`torch.Generator`, optional): a pseudorandom number generator for sampling
            out (Tensor, optional): the output tensor.
            dtype (:class:`torch.dtype`, optional): the desired data type of returned tensor.
                Default: if ``None``, uses a global default (see :func:`torch.set_default_dtype`).
            layout (:class:`torch.layout`, optional): the desired layout of returned Tensor.
                Default: ``torch.strided``.
            device (:class:`torch.device`, optional): the desired device of returned tensor.
                Default: if ``None``, uses the current device for the default tensor type
                (see :func:`torch.set_default_device`). :attr:`device` will be the CPU
                for CPU tensor types and the current CUDA device for CUDA tensor types.
            requires_grad (bool, optional): If autograd should record operations on the
                returned tensor. Default: ``False``.
            pin_memory (bool, optional): If set, returned tensor would be allocated in
                the pinned memory. Works only for CPU tensors. Default: ``False``.

        Example::

            >>> torch.randn(4)
            tensor([-2.1436,  0.9966,  2.3426, -0.6366])
            >>> torch.randn(2, 3)
            tensor([[ 1.5954,  2.8929, -1.0923],
                    [ 1.1719, -0.4709, -0.1996]])

        .. _complex normal distribution: https://en.wikipedia.org/wiki/Complex_normal_distribution
        """
    @overload
    @staticmethod
    def randn_like(input, dtype=..., layout=..., device=..., requires_grad=..., memory_format=...) -> Tensor:
        """
        randn_like(input, *, dtype=None, layout=None, device=None, requires_grad=False, memory_format=torch.preserve_format) -> Tensor

        Returns a tensor with the same size as :attr:`input` that is filled with
        random numbers from a normal distribution with mean 0 and variance 1. Please refer to :func:`torch.randn` for the
        sampling process of complex dtypes. ``torch.randn_like(input)`` is equivalent to
        ``torch.randn(input.size(), dtype=input.dtype, layout=input.layout, device=input.device)``.

        Args:
            input (Tensor): the size of :attr:`input` will determine size of the output tensor.

        Keyword args:
            dtype (:class:`torch.dtype`, optional): the desired data type of returned Tensor.
                Default: if ``None``, defaults to the dtype of :attr:`input`.
            layout (:class:`torch.layout`, optional): the desired layout of returned tensor.
                Default: if ``None``, defaults to the layout of :attr:`input`.
            device (:class:`torch.device`, optional): the desired device of returned tensor.
                Default: if ``None``, defaults to the device of :attr:`input`.
            requires_grad (bool, optional): If autograd should record operations on the
                returned tensor. Default: ``False``.
            memory_format (:class:`torch.memory_format`, optional): the desired memory format of
                returned Tensor. Default: ``torch.preserve_format``.

        """
    @overload
    @staticmethod
    def randn_like(input) -> Any:
        """
        randn_like(input, *, dtype=None, layout=None, device=None, requires_grad=False, memory_format=torch.preserve_format) -> Tensor

        Returns a tensor with the same size as :attr:`input` that is filled with
        random numbers from a normal distribution with mean 0 and variance 1. Please refer to :func:`torch.randn` for the
        sampling process of complex dtypes. ``torch.randn_like(input)`` is equivalent to
        ``torch.randn(input.size(), dtype=input.dtype, layout=input.layout, device=input.device)``.

        Args:
            input (Tensor): the size of :attr:`input` will determine size of the output tensor.

        Keyword args:
            dtype (:class:`torch.dtype`, optional): the desired data type of returned Tensor.
                Default: if ``None``, defaults to the dtype of :attr:`input`.
            layout (:class:`torch.layout`, optional): the desired layout of returned tensor.
                Default: if ``None``, defaults to the layout of :attr:`input`.
            device (:class:`torch.device`, optional): the desired device of returned tensor.
                Default: if ``None``, defaults to the device of :attr:`input`.
            requires_grad (bool, optional): If autograd should record operations on the
                returned tensor. Default: ``False``.
            memory_format (:class:`torch.memory_format`, optional): the desired memory format of
                returned Tensor. Default: ``torch.preserve_format``.

        """
    @staticmethod
    def randperm(n, generator=..., out=..., dtype=..., layout=..., device=..., requires_grad=..., pin_memory=...) -> Tensor:
        """
        randperm(n, *, generator=None, out=None, dtype=torch.int64,layout=torch.strided, device=None, requires_grad=False, pin_memory=False) -> Tensor

        Returns a random permutation of integers from ``0`` to ``n - 1``.

        Args:
            n (int): the upper bound (exclusive)

        Keyword args:
            generator (:class:`torch.Generator`, optional): a pseudorandom number generator for sampling
            out (Tensor, optional): the output tensor.
            dtype (:class:`torch.dtype`, optional): the desired data type of returned tensor.
                Default: ``torch.int64``.
            layout (:class:`torch.layout`, optional): the desired layout of returned Tensor.
                Default: ``torch.strided``.
            device (:class:`torch.device`, optional): the desired device of returned tensor.
                Default: if ``None``, uses the current device for the default tensor type
                (see :func:`torch.set_default_device`). :attr:`device` will be the CPU
                for CPU tensor types and the current CUDA device for CUDA tensor types.
            requires_grad (bool, optional): If autograd should record operations on the
                returned tensor. Default: ``False``.
            pin_memory (bool, optional): If set, returned tensor would be allocated in
                the pinned memory. Works only for CPU tensors. Default: ``False``.

        Example::

            >>> torch.randperm(4)
            tensor([2, 1, 0, 3])
        """
    @staticmethod
    def range(start=..., end, step=..., out=..., dtype=..., layout=..., device=..., requires_grad=...) -> Tensor:
        """
        range(start=0, end, step=1, *, out=None, dtype=None, layout=torch.strided, device=None, requires_grad=False) -> Tensor

        Returns a 1-D tensor of size :math:`\\left\\lfloor \\frac{\\text{end} - \\text{start}}{\\text{step}} \\right\\rfloor + 1`
        with values from :attr:`start` to :attr:`end` with step :attr:`step`. Step is
        the gap between two values in the tensor.

        .. math::
            \\text{out}_{i+1} = \\text{out}_i + \\text{step}.

        .. warning::
            This function is deprecated and will be removed in a future release because its behavior is inconsistent with
            Python's range builtin. Instead, use :func:`torch.arange`, which produces values in [start, end).

        Args:
            start (float, optional): the starting value for the set of points. Default: ``0``.
            end (float): the ending value for the set of points
            step (float, optional): the gap between each pair of adjacent points. Default: ``1``.

        Keyword args:
            out (Tensor, optional): the output tensor.
            dtype (:class:`torch.dtype`, optional): the desired data type of returned tensor.
                Default: if ``None``, uses a global default (see :func:`torch.set_default_dtype`). If `dtype` is not given, infer the data type from the other input
                arguments. If any of `start`, `end`, or `step` are floating-point, the
                `dtype` is inferred to be the default dtype, see
                :meth:`~torch.get_default_dtype`. Otherwise, the `dtype` is inferred to
                be `torch.int64`.
            layout (:class:`torch.layout`, optional): the desired layout of returned Tensor.
                Default: ``torch.strided``.
            device (:class:`torch.device`, optional): the desired device of returned tensor.
                Default: if ``None``, uses the current device for the default tensor type
                (see :func:`torch.set_default_device`). :attr:`device` will be the CPU
                for CPU tensor types and the current CUDA device for CUDA tensor types.
            requires_grad (bool, optional): If autograd should record operations on the
                returned tensor. Default: ``False``.

        Example::

            >>> torch.range(1, 4)
            tensor([ 1.,  2.,  3.,  4.])
            >>> torch.range(1, 4, 0.5)
            tensor([ 1.0000,  1.5000,  2.0000,  2.5000,  3.0000,  3.5000,  4.0000])
        """
    @overload
    @staticmethod
    def ravel(input) -> Tensor:
        """
        ravel(input) -> Tensor

        Return a contiguous flattened tensor. A copy is made only if needed.

        Args:
            input (Tensor): the input tensor.

        Example::

            >>> t = torch.tensor([[[1, 2],
            ...                    [3, 4]],
            ...                   [[5, 6],
            ...                    [7, 8]]])
            >>> torch.ravel(t)
            tensor([1, 2, 3, 4, 5, 6, 7, 8])
        """
    @overload
    @staticmethod
    def ravel(t) -> Any:
        """
        ravel(input) -> Tensor

        Return a contiguous flattened tensor. A copy is made only if needed.

        Args:
            input (Tensor): the input tensor.

        Example::

            >>> t = torch.tensor([[[1, 2],
            ...                    [3, 4]],
            ...                   [[5, 6],
            ...                    [7, 8]]])
            >>> torch.ravel(t)
            tensor([1, 2, 3, 4, 5, 6, 7, 8])
        """
    @staticmethod
    def real(input) -> Tensor:
        """
        real(input) -> Tensor

        Returns a new tensor containing real values of the :attr:`self` tensor.
        The returned tensor and :attr:`self` share the same underlying storage.

        Args:
            input (Tensor): the input tensor.

        Example::

            >>> x=torch.randn(4, dtype=torch.cfloat)
            >>> x
            tensor([(0.3100+0.3553j), (-0.5445-0.7896j), (-1.6492-0.0633j), (-0.0638-0.8119j)])
            >>> x.real
            tensor([ 0.3100, -0.5445, -1.6492, -0.0638])

        """
    @staticmethod
    def reciprocal(input, out=...) -> Tensor:
        """
        reciprocal(input, *, out=None) -> Tensor

        Returns a new tensor with the reciprocal of the elements of :attr:`input`

        .. math::
            \\text{out}_{i} = \\frac{1}{\\text{input}_{i}}

        .. note::
            Unlike NumPy's reciprocal, torch.reciprocal supports integral inputs. Integral
            inputs to reciprocal are automatically :ref:`promoted <type-promotion-doc>` to
            the default scalar type.

        Args:
            input (Tensor): the input tensor.

        Keyword args:
            out (Tensor, optional): the output tensor.

        Example::

            >>> a = torch.randn(4)
            >>> a
            tensor([-0.4595, -2.1219, -1.4314,  0.7298])
            >>> torch.reciprocal(a)
            tensor([-2.1763, -0.4713, -0.6986,  1.3702])
        """
    @staticmethod
    def reciprocal_(*args, **kwargs): ...
    @staticmethod
    def relu(*args, **kwargs): ...
    @staticmethod
    def relu_(input) -> Tensor:
        """
        relu_(input) -> Tensor

        In-place version of :func:`~relu`.
        """
    @staticmethod
    def remainder(input, other, out=...) -> Tensor:
        '''
        remainder(input, other, *, out=None) -> Tensor

        Computes
        `Python\'s modulus operation <https://docs.python.org/3/reference/expressions.html#binary-arithmetic-operations>`_
        entrywise.  The result has the same sign as the divisor :attr:`other` and its absolute value
        is less than that of :attr:`other`.

        It may also be defined in terms of :func:`torch.div` as

        .. code:: python

            torch.remainder(a, b) == a - a.div(b, rounding_mode="floor") * b

        Supports :ref:`broadcasting to a common shape <broadcasting-semantics>`,
        :ref:`type promotion <type-promotion-doc>`, and integer and float inputs.

        .. note::
            Complex inputs are not supported. In some cases, it is not mathematically
            possible to satisfy the definition of a modulo operation with complex numbers.
            See :func:`torch.fmod` for how division by zero is handled.

        .. seealso::

            :func:`torch.fmod` which implements C++\'s `std::fmod <https://en.cppreference.com/w/cpp/numeric/math/fmod>`_.
            This one is defined in terms of division rounding towards zero.

        Args:
            input (Tensor or Scalar): the dividend
            other (Tensor or Scalar): the divisor

        Keyword args:
            out (Tensor, optional): the output tensor.

        Example::

            >>> torch.remainder(torch.tensor([-3., -2, -1, 1, 2, 3]), 2)
            tensor([ 1.,  0.,  1.,  1.,  0.,  1.])
            >>> torch.remainder(torch.tensor([1, 2, 3, 4, 5]), -1.5)
            tensor([ -0.5000, -1.0000,  0.0000, -0.5000, -1.0000 ])
        '''
    @staticmethod
    def renorm(input, p, dim, maxnorm, out=...) -> Tensor:
        """
        renorm(input, p, dim, maxnorm, *, out=None) -> Tensor

        Returns a tensor where each sub-tensor of :attr:`input` along dimension
        :attr:`dim` is normalized such that the `p`-norm of the sub-tensor is lower
        than the value :attr:`maxnorm`

        .. note:: If the norm of a row is lower than `maxnorm`, the row is unchanged

        Args:
            input (Tensor): the input tensor.
            p (float): the power for the norm computation
            dim (int): the dimension to slice over to get the sub-tensors
            maxnorm (float): the maximum norm to keep each sub-tensor under

        Keyword args:
            out (Tensor, optional): the output tensor.

        Example::

            >>> x = torch.ones(3, 3)
            >>> x[1].fill_(2)
            tensor([ 2.,  2.,  2.])
            >>> x[2].fill_(3)
            tensor([ 3.,  3.,  3.])
            >>> x
            tensor([[ 1.,  1.,  1.],
                    [ 2.,  2.,  2.],
                    [ 3.,  3.,  3.]])
            >>> torch.renorm(x, 1, 0, 5)
            tensor([[ 1.0000,  1.0000,  1.0000],
                    [ 1.6667,  1.6667,  1.6667],
                    [ 1.6667,  1.6667,  1.6667]])
        """
    @staticmethod
    def repeat_interleave(input, repeats, dim=..., output_size=...) -> Tensor:
        """
        repeat_interleave(input, repeats, dim=None, *, output_size=None) -> Tensor

        Repeat elements of a tensor.

        .. warning::

            This is different from :meth:`torch.Tensor.repeat` but similar to ``numpy.repeat``.

        Args:
            input (Tensor): the input tensor.
            repeats (Tensor or int): The number of repetitions for each element.
                repeats is broadcasted to fit the shape of the given axis.
            dim (int, optional): The dimension along which to repeat values.
                By default, use the flattened input array, and return a flat output
                array.

        Keyword args:
            output_size (int, optional): Total output size for the given axis
                ( e.g. sum of repeats). If given, it will avoid stream synchronization
                needed to calculate output shape of the tensor.

        Returns:
            Tensor: Repeated tensor which has the same shape as input, except along the given axis.

        Example::

            >>> x = torch.tensor([1, 2, 3])
            >>> x.repeat_interleave(2)
            tensor([1, 1, 2, 2, 3, 3])
            >>> y = torch.tensor([[1, 2], [3, 4]])
            >>> torch.repeat_interleave(y, 2)
            tensor([1, 1, 2, 2, 3, 3, 4, 4])
            >>> torch.repeat_interleave(y, 3, dim=1)
            tensor([[1, 1, 1, 2, 2, 2],
                    [3, 3, 3, 4, 4, 4]])
            >>> torch.repeat_interleave(y, torch.tensor([1, 2]), dim=0)
            tensor([[1, 2],
                    [3, 4],
                    [3, 4]])
            >>> torch.repeat_interleave(y, torch.tensor([1, 2]), dim=0, output_size=3)
            tensor([[1, 2],
                    [3, 4],
                    [3, 4]])

        If the `repeats` is `tensor([n1, n2, n3, ...])`, then the output will be
        `tensor([0, 0, ..., 1, 1, ..., 2, 2, ..., ...])` where `0` appears `n1` times,
        `1` appears `n2` times, `2` appears `n3` times, etc.

        .. function:: repeat_interleave(repeats, *) -> Tensor
           :noindex:

        Repeats 0 repeats[0] times, 1 repeats[1] times, 2 repeats[2] times, etc.

        Args:
            repeats (Tensor): The number of repetitions for each element.

        Returns:
            Tensor: Repeated tensor of size `sum(repeats)`.

        Example::

            >>> torch.repeat_interleave(torch.tensor([1, 2, 3]))
            tensor([0, 1, 1, 2, 2, 2])

        """
    @staticmethod
    def reshape(input, shape) -> Tensor:
        """
        reshape(input, shape) -> Tensor

        Returns a tensor with the same data and number of elements as :attr:`input`,
        but with the specified shape. When possible, the returned tensor will be a view
        of :attr:`input`. Otherwise, it will be a copy. Contiguous inputs and inputs
        with compatible strides can be reshaped without copying, but you should not
        depend on the copying vs. viewing behavior.

        See :meth:`torch.Tensor.view` on when it is possible to return a view.

        A single dimension may be -1, in which case it's inferred from the remaining
        dimensions and the number of elements in :attr:`input`.

        Args:
            input (Tensor): the tensor to be reshaped
            shape (tuple of int): the new shape

        Example::

            >>> a = torch.arange(4.)
            >>> torch.reshape(a, (2, 2))
            tensor([[ 0.,  1.],
                    [ 2.,  3.]])
            >>> b = torch.tensor([[0, 1], [2, 3]])
            >>> torch.reshape(b, (-1,))
            tensor([ 0,  1,  2,  3])
        """
    @staticmethod
    def resize_as_(*args, **kwargs): ...
    @staticmethod
    def resize_as_sparse_(*args, **kwargs): ...
    @staticmethod
    def resolve_conj(input) -> Tensor:
        """
        resolve_conj(input) -> Tensor

        Returns a new tensor with materialized conjugation if :attr:`input`'s conjugate bit is set to `True`,
        else returns :attr:`input`. The output tensor will always have its conjugate bit set to `False`.

        Args:
            input (Tensor): the input tensor.

        Example::

            >>> x = torch.tensor([-1 + 1j, -2 + 2j, 3 - 3j])
            >>> y = x.conj()
            >>> y.is_conj()
            True
            >>> z = y.resolve_conj()
            >>> z
            tensor([-1 - 1j, -2 - 2j, 3 + 3j])
            >>> z.is_conj()
            False
        """
    @staticmethod
    def resolve_neg(input) -> Tensor:
        """
        resolve_neg(input) -> Tensor

        Returns a new tensor with materialized negation if :attr:`input`'s negative bit is set to `True`,
        else returns :attr:`input`. The output tensor will always have its negative bit set to `False`.

        Args:
            input (Tensor): the input tensor.

        Example::

            >>> x = torch.tensor([-1 + 1j, -2 + 2j, 3 - 3j])
            >>> y = x.conj()
            >>> z = y.imag
            >>> z.is_neg()
            True
            >>> out = z.resolve_neg()
            >>> out
            tensor([-1., -2., 3.])
            >>> out.is_neg()
            False
        """
    @staticmethod
    def result_type(tensor1, tensor2) -> dtype:
        """
        result_type(tensor1, tensor2) -> dtype

        Returns the :class:`torch.dtype` that would result from performing an arithmetic
        operation on the provided input tensors. See type promotion :ref:`documentation <type-promotion-doc>`
        for more information on the type promotion logic.

        Args:
            tensor1 (Tensor or Number): an input tensor or number
            tensor2 (Tensor or Number): an input tensor or number

        Example::

            >>> torch.result_type(torch.tensor([1, 2], dtype=torch.int), 1.0)
            torch.float32
            >>> torch.result_type(torch.tensor([1, 2], dtype=torch.uint8), torch.tensor(1))
            torch.uint8
        """
    @staticmethod
    def rms_norm(*args, **kwargs): ...
    @staticmethod
    def rnn_relu(*args, **kwargs): ...
    @staticmethod
    def rnn_relu_cell(*args, **kwargs): ...
    @staticmethod
    def rnn_tanh(*args, **kwargs): ...
    @staticmethod
    def rnn_tanh_cell(*args, **kwargs): ...
    @overload
    @staticmethod
    def roll(input, shifts, dims=...) -> Tensor:
        """
        roll(input, shifts, dims=None) -> Tensor

        Roll the tensor :attr:`input` along the given dimension(s). Elements that are
        shifted beyond the last position are re-introduced at the first position. If
        :attr:`dims` is `None`, the tensor will be flattened before rolling and then
        restored to the original shape.

        Args:
            input (Tensor): the input tensor.
            shifts (int or tuple of ints): The number of places by which the elements
                of the tensor are shifted. If shifts is a tuple, dims must be a tuple of
                the same size, and each dimension will be rolled by the corresponding
                value
            dims (int or tuple of ints): Axis along which to roll

        Example::

            >>> x = torch.tensor([1, 2, 3, 4, 5, 6, 7, 8]).view(4, 2)
            >>> x
            tensor([[1, 2],
                    [3, 4],
                    [5, 6],
                    [7, 8]])
            >>> torch.roll(x, 1)
            tensor([[8, 1],
                    [2, 3],
                    [4, 5],
                    [6, 7]])
            >>> torch.roll(x, 1, 0)
            tensor([[7, 8],
                    [1, 2],
                    [3, 4],
                    [5, 6]])
            >>> torch.roll(x, -1, 0)
            tensor([[3, 4],
                    [5, 6],
                    [7, 8],
                    [1, 2]])
            >>> torch.roll(x, shifts=(2, 1), dims=(0, 1))
            tensor([[6, 5],
                    [8, 7],
                    [2, 1],
                    [4, 3]])
        """
    @overload
    @staticmethod
    def roll(x, shifts=..., dims=...) -> Any:
        """
        roll(input, shifts, dims=None) -> Tensor

        Roll the tensor :attr:`input` along the given dimension(s). Elements that are
        shifted beyond the last position are re-introduced at the first position. If
        :attr:`dims` is `None`, the tensor will be flattened before rolling and then
        restored to the original shape.

        Args:
            input (Tensor): the input tensor.
            shifts (int or tuple of ints): The number of places by which the elements
                of the tensor are shifted. If shifts is a tuple, dims must be a tuple of
                the same size, and each dimension will be rolled by the corresponding
                value
            dims (int or tuple of ints): Axis along which to roll

        Example::

            >>> x = torch.tensor([1, 2, 3, 4, 5, 6, 7, 8]).view(4, 2)
            >>> x
            tensor([[1, 2],
                    [3, 4],
                    [5, 6],
                    [7, 8]])
            >>> torch.roll(x, 1)
            tensor([[8, 1],
                    [2, 3],
                    [4, 5],
                    [6, 7]])
            >>> torch.roll(x, 1, 0)
            tensor([[7, 8],
                    [1, 2],
                    [3, 4],
                    [5, 6]])
            >>> torch.roll(x, -1, 0)
            tensor([[3, 4],
                    [5, 6],
                    [7, 8],
                    [1, 2]])
            >>> torch.roll(x, shifts=(2, 1), dims=(0, 1))
            tensor([[6, 5],
                    [8, 7],
                    [2, 1],
                    [4, 3]])
        """
    @staticmethod
    def rot90(input, k=..., dims=...) -> Tensor:
        """
        rot90(input, k=1, dims=(0, 1)) -> Tensor

        Rotate an n-D tensor by 90 degrees in the plane specified by dims axis.
        Rotation direction is from the first towards the second axis if k > 0, and from the second towards the first for k < 0.

        Args:
            input (Tensor): the input tensor.
            k (int): number of times to rotate. Default value is 1
            dims (a list or tuple): axis to rotate. Default value is [0, 1]

        Example::

            >>> x = torch.arange(4).view(2, 2)
            >>> x
            tensor([[0, 1],
                    [2, 3]])
            >>> torch.rot90(x, 1, [0, 1])
            tensor([[1, 3],
                    [0, 2]])

            >>> x = torch.arange(8).view(2, 2, 2)
            >>> x
            tensor([[[0, 1],
                     [2, 3]],

                    [[4, 5],
                     [6, 7]]])
            >>> torch.rot90(x, 1, [1, 2])
            tensor([[[1, 3],
                     [0, 2]],

                    [[5, 7],
                     [4, 6]]])
        """
    @staticmethod
    def round(input, decimals=..., out=...) -> Tensor:
        '''
        round(input, *, decimals=0, out=None) -> Tensor

        Rounds elements of :attr:`input` to the nearest integer.

        For integer inputs, follows the array-api convention of returning a
        copy of the input tensor.
        The return type of output is same as that of input\'s dtype.

        .. note::
            This function implements the "round half to even" to
            break ties when a number is equidistant from two
            integers (e.g. `round(2.5)` is 2).

            When the :attr:\\`decimals\\` argument is specified the
            algorithm used is similar to NumPy\'s `around`. This
            algorithm is fast but inexact and it can easily
            overflow for low precision dtypes.
            Eg. `round(tensor([10000], dtype=torch.float16), decimals=3)` is `inf`.

        .. seealso::
            :func:`torch.ceil`, which rounds up.
            :func:`torch.floor`, which rounds down.
            :func:`torch.trunc`, which rounds towards zero.

        Args:
            input (Tensor): the input tensor.
            decimals (int): Number of decimal places to round to (default: 0).
                If decimals is negative, it specifies the number of positions
                to the left of the decimal point.

        Keyword args:
            out (Tensor, optional): the output tensor.

        Example::

            >>> torch.round(torch.tensor((4.7, -2.3, 9.1, -7.7)))
            tensor([ 5.,  -2.,  9., -8.])

            >>> # Values equidistant from two integers are rounded towards the
            >>> #   the nearest even value (zero is treated as even)
            >>> torch.round(torch.tensor([-0.5, 0.5, 1.5, 2.5]))
            tensor([-0., 0., 2., 2.])

            >>> # A positive decimals argument rounds to the to that decimal place
            >>> torch.round(torch.tensor([0.1234567]), decimals=3)
            tensor([0.1230])

            >>> # A negative decimals argument rounds to the left of the decimal
            >>> torch.round(torch.tensor([1200.1234567]), decimals=-3)
            tensor([1000.])
        '''
    @staticmethod
    def round_(*args, **kwargs): ...
    @staticmethod
    def row_indices_copy(*args, **kwargs): ...
    @staticmethod
    def row_stack(tensors, out=...) -> Tensor:
        """
        row_stack(tensors, *, out=None) -> Tensor

        Alias of :func:`torch.vstack`.
        """
    @staticmethod
    def rrelu(*args, **kwargs): ...
    @staticmethod
    def rrelu_(input, lower=..., upper=..., training=...) -> Tensor:
        """
        rrelu_(input, lower=1./8, upper=1./3, training=False) -> Tensor

        In-place version of :func:`~rrelu`.
        """
    @staticmethod
    def rsqrt(input, out=...) -> Tensor:
        """
        rsqrt(input, *, out=None) -> Tensor

        Returns a new tensor with the reciprocal of the square-root of each of
        the elements of :attr:`input`.

        .. math::
            \\text{out}_{i} = \\frac{1}{\\sqrt{\\text{input}_{i}}}

        Args:
            input (Tensor): the input tensor.

        Keyword args:
            out (Tensor, optional): the output tensor.

        Example::

            >>> a = torch.randn(4)
            >>> a
            tensor([-0.0370,  0.2970,  1.5420, -0.9105])
            >>> torch.rsqrt(a)
            tensor([    nan,  1.8351,  0.8053,     nan])
        """
    @staticmethod
    def rsqrt_(*args, **kwargs): ...
    @staticmethod
    def rsub(*args, **kwargs): ...
    @staticmethod
    def saddmm(*args, **kwargs): ...
    @staticmethod
    def scalar_tensor(*args, **kwargs): ...
    @staticmethod
    def scatter(input, dim, index, src) -> Tensor:
        """
        scatter(input, dim, index, src) -> Tensor

        Out-of-place version of :meth:`torch.Tensor.scatter_`
        """
    @staticmethod
    def scatter_add(input, dim, index, src) -> Tensor:
        """
        scatter_add(input, dim, index, src) -> Tensor

        Out-of-place version of :meth:`torch.Tensor.scatter_add_`
        """
    @staticmethod
    def scatter_reduce(input, dim, index, src, reduce, include_self=...) -> Tensor:
        """
        scatter_reduce(input, dim, index, src, reduce, *, include_self=True) -> Tensor

        Out-of-place version of :meth:`torch.Tensor.scatter_reduce_`
        """
    @overload
    @staticmethod
    def searchsorted(sorted_sequence, values, out_int32=..., right=..., side=..., out=..., sorter=...) -> Tensor:
        '''
        searchsorted(sorted_sequence, values, *, out_int32=False, right=False, side=None, out=None, sorter=None) -> Tensor

        Find the indices from the *innermost* dimension of :attr:`sorted_sequence` such that, if the
        corresponding values in :attr:`values` were inserted before the indices, when sorted, the order
        of the corresponding *innermost* dimension within :attr:`sorted_sequence` would be preserved.
        Return a new tensor with the same size as :attr:`values`. More formally,
        the returned index satisfies the following rules:

        .. list-table::
           :widths: 12 10 78
           :header-rows: 1

           * - :attr:`sorted_sequence`
             - :attr:`right`
             - *returned index satisfies*
           * - 1-D
             - False
             - ``sorted_sequence[i-1] < values[m][n]...[l][x] <= sorted_sequence[i]``
           * - 1-D
             - True
             - ``sorted_sequence[i-1] <= values[m][n]...[l][x] < sorted_sequence[i]``
           * - N-D
             - False
             - ``sorted_sequence[m][n]...[l][i-1] < values[m][n]...[l][x] <= sorted_sequence[m][n]...[l][i]``
           * - N-D
             - True
             - ``sorted_sequence[m][n]...[l][i-1] <= values[m][n]...[l][x] < sorted_sequence[m][n]...[l][i]``

        Args:
            sorted_sequence (Tensor): N-D or 1-D tensor, containing monotonically increasing sequence on the *innermost*
                                      dimension unless :attr:`sorter` is provided, in which case the sequence does not
                                      need to be sorted
            values (Tensor or Scalar): N-D tensor or a Scalar containing the search value(s).

        Keyword args:
            out_int32 (bool, optional): indicate the output data type. torch.int32 if True, torch.int64 otherwise.
                                        Default value is False, i.e. default output data type is torch.int64.
            right (bool, optional): if False, return the first suitable location that is found. If True, return the
                                    last such index. If no suitable index found, return 0 for non-numerical value
                                    (eg. nan, inf) or the size of *innermost* dimension within :attr:`sorted_sequence`
                                    (one pass the last index of the *innermost* dimension). In other words, if False,
                                    gets the lower bound index for each value in :attr:`values` on the corresponding
                                    *innermost* dimension of the :attr:`sorted_sequence`. If True, gets the upper
                                    bound index instead. Default value is False. :attr:`side` does the same and is
                                    preferred. It will error if :attr:`side` is set to "left" while this is True.
            side (str, optional): the same as :attr:`right` but preferred. "left" corresponds to False for :attr:`right`
                                    and "right" corresponds to True for :attr:`right`. It will error if this is set to
                                    "left" while :attr:`right` is True. Default value is None.
            out (Tensor, optional): the output tensor, must be the same size as :attr:`values` if provided.
            sorter (LongTensor, optional): if provided, a tensor matching the shape of the unsorted
                                    :attr:`sorted_sequence` containing a sequence of indices that sort it in the
                                    ascending order on the innermost dimension


        Example::

            >>> sorted_sequence = torch.tensor([[1, 3, 5, 7, 9], [2, 4, 6, 8, 10]])
            >>> sorted_sequence
            tensor([[ 1,  3,  5,  7,  9],
                    [ 2,  4,  6,  8, 10]])
            >>> values = torch.tensor([[3, 6, 9], [3, 6, 9]])
            >>> values
            tensor([[3, 6, 9],
                    [3, 6, 9]])
            >>> torch.searchsorted(sorted_sequence, values)
            tensor([[1, 3, 4],
                    [1, 2, 4]])
            >>> torch.searchsorted(sorted_sequence, values, side=\'right\')
            tensor([[2, 3, 5],
                    [1, 3, 4]])

            >>> sorted_sequence_1d = torch.tensor([1, 3, 5, 7, 9])
            >>> sorted_sequence_1d
            tensor([1, 3, 5, 7, 9])
            >>> torch.searchsorted(sorted_sequence_1d, values)
            tensor([[1, 3, 4],
                    [1, 3, 4]])
        '''
    @overload
    @staticmethod
    def searchsorted(sorted_sequence, values) -> Any:
        '''
        searchsorted(sorted_sequence, values, *, out_int32=False, right=False, side=None, out=None, sorter=None) -> Tensor

        Find the indices from the *innermost* dimension of :attr:`sorted_sequence` such that, if the
        corresponding values in :attr:`values` were inserted before the indices, when sorted, the order
        of the corresponding *innermost* dimension within :attr:`sorted_sequence` would be preserved.
        Return a new tensor with the same size as :attr:`values`. More formally,
        the returned index satisfies the following rules:

        .. list-table::
           :widths: 12 10 78
           :header-rows: 1

           * - :attr:`sorted_sequence`
             - :attr:`right`
             - *returned index satisfies*
           * - 1-D
             - False
             - ``sorted_sequence[i-1] < values[m][n]...[l][x] <= sorted_sequence[i]``
           * - 1-D
             - True
             - ``sorted_sequence[i-1] <= values[m][n]...[l][x] < sorted_sequence[i]``
           * - N-D
             - False
             - ``sorted_sequence[m][n]...[l][i-1] < values[m][n]...[l][x] <= sorted_sequence[m][n]...[l][i]``
           * - N-D
             - True
             - ``sorted_sequence[m][n]...[l][i-1] <= values[m][n]...[l][x] < sorted_sequence[m][n]...[l][i]``

        Args:
            sorted_sequence (Tensor): N-D or 1-D tensor, containing monotonically increasing sequence on the *innermost*
                                      dimension unless :attr:`sorter` is provided, in which case the sequence does not
                                      need to be sorted
            values (Tensor or Scalar): N-D tensor or a Scalar containing the search value(s).

        Keyword args:
            out_int32 (bool, optional): indicate the output data type. torch.int32 if True, torch.int64 otherwise.
                                        Default value is False, i.e. default output data type is torch.int64.
            right (bool, optional): if False, return the first suitable location that is found. If True, return the
                                    last such index. If no suitable index found, return 0 for non-numerical value
                                    (eg. nan, inf) or the size of *innermost* dimension within :attr:`sorted_sequence`
                                    (one pass the last index of the *innermost* dimension). In other words, if False,
                                    gets the lower bound index for each value in :attr:`values` on the corresponding
                                    *innermost* dimension of the :attr:`sorted_sequence`. If True, gets the upper
                                    bound index instead. Default value is False. :attr:`side` does the same and is
                                    preferred. It will error if :attr:`side` is set to "left" while this is True.
            side (str, optional): the same as :attr:`right` but preferred. "left" corresponds to False for :attr:`right`
                                    and "right" corresponds to True for :attr:`right`. It will error if this is set to
                                    "left" while :attr:`right` is True. Default value is None.
            out (Tensor, optional): the output tensor, must be the same size as :attr:`values` if provided.
            sorter (LongTensor, optional): if provided, a tensor matching the shape of the unsorted
                                    :attr:`sorted_sequence` containing a sequence of indices that sort it in the
                                    ascending order on the innermost dimension


        Example::

            >>> sorted_sequence = torch.tensor([[1, 3, 5, 7, 9], [2, 4, 6, 8, 10]])
            >>> sorted_sequence
            tensor([[ 1,  3,  5,  7,  9],
                    [ 2,  4,  6,  8, 10]])
            >>> values = torch.tensor([[3, 6, 9], [3, 6, 9]])
            >>> values
            tensor([[3, 6, 9],
                    [3, 6, 9]])
            >>> torch.searchsorted(sorted_sequence, values)
            tensor([[1, 3, 4],
                    [1, 2, 4]])
            >>> torch.searchsorted(sorted_sequence, values, side=\'right\')
            tensor([[2, 3, 5],
                    [1, 3, 4]])

            >>> sorted_sequence_1d = torch.tensor([1, 3, 5, 7, 9])
            >>> sorted_sequence_1d
            tensor([1, 3, 5, 7, 9])
            >>> torch.searchsorted(sorted_sequence_1d, values)
            tensor([[1, 3, 4],
                    [1, 3, 4]])
        '''
    @overload
    @staticmethod
    def searchsorted(sorted_sequence, values, side=...) -> Any:
        '''
        searchsorted(sorted_sequence, values, *, out_int32=False, right=False, side=None, out=None, sorter=None) -> Tensor

        Find the indices from the *innermost* dimension of :attr:`sorted_sequence` such that, if the
        corresponding values in :attr:`values` were inserted before the indices, when sorted, the order
        of the corresponding *innermost* dimension within :attr:`sorted_sequence` would be preserved.
        Return a new tensor with the same size as :attr:`values`. More formally,
        the returned index satisfies the following rules:

        .. list-table::
           :widths: 12 10 78
           :header-rows: 1

           * - :attr:`sorted_sequence`
             - :attr:`right`
             - *returned index satisfies*
           * - 1-D
             - False
             - ``sorted_sequence[i-1] < values[m][n]...[l][x] <= sorted_sequence[i]``
           * - 1-D
             - True
             - ``sorted_sequence[i-1] <= values[m][n]...[l][x] < sorted_sequence[i]``
           * - N-D
             - False
             - ``sorted_sequence[m][n]...[l][i-1] < values[m][n]...[l][x] <= sorted_sequence[m][n]...[l][i]``
           * - N-D
             - True
             - ``sorted_sequence[m][n]...[l][i-1] <= values[m][n]...[l][x] < sorted_sequence[m][n]...[l][i]``

        Args:
            sorted_sequence (Tensor): N-D or 1-D tensor, containing monotonically increasing sequence on the *innermost*
                                      dimension unless :attr:`sorter` is provided, in which case the sequence does not
                                      need to be sorted
            values (Tensor or Scalar): N-D tensor or a Scalar containing the search value(s).

        Keyword args:
            out_int32 (bool, optional): indicate the output data type. torch.int32 if True, torch.int64 otherwise.
                                        Default value is False, i.e. default output data type is torch.int64.
            right (bool, optional): if False, return the first suitable location that is found. If True, return the
                                    last such index. If no suitable index found, return 0 for non-numerical value
                                    (eg. nan, inf) or the size of *innermost* dimension within :attr:`sorted_sequence`
                                    (one pass the last index of the *innermost* dimension). In other words, if False,
                                    gets the lower bound index for each value in :attr:`values` on the corresponding
                                    *innermost* dimension of the :attr:`sorted_sequence`. If True, gets the upper
                                    bound index instead. Default value is False. :attr:`side` does the same and is
                                    preferred. It will error if :attr:`side` is set to "left" while this is True.
            side (str, optional): the same as :attr:`right` but preferred. "left" corresponds to False for :attr:`right`
                                    and "right" corresponds to True for :attr:`right`. It will error if this is set to
                                    "left" while :attr:`right` is True. Default value is None.
            out (Tensor, optional): the output tensor, must be the same size as :attr:`values` if provided.
            sorter (LongTensor, optional): if provided, a tensor matching the shape of the unsorted
                                    :attr:`sorted_sequence` containing a sequence of indices that sort it in the
                                    ascending order on the innermost dimension


        Example::

            >>> sorted_sequence = torch.tensor([[1, 3, 5, 7, 9], [2, 4, 6, 8, 10]])
            >>> sorted_sequence
            tensor([[ 1,  3,  5,  7,  9],
                    [ 2,  4,  6,  8, 10]])
            >>> values = torch.tensor([[3, 6, 9], [3, 6, 9]])
            >>> values
            tensor([[3, 6, 9],
                    [3, 6, 9]])
            >>> torch.searchsorted(sorted_sequence, values)
            tensor([[1, 3, 4],
                    [1, 2, 4]])
            >>> torch.searchsorted(sorted_sequence, values, side=\'right\')
            tensor([[2, 3, 5],
                    [1, 3, 4]])

            >>> sorted_sequence_1d = torch.tensor([1, 3, 5, 7, 9])
            >>> sorted_sequence_1d
            tensor([1, 3, 5, 7, 9])
            >>> torch.searchsorted(sorted_sequence_1d, values)
            tensor([[1, 3, 4],
                    [1, 3, 4]])
        '''
    @overload
    @staticmethod
    def searchsorted(sorted_sequence_1d, values) -> Any:
        '''
        searchsorted(sorted_sequence, values, *, out_int32=False, right=False, side=None, out=None, sorter=None) -> Tensor

        Find the indices from the *innermost* dimension of :attr:`sorted_sequence` such that, if the
        corresponding values in :attr:`values` were inserted before the indices, when sorted, the order
        of the corresponding *innermost* dimension within :attr:`sorted_sequence` would be preserved.
        Return a new tensor with the same size as :attr:`values`. More formally,
        the returned index satisfies the following rules:

        .. list-table::
           :widths: 12 10 78
           :header-rows: 1

           * - :attr:`sorted_sequence`
             - :attr:`right`
             - *returned index satisfies*
           * - 1-D
             - False
             - ``sorted_sequence[i-1] < values[m][n]...[l][x] <= sorted_sequence[i]``
           * - 1-D
             - True
             - ``sorted_sequence[i-1] <= values[m][n]...[l][x] < sorted_sequence[i]``
           * - N-D
             - False
             - ``sorted_sequence[m][n]...[l][i-1] < values[m][n]...[l][x] <= sorted_sequence[m][n]...[l][i]``
           * - N-D
             - True
             - ``sorted_sequence[m][n]...[l][i-1] <= values[m][n]...[l][x] < sorted_sequence[m][n]...[l][i]``

        Args:
            sorted_sequence (Tensor): N-D or 1-D tensor, containing monotonically increasing sequence on the *innermost*
                                      dimension unless :attr:`sorter` is provided, in which case the sequence does not
                                      need to be sorted
            values (Tensor or Scalar): N-D tensor or a Scalar containing the search value(s).

        Keyword args:
            out_int32 (bool, optional): indicate the output data type. torch.int32 if True, torch.int64 otherwise.
                                        Default value is False, i.e. default output data type is torch.int64.
            right (bool, optional): if False, return the first suitable location that is found. If True, return the
                                    last such index. If no suitable index found, return 0 for non-numerical value
                                    (eg. nan, inf) or the size of *innermost* dimension within :attr:`sorted_sequence`
                                    (one pass the last index of the *innermost* dimension). In other words, if False,
                                    gets the lower bound index for each value in :attr:`values` on the corresponding
                                    *innermost* dimension of the :attr:`sorted_sequence`. If True, gets the upper
                                    bound index instead. Default value is False. :attr:`side` does the same and is
                                    preferred. It will error if :attr:`side` is set to "left" while this is True.
            side (str, optional): the same as :attr:`right` but preferred. "left" corresponds to False for :attr:`right`
                                    and "right" corresponds to True for :attr:`right`. It will error if this is set to
                                    "left" while :attr:`right` is True. Default value is None.
            out (Tensor, optional): the output tensor, must be the same size as :attr:`values` if provided.
            sorter (LongTensor, optional): if provided, a tensor matching the shape of the unsorted
                                    :attr:`sorted_sequence` containing a sequence of indices that sort it in the
                                    ascending order on the innermost dimension


        Example::

            >>> sorted_sequence = torch.tensor([[1, 3, 5, 7, 9], [2, 4, 6, 8, 10]])
            >>> sorted_sequence
            tensor([[ 1,  3,  5,  7,  9],
                    [ 2,  4,  6,  8, 10]])
            >>> values = torch.tensor([[3, 6, 9], [3, 6, 9]])
            >>> values
            tensor([[3, 6, 9],
                    [3, 6, 9]])
            >>> torch.searchsorted(sorted_sequence, values)
            tensor([[1, 3, 4],
                    [1, 2, 4]])
            >>> torch.searchsorted(sorted_sequence, values, side=\'right\')
            tensor([[2, 3, 5],
                    [1, 3, 4]])

            >>> sorted_sequence_1d = torch.tensor([1, 3, 5, 7, 9])
            >>> sorted_sequence_1d
            tensor([1, 3, 5, 7, 9])
            >>> torch.searchsorted(sorted_sequence_1d, values)
            tensor([[1, 3, 4],
                    [1, 3, 4]])
        '''
    @staticmethod
    def segment_reduce(*args, **kwargs): ...
    @staticmethod
    def select(input, dim, index) -> Tensor:
        """
        select(input, dim, index) -> Tensor

        Slices the :attr:`input` tensor along the selected dimension at the given index.
        This function returns a view of the original tensor with the given dimension removed.

        .. note:: If :attr:`input` is a sparse tensor and returning a view of
                  the tensor is not possible, a RuntimeError exception is
                  raised. In this is the case, consider using
                  :func:`torch.select_copy` function.

        Args:
            input (Tensor): the input tensor.
            dim (int): the dimension to slice
            index (int): the index to select with

        .. note::

            :meth:`select` is equivalent to slicing. For example,
            ``tensor.select(0, index)`` is equivalent to ``tensor[index]`` and
            ``tensor.select(2, index)`` is equivalent to ``tensor[:,:,index]``.
        """
    @staticmethod
    def select_copy(*args, **kwargs):
        """
        Performs the same operation as :func:`torch.select`, but all output tensors
        are freshly created instead of aliasing the input.
        """
    @staticmethod
    def select_scatter(input, src, dim, index) -> Tensor:
        """
        select_scatter(input, src, dim, index) -> Tensor

        Embeds the values of the :attr:`src` tensor into :attr:`input` at the given index.
        This function returns a tensor with fresh storage; it does not create a view.


        Args:
            input (Tensor): the input tensor.
            src (Tensor): The tensor to embed into :attr:`input`
            dim (int): the dimension to insert the slice into.
            index (int): the index to select with

        .. note::

            :attr:`src` must be of the proper size in order to be embedded
            into :attr:`input`. Specifically, it should have the same shape as
            ``torch.select(input, dim, index)``

        Example::

            >>> a = torch.zeros(2, 2)
            >>> b = torch.ones(2)
            >>> a.select_scatter(b, 0, 0)
            tensor([[1., 1.],
                    [0., 0.]])
        """
    @staticmethod
    def selu(*args, **kwargs): ...
    @staticmethod
    def selu_(input) -> Tensor:
        """
        selu_(input) -> Tensor

        In-place version of :func:`~selu`.
        """
    @staticmethod
    def sgn(input, out=...) -> Tensor:
        """
        sgn(input, *, out=None) -> Tensor

        This function is an extension of torch.sign() to complex tensors.
        It computes a new tensor whose elements have
        the same angles as the corresponding elements of :attr:`input` and
        absolute values (i.e. magnitudes) of one for complex tensors and
        is equivalent to torch.sign() for non-complex tensors.

        .. math::
            \\text{out}_{i} = \\begin{cases}
                            0 & |\\text{{input}}_i| == 0 \\\\\n                            \\frac{{\\text{{input}}_i}}{|{\\text{{input}}_i}|} & \\text{otherwise}
                            \\end{cases}


        Args:
            input (Tensor): the input tensor.

        Keyword args:
          out (Tensor, optional): the output tensor.

        Example::

            >>> t = torch.tensor([3+4j, 7-24j, 0, 1+2j])
            >>> t.sgn()
            tensor([0.6000+0.8000j, 0.2800-0.9600j, 0.0000+0.0000j, 0.4472+0.8944j])
        """
    @staticmethod
    def sigmoid(input, out=...) -> Tensor:
        """
        sigmoid(input, *, out=None) -> Tensor

        Alias for :func:`torch.special.expit`.
        """
    @staticmethod
    def sigmoid_(*args, **kwargs): ...
    @staticmethod
    def sign(input, out=...) -> Tensor:
        """
        sign(input, *, out=None) -> Tensor

        Returns a new tensor with the signs of the elements of :attr:`input`.

        .. math::
            \\text{out}_{i} = \\operatorname{sgn}(\\text{input}_{i})

        Args:
            input (Tensor): the input tensor.

        Keyword args:
            out (Tensor, optional): the output tensor.

        Example::

            >>> a = torch.tensor([0.7, -1.2, 0., 2.3])
            >>> a
            tensor([ 0.7000, -1.2000,  0.0000,  2.3000])
            >>> torch.sign(a)
            tensor([ 1., -1.,  0.,  1.])
        """
    @overload
    @staticmethod
    def signbit(input, out=...) -> Tensor:
        """
        signbit(input, *, out=None) -> Tensor

        Tests if each element of :attr:`input` has its sign bit set or not.

        Args:
          input (Tensor): the input tensor.

        Keyword args:
          out (Tensor, optional): the output tensor.

        Example::

            >>> a = torch.tensor([0.7, -1.2, 0., 2.3])
            >>> torch.signbit(a)
            tensor([ False, True,  False,  False])
            >>> a = torch.tensor([-0.0, 0.0])
            >>> torch.signbit(a)
            tensor([ True,  False])

        .. note::
            signbit handles signed zeros, so negative zero (-0) returns True.

        """
    @overload
    @staticmethod
    def signbit(a) -> Any:
        """
        signbit(input, *, out=None) -> Tensor

        Tests if each element of :attr:`input` has its sign bit set or not.

        Args:
          input (Tensor): the input tensor.

        Keyword args:
          out (Tensor, optional): the output tensor.

        Example::

            >>> a = torch.tensor([0.7, -1.2, 0., 2.3])
            >>> torch.signbit(a)
            tensor([ False, True,  False,  False])
            >>> a = torch.tensor([-0.0, 0.0])
            >>> torch.signbit(a)
            tensor([ True,  False])

        .. note::
            signbit handles signed zeros, so negative zero (-0) returns True.

        """
    @overload
    @staticmethod
    def signbit(a) -> Any:
        """
        signbit(input, *, out=None) -> Tensor

        Tests if each element of :attr:`input` has its sign bit set or not.

        Args:
          input (Tensor): the input tensor.

        Keyword args:
          out (Tensor, optional): the output tensor.

        Example::

            >>> a = torch.tensor([0.7, -1.2, 0., 2.3])
            >>> torch.signbit(a)
            tensor([ False, True,  False,  False])
            >>> a = torch.tensor([-0.0, 0.0])
            >>> torch.signbit(a)
            tensor([ True,  False])

        .. note::
            signbit handles signed zeros, so negative zero (-0) returns True.

        """
    @staticmethod
    def sin(input, out=...) -> Tensor:
        """
        sin(input, *, out=None) -> Tensor

        Returns a new tensor with the sine of the elements of :attr:`input`.

        .. math::
            \\text{out}_{i} = \\sin(\\text{input}_{i})

        Args:
            input (Tensor): the input tensor.

        Keyword args:
            out (Tensor, optional): the output tensor.

        Example::

            >>> a = torch.randn(4)
            >>> a
            tensor([-0.5461,  0.1347, -2.7266, -0.2746])
            >>> torch.sin(a)
            tensor([-0.5194,  0.1343, -0.4032, -0.2711])
        """
    @staticmethod
    def sin_(*args, **kwargs): ...
    @staticmethod
    def sinc(input, out=...) -> Tensor:
        """
        sinc(input, *, out=None) -> Tensor

        Alias for :func:`torch.special.sinc`.
        """
    @staticmethod
    def sinc_(*args, **kwargs): ...
    @staticmethod
    def sinh(input, out=...) -> Tensor:
        """
        sinh(input, *, out=None) -> Tensor

        Returns a new tensor with the hyperbolic sine of the elements of
        :attr:`input`.

        .. math::
            \\text{out}_{i} = \\sinh(\\text{input}_{i})

        Args:
            input (Tensor): the input tensor.

        Keyword args:
            out (Tensor, optional): the output tensor.

        Example::

            >>> a = torch.randn(4)
            >>> a
            tensor([ 0.5380, -0.8632, -0.1265,  0.9399])
            >>> torch.sinh(a)
            tensor([ 0.5644, -0.9744, -0.1268,  1.0845])

        .. note::
           When :attr:`input` is on the CPU, the implementation of torch.sinh may use
           the Sleef library, which rounds very large results to infinity or negative
           infinity. See `here <https://sleef.org/purec.xhtml>`_ for details.
        """
    @staticmethod
    def sinh_(*args, **kwargs): ...
    @staticmethod
    def slice_copy(*args, **kwargs):
        """
        Performs the same operation as :func:`torch.slice`, but all output tensors
        are freshly created instead of aliasing the input.
        """
    @staticmethod
    def slice_inverse(*args, **kwargs): ...
    @overload
    @staticmethod
    def slice_scatter(input, src, dim=..., start=..., end=..., step=...) -> Tensor:
        """
        slice_scatter(input, src, dim=0, start=None, end=None, step=1) -> Tensor

        Embeds the values of the :attr:`src` tensor into :attr:`input` at the given
        dimension.
        This function returns a tensor with fresh storage; it does not create a view.


        Args:
            input (Tensor): the input tensor.
            src (Tensor): The tensor to embed into :attr:`input`
            dim (int): the dimension to insert the slice into
            start (Optional[int]): the start index of where to insert the slice
            end (Optional[int]): the end index of where to insert the slice
            step (int): the how many elements to skip in

        Example::

            >>> a = torch.zeros(8, 8)
            >>> b = torch.ones(2, 8)
            >>> a.slice_scatter(b, start=6)
            tensor([[0., 0., 0., 0., 0., 0., 0., 0.],
                    [0., 0., 0., 0., 0., 0., 0., 0.],
                    [0., 0., 0., 0., 0., 0., 0., 0.],
                    [0., 0., 0., 0., 0., 0., 0., 0.],
                    [0., 0., 0., 0., 0., 0., 0., 0.],
                    [0., 0., 0., 0., 0., 0., 0., 0.],
                    [1., 1., 1., 1., 1., 1., 1., 1.],
                    [1., 1., 1., 1., 1., 1., 1., 1.]])

            >>> b = torch.ones(8, 2)
            >>> a.slice_scatter(b, dim=1, start=2, end=6, step=2)
            tensor([[0., 0., 1., 0., 1., 0., 0., 0.],
                    [0., 0., 1., 0., 1., 0., 0., 0.],
                    [0., 0., 1., 0., 1., 0., 0., 0.],
                    [0., 0., 1., 0., 1., 0., 0., 0.],
                    [0., 0., 1., 0., 1., 0., 0., 0.],
                    [0., 0., 1., 0., 1., 0., 0., 0.],
                    [0., 0., 1., 0., 1., 0., 0., 0.],
                    [0., 0., 1., 0., 1., 0., 0., 0.]])
        """
    @overload
    @staticmethod
    def slice_scatter(b, start=...) -> Any:
        """
        slice_scatter(input, src, dim=0, start=None, end=None, step=1) -> Tensor

        Embeds the values of the :attr:`src` tensor into :attr:`input` at the given
        dimension.
        This function returns a tensor with fresh storage; it does not create a view.


        Args:
            input (Tensor): the input tensor.
            src (Tensor): The tensor to embed into :attr:`input`
            dim (int): the dimension to insert the slice into
            start (Optional[int]): the start index of where to insert the slice
            end (Optional[int]): the end index of where to insert the slice
            step (int): the how many elements to skip in

        Example::

            >>> a = torch.zeros(8, 8)
            >>> b = torch.ones(2, 8)
            >>> a.slice_scatter(b, start=6)
            tensor([[0., 0., 0., 0., 0., 0., 0., 0.],
                    [0., 0., 0., 0., 0., 0., 0., 0.],
                    [0., 0., 0., 0., 0., 0., 0., 0.],
                    [0., 0., 0., 0., 0., 0., 0., 0.],
                    [0., 0., 0., 0., 0., 0., 0., 0.],
                    [0., 0., 0., 0., 0., 0., 0., 0.],
                    [1., 1., 1., 1., 1., 1., 1., 1.],
                    [1., 1., 1., 1., 1., 1., 1., 1.]])

            >>> b = torch.ones(8, 2)
            >>> a.slice_scatter(b, dim=1, start=2, end=6, step=2)
            tensor([[0., 0., 1., 0., 1., 0., 0., 0.],
                    [0., 0., 1., 0., 1., 0., 0., 0.],
                    [0., 0., 1., 0., 1., 0., 0., 0.],
                    [0., 0., 1., 0., 1., 0., 0., 0.],
                    [0., 0., 1., 0., 1., 0., 0., 0.],
                    [0., 0., 1., 0., 1., 0., 0., 0.],
                    [0., 0., 1., 0., 1., 0., 0., 0.],
                    [0., 0., 1., 0., 1., 0., 0., 0.]])
        """
    @overload
    @staticmethod
    def slice_scatter(b, dim=..., start=..., end=..., step=...) -> Any:
        """
        slice_scatter(input, src, dim=0, start=None, end=None, step=1) -> Tensor

        Embeds the values of the :attr:`src` tensor into :attr:`input` at the given
        dimension.
        This function returns a tensor with fresh storage; it does not create a view.


        Args:
            input (Tensor): the input tensor.
            src (Tensor): The tensor to embed into :attr:`input`
            dim (int): the dimension to insert the slice into
            start (Optional[int]): the start index of where to insert the slice
            end (Optional[int]): the end index of where to insert the slice
            step (int): the how many elements to skip in

        Example::

            >>> a = torch.zeros(8, 8)
            >>> b = torch.ones(2, 8)
            >>> a.slice_scatter(b, start=6)
            tensor([[0., 0., 0., 0., 0., 0., 0., 0.],
                    [0., 0., 0., 0., 0., 0., 0., 0.],
                    [0., 0., 0., 0., 0., 0., 0., 0.],
                    [0., 0., 0., 0., 0., 0., 0., 0.],
                    [0., 0., 0., 0., 0., 0., 0., 0.],
                    [0., 0., 0., 0., 0., 0., 0., 0.],
                    [1., 1., 1., 1., 1., 1., 1., 1.],
                    [1., 1., 1., 1., 1., 1., 1., 1.]])

            >>> b = torch.ones(8, 2)
            >>> a.slice_scatter(b, dim=1, start=2, end=6, step=2)
            tensor([[0., 0., 1., 0., 1., 0., 0., 0.],
                    [0., 0., 1., 0., 1., 0., 0., 0.],
                    [0., 0., 1., 0., 1., 0., 0., 0.],
                    [0., 0., 1., 0., 1., 0., 0., 0.],
                    [0., 0., 1., 0., 1., 0., 0., 0.],
                    [0., 0., 1., 0., 1., 0., 0., 0.],
                    [0., 0., 1., 0., 1., 0., 0., 0.],
                    [0., 0., 1., 0., 1., 0., 0., 0.]])
        """
    @staticmethod
    def slogdet(*args, **kwargs):
        """
        slogdet(input) -> (Tensor, Tensor)

        Alias for :func:`torch.linalg.slogdet`
        """
    @staticmethod
    def smm(input, mat) -> Tensor:
        """
        smm(input, mat) -> Tensor

        Performs a matrix multiplication of the sparse matrix :attr:`input`
        with the dense matrix :attr:`mat`.

        Args:
            input (Tensor): a sparse matrix to be matrix multiplied
            mat (Tensor): a dense matrix to be matrix multiplied
        """
    @staticmethod
    def softmax(input, dim, dtype=...) -> Tensor:
        """
        softmax(input, dim, *, dtype=None) -> Tensor

        Alias for :func:`torch.nn.functional.softmax`.
        """
    @overload
    @staticmethod
    def sort(x) -> Any:
        """
        sort(input, dim=-1, descending=False, stable=False, *, out=None) -> (Tensor, LongTensor)

        Sorts the elements of the :attr:`input` tensor along a given dimension
        in ascending order by value.

        If :attr:`dim` is not given, the last dimension of the `input` is chosen.

        If :attr:`descending` is ``True`` then the elements are sorted in descending
        order by value.

        If :attr:`stable` is ``True`` then the sorting routine becomes stable, preserving
        the order of equivalent elements.

        A namedtuple of (values, indices) is returned, where the `values` are the
        sorted values and `indices` are the indices of the elements in the original
        `input` tensor.

        Args:
            input (Tensor): the input tensor.
            dim (int, optional): the dimension to sort along
            descending (bool, optional): controls the sorting order (ascending or descending)
            stable (bool, optional): makes the sorting routine stable, which guarantees that the order
               of equivalent elements is preserved.

        Keyword args:
            out (tuple, optional): the output tuple of (`Tensor`, `LongTensor`) that can
                be optionally given to be used as output buffers

        Example::

            >>> x = torch.randn(3, 4)
            >>> sorted, indices = torch.sort(x)
            >>> sorted
            tensor([[-0.2162,  0.0608,  0.6719,  2.3332],
                    [-0.5793,  0.0061,  0.6058,  0.9497],
                    [-0.5071,  0.3343,  0.9553,  1.0960]])
            >>> indices
            tensor([[ 1,  0,  2,  3],
                    [ 3,  1,  0,  2],
                    [ 0,  3,  1,  2]])

            >>> sorted, indices = torch.sort(x, 0)
            >>> sorted
            tensor([[-0.5071, -0.2162,  0.6719, -0.5793],
                    [ 0.0608,  0.0061,  0.9497,  0.3343],
                    [ 0.6058,  0.9553,  1.0960,  2.3332]])
            >>> indices
            tensor([[ 2,  0,  0,  1],
                    [ 0,  1,  1,  2],
                    [ 1,  2,  2,  0]])
            >>> x = torch.tensor([0, 1] * 9)
            >>> x.sort()
            torch.return_types.sort(
                values=tensor([0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1]),
                indices=tensor([ 2, 16,  4,  6, 14,  8,  0, 10, 12,  9, 17, 15, 13, 11,  7,  5,  3,  1]))
            >>> x.sort(stable=True)
            torch.return_types.sort(
                values=tensor([0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1]),
                indices=tensor([ 0,  2,  4,  6,  8, 10, 12, 14, 16,  1,  3,  5,  7,  9, 11, 13, 15, 17]))
        """
    @overload
    @staticmethod
    def sort() -> Any:
        """
        sort(input, dim=-1, descending=False, stable=False, *, out=None) -> (Tensor, LongTensor)

        Sorts the elements of the :attr:`input` tensor along a given dimension
        in ascending order by value.

        If :attr:`dim` is not given, the last dimension of the `input` is chosen.

        If :attr:`descending` is ``True`` then the elements are sorted in descending
        order by value.

        If :attr:`stable` is ``True`` then the sorting routine becomes stable, preserving
        the order of equivalent elements.

        A namedtuple of (values, indices) is returned, where the `values` are the
        sorted values and `indices` are the indices of the elements in the original
        `input` tensor.

        Args:
            input (Tensor): the input tensor.
            dim (int, optional): the dimension to sort along
            descending (bool, optional): controls the sorting order (ascending or descending)
            stable (bool, optional): makes the sorting routine stable, which guarantees that the order
               of equivalent elements is preserved.

        Keyword args:
            out (tuple, optional): the output tuple of (`Tensor`, `LongTensor`) that can
                be optionally given to be used as output buffers

        Example::

            >>> x = torch.randn(3, 4)
            >>> sorted, indices = torch.sort(x)
            >>> sorted
            tensor([[-0.2162,  0.0608,  0.6719,  2.3332],
                    [-0.5793,  0.0061,  0.6058,  0.9497],
                    [-0.5071,  0.3343,  0.9553,  1.0960]])
            >>> indices
            tensor([[ 1,  0,  2,  3],
                    [ 3,  1,  0,  2],
                    [ 0,  3,  1,  2]])

            >>> sorted, indices = torch.sort(x, 0)
            >>> sorted
            tensor([[-0.5071, -0.2162,  0.6719, -0.5793],
                    [ 0.0608,  0.0061,  0.9497,  0.3343],
                    [ 0.6058,  0.9553,  1.0960,  2.3332]])
            >>> indices
            tensor([[ 2,  0,  0,  1],
                    [ 0,  1,  1,  2],
                    [ 1,  2,  2,  0]])
            >>> x = torch.tensor([0, 1] * 9)
            >>> x.sort()
            torch.return_types.sort(
                values=tensor([0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1]),
                indices=tensor([ 2, 16,  4,  6, 14,  8,  0, 10, 12,  9, 17, 15, 13, 11,  7,  5,  3,  1]))
            >>> x.sort(stable=True)
            torch.return_types.sort(
                values=tensor([0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1]),
                indices=tensor([ 0,  2,  4,  6,  8, 10, 12, 14, 16,  1,  3,  5,  7,  9, 11, 13, 15, 17]))
        """
    @overload
    @staticmethod
    def sort(
values=..., 
indices=...) -> Any:
        """
        sort(input, dim=-1, descending=False, stable=False, *, out=None) -> (Tensor, LongTensor)

        Sorts the elements of the :attr:`input` tensor along a given dimension
        in ascending order by value.

        If :attr:`dim` is not given, the last dimension of the `input` is chosen.

        If :attr:`descending` is ``True`` then the elements are sorted in descending
        order by value.

        If :attr:`stable` is ``True`` then the sorting routine becomes stable, preserving
        the order of equivalent elements.

        A namedtuple of (values, indices) is returned, where the `values` are the
        sorted values and `indices` are the indices of the elements in the original
        `input` tensor.

        Args:
            input (Tensor): the input tensor.
            dim (int, optional): the dimension to sort along
            descending (bool, optional): controls the sorting order (ascending or descending)
            stable (bool, optional): makes the sorting routine stable, which guarantees that the order
               of equivalent elements is preserved.

        Keyword args:
            out (tuple, optional): the output tuple of (`Tensor`, `LongTensor`) that can
                be optionally given to be used as output buffers

        Example::

            >>> x = torch.randn(3, 4)
            >>> sorted, indices = torch.sort(x)
            >>> sorted
            tensor([[-0.2162,  0.0608,  0.6719,  2.3332],
                    [-0.5793,  0.0061,  0.6058,  0.9497],
                    [-0.5071,  0.3343,  0.9553,  1.0960]])
            >>> indices
            tensor([[ 1,  0,  2,  3],
                    [ 3,  1,  0,  2],
                    [ 0,  3,  1,  2]])

            >>> sorted, indices = torch.sort(x, 0)
            >>> sorted
            tensor([[-0.5071, -0.2162,  0.6719, -0.5793],
                    [ 0.0608,  0.0061,  0.9497,  0.3343],
                    [ 0.6058,  0.9553,  1.0960,  2.3332]])
            >>> indices
            tensor([[ 2,  0,  0,  1],
                    [ 0,  1,  1,  2],
                    [ 1,  2,  2,  0]])
            >>> x = torch.tensor([0, 1] * 9)
            >>> x.sort()
            torch.return_types.sort(
                values=tensor([0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1]),
                indices=tensor([ 2, 16,  4,  6, 14,  8,  0, 10, 12,  9, 17, 15, 13, 11,  7,  5,  3,  1]))
            >>> x.sort(stable=True)
            torch.return_types.sort(
                values=tensor([0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1]),
                indices=tensor([ 0,  2,  4,  6,  8, 10, 12, 14, 16,  1,  3,  5,  7,  9, 11, 13, 15, 17]))
        """
    @overload
    @staticmethod
    def sort(stable=...) -> Any:
        """
        sort(input, dim=-1, descending=False, stable=False, *, out=None) -> (Tensor, LongTensor)

        Sorts the elements of the :attr:`input` tensor along a given dimension
        in ascending order by value.

        If :attr:`dim` is not given, the last dimension of the `input` is chosen.

        If :attr:`descending` is ``True`` then the elements are sorted in descending
        order by value.

        If :attr:`stable` is ``True`` then the sorting routine becomes stable, preserving
        the order of equivalent elements.

        A namedtuple of (values, indices) is returned, where the `values` are the
        sorted values and `indices` are the indices of the elements in the original
        `input` tensor.

        Args:
            input (Tensor): the input tensor.
            dim (int, optional): the dimension to sort along
            descending (bool, optional): controls the sorting order (ascending or descending)
            stable (bool, optional): makes the sorting routine stable, which guarantees that the order
               of equivalent elements is preserved.

        Keyword args:
            out (tuple, optional): the output tuple of (`Tensor`, `LongTensor`) that can
                be optionally given to be used as output buffers

        Example::

            >>> x = torch.randn(3, 4)
            >>> sorted, indices = torch.sort(x)
            >>> sorted
            tensor([[-0.2162,  0.0608,  0.6719,  2.3332],
                    [-0.5793,  0.0061,  0.6058,  0.9497],
                    [-0.5071,  0.3343,  0.9553,  1.0960]])
            >>> indices
            tensor([[ 1,  0,  2,  3],
                    [ 3,  1,  0,  2],
                    [ 0,  3,  1,  2]])

            >>> sorted, indices = torch.sort(x, 0)
            >>> sorted
            tensor([[-0.5071, -0.2162,  0.6719, -0.5793],
                    [ 0.0608,  0.0061,  0.9497,  0.3343],
                    [ 0.6058,  0.9553,  1.0960,  2.3332]])
            >>> indices
            tensor([[ 2,  0,  0,  1],
                    [ 0,  1,  1,  2],
                    [ 1,  2,  2,  0]])
            >>> x = torch.tensor([0, 1] * 9)
            >>> x.sort()
            torch.return_types.sort(
                values=tensor([0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1]),
                indices=tensor([ 2, 16,  4,  6, 14,  8,  0, 10, 12,  9, 17, 15, 13, 11,  7,  5,  3,  1]))
            >>> x.sort(stable=True)
            torch.return_types.sort(
                values=tensor([0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1]),
                indices=tensor([ 0,  2,  4,  6,  8, 10, 12, 14, 16,  1,  3,  5,  7,  9, 11, 13, 15, 17]))
        """
    @overload
    @staticmethod
    def sort(
values=..., 
indices=...) -> Any:
        """
        sort(input, dim=-1, descending=False, stable=False, *, out=None) -> (Tensor, LongTensor)

        Sorts the elements of the :attr:`input` tensor along a given dimension
        in ascending order by value.

        If :attr:`dim` is not given, the last dimension of the `input` is chosen.

        If :attr:`descending` is ``True`` then the elements are sorted in descending
        order by value.

        If :attr:`stable` is ``True`` then the sorting routine becomes stable, preserving
        the order of equivalent elements.

        A namedtuple of (values, indices) is returned, where the `values` are the
        sorted values and `indices` are the indices of the elements in the original
        `input` tensor.

        Args:
            input (Tensor): the input tensor.
            dim (int, optional): the dimension to sort along
            descending (bool, optional): controls the sorting order (ascending or descending)
            stable (bool, optional): makes the sorting routine stable, which guarantees that the order
               of equivalent elements is preserved.

        Keyword args:
            out (tuple, optional): the output tuple of (`Tensor`, `LongTensor`) that can
                be optionally given to be used as output buffers

        Example::

            >>> x = torch.randn(3, 4)
            >>> sorted, indices = torch.sort(x)
            >>> sorted
            tensor([[-0.2162,  0.0608,  0.6719,  2.3332],
                    [-0.5793,  0.0061,  0.6058,  0.9497],
                    [-0.5071,  0.3343,  0.9553,  1.0960]])
            >>> indices
            tensor([[ 1,  0,  2,  3],
                    [ 3,  1,  0,  2],
                    [ 0,  3,  1,  2]])

            >>> sorted, indices = torch.sort(x, 0)
            >>> sorted
            tensor([[-0.5071, -0.2162,  0.6719, -0.5793],
                    [ 0.0608,  0.0061,  0.9497,  0.3343],
                    [ 0.6058,  0.9553,  1.0960,  2.3332]])
            >>> indices
            tensor([[ 2,  0,  0,  1],
                    [ 0,  1,  1,  2],
                    [ 1,  2,  2,  0]])
            >>> x = torch.tensor([0, 1] * 9)
            >>> x.sort()
            torch.return_types.sort(
                values=tensor([0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1]),
                indices=tensor([ 2, 16,  4,  6, 14,  8,  0, 10, 12,  9, 17, 15, 13, 11,  7,  5,  3,  1]))
            >>> x.sort(stable=True)
            torch.return_types.sort(
                values=tensor([0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1]),
                indices=tensor([ 0,  2,  4,  6,  8, 10, 12, 14, 16,  1,  3,  5,  7,  9, 11, 13, 15, 17]))
        """
    @staticmethod
    def sparse_bsc_tensor(ccol_indices, row_indices, values, size=..., dtype=..., device=..., pin_memory=..., requires_grad=..., check_invariants=...) -> Tensor:
        """sparse_bsc_tensor(ccol_indices, row_indices, values, size=None, *, dtype=None, device=None, pin_memory=False, requires_grad=False, check_invariants=None) -> Tensor

        Constructs a :ref:`sparse tensor in BSC (Block Compressed Sparse
        Column)) <sparse-bsc-docs>` with specified 2-dimensional blocks at the
        given :attr:`ccol_indices` and :attr:`row_indices`. Sparse matrix
        multiplication operations in BSC format are typically faster than that
        for sparse tensors in COO format. Make you have a look at :ref:`the
        note on the data type of the indices <sparse-bsc-docs>`.

        .. note::

           If the ``device`` argument is not specified the device of the given
           :attr:`values` and indices tensor(s) must match. If, however, the
           argument is specified the input Tensors will be converted to the
           given device and in turn determine the device of the constructed
           sparse tensor.

        Args:
            ccol_indices (array_like): (B+1)-dimensional array of size
                ``(*batchsize, ncolblocks + 1)``. The last element of each
                batch is the number of non-zeros. This tensor encodes the
                index in values and row_indices depending on where the given
                column starts. Each successive number in the tensor subtracted
                by the number before it denotes the number of elements in a
                given column.
            row_indices (array_like): Row block co-ordinates of each block in
                values. (B+1)-dimensional tensor with the same length
                as values.
            values (array_list): Initial blocks for the tensor. Can be a list,
                tuple, NumPy ``ndarray``, and other types that
                represents a (1 + 2 + K)-dimensional tensor where ``K`` is the
                number of dense dimensions.
            size (list, tuple, :class:`torch.Size`, optional): Size of the
                sparse tensor: ``(*batchsize, nrows * blocksize[0], ncols *
                blocksize[1], *densesize)`` If not provided, the size will be
                inferred as the minimum size big enough to hold all non-zero
                blocks.

        Keyword args:
            dtype (:class:`torch.dtype`, optional): the desired data type of
                returned tensor.  Default: if None, infers data type from
                :attr:`values`.
            device (:class:`torch.device`, optional): the desired device of
                returned tensor.  Default: if None, uses the current device
                for the default tensor type (see
                :func:`torch.set_default_device`). :attr:`device` will be
                the CPU for CPU tensor types and the current CUDA device for
                CUDA tensor types.
            pin_memory (bool, optional): If set, returned tensor would be allocated in
                the pinned memory. Works only for CPU tensors. Default: ``False``.
            requires_grad (bool, optional): If autograd should record operations on the
                returned tensor. Default: ``False``.
            check_invariants (bool, optional): If sparse tensor invariants are checked.
                Default: as returned by :func:`torch.sparse.check_sparse_tensor_invariants.is_enabled`,
                initially False.

        Example::

            >>> ccol_indices = [0, 1, 2]
            >>> row_indices = [0, 1]
            >>> values = [[[1, 2], [3, 4]], [[5, 6], [7, 8]]]
            >>> torch.sparse_bsc_tensor(torch.tensor(ccol_indices, dtype=torch.int64),
            ...                         torch.tensor(row_indices, dtype=torch.int64),
            ...                         torch.tensor(values), dtype=torch.double)
            tensor(ccol_indices=tensor([0, 1, 2]),
                   row_indices=tensor([0, 1]),
                   values=tensor([[[1., 2.],
                                   [3., 4.]],
                                  [[5., 6.],
                                   [7., 8.]]]), size=(2, 2), nnz=2, dtype=torch.float64,
                   layout=torch.sparse_bsc)
        """
    @staticmethod
    def sparse_bsr_tensor(crow_indices, col_indices, values, size=..., dtype=..., device=..., pin_memory=..., requires_grad=..., check_invariants=...) -> Tensor:
        """sparse_bsr_tensor(crow_indices, col_indices, values, size=None, *, dtype=None, device=None, pin_memory=False, requires_grad=False, check_invariants=None) -> Tensor

        Constructs a :ref:`sparse tensor in BSR (Block Compressed Sparse Row))
        <sparse-bsr-docs>` with specified 2-dimensional blocks at the given
        :attr:`crow_indices` and :attr:`col_indices`. Sparse matrix
        multiplication operations in BSR format are typically faster than that
        for sparse tensors in COO format. Make you have a look at :ref:`the
        note on the data type of the indices <sparse-bsr-docs>`.

        .. note::

           If the ``device`` argument is not specified the device of the given
           :attr:`values` and indices tensor(s) must match. If, however, the
           argument is specified the input Tensors will be converted to the
           given device and in turn determine the device of the constructed
           sparse tensor.

        Args:
            crow_indices (array_like): (B+1)-dimensional array of size
                ``(*batchsize, nrowblocks + 1)``.  The last element of each
                batch is the number of non-zeros. This tensor encodes the
                block index in values and col_indices depending on where the
                given row block starts. Each successive number in the tensor
                subtracted by the number before it denotes the number of
                blocks in a given row.
            col_indices (array_like): Column block co-ordinates of each block
                in values. (B+1)-dimensional tensor with the same length as
                values.
            values (array_list): Initial values for the tensor. Can be a list,
                tuple, NumPy ``ndarray``, scalar, and other types that
                represents a (1 + 2 + K)-dimensional tensor where ``K`` is the
                number of dense dimensions.
            size (list, tuple, :class:`torch.Size`, optional): Size of the
                sparse tensor: ``(*batchsize, nrows * blocksize[0], ncols *
                blocksize[1], *densesize)`` where ``blocksize ==
                values.shape[1:3]``. If not provided, the size will be
                inferred as the minimum size big enough to hold all non-zero
                blocks.

        Keyword args:
            dtype (:class:`torch.dtype`, optional): the desired data type of
                returned tensor.  Default: if None, infers data type from
                :attr:`values`.
            device (:class:`torch.device`, optional): the desired device of
                returned tensor.  Default: if None, uses the current device
                for the default tensor type (see
                :func:`torch.set_default_device`). :attr:`device` will be
                the CPU for CPU tensor types and the current CUDA device for
                CUDA tensor types.
            pin_memory (bool, optional): If set, returned tensor would be allocated in
                the pinned memory. Works only for CPU tensors. Default: ``False``.
            requires_grad (bool, optional): If autograd should record operations on the
                returned tensor. Default: ``False``.
            check_invariants (bool, optional): If sparse tensor invariants are checked.
                Default: as returned by :func:`torch.sparse.check_sparse_tensor_invariants.is_enabled`,
                initially False.

        Example::

            >>> crow_indices = [0, 1, 2]
            >>> col_indices = [0, 1]
            >>> values = [[[1, 2], [3, 4]], [[5, 6], [7, 8]]]
            >>> torch.sparse_bsr_tensor(torch.tensor(crow_indices, dtype=torch.int64),
            ...                         torch.tensor(col_indices, dtype=torch.int64),
            ...                         torch.tensor(values), dtype=torch.double)
            tensor(crow_indices=tensor([0, 1, 2]),
                   col_indices=tensor([0, 1]),
                   values=tensor([[[1., 2.],
                                   [3., 4.]],
                                  [[5., 6.],
                                   [7., 8.]]]), size=(2, 2), nnz=2, dtype=torch.float64,
                   layout=torch.sparse_bsr)
        """
    @staticmethod
    def sparse_compressed_tensor(compressed_indices, plain_indices, values, size=..., dtype=..., layout=..., device=..., pin_memory=..., requires_grad=..., check_invariants=...) -> Tensor:
        """sparse_compressed_tensor(compressed_indices, plain_indices, values, size=None, *, dtype=None, layout=None, device=None, pin_memory=False, requires_grad=False, check_invariants=None) -> Tensor

        Constructs a :ref:`sparse tensor in Compressed Sparse format - CSR,
        CSC, BSR, or BSC - <sparse-compressed-docs>` with specified values at
        the given :attr:`compressed_indices` and :attr:`plain_indices`. Sparse
        matrix multiplication operations in Compressed Sparse format are
        typically faster than that for sparse tensors in COO format. Make you
        have a look at :ref:`the note on the data type of the indices
        <sparse-compressed-docs>`.

        .. note::

           If the ``device`` argument is not specified the device of the given
           :attr:`values` and indices tensor(s) must match. If, however, the
           argument is specified the input Tensors will be converted to the
           given device and in turn determine the device of the constructed
           sparse tensor.

        Args:
            compressed_indices (array_like): (B+1)-dimensional array of size
                ``(*batchsize, compressed_dim_size + 1)``.  The last element of
                each batch is the number of non-zero elements or blocks. This
                tensor encodes the index in ``values`` and ``plain_indices``
                depending on where the given compressed dimension (row or
                column) starts. Each successive number in the tensor
                subtracted by the number before it denotes the number of
                elements or blocks in a given compressed dimension.
            plain_indices (array_like): Plain dimension (column or row)
                co-ordinates of each element or block in values. (B+1)-dimensional
                tensor with the same length as values.

            values (array_list): Initial values for the tensor. Can be a list,
                tuple, NumPy ``ndarray``, scalar, and other types.  that
                represents a (1+K)-dimensional (for CSR and CSC layouts) or
                (1+2+K)-dimensional tensor (for BSR and BSC layouts) where
                ``K`` is the number of dense dimensions.
            size (list, tuple, :class:`torch.Size`, optional): Size of the
                sparse tensor: ``(*batchsize, nrows * blocksize[0], ncols *
                blocksize[1], *densesize)`` where ``blocksize[0] ==
                blocksize[1] == 1`` for CSR and CSC formats. If not provided,
                the size will be inferred as the minimum size big enough to
                hold all non-zero elements or blocks.

        Keyword args:
            dtype (:class:`torch.dtype`, optional): the desired data type of
                returned tensor.  Default: if None, infers data type from
                :attr:`values`.
            layout (:class:`torch.layout`, required): the desired layout of
                returned tensor: :attr:`torch.sparse_csr`,
                :attr:`torch.sparse_csc`, :attr:`torch.sparse_bsr`, or
                :attr:`torch.sparse_bsc`.
            device (:class:`torch.device`, optional): the desired device of
                returned tensor.  Default: if None, uses the current device
                for the default tensor type (see
                :func:`torch.set_default_device`). :attr:`device` will be
                the CPU for CPU tensor types and the current CUDA device for
                CUDA tensor types.
            pin_memory (bool, optional): If set, returned tensor would be allocated in
                the pinned memory. Works only for CPU tensors. Default: ``False``.
            requires_grad (bool, optional): If autograd should record operations on the
                returned tensor. Default: ``False``.
            check_invariants (bool, optional): If sparse tensor invariants are checked.
                Default: as returned by :func:`torch.sparse.check_sparse_tensor_invariants.is_enabled`,
                initially False.

        Example::

            >>> compressed_indices = [0, 2, 4]
            >>> plain_indices = [0, 1, 0, 1]
            >>> values = [1, 2, 3, 4]
            >>> torch.sparse_compressed_tensor(torch.tensor(compressed_indices, dtype=torch.int64),
            ...                                torch.tensor(plain_indices, dtype=torch.int64),
            ...                                torch.tensor(values), dtype=torch.double, layout=torch.sparse_csr)
            tensor(crow_indices=tensor([0, 2, 4]),
                   col_indices=tensor([0, 1, 0, 1]),
                   values=tensor([1., 2., 3., 4.]), size=(2, 2), nnz=4,
                   dtype=torch.float64, layout=torch.sparse_csr)
        """
    @overload
    @staticmethod
    def sparse_coo_tensor(indices, values, size=..., dtype=..., device=..., pin_memory=..., requires_grad=..., check_invariants=..., is_coalesced=...) -> Tensor:
        """sparse_coo_tensor(indices, values, size=None, *, dtype=None, device=None, pin_memory=False, requires_grad=False, check_invariants=None, is_coalesced=None) -> Tensor

        Constructs a :ref:`sparse tensor in COO(rdinate) format
        <sparse-coo-docs>` with specified values at the given
        :attr:`indices`.

        .. note::

           This function returns an :ref:`uncoalesced tensor
           <sparse-uncoalesced-coo-docs>` when :attr:`is_coalesced` is
           unspecified or ``None``.

        .. note::

           If the ``device`` argument is not specified the device of the given
           :attr:`values` and indices tensor(s) must match. If, however, the
           argument is specified the input Tensors will be converted to the
           given device and in turn determine the device of the constructed
           sparse tensor.

        Args:
            indices (array_like): Initial data for the tensor. Can be a list, tuple,
                NumPy ``ndarray``, scalar, and other types. Will be cast to a :class:`torch.LongTensor`
                internally. The indices are the coordinates of the non-zero values in the matrix, and thus
                should be two-dimensional where the first dimension is the number of tensor dimensions and
                the second dimension is the number of non-zero values.
            values (array_like): Initial values for the tensor. Can be a list, tuple,
                NumPy ``ndarray``, scalar, and other types.
            size (list, tuple, or :class:`torch.Size`, optional): Size of the sparse tensor. If not
                provided the size will be inferred as the minimum size big enough to hold all non-zero
                elements.

        Keyword args:
            dtype (:class:`torch.dtype`, optional): the desired data type of returned tensor.
                Default: if None, infers data type from :attr:`values`.
            device (:class:`torch.device`, optional): the desired device of returned tensor.
                Default: if None, uses the current device for the default tensor type
                (see :func:`torch.set_default_device`). :attr:`device` will be the CPU
                for CPU tensor types and the current CUDA device for CUDA tensor types.
            pin_memory (bool, optional): If set, returned tensor would be allocated in
                the pinned memory. Works only for CPU tensors. Default: ``False``.
            requires_grad (bool, optional): If autograd should record operations on the
                returned tensor. Default: ``False``.
            check_invariants (bool, optional): If sparse tensor invariants are checked.
                Default: as returned by :func:`torch.sparse.check_sparse_tensor_invariants.is_enabled`,
                initially False.
            is_coalesced (bool, optional): When``True``, the caller is
                responsible for providing tensor indices that correspond to a
                coalesced tensor.  If the :attr:`check_invariants` flag is
                False, no error will be raised if the prerequisites are not
                met and this will lead to silently incorrect results. To force
                coalescion please use :meth:`coalesce` on the resulting
                Tensor.
                Default: None: except for trivial cases (e.g. nnz < 2) the
                resulting Tensor has is_coalesced set to ``False```.

        Example::

            >>> i = torch.tensor([[0, 1, 1],
            ...                   [2, 0, 2]])
            >>> v = torch.tensor([3, 4, 5], dtype=torch.float32)
            >>> torch.sparse_coo_tensor(i, v, [2, 4])
            tensor(indices=tensor([[0, 1, 1],
                                   [2, 0, 2]]),
                   values=tensor([3., 4., 5.]),
                   size=(2, 4), nnz=3, layout=torch.sparse_coo)

            >>> torch.sparse_coo_tensor(i, v)  # Shape inference
            tensor(indices=tensor([[0, 1, 1],
                                   [2, 0, 2]]),
                   values=tensor([3., 4., 5.]),
                   size=(2, 3), nnz=3, layout=torch.sparse_coo)

            >>> torch.sparse_coo_tensor(i, v, [2, 4],
            ...                         dtype=torch.float64,
            ...                         device=torch.device('cuda:0'))
            tensor(indices=tensor([[0, 1, 1],
                                   [2, 0, 2]]),
                   values=tensor([3., 4., 5.]),
                   device='cuda:0', size=(2, 4), nnz=3, dtype=torch.float64,
                   layout=torch.sparse_coo)

            # Create an empty sparse tensor with the following invariants:
            #   1. sparse_dim + dense_dim = len(SparseTensor.shape)
            #   2. SparseTensor._indices().shape = (sparse_dim, nnz)
            #   3. SparseTensor._values().shape = (nnz, SparseTensor.shape[sparse_dim:])
            #
            # For instance, to create an empty sparse tensor with nnz = 0, dense_dim = 0 and
            # sparse_dim = 1 (hence indices is a 2D tensor of shape = (1, 0))
            >>> S = torch.sparse_coo_tensor(torch.empty([1, 0]), [], [1])
            tensor(indices=tensor([], size=(1, 0)),
                   values=tensor([], size=(0,)),
                   size=(1,), nnz=0, layout=torch.sparse_coo)

            # and to create an empty sparse tensor with nnz = 0, dense_dim = 1 and
            # sparse_dim = 1
            >>> S = torch.sparse_coo_tensor(torch.empty([1, 0]), torch.empty([0, 2]), [1, 2])
            tensor(indices=tensor([], size=(1, 0)),
                   values=tensor([], size=(0, 2)),
                   size=(1, 2), nnz=0, layout=torch.sparse_coo)

        .. _torch.sparse: https://pytorch.org/docs/stable/sparse.html
        """
    @overload
    @staticmethod
    def sparse_coo_tensor(i, v) -> Any:
        """sparse_coo_tensor(indices, values, size=None, *, dtype=None, device=None, pin_memory=False, requires_grad=False, check_invariants=None, is_coalesced=None) -> Tensor

        Constructs a :ref:`sparse tensor in COO(rdinate) format
        <sparse-coo-docs>` with specified values at the given
        :attr:`indices`.

        .. note::

           This function returns an :ref:`uncoalesced tensor
           <sparse-uncoalesced-coo-docs>` when :attr:`is_coalesced` is
           unspecified or ``None``.

        .. note::

           If the ``device`` argument is not specified the device of the given
           :attr:`values` and indices tensor(s) must match. If, however, the
           argument is specified the input Tensors will be converted to the
           given device and in turn determine the device of the constructed
           sparse tensor.

        Args:
            indices (array_like): Initial data for the tensor. Can be a list, tuple,
                NumPy ``ndarray``, scalar, and other types. Will be cast to a :class:`torch.LongTensor`
                internally. The indices are the coordinates of the non-zero values in the matrix, and thus
                should be two-dimensional where the first dimension is the number of tensor dimensions and
                the second dimension is the number of non-zero values.
            values (array_like): Initial values for the tensor. Can be a list, tuple,
                NumPy ``ndarray``, scalar, and other types.
            size (list, tuple, or :class:`torch.Size`, optional): Size of the sparse tensor. If not
                provided the size will be inferred as the minimum size big enough to hold all non-zero
                elements.

        Keyword args:
            dtype (:class:`torch.dtype`, optional): the desired data type of returned tensor.
                Default: if None, infers data type from :attr:`values`.
            device (:class:`torch.device`, optional): the desired device of returned tensor.
                Default: if None, uses the current device for the default tensor type
                (see :func:`torch.set_default_device`). :attr:`device` will be the CPU
                for CPU tensor types and the current CUDA device for CUDA tensor types.
            pin_memory (bool, optional): If set, returned tensor would be allocated in
                the pinned memory. Works only for CPU tensors. Default: ``False``.
            requires_grad (bool, optional): If autograd should record operations on the
                returned tensor. Default: ``False``.
            check_invariants (bool, optional): If sparse tensor invariants are checked.
                Default: as returned by :func:`torch.sparse.check_sparse_tensor_invariants.is_enabled`,
                initially False.
            is_coalesced (bool, optional): When``True``, the caller is
                responsible for providing tensor indices that correspond to a
                coalesced tensor.  If the :attr:`check_invariants` flag is
                False, no error will be raised if the prerequisites are not
                met and this will lead to silently incorrect results. To force
                coalescion please use :meth:`coalesce` on the resulting
                Tensor.
                Default: None: except for trivial cases (e.g. nnz < 2) the
                resulting Tensor has is_coalesced set to ``False```.

        Example::

            >>> i = torch.tensor([[0, 1, 1],
            ...                   [2, 0, 2]])
            >>> v = torch.tensor([3, 4, 5], dtype=torch.float32)
            >>> torch.sparse_coo_tensor(i, v, [2, 4])
            tensor(indices=tensor([[0, 1, 1],
                                   [2, 0, 2]]),
                   values=tensor([3., 4., 5.]),
                   size=(2, 4), nnz=3, layout=torch.sparse_coo)

            >>> torch.sparse_coo_tensor(i, v)  # Shape inference
            tensor(indices=tensor([[0, 1, 1],
                                   [2, 0, 2]]),
                   values=tensor([3., 4., 5.]),
                   size=(2, 3), nnz=3, layout=torch.sparse_coo)

            >>> torch.sparse_coo_tensor(i, v, [2, 4],
            ...                         dtype=torch.float64,
            ...                         device=torch.device('cuda:0'))
            tensor(indices=tensor([[0, 1, 1],
                                   [2, 0, 2]]),
                   values=tensor([3., 4., 5.]),
                   device='cuda:0', size=(2, 4), nnz=3, dtype=torch.float64,
                   layout=torch.sparse_coo)

            # Create an empty sparse tensor with the following invariants:
            #   1. sparse_dim + dense_dim = len(SparseTensor.shape)
            #   2. SparseTensor._indices().shape = (sparse_dim, nnz)
            #   3. SparseTensor._values().shape = (nnz, SparseTensor.shape[sparse_dim:])
            #
            # For instance, to create an empty sparse tensor with nnz = 0, dense_dim = 0 and
            # sparse_dim = 1 (hence indices is a 2D tensor of shape = (1, 0))
            >>> S = torch.sparse_coo_tensor(torch.empty([1, 0]), [], [1])
            tensor(indices=tensor([], size=(1, 0)),
                   values=tensor([], size=(0,)),
                   size=(1,), nnz=0, layout=torch.sparse_coo)

            # and to create an empty sparse tensor with nnz = 0, dense_dim = 1 and
            # sparse_dim = 1
            >>> S = torch.sparse_coo_tensor(torch.empty([1, 0]), torch.empty([0, 2]), [1, 2])
            tensor(indices=tensor([], size=(1, 0)),
                   values=tensor([], size=(0, 2)),
                   size=(1, 2), nnz=0, layout=torch.sparse_coo)

        .. _torch.sparse: https://pytorch.org/docs/stable/sparse.html
        """
    @staticmethod
    def sparse_csc_tensor(ccol_indices, row_indices, values, size=..., dtype=..., device=..., pin_memory=..., requires_grad=..., check_invariants=...) -> Tensor:
        """sparse_csc_tensor(ccol_indices, row_indices, values, size=None, *, dtype=None, device=None, pin_memory=False, requires_grad=False, check_invariants=None) -> Tensor

        Constructs a :ref:`sparse tensor in CSC (Compressed Sparse Column)
        <sparse-csc-docs>` with specified values at the given
        :attr:`ccol_indices` and :attr:`row_indices`. Sparse matrix
        multiplication operations in CSC format are typically faster than that
        for sparse tensors in COO format. Make you have a look at :ref:`the
        note on the data type of the indices <sparse-csc-docs>`.

        .. note::

           If the ``device`` argument is not specified the device of the given
           :attr:`values` and indices tensor(s) must match. If, however, the
           argument is specified the input Tensors will be converted to the
           given device and in turn determine the device of the constructed
           sparse tensor.

        Args:
            ccol_indices (array_like): (B+1)-dimensional array of size
                ``(*batchsize, ncols + 1)``.  The last element of each batch
                is the number of non-zeros. This tensor encodes the index in
                values and row_indices depending on where the given column
                starts. Each successive number in the tensor subtracted by the
                number before it denotes the number of elements in a given
                column.
            row_indices (array_like): Row co-ordinates of each element in
                values. (B+1)-dimensional tensor with the same length as
                values.
            values (array_list): Initial values for the tensor. Can be a list,
                tuple, NumPy ``ndarray``, scalar, and other types that
                represents a (1+K)-dimensional tensor where ``K`` is the number
                of dense dimensions.
            size (list, tuple, :class:`torch.Size`, optional): Size of the
                sparse tensor: ``(*batchsize, nrows, ncols, *densesize)``. If
                not provided, the size will be inferred as the minimum size
                big enough to hold all non-zero elements.

        Keyword args:
            dtype (:class:`torch.dtype`, optional): the desired data type of
                returned tensor.  Default: if None, infers data type from
                :attr:`values`.
            device (:class:`torch.device`, optional): the desired device of
                returned tensor.  Default: if None, uses the current device
                for the default tensor type (see
                :func:`torch.set_default_device`). :attr:`device` will be
                the CPU for CPU tensor types and the current CUDA device for
                CUDA tensor types.
            pin_memory (bool, optional): If set, returned tensor would be allocated in
                the pinned memory. Works only for CPU tensors. Default: ``False``.
            requires_grad (bool, optional): If autograd should record operations on the
                returned tensor. Default: ``False``.
            check_invariants (bool, optional): If sparse tensor invariants are checked.
                Default: as returned by :func:`torch.sparse.check_sparse_tensor_invariants.is_enabled`,
                initially False.

        Example::

            >>> ccol_indices = [0, 2, 4]
            >>> row_indices = [0, 1, 0, 1]
            >>> values = [1, 2, 3, 4]
            >>> torch.sparse_csc_tensor(torch.tensor(ccol_indices, dtype=torch.int64),
            ...                         torch.tensor(row_indices, dtype=torch.int64),
            ...                         torch.tensor(values), dtype=torch.double)
            tensor(ccol_indices=tensor([0, 2, 4]),
                   row_indices=tensor([0, 1, 0, 1]),
                   values=tensor([1., 2., 3., 4.]), size=(2, 2), nnz=4,
                   dtype=torch.float64, layout=torch.sparse_csc)
        """
    @staticmethod
    def sparse_csr_tensor(crow_indices, col_indices, values, size=..., dtype=..., device=..., pin_memory=..., requires_grad=..., check_invariants=...) -> Tensor:
        """sparse_csr_tensor(crow_indices, col_indices, values, size=None, *, dtype=None, device=None, pin_memory=False, requires_grad=False, check_invariants=None) -> Tensor

        Constructs a :ref:`sparse tensor in CSR (Compressed Sparse Row) <sparse-csr-docs>` with specified
        values at the given :attr:`crow_indices` and :attr:`col_indices`. Sparse matrix multiplication operations
        in CSR format are typically faster than that for sparse tensors in COO format. Make you have a look
        at :ref:`the note on the data type of the indices <sparse-csr-docs>`.

        .. note::

           If the ``device`` argument is not specified the device of the given
           :attr:`values` and indices tensor(s) must match. If, however, the
           argument is specified the input Tensors will be converted to the
           given device and in turn determine the device of the constructed
           sparse tensor.

        Args:
            crow_indices (array_like): (B+1)-dimensional array of size
                ``(*batchsize, nrows + 1)``.  The last element of each batch
                is the number of non-zeros. This tensor encodes the index in
                values and col_indices depending on where the given row
                starts. Each successive number in the tensor subtracted by the
                number before it denotes the number of elements in a given
                row.
            col_indices (array_like): Column co-ordinates of each element in
                values. (B+1)-dimensional tensor with the same length
                as values.
            values (array_list): Initial values for the tensor. Can be a list,
                tuple, NumPy ``ndarray``, scalar, and other types that
                represents a (1+K)-dimensional tensor where ``K`` is the number
                of dense dimensions.
            size (list, tuple, :class:`torch.Size`, optional): Size of the
                sparse tensor: ``(*batchsize, nrows, ncols, *densesize)``. If
                not provided, the size will be inferred as the minimum size
                big enough to hold all non-zero elements.

        Keyword args:
            dtype (:class:`torch.dtype`, optional): the desired data type of
                returned tensor.  Default: if None, infers data type from
                :attr:`values`.
            device (:class:`torch.device`, optional): the desired device of
                returned tensor.  Default: if None, uses the current device
                for the default tensor type (see
                :func:`torch.set_default_device`). :attr:`device` will be
                the CPU for CPU tensor types and the current CUDA device for
                CUDA tensor types.
            pin_memory (bool, optional): If set, returned tensor would be allocated in
                the pinned memory. Works only for CPU tensors. Default: ``False``.
            requires_grad (bool, optional): If autograd should record operations on the
                returned tensor. Default: ``False``.
            check_invariants (bool, optional): If sparse tensor invariants are checked.
                Default: as returned by :func:`torch.sparse.check_sparse_tensor_invariants.is_enabled`,
                initially False.

        Example::

            >>> crow_indices = [0, 2, 4]
            >>> col_indices = [0, 1, 0, 1]
            >>> values = [1, 2, 3, 4]
            >>> torch.sparse_csr_tensor(torch.tensor(crow_indices, dtype=torch.int64),
            ...                         torch.tensor(col_indices, dtype=torch.int64),
            ...                         torch.tensor(values), dtype=torch.double)
            tensor(crow_indices=tensor([0, 2, 4]),
                   col_indices=tensor([0, 1, 0, 1]),
                   values=tensor([1., 2., 3., 4.]), size=(2, 2), nnz=4,
                   dtype=torch.float64, layout=torch.sparse_csr)
        """
    @staticmethod
    def split(*args, **kwargs): ...
    @staticmethod
    def split_copy(*args, **kwargs):
        """
        Performs the same operation as :func:`torch.split`, but all output tensors
        are freshly created instead of aliasing the input.
        """
    @staticmethod
    def split_with_sizes(*args, **kwargs): ...
    @staticmethod
    def split_with_sizes_copy(*args, **kwargs):
        """
        Performs the same operation as :func:`torch.split_with_sizes`, but all output tensors
        are freshly created instead of aliasing the input.
        """
    @staticmethod
    def spmm(*args, **kwargs): ...
    @staticmethod
    def sqrt(input, out=...) -> Tensor:
        """
        sqrt(input, *, out=None) -> Tensor

        Returns a new tensor with the square-root of the elements of :attr:`input`.

        .. math::
            \\text{out}_{i} = \\sqrt{\\text{input}_{i}}

        Args:
            input (Tensor): the input tensor.

        Keyword args:
            out (Tensor, optional): the output tensor.

        Example::

            >>> a = torch.randn(4)
            >>> a
            tensor([-2.0755,  1.0226,  0.0831,  0.4806])
            >>> torch.sqrt(a)
            tensor([    nan,  1.0112,  0.2883,  0.6933])
        """
    @staticmethod
    def sqrt_(*args, **kwargs): ...
    @overload
    @staticmethod
    def square(input: Tensor, out: Tensor | None) -> Tensor:
        """
        square(input: Tensor, *, out: Optional[Tensor]) -> Tensor

        Returns a new tensor with the square of the elements of :attr:`input`.

        Args:
            input (Tensor): the input tensor.

        Keyword args:
            out (Tensor, optional): the output tensor.

        Example::

            >>> a = torch.randn(4)
            >>> a
            tensor([-2.0755,  1.0226,  0.0831,  0.4806])
            >>> torch.square(a)
            tensor([ 4.3077,  1.0457,  0.0069,  0.2310])
        """
    @overload
    @staticmethod
    def square(a) -> Any:
        """
        square(input: Tensor, *, out: Optional[Tensor]) -> Tensor

        Returns a new tensor with the square of the elements of :attr:`input`.

        Args:
            input (Tensor): the input tensor.

        Keyword args:
            out (Tensor, optional): the output tensor.

        Example::

            >>> a = torch.randn(4)
            >>> a
            tensor([-2.0755,  1.0226,  0.0831,  0.4806])
            >>> torch.square(a)
            tensor([ 4.3077,  1.0457,  0.0069,  0.2310])
        """
    @staticmethod
    def square_(*args, **kwargs): ...
    @staticmethod
    def squeeze(input: Tensor, dim: int | list[int] | None) -> Tensor:
        """
        squeeze(input: Tensor, dim: Optional[Union[int, List[int]]]) -> Tensor

        Returns a tensor with all specified dimensions of :attr:`input` of size `1` removed.

        For example, if `input` is of shape:
        :math:`(A \\times 1 \\times B \\times C \\times 1 \\times D)` then the `input.squeeze()`
        will be of shape: :math:`(A \\times B \\times C \\times D)`.

        When :attr:`dim` is given, a squeeze operation is done only in the given
        dimension(s). If `input` is of shape: :math:`(A \\times 1 \\times B)`,
        ``squeeze(input, 0)`` leaves the tensor unchanged, but ``squeeze(input, 1)``
        will squeeze the tensor to the shape :math:`(A \\times B)`.

        .. note:: The returned tensor shares the storage with the input tensor,
                  so changing the contents of one will change the contents of the other.

        .. warning:: If the tensor has a batch dimension of size 1, then `squeeze(input)`
                  will also remove the batch dimension, which can lead to unexpected
                  errors. Consider specifying only the dims you wish to be squeezed.

        Args:
            input (Tensor): the input tensor.
            dim (int or tuple of ints, optional): if given, the input will be squeezed
                   only in the specified dimensions.

                .. versionchanged:: 2.0
                   :attr:`dim` now accepts tuples of dimensions.

        Example::

            >>> x = torch.zeros(2, 1, 2, 1, 2)
            >>> x.size()
            torch.Size([2, 1, 2, 1, 2])
            >>> y = torch.squeeze(x)
            >>> y.size()
            torch.Size([2, 2, 2])
            >>> y = torch.squeeze(x, 0)
            >>> y.size()
            torch.Size([2, 1, 2, 1, 2])
            >>> y = torch.squeeze(x, 1)
            >>> y.size()
            torch.Size([2, 2, 1, 2])
            >>> y = torch.squeeze(x, (1, 2, 3))
            torch.Size([2, 2, 2])
        """
    @staticmethod
    def squeeze_copy(*args, **kwargs):
        """
        Performs the same operation as :func:`torch.squeeze`, but all output tensors
        are freshly created instead of aliasing the input.
        """
    @staticmethod
    def sspaddmm(input, mat1, mat2, beta=..., alpha=..., out=...) -> Tensor:
        """
        sspaddmm(input, mat1, mat2, *, beta=1, alpha=1, out=None) -> Tensor

        Matrix multiplies a sparse tensor :attr:`mat1` with a dense tensor
        :attr:`mat2`, then adds the sparse tensor :attr:`input` to the result.

        Note: This function is equivalent to :func:`torch.addmm`, except
        :attr:`input` and :attr:`mat1` are sparse.

        Args:
            input (Tensor): a sparse matrix to be added
            mat1 (Tensor): a sparse matrix to be matrix multiplied
            mat2 (Tensor): a dense matrix to be matrix multiplied

        Keyword args:
            beta (Number, optional): multiplier for :attr:`mat` (:math:`\\beta`)
            alpha (Number, optional): multiplier for :math:`mat1 @ mat2` (:math:`\\alpha`)
            out (Tensor, optional): the output tensor.
        """
    @staticmethod
    def stack(tensors, dim=..., out=...) -> Tensor:
        """
        stack(tensors, dim=0, *, out=None) -> Tensor

        Concatenates a sequence of tensors along a new dimension.

        All tensors need to be of the same size.

        .. seealso::

            :func:`torch.cat` concatenates the given sequence along an existing dimension.

        Arguments:
            tensors (sequence of Tensors): sequence of tensors to concatenate
            dim (int, optional): dimension to insert. Has to be between 0 and the number
                of dimensions of concatenated tensors (inclusive). Default: 0

        Keyword args:
            out (Tensor, optional): the output tensor.

        Example::

            >>> x = torch.randn(2, 3)
            >>> x
            tensor([[ 0.3367,  0.1288,  0.2345],
                    [ 0.2303, -1.1229, -0.1863]])
            >>> torch.stack((x, x)) # same as torch.stack((x, x), dim=0)
            tensor([[[ 0.3367,  0.1288,  0.2345],
                     [ 0.2303, -1.1229, -0.1863]],

                    [[ 0.3367,  0.1288,  0.2345],
                     [ 0.2303, -1.1229, -0.1863]]])
            >>> torch.stack((x, x)).size()
            torch.Size([2, 2, 3])
            >>> torch.stack((x, x), dim=1)
            tensor([[[ 0.3367,  0.1288,  0.2345],
                     [ 0.3367,  0.1288,  0.2345]],

                    [[ 0.2303, -1.1229, -0.1863],
                     [ 0.2303, -1.1229, -0.1863]]])
            >>> torch.stack((x, x), dim=2)
            tensor([[[ 0.3367,  0.3367],
                     [ 0.1288,  0.1288],
                     [ 0.2345,  0.2345]],

                    [[ 0.2303,  0.2303],
                     [-1.1229, -1.1229],
                     [-0.1863, -0.1863]]])
            >>> torch.stack((x, x), dim=-1)
            tensor([[[ 0.3367,  0.3367],
                     [ 0.1288,  0.1288],
                     [ 0.2345,  0.2345]],

                    [[ 0.2303,  0.2303],
                     [-1.1229, -1.1229],
                     [-0.1863, -0.1863]]])
        """
    @staticmethod
    def std(input, dim=..., correction=..., keepdim=..., out=...) -> Tensor:
        """
        std(input, dim=None, *, correction=1, keepdim=False, out=None) -> Tensor

        Calculates the standard deviation over the dimensions specified by :attr:`dim`.
        :attr:`dim` can be a single dimension, list of dimensions, or ``None`` to
        reduce over all dimensions.

        The standard deviation (:math:`\\sigma`) is calculated as

        .. math:: \\sigma = \\sqrt{\\frac{1}{\\max(0,~N - \\delta N)}\\sum_{i=0}^{N-1}(x_i-\\bar{x})^2}

        where :math:`x` is the sample set of elements, :math:`\\bar{x}` is the
        sample mean, :math:`N` is the number of samples and :math:`\\delta N` is
        the :attr:`correction`.



        If :attr:`keepdim` is ``True``, the output tensor is of the same size
        as :attr:`input` except in the dimension(s) :attr:`dim` where it is of size 1.
        Otherwise, :attr:`dim` is squeezed (see :func:`torch.squeeze`), resulting in the
        output tensor having 1 (or ``len(dim)``) fewer dimension(s).


        Args:
            input (Tensor): the input tensor.
    
            dim (int or tuple of ints, optional): the dimension or dimensions to reduce.
                If ``None``, all dimensions are reduced.


        Keyword args:
            correction (int): difference between the sample size and sample degrees of freedom.
                Defaults to `Bessel's correction`_, ``correction=1``.

                .. versionchanged:: 2.0
                    Previously this argument was called ``unbiased`` and was a boolean
                    with ``True`` corresponding to ``correction=1`` and ``False`` being
                    ``correction=0``.
    
            keepdim (bool, optional): whether the output tensor has :attr:`dim` retained or not. Default: ``False``.

            out (Tensor, optional): the output tensor.

        Example:

            >>> a = torch.tensor(
            ...     [[ 0.2035,  1.2959,  1.8101, -0.4644],
            ...      [ 1.5027, -0.3270,  0.5905,  0.6538],
            ...      [-1.5745,  1.3330, -0.5596, -0.6548],
            ...      [ 0.1264, -0.5080,  1.6420,  0.1992]]
            ... )  # fmt: skip
            >>> torch.std(a, dim=1, keepdim=True)
            tensor([[1.0311],
                    [0.7477],
                    [1.2204],
                    [0.9087]])

        .. _Bessel's correction: https://en.wikipedia.org/wiki/Bessel%27s_correction

        """
    @staticmethod
    def std_mean(*args, **kwargs):
        """
        std_mean(input, dim=None, *, correction=1, keepdim=False, out=None) -> (Tensor, Tensor)

        Calculates the standard deviation and mean over the dimensions specified by
        :attr:`dim`. :attr:`dim` can be a single dimension, list of dimensions, or
        ``None`` to reduce over all dimensions.

        The standard deviation (:math:`\\sigma`) is calculated as

        .. math:: \\sigma = \\sqrt{\\frac{1}{\\max(0,~N - \\delta N)}\\sum_{i=0}^{N-1}(x_i-\\bar{x})^2}

        where :math:`x` is the sample set of elements, :math:`\\bar{x}` is the
        sample mean, :math:`N` is the number of samples and :math:`\\delta N` is
        the :attr:`correction`.




        If :attr:`keepdim` is ``True``, the output tensor is of the same size
        as :attr:`input` except in the dimension(s) :attr:`dim` where it is of size 1.
        Otherwise, :attr:`dim` is squeezed (see :func:`torch.squeeze`), resulting in the
        output tensor having 1 (or ``len(dim)``) fewer dimension(s).


        Args:
            input (Tensor): the input tensor.
    
            dim (int or tuple of ints, optional): the dimension or dimensions to reduce.
                If ``None``, all dimensions are reduced.


        Keyword args:
            correction (int): difference between the sample size and sample degrees of freedom.
                Defaults to `Bessel's correction`_, ``correction=1``.

                .. versionchanged:: 2.0
                    Previously this argument was called ``unbiased`` and was a boolean
                    with ``True`` corresponding to ``correction=1`` and ``False`` being
                    ``correction=0``.
    
            keepdim (bool, optional): whether the output tensor has :attr:`dim` retained or not. Default: ``False``.

            out (Tensor, optional): the output tensor.

        Returns:
            A tuple (std, mean) containing the standard deviation and mean.

        Example:

            >>> a = torch.tensor(
            ...     [[ 0.2035,  1.2959,  1.8101, -0.4644],
            ...      [ 1.5027, -0.3270,  0.5905,  0.6538],
            ...      [-1.5745,  1.3330, -0.5596, -0.6548],
            ...      [ 0.1264, -0.5080,  1.6420,  0.1992]]
            ... )  # fmt: skip
            >>> torch.std_mean(a, dim=0, keepdim=True)
            (tensor([[1.2620, 1.0028, 1.0957, 0.6038]]),
             tensor([[ 0.0645,  0.4485,  0.8707, -0.0665]]))

        .. _Bessel's correction: https://en.wikipedia.org/wiki/Bessel%27s_correction

        """
    @staticmethod
    def stft(*args, **kwargs): ...
    @staticmethod
    def sub(input, other, alpha=..., out=...) -> Tensor:
        """
        sub(input, other, *, alpha=1, out=None) -> Tensor

        Subtracts :attr:`other`, scaled by :attr:`alpha`, from :attr:`input`.

        .. math::
            \\text{{out}}_i = \\text{{input}}_i - \\text{{alpha}} \\times \\text{{other}}_i


        Supports :ref:`broadcasting to a common shape <broadcasting-semantics>`,
        :ref:`type promotion <type-promotion-doc>`, and integer, float, and complex inputs.

        Args:
            input (Tensor): the input tensor.
            other (Tensor or Number): the tensor or number to subtract from :attr:`input`.

        Keyword args:
            alpha (Number): the multiplier for :attr:`other`.
            out (Tensor, optional): the output tensor.

        Example::

            >>> a = torch.tensor((1, 2))
            >>> b = torch.tensor((0, 1))
            >>> torch.sub(a, b, alpha=2)
            tensor([1, 0])
        """
    @staticmethod
    def subtract(input, other, alpha=..., out=...) -> Tensor:
        """
        subtract(input, other, *, alpha=1, out=None) -> Tensor

        Alias for :func:`torch.sub`.
        """
    @overload
    @staticmethod
    def sum(input, dtype=...) -> Tensor:
        """
        sum(input, *, dtype=None) -> Tensor

        Returns the sum of all elements in the :attr:`input` tensor.

        Args:
            input (Tensor): the input tensor.

        Keyword args:
            dtype (:class:`torch.dtype`, optional): the desired data type of returned tensor.
                If specified, the input tensor is casted to :attr:`dtype` before the operation
                is performed. This is useful for preventing data type overflows. Default: None.

        .. note:: Use the `dtype` argument if you need the result in a specific tensor type.
                  Otherwise, the result type may be automatically promoted (e.g., from `torch.int32` to `torch.int64`).

        Example::

            >>> a = torch.randn(1, 3)
            >>> a
            tensor([[ 0.1133, -0.9567,  0.2958]])
            >>> torch.sum(a)
            tensor(-0.5475)

        .. function:: sum(input, dim, keepdim=False, *, dtype=None) -> Tensor
           :noindex:

        Returns the sum of each row of the :attr:`input` tensor in the given
        dimension :attr:`dim`. If :attr:`dim` is a list of dimensions,
        reduce over all of them.


        If :attr:`keepdim` is ``True``, the output tensor is of the same size
        as :attr:`input` except in the dimension(s) :attr:`dim` where it is of size 1.
        Otherwise, :attr:`dim` is squeezed (see :func:`torch.squeeze`), resulting in the
        output tensor having 1 (or ``len(dim)``) fewer dimension(s).


        Args:
            input (Tensor): the input tensor.
    
            dim (int or tuple of ints, optional): the dimension or dimensions to reduce.
                If ``None``, all dimensions are reduced.

    
            keepdim (bool, optional): whether the output tensor has :attr:`dim` retained or not. Default: ``False``.


        Keyword args:
            dtype (:class:`torch.dtype`, optional): the desired data type of returned tensor.
                If specified, the input tensor is casted to :attr:`dtype` before the operation
                is performed. This is useful for preventing data type overflows. Default: None.

        Example::

            >>> a = torch.randn(4, 4)
            >>> a
            tensor([[ 0.0569, -0.2475,  0.0737, -0.3429],
                    [-0.2993,  0.9138,  0.9337, -1.6864],
                    [ 0.1132,  0.7892, -0.1003,  0.5688],
                    [ 0.3637, -0.9906, -0.4752, -1.5197]])
            >>> torch.sum(a, 1)
            tensor([-0.4598, -0.1381,  1.3708, -2.6217])
            >>> b = torch.arange(4 * 5 * 6).view(4, 5, 6)
            >>> torch.sum(b, (2, 1))
            tensor([  435.,  1335.,  2235.,  3135.])
        """
    @overload
    @staticmethod
    def sum(a) -> Any:
        """
        sum(input, *, dtype=None) -> Tensor

        Returns the sum of all elements in the :attr:`input` tensor.

        Args:
            input (Tensor): the input tensor.

        Keyword args:
            dtype (:class:`torch.dtype`, optional): the desired data type of returned tensor.
                If specified, the input tensor is casted to :attr:`dtype` before the operation
                is performed. This is useful for preventing data type overflows. Default: None.

        .. note:: Use the `dtype` argument if you need the result in a specific tensor type.
                  Otherwise, the result type may be automatically promoted (e.g., from `torch.int32` to `torch.int64`).

        Example::

            >>> a = torch.randn(1, 3)
            >>> a
            tensor([[ 0.1133, -0.9567,  0.2958]])
            >>> torch.sum(a)
            tensor(-0.5475)

        .. function:: sum(input, dim, keepdim=False, *, dtype=None) -> Tensor
           :noindex:

        Returns the sum of each row of the :attr:`input` tensor in the given
        dimension :attr:`dim`. If :attr:`dim` is a list of dimensions,
        reduce over all of them.


        If :attr:`keepdim` is ``True``, the output tensor is of the same size
        as :attr:`input` except in the dimension(s) :attr:`dim` where it is of size 1.
        Otherwise, :attr:`dim` is squeezed (see :func:`torch.squeeze`), resulting in the
        output tensor having 1 (or ``len(dim)``) fewer dimension(s).


        Args:
            input (Tensor): the input tensor.
    
            dim (int or tuple of ints, optional): the dimension or dimensions to reduce.
                If ``None``, all dimensions are reduced.

    
            keepdim (bool, optional): whether the output tensor has :attr:`dim` retained or not. Default: ``False``.


        Keyword args:
            dtype (:class:`torch.dtype`, optional): the desired data type of returned tensor.
                If specified, the input tensor is casted to :attr:`dtype` before the operation
                is performed. This is useful for preventing data type overflows. Default: None.

        Example::

            >>> a = torch.randn(4, 4)
            >>> a
            tensor([[ 0.0569, -0.2475,  0.0737, -0.3429],
                    [-0.2993,  0.9138,  0.9337, -1.6864],
                    [ 0.1132,  0.7892, -0.1003,  0.5688],
                    [ 0.3637, -0.9906, -0.4752, -1.5197]])
            >>> torch.sum(a, 1)
            tensor([-0.4598, -0.1381,  1.3708, -2.6217])
            >>> b = torch.arange(4 * 5 * 6).view(4, 5, 6)
            >>> torch.sum(b, (2, 1))
            tensor([  435.,  1335.,  2235.,  3135.])
        """
    @staticmethod
    def svd(*args, **kwargs):
        """
        svd(input, some=True, compute_uv=True, *, out=None) -> (Tensor, Tensor, Tensor)

        Computes the singular value decomposition of either a matrix or batch of
        matrices :attr:`input`. The singular value decomposition is represented as a
        namedtuple `(U, S, V)`, such that :attr:`input` :math:`= U \\text{diag}(S) V^{\\text{H}}`.
        where :math:`V^{\\text{H}}` is the transpose of `V` for real inputs,
        and the conjugate transpose of `V` for complex inputs.
        If :attr:`input` is a batch of matrices, then `U`, `S`, and `V` are also
        batched with the same batch dimensions as :attr:`input`.

        If :attr:`some` is `True` (default), the method returns the reduced singular
        value decomposition. In this case, if the last two dimensions of :attr:`input` are
        `m` and `n`, then the returned `U` and `V` matrices will contain only
        `min(n, m)` orthonormal columns.

        If :attr:`compute_uv` is `False`, the returned `U` and `V` will be
        zero-filled matrices of shape `(m, m)` and `(n, n)`
        respectively, and the same device as :attr:`input`. The argument :attr:`some`
        has no effect when :attr:`compute_uv` is `False`.

        Supports :attr:`input` of float, double, cfloat and cdouble data types.
        The dtypes of `U` and `V` are the same as :attr:`input`'s. `S` will
        always be real-valued, even if :attr:`input` is complex.

        .. warning::

            :func:`torch.svd` is deprecated in favor of :func:`torch.linalg.svd`
            and will be removed in a future PyTorch release.

            ``U, S, V = torch.svd(A, some=some, compute_uv=True)`` (default) should be replaced with

            .. code:: python

                U, S, Vh = torch.linalg.svd(A, full_matrices=not some)
                V = Vh.mH

            ``_, S, _ = torch.svd(A, some=some, compute_uv=False)`` should be replaced with

            .. code:: python

                S = torch.linalg.svdvals(A)

        .. note:: Differences with :func:`torch.linalg.svd`:

                     * :attr:`some` is the opposite of
                       :func:`torch.linalg.svd`'s :attr:`full_matrices`. Note that
                       default value for both is `True`, so the default behavior is
                       effectively the opposite.
                     * :func:`torch.svd` returns `V`, whereas :func:`torch.linalg.svd` returns
                       `Vh`, that is, :math:`V^{\\text{H}}`.
                     * If :attr:`compute_uv` is `False`, :func:`torch.svd` returns zero-filled
                       tensors for `U` and `Vh`, whereas :func:`torch.linalg.svd` returns
                       empty tensors.

        .. note:: The singular values are returned in descending order. If :attr:`input` is a batch of matrices,
                  then the singular values of each matrix in the batch are returned in descending order.

        .. note:: The `S` tensor can only be used to compute gradients if :attr:`compute_uv` is `True`.

        .. note:: When :attr:`some` is `False`, the gradients on `U[..., :, min(m, n):]`
                  and `V[..., :, min(m, n):]` will be ignored in the backward pass, as those vectors
                  can be arbitrary bases of the corresponding subspaces.

        .. note:: The implementation of :func:`torch.linalg.svd` on CPU uses LAPACK's routine `?gesdd`
                  (a divide-and-conquer algorithm) instead of `?gesvd` for speed. Analogously,
                  on GPU, it uses cuSOLVER's routines `gesvdj` and `gesvdjBatched` on CUDA 10.1.243
                  and later, and MAGMA's routine `gesdd` on earlier versions of CUDA.

        .. note:: The returned `U` will not be contiguous. The matrix (or batch of matrices) will
                  be represented as a column-major matrix (i.e. Fortran-contiguous).

        .. warning:: The gradients with respect to `U` and `V` will only be finite when the input does not
                     have zero nor repeated singular values.

        .. warning:: If the distance between any two singular values is close to zero, the gradients with respect to
                     `U` and `V` will be numerically unstable, as they depends on
                     :math:`\\frac{1}{\\min_{i \\neq j} \\sigma_i^2 - \\sigma_j^2}`. The same happens when the matrix
                     has small singular values, as these gradients also depend on `S^{-1}`.

        .. warning:: For complex-valued :attr:`input` the singular value decomposition is not unique,
                     as `U` and `V` may be multiplied by an arbitrary phase factor :math:`e^{i \\phi}` on every column.
                     The same happens when :attr:`input` has repeated singular values, where one may multiply
                     the columns of the spanning subspace in `U` and `V` by a rotation matrix
                     and `the resulting vectors will span the same subspace`_.
                     Different platforms, like NumPy, or inputs on different device types,
                     may produce different `U` and `V` tensors.

        Args:
            input (Tensor): the input tensor of size `(*, m, n)` where `*` is zero or more
                            batch dimensions consisting of `(m, n)` matrices.
            some (bool, optional): controls whether to compute the reduced or full decomposition, and
                                   consequently, the shape of returned `U` and `V`. Default: `True`.
            compute_uv (bool, optional): controls whether to compute `U` and `V`. Default: `True`.

        Keyword args:
            out (tuple, optional): the output tuple of tensors

        Example::

            >>> a = torch.randn(5, 3)
            >>> a
            tensor([[ 0.2364, -0.7752,  0.6372],
                    [ 1.7201,  0.7394, -0.0504],
                    [-0.3371, -1.0584,  0.5296],
                    [ 0.3550, -0.4022,  1.5569],
                    [ 0.2445, -0.0158,  1.1414]])
            >>> u, s, v = torch.svd(a)
            >>> u
            tensor([[ 0.4027,  0.0287,  0.5434],
                    [-0.1946,  0.8833,  0.3679],
                    [ 0.4296, -0.2890,  0.5261],
                    [ 0.6604,  0.2717, -0.2618],
                    [ 0.4234,  0.2481, -0.4733]])
            >>> s
            tensor([2.3289, 2.0315, 0.7806])
            >>> v
            tensor([[-0.0199,  0.8766,  0.4809],
                    [-0.5080,  0.4054, -0.7600],
                    [ 0.8611,  0.2594, -0.4373]])
            >>> torch.dist(a, torch.mm(torch.mm(u, torch.diag(s)), v.t()))
            tensor(8.6531e-07)
            >>> a_big = torch.randn(7, 5, 3)
            >>> u, s, v = torch.svd(a_big)
            >>> torch.dist(a_big, torch.matmul(torch.matmul(u, torch.diag_embed(s)), v.mT))
            tensor(2.6503e-06)

        .. _the resulting vectors will span the same subspace:
               (https://en.wikipedia.org/wiki/Singular_value_decomposition#Singular_values,_singular_vectors,_and_their_relation_to_the_SVD)
        """
    @staticmethod
    def swapaxes(input, axis0, axis1) -> Tensor:
        """
        swapaxes(input, axis0, axis1) -> Tensor

        Alias for :func:`torch.transpose`.

        This function is equivalent to NumPy's swapaxes function.

        Examples::

            >>> x = torch.tensor([[[0,1],[2,3]],[[4,5],[6,7]]])
            >>> x
            tensor([[[0, 1],
                    [2, 3]],

                    [[4, 5],
                    [6, 7]]])
            >>> torch.swapaxes(x, 0, 1)
            tensor([[[0, 1],
                    [4, 5]],

                    [[2, 3],
                    [6, 7]]])
            >>> torch.swapaxes(x, 0, 2)
            tensor([[[0, 4],
                    [2, 6]],

                    [[1, 5],
                    [3, 7]]])
        """
    @staticmethod
    def swapdims(input, dim0, dim1) -> Tensor:
        """
        swapdims(input, dim0, dim1) -> Tensor

        Alias for :func:`torch.transpose`.

        This function is equivalent to NumPy's swapaxes function.

        Examples::

            >>> x = torch.tensor([[[0,1],[2,3]],[[4,5],[6,7]]])
            >>> x
            tensor([[[0, 1],
                    [2, 3]],

                    [[4, 5],
                    [6, 7]]])
            >>> torch.swapdims(x, 0, 1)
            tensor([[[0, 1],
                    [4, 5]],

                    [[2, 3],
                    [6, 7]]])
            >>> torch.swapdims(x, 0, 2)
            tensor([[[0, 4],
                    [2, 6]],

                    [[1, 5],
                    [3, 7]]])
        """
    @staticmethod
    def sym_constrain_range(*args, **kwargs): ...
    @staticmethod
    def sym_constrain_range_for_size(*args, **kwargs): ...
    @overload
    @staticmethod
    def t(input) -> Tensor:
        """
        t(input) -> Tensor

        Expects :attr:`input` to be <= 2-D tensor and transposes dimensions 0
        and 1.

        0-D and 1-D tensors are returned as is. When input is a 2-D tensor this
        is equivalent to ``transpose(input, 0, 1)``.

        Args:
            input (Tensor): the input tensor.

        Example::

            >>> x = torch.randn(())
            >>> x
            tensor(0.1995)
            >>> torch.t(x)
            tensor(0.1995)
            >>> x = torch.randn(3)
            >>> x
            tensor([ 2.4320, -0.4608,  0.7702])
            >>> torch.t(x)
            tensor([ 2.4320, -0.4608,  0.7702])
            >>> x = torch.randn(2, 3)
            >>> x
            tensor([[ 0.4875,  0.9158, -0.5872],
                    [ 0.3938, -0.6929,  0.6932]])
            >>> torch.t(x)
            tensor([[ 0.4875,  0.3938],
                    [ 0.9158, -0.6929],
                    [-0.5872,  0.6932]])

        See also :func:`torch.transpose`.
        """
    @overload
    @staticmethod
    def t(x) -> Any:
        """
        t(input) -> Tensor

        Expects :attr:`input` to be <= 2-D tensor and transposes dimensions 0
        and 1.

        0-D and 1-D tensors are returned as is. When input is a 2-D tensor this
        is equivalent to ``transpose(input, 0, 1)``.

        Args:
            input (Tensor): the input tensor.

        Example::

            >>> x = torch.randn(())
            >>> x
            tensor(0.1995)
            >>> torch.t(x)
            tensor(0.1995)
            >>> x = torch.randn(3)
            >>> x
            tensor([ 2.4320, -0.4608,  0.7702])
            >>> torch.t(x)
            tensor([ 2.4320, -0.4608,  0.7702])
            >>> x = torch.randn(2, 3)
            >>> x
            tensor([[ 0.4875,  0.9158, -0.5872],
                    [ 0.3938, -0.6929,  0.6932]])
            >>> torch.t(x)
            tensor([[ 0.4875,  0.3938],
                    [ 0.9158, -0.6929],
                    [-0.5872,  0.6932]])

        See also :func:`torch.transpose`.
        """
    @overload
    @staticmethod
    def t(x) -> Any:
        """
        t(input) -> Tensor

        Expects :attr:`input` to be <= 2-D tensor and transposes dimensions 0
        and 1.

        0-D and 1-D tensors are returned as is. When input is a 2-D tensor this
        is equivalent to ``transpose(input, 0, 1)``.

        Args:
            input (Tensor): the input tensor.

        Example::

            >>> x = torch.randn(())
            >>> x
            tensor(0.1995)
            >>> torch.t(x)
            tensor(0.1995)
            >>> x = torch.randn(3)
            >>> x
            tensor([ 2.4320, -0.4608,  0.7702])
            >>> torch.t(x)
            tensor([ 2.4320, -0.4608,  0.7702])
            >>> x = torch.randn(2, 3)
            >>> x
            tensor([[ 0.4875,  0.9158, -0.5872],
                    [ 0.3938, -0.6929,  0.6932]])
            >>> torch.t(x)
            tensor([[ 0.4875,  0.3938],
                    [ 0.9158, -0.6929],
                    [-0.5872,  0.6932]])

        See also :func:`torch.transpose`.
        """
    @overload
    @staticmethod
    def t(x) -> Any:
        """
        t(input) -> Tensor

        Expects :attr:`input` to be <= 2-D tensor and transposes dimensions 0
        and 1.

        0-D and 1-D tensors are returned as is. When input is a 2-D tensor this
        is equivalent to ``transpose(input, 0, 1)``.

        Args:
            input (Tensor): the input tensor.

        Example::

            >>> x = torch.randn(())
            >>> x
            tensor(0.1995)
            >>> torch.t(x)
            tensor(0.1995)
            >>> x = torch.randn(3)
            >>> x
            tensor([ 2.4320, -0.4608,  0.7702])
            >>> torch.t(x)
            tensor([ 2.4320, -0.4608,  0.7702])
            >>> x = torch.randn(2, 3)
            >>> x
            tensor([[ 0.4875,  0.9158, -0.5872],
                    [ 0.3938, -0.6929,  0.6932]])
            >>> torch.t(x)
            tensor([[ 0.4875,  0.3938],
                    [ 0.9158, -0.6929],
                    [-0.5872,  0.6932]])

        See also :func:`torch.transpose`.
        """
    @staticmethod
    def t_copy(*args, **kwargs):
        """
        Performs the same operation as :func:`torch.t`, but all output tensors
        are freshly created instead of aliasing the input.
        """
    @staticmethod
    def take(input, index) -> Tensor:
        """
        take(input, index) -> Tensor

        Returns a new tensor with the elements of :attr:`input` at the given indices.
        The input tensor is treated as if it were viewed as a 1-D tensor. The result
        takes the same shape as the indices.

        Args:
            input (Tensor): the input tensor.
            index (LongTensor): the indices into tensor

        Example::

            >>> src = torch.tensor([[4, 3, 5],
            ...                     [6, 7, 8]])
            >>> torch.take(src, torch.tensor([0, 2, 5]))
            tensor([ 4,  5,  8])
        """
    @staticmethod
    def take_along_dim(input, indices, dim=..., out=...) -> Tensor:
        """
        take_along_dim(input, indices, dim=None, *, out=None) -> Tensor

        Selects values from :attr:`input` at the 1-dimensional indices from :attr:`indices` along the given :attr:`dim`.

        If :attr:`dim` is None, the input array is treated as if it has been flattened to 1d.

        Functions that return indices along a dimension, like :func:`torch.argmax` and :func:`torch.argsort`,
        are designed to work with this function. See the examples below.

        .. note::
            This function is similar to NumPy's `take_along_axis`.
            See also :func:`torch.gather`.

        Args:
            input (Tensor): the input tensor.
            indices (LongTensor): the indices into :attr:`input`. Must have long dtype.
            dim (int, optional): dimension to select along. Default: 0

        Keyword args:
            out (Tensor, optional): the output tensor.

        Example::

            >>> t = torch.tensor([[10, 30, 20], [60, 40, 50]])
            >>> max_idx = torch.argmax(t)
            >>> torch.take_along_dim(t, max_idx)
            tensor([60])
            >>> sorted_idx = torch.argsort(t, dim=1)
            >>> torch.take_along_dim(t, sorted_idx, dim=1)
            tensor([[10, 20, 30],
                    [40, 50, 60]])
        """
    @staticmethod
    def tan(input, out=...) -> Tensor:
        """
        tan(input, *, out=None) -> Tensor

        Returns a new tensor with the tangent of the elements of :attr:`input`.

        .. math::
            \\text{out}_{i} = \\tan(\\text{input}_{i})

        Args:
            input (Tensor): the input tensor.

        Keyword args:
            out (Tensor, optional): the output tensor.

        Example::

            >>> a = torch.randn(4)
            >>> a
            tensor([-1.2027, -1.7687,  0.4412, -1.3856])
            >>> torch.tan(a)
            tensor([-2.5930,  4.9859,  0.4722, -5.3366])
        """
    @staticmethod
    def tan_(*args, **kwargs): ...
    @staticmethod
    def tanh(input, out=...) -> Tensor:
        """
        tanh(input, *, out=None) -> Tensor

        Returns a new tensor with the hyperbolic tangent of the elements
        of :attr:`input`.

        .. math::
            \\text{out}_{i} = \\tanh(\\text{input}_{i})

        Args:
            input (Tensor): the input tensor.

        Keyword args:
            out (Tensor, optional): the output tensor.

        Example::

            >>> a = torch.randn(4)
            >>> a
            tensor([ 0.8986, -0.7279,  1.1745,  0.2611])
            >>> torch.tanh(a)
            tensor([ 0.7156, -0.6218,  0.8257,  0.2553])
        """
    @staticmethod
    def tanh_(*args, **kwargs): ...
    @overload
    @staticmethod
    def tensor(data, dtype=..., device=..., requires_grad=..., pin_memory=...) -> Tensor:
        '''
        tensor(data, *, dtype=None, device=None, requires_grad=False, pin_memory=False) -> Tensor

        Constructs a tensor with no autograd history (also known as a "leaf tensor", see :doc:`/notes/autograd`) by copying :attr:`data`.

        .. warning::

            When working with tensors prefer using :func:`torch.Tensor.clone`,
            :func:`torch.Tensor.detach`, and :func:`torch.Tensor.requires_grad_` for
            readability. Letting `t` be a tensor, ``torch.tensor(t)`` is equivalent to
            ``t.detach().clone()``, and ``torch.tensor(t, requires_grad=True)``
            is equivalent to ``t.detach().clone().requires_grad_(True)``.

        .. seealso::

            :func:`torch.as_tensor` preserves autograd history and avoids copies where possible.
            :func:`torch.from_numpy` creates a tensor that shares storage with a NumPy array.

        Args:
            data (array_like): Initial data for the tensor. Can be a list, tuple,
                NumPy ``ndarray``, scalar, and other types.

        Keyword args:
            dtype (:class:`torch.dtype`, optional): the desired data type of returned tensor.
                Default: if ``None``, infers data type from :attr:`data`.
            device (:class:`torch.device`, optional): the device of the constructed tensor. If None and data is a tensor
                then the device of data is used. If None and data is not a tensor then
                the result tensor is constructed on the current device.
            requires_grad (bool, optional): If autograd should record operations on the
                returned tensor. Default: ``False``.
            pin_memory (bool, optional): If set, returned tensor would be allocated in
                the pinned memory. Works only for CPU tensors. Default: ``False``.


        Example::

            >>> torch.tensor([[0.1, 1.2], [2.2, 3.1], [4.9, 5.2]])
            tensor([[ 0.1000,  1.2000],
                    [ 2.2000,  3.1000],
                    [ 4.9000,  5.2000]])

            >>> torch.tensor([0, 1])  # Type inference on data
            tensor([ 0,  1])

            >>> torch.tensor([[0.11111, 0.222222, 0.3333333]],
            ...              dtype=torch.float64,
            ...              device=torch.device(\'cuda:0\'))  # creates a double tensor on a CUDA device
            tensor([[ 0.1111,  0.2222,  0.3333]], dtype=torch.float64, device=\'cuda:0\')

            >>> torch.tensor(3.14159)  # Create a zero-dimensional (scalar) tensor
            tensor(3.1416)

            >>> torch.tensor([])  # Create an empty tensor (of size (0,))
            tensor([])
        '''
    @overload
    @staticmethod
    def tensor(t) -> Any:
        '''
        tensor(data, *, dtype=None, device=None, requires_grad=False, pin_memory=False) -> Tensor

        Constructs a tensor with no autograd history (also known as a "leaf tensor", see :doc:`/notes/autograd`) by copying :attr:`data`.

        .. warning::

            When working with tensors prefer using :func:`torch.Tensor.clone`,
            :func:`torch.Tensor.detach`, and :func:`torch.Tensor.requires_grad_` for
            readability. Letting `t` be a tensor, ``torch.tensor(t)`` is equivalent to
            ``t.detach().clone()``, and ``torch.tensor(t, requires_grad=True)``
            is equivalent to ``t.detach().clone().requires_grad_(True)``.

        .. seealso::

            :func:`torch.as_tensor` preserves autograd history and avoids copies where possible.
            :func:`torch.from_numpy` creates a tensor that shares storage with a NumPy array.

        Args:
            data (array_like): Initial data for the tensor. Can be a list, tuple,
                NumPy ``ndarray``, scalar, and other types.

        Keyword args:
            dtype (:class:`torch.dtype`, optional): the desired data type of returned tensor.
                Default: if ``None``, infers data type from :attr:`data`.
            device (:class:`torch.device`, optional): the device of the constructed tensor. If None and data is a tensor
                then the device of data is used. If None and data is not a tensor then
                the result tensor is constructed on the current device.
            requires_grad (bool, optional): If autograd should record operations on the
                returned tensor. Default: ``False``.
            pin_memory (bool, optional): If set, returned tensor would be allocated in
                the pinned memory. Works only for CPU tensors. Default: ``False``.


        Example::

            >>> torch.tensor([[0.1, 1.2], [2.2, 3.1], [4.9, 5.2]])
            tensor([[ 0.1000,  1.2000],
                    [ 2.2000,  3.1000],
                    [ 4.9000,  5.2000]])

            >>> torch.tensor([0, 1])  # Type inference on data
            tensor([ 0,  1])

            >>> torch.tensor([[0.11111, 0.222222, 0.3333333]],
            ...              dtype=torch.float64,
            ...              device=torch.device(\'cuda:0\'))  # creates a double tensor on a CUDA device
            tensor([[ 0.1111,  0.2222,  0.3333]], dtype=torch.float64, device=\'cuda:0\')

            >>> torch.tensor(3.14159)  # Create a zero-dimensional (scalar) tensor
            tensor(3.1416)

            >>> torch.tensor([])  # Create an empty tensor (of size (0,))
            tensor([])
        '''
    @overload
    @staticmethod
    def tensor(t, requires_grad=...) -> Any:
        '''
        tensor(data, *, dtype=None, device=None, requires_grad=False, pin_memory=False) -> Tensor

        Constructs a tensor with no autograd history (also known as a "leaf tensor", see :doc:`/notes/autograd`) by copying :attr:`data`.

        .. warning::

            When working with tensors prefer using :func:`torch.Tensor.clone`,
            :func:`torch.Tensor.detach`, and :func:`torch.Tensor.requires_grad_` for
            readability. Letting `t` be a tensor, ``torch.tensor(t)`` is equivalent to
            ``t.detach().clone()``, and ``torch.tensor(t, requires_grad=True)``
            is equivalent to ``t.detach().clone().requires_grad_(True)``.

        .. seealso::

            :func:`torch.as_tensor` preserves autograd history and avoids copies where possible.
            :func:`torch.from_numpy` creates a tensor that shares storage with a NumPy array.

        Args:
            data (array_like): Initial data for the tensor. Can be a list, tuple,
                NumPy ``ndarray``, scalar, and other types.

        Keyword args:
            dtype (:class:`torch.dtype`, optional): the desired data type of returned tensor.
                Default: if ``None``, infers data type from :attr:`data`.
            device (:class:`torch.device`, optional): the device of the constructed tensor. If None and data is a tensor
                then the device of data is used. If None and data is not a tensor then
                the result tensor is constructed on the current device.
            requires_grad (bool, optional): If autograd should record operations on the
                returned tensor. Default: ``False``.
            pin_memory (bool, optional): If set, returned tensor would be allocated in
                the pinned memory. Works only for CPU tensors. Default: ``False``.


        Example::

            >>> torch.tensor([[0.1, 1.2], [2.2, 3.1], [4.9, 5.2]])
            tensor([[ 0.1000,  1.2000],
                    [ 2.2000,  3.1000],
                    [ 4.9000,  5.2000]])

            >>> torch.tensor([0, 1])  # Type inference on data
            tensor([ 0,  1])

            >>> torch.tensor([[0.11111, 0.222222, 0.3333333]],
            ...              dtype=torch.float64,
            ...              device=torch.device(\'cuda:0\'))  # creates a double tensor on a CUDA device
            tensor([[ 0.1111,  0.2222,  0.3333]], dtype=torch.float64, device=\'cuda:0\')

            >>> torch.tensor(3.14159)  # Create a zero-dimensional (scalar) tensor
            tensor(3.1416)

            >>> torch.tensor([])  # Create an empty tensor (of size (0,))
            tensor([])
        '''
    @staticmethod
    def tensor_split(input, indices_or_sections, dim=...) -> ListofTensors:
        """
        tensor_split(input, indices_or_sections, dim=0) -> List of Tensors

        Splits a tensor into multiple sub-tensors, all of which are views of :attr:`input`,
        along dimension :attr:`dim` according to the indices or number of sections specified
        by :attr:`indices_or_sections`. This function is based on NumPy's
        :func:`numpy.array_split`.

        Args:
            input (Tensor): the tensor to split
            indices_or_sections (Tensor, int or list or tuple of ints):
                If :attr:`indices_or_sections` is an integer ``n`` or a zero dimensional long tensor
                with value ``n``, :attr:`input` is split into ``n`` sections along dimension :attr:`dim`.
                If :attr:`input` is divisible by ``n`` along dimension :attr:`dim`, each
                section will be of equal size, :code:`input.size(dim) / n`. If :attr:`input`
                is not divisible by ``n``, the sizes of the first :code:`int(input.size(dim) % n)`
                sections will have size :code:`int(input.size(dim) / n) + 1`, and the rest will
                have size :code:`int(input.size(dim) / n)`.

                If :attr:`indices_or_sections` is a list or tuple of ints, or a one-dimensional long
                tensor, then :attr:`input` is split along dimension :attr:`dim` at each of the indices
                in the list, tuple or tensor. For instance, :code:`indices_or_sections=[2, 3]` and :code:`dim=0`
                would result in the tensors :code:`input[:2]`, :code:`input[2:3]`, and :code:`input[3:]`.

                If :attr:`indices_or_sections` is a tensor, it must be a zero-dimensional or one-dimensional
                long tensor on the CPU.

            dim (int, optional): dimension along which to split the tensor. Default: ``0``

        Example::

            >>> x = torch.arange(8)
            >>> torch.tensor_split(x, 3)
            (tensor([0, 1, 2]), tensor([3, 4, 5]), tensor([6, 7]))

            >>> x = torch.arange(7)
            >>> torch.tensor_split(x, 3)
            (tensor([0, 1, 2]), tensor([3, 4]), tensor([5, 6]))
            >>> torch.tensor_split(x, (1, 6))
            (tensor([0]), tensor([1, 2, 3, 4, 5]), tensor([6]))

            >>> x = torch.arange(14).reshape(2, 7)
            >>> x
            tensor([[ 0,  1,  2,  3,  4,  5,  6],
                    [ 7,  8,  9, 10, 11, 12, 13]])
            >>> torch.tensor_split(x, 3, dim=1)
            (tensor([[0, 1, 2],
                    [7, 8, 9]]),
             tensor([[ 3,  4],
                    [10, 11]]),
             tensor([[ 5,  6],
                    [12, 13]]))
            >>> torch.tensor_split(x, (1, 6), dim=1)
            (tensor([[0],
                    [7]]),
             tensor([[ 1,  2,  3,  4,  5],
                    [ 8,  9, 10, 11, 12]]),
             tensor([[ 6],
                    [13]]))
        """
    @staticmethod
    def tensordot(*args, **kwargs): ...
    @staticmethod
    def threshold(*args, **kwargs): ...
    @staticmethod
    def threshold_(input, threshold, value) -> Tensor:
        """
        threshold_(input, threshold, value) -> Tensor

        In-place version of :func:`~threshold`.
        """
    @staticmethod
    def tile(input, dims) -> Tensor:
        """
        tile(input, dims) -> Tensor

        Constructs a tensor by repeating the elements of :attr:`input`.
        The :attr:`dims` argument specifies the number of repetitions
        in each dimension.

        If :attr:`dims` specifies fewer dimensions than :attr:`input` has, then
        ones are prepended to :attr:`dims` until all dimensions are specified.
        For example, if :attr:`input` has shape (8, 6, 4, 2) and :attr:`dims`
        is (2, 2), then :attr:`dims` is treated as (1, 1, 2, 2).

        Analogously, if :attr:`input` has fewer dimensions than :attr:`dims`
        specifies, then :attr:`input` is treated as if it were unsqueezed at
        dimension zero until it has as many dimensions as :attr:`dims` specifies.
        For example, if :attr:`input` has shape (4, 2) and :attr:`dims`
        is (3, 3, 2, 2), then :attr:`input` is treated as if it had the
        shape (1, 1, 4, 2).

        .. note::

            This function is similar to NumPy's tile function.

        Args:
            input (Tensor): the tensor whose elements to repeat.
            dims (tuple): the number of repetitions per dimension.

        Example::

            >>> x = torch.tensor([1, 2, 3])
            >>> x.tile((2,))
            tensor([1, 2, 3, 1, 2, 3])
            >>> y = torch.tensor([[1, 2], [3, 4]])
            >>> torch.tile(y, (2, 2))
            tensor([[1, 2, 1, 2],
                    [3, 4, 3, 4],
                    [1, 2, 1, 2],
                    [3, 4, 3, 4]])
        """
    @staticmethod
    def topk(values=..., indices=...) -> Any:
        '''
        topk(input, k, dim=None, largest=True, sorted=True, *, out=None) -> (Tensor, LongTensor)

        Returns the :attr:`k` largest elements of the given :attr:`input` tensor along
        a given dimension.

        If :attr:`dim` is not given, the last dimension of the `input` is chosen.

        If :attr:`largest` is ``False`` then the `k` smallest elements are returned.

        A namedtuple of `(values, indices)` is returned with the `values` and
        `indices` of the largest `k` elements of each row of the `input` tensor in the
        given dimension `dim`.

        The boolean option :attr:`sorted` if ``True``, will make sure that the returned
        `k` elements are themselves sorted

        .. note::
            When using `torch.topk`, the indices of tied elements are not guaranteed to be stable
            and may vary across different invocations.

        Args:
            input (Tensor): the input tensor.
            k (int): the k in "top-k"
            dim (int, optional): the dimension to sort along
            largest (bool, optional): controls whether to return largest or
                   smallest elements
            sorted (bool, optional): controls whether to return the elements
                   in sorted order

        Keyword args:
            out (tuple, optional): the output tuple of (Tensor, LongTensor) that can be
                optionally given to be used as output buffers

        Example::

            >>> x = torch.arange(1., 6.)
            >>> x
            tensor([ 1.,  2.,  3.,  4.,  5.])
            >>> torch.topk(x, 3)
            torch.return_types.topk(values=tensor([5., 4., 3.]), indices=tensor([4, 3, 2]))
        '''
    @overload
    @staticmethod
    def trace(input) -> Tensor:
        """
        trace(input) -> Tensor

        Returns the sum of the elements of the diagonal of the input 2-D matrix.

        Example::

            >>> x = torch.arange(1., 10.).view(3, 3)
            >>> x
            tensor([[ 1.,  2.,  3.],
                    [ 4.,  5.,  6.],
                    [ 7.,  8.,  9.]])
            >>> torch.trace(x)
            tensor(15.)
        """
    @overload
    @staticmethod
    def trace(x) -> Any:
        """
        trace(input) -> Tensor

        Returns the sum of the elements of the diagonal of the input 2-D matrix.

        Example::

            >>> x = torch.arange(1., 10.).view(3, 3)
            >>> x
            tensor([[ 1.,  2.,  3.],
                    [ 4.,  5.,  6.],
                    [ 7.,  8.,  9.]])
            >>> torch.trace(x)
            tensor(15.)
        """
    @staticmethod
    def transpose(input, dim0, dim1) -> Tensor:
        """
        transpose(input, dim0, dim1) -> Tensor

        Returns a tensor that is a transposed version of :attr:`input`.
        The given dimensions :attr:`dim0` and :attr:`dim1` are swapped.

        If :attr:`input` is a strided tensor then the resulting :attr:`out`
        tensor shares its underlying storage with the :attr:`input` tensor, so
        changing the content of one would change the content of the other.

        If :attr:`input` is a :ref:`sparse tensor <sparse-docs>` then the
        resulting :attr:`out` tensor *does not* share the underlying storage
        with the :attr:`input` tensor.

        If :attr:`input` is a :ref:`sparse tensor <sparse-docs>` with compressed
        layout (SparseCSR, SparseBSR, SparseCSC or SparseBSC) the arguments
        :attr:`dim0` and :attr:`dim1` must be both batch dimensions, or must
        both be sparse dimensions. The batch dimensions of a sparse tensor are the
        dimensions preceding the sparse dimensions.

        .. note::
            Transpositions which interchange the sparse dimensions of a `SparseCSR`
            or `SparseCSC` layout tensor will result in the layout changing between
            the two options. Transposition of the sparse dimensions of a ` SparseBSR`
            or `SparseBSC` layout tensor will likewise generate a result with the
            opposite layout.


        Args:
            input (Tensor): the input tensor.
            dim0 (int): the first dimension to be transposed
            dim1 (int): the second dimension to be transposed

        Example::

            >>> x = torch.randn(2, 3)
            >>> x
            tensor([[ 1.0028, -0.9893,  0.5809],
                    [-0.1669,  0.7299,  0.4942]])
            >>> torch.transpose(x, 0, 1)
            tensor([[ 1.0028, -0.1669],
                    [-0.9893,  0.7299],
                    [ 0.5809,  0.4942]])

        See also :func:`torch.t`.
        """
    @staticmethod
    def transpose_copy(*args, **kwargs):
        """
        Performs the same operation as :func:`torch.transpose`, but all output tensors
        are freshly created instead of aliasing the input.
        """
    @staticmethod
    def trapezoid(y, x=..., dx=..., dim=...) -> Tensor:
        """
        trapezoid(y, x=None, *, dx=None, dim=-1) -> Tensor

        Computes the `trapezoidal rule <https://en.wikipedia.org/wiki/Trapezoidal_rule>`_ along
        :attr:`dim`. By default the spacing between elements is assumed to be 1, but
        :attr:`dx` can be used to specify a different constant spacing, and :attr:`x` can be
        used to specify arbitrary spacing along :attr:`dim`. Only one of :attr:`x` or :attr:`dx` should be specified.


        Assuming :attr:`y` is a one-dimensional tensor with elements :math:`{y_0, y_1, ..., y_n}`,
        the default computation is

        .. math::
            \\begin{aligned}
                \\sum_{i = 1}^{n} \\frac{1}{2} (y_i + y_{i-1})
            \\end{aligned}

        When :attr:`dx` is specified the computation becomes

        .. math::
            \\begin{aligned}
                \\sum_{i = 1}^{n} \\frac{\\Delta x}{2} (y_i + y_{i-1})
            \\end{aligned}

        effectively multiplying the result by :attr:`dx`. When :attr:`x` is specified,
        assuming :attr:`x` is also a one-dimensional tensor with
        elements :math:`{x_0, x_1, ..., x_n}`, the computation becomes

        .. math::
            \\begin{aligned}
                \\sum_{i = 1}^{n} \\frac{(x_i - x_{i-1})}{2} (y_i + y_{i-1})
            \\end{aligned}

        When :attr:`x` and :attr:`y` have the same size, the computation is as described above and no broadcasting is needed.
        The broadcasting behavior of this function is as follows when their sizes are different. For both :attr:`x`
        and :attr:`y`, the function computes the difference between consecutive elements along
        dimension :attr:`dim`. This effectively creates two tensors, `x_diff` and `y_diff`, that have
        the same shape as the original tensors except their lengths along the dimension :attr:`dim` is reduced by 1.
        After that, those two tensors are broadcast together to compute final output as part of the trapezoidal rule.
        See the examples below for details.

        .. note::
            The trapezoidal rule is a technique for approximating the definite integral of a function
            by averaging its left and right Riemann sums. The approximation becomes more accurate as
            the resolution of the partition increases.

        Arguments:
            y (Tensor): Values to use when computing the trapezoidal rule.
            x (Tensor): If specified, defines spacing between values as specified above.

        Keyword arguments:
            dx (float): constant spacing between values. If neither :attr:`x` or :attr:`dx`
                are specified then this defaults to 1. Effectively multiplies the result by its value.
            dim (int): The dimension along which to compute the trapezoidal rule.
                The last (inner-most) dimension by default.

        Examples::

            >>> # Computes the trapezoidal rule in 1D, spacing is implicitly 1
            >>> y = torch.tensor([1, 5, 10])
            >>> torch.trapezoid(y)
            tensor(10.5)

            >>> # Computes the same trapezoidal rule directly to verify
            >>> (1 + 10 + 10) / 2
            10.5

            >>> # Computes the trapezoidal rule in 1D with constant spacing of 2
            >>> # NOTE: the result is the same as before, but multiplied by 2
            >>> torch.trapezoid(y, dx=2)
            21.0

            >>> # Computes the trapezoidal rule in 1D with arbitrary spacing
            >>> x = torch.tensor([1, 3, 6])
            >>> torch.trapezoid(y, x)
            28.5

            >>> # Computes the same trapezoidal rule directly to verify
            >>> ((3 - 1) * (1 + 5) + (6 - 3) * (5 + 10)) / 2
            28.5

            >>> # Computes the trapezoidal rule for each row of a 3x3 matrix
            >>> y = torch.arange(9).reshape(3, 3)
            tensor([[0, 1, 2],
                    [3, 4, 5],
                    [6, 7, 8]])
            >>> torch.trapezoid(y)
            tensor([ 2., 8., 14.])

            >>> # Computes the trapezoidal rule for each column of the matrix
            >>> torch.trapezoid(y, dim=0)
            tensor([ 6., 8., 10.])

            >>> # Computes the trapezoidal rule for each row of a 3x3 ones matrix
            >>> #   with the same arbitrary spacing
            >>> y = torch.ones(3, 3)
            >>> x = torch.tensor([1, 3, 6])
            >>> torch.trapezoid(y, x)
            array([5., 5., 5.])

            >>> # Computes the trapezoidal rule for each row of a 3x3 ones matrix
            >>> #   with different arbitrary spacing per row
            >>> y = torch.ones(3, 3)
            >>> x = torch.tensor([[1, 2, 3], [1, 3, 5], [1, 4, 7]])
            >>> torch.trapezoid(y, x)
            array([2., 4., 6.])
        """
    @staticmethod
    def trapz(y, x, dim=...) -> Tensor:
        """
        trapz(y, x, *, dim=-1) -> Tensor

        Alias for :func:`torch.trapezoid`.
        """
    @staticmethod
    def triangular_solve(*args, **kwargs):
        """
        triangular_solve(b, A, upper=True, transpose=False, unitriangular=False, *, out=None) -> (Tensor, Tensor)

        Solves a system of equations with a square upper or lower triangular invertible matrix :math:`A`
        and multiple right-hand sides :math:`b`.

        In symbols, it solves :math:`AX = b` and assumes :math:`A` is square upper-triangular
        (or lower-triangular if :attr:`upper`\\ `= False`) and does not have zeros on the diagonal.

        `torch.triangular_solve(b, A)` can take in 2D inputs `b, A` or inputs that are
        batches of 2D matrices. If the inputs are batches, then returns
        batched outputs `X`

        If the diagonal of :attr:`A` contains zeros or elements that are very close to zero and
        :attr:`unitriangular`\\ `= False` (default) or if the input matrix is badly conditioned,
        the result may contain `NaN` s.

        Supports input of float, double, cfloat and cdouble data types.

        .. warning::

            :func:`torch.triangular_solve` is deprecated in favor of :func:`torch.linalg.solve_triangular`
            and will be removed in a future PyTorch release.
            :func:`torch.linalg.solve_triangular` has its arguments reversed and does not return a
            copy of one of the inputs.

            ``X = torch.triangular_solve(B, A).solution`` should be replaced with

            .. code:: python

                X = torch.linalg.solve_triangular(A, B)

        Args:
            b (Tensor): multiple right-hand sides of size :math:`(*, m, k)` where
                        :math:`*` is zero of more batch dimensions
            A (Tensor): the input triangular coefficient matrix of size :math:`(*, m, m)`
                        where :math:`*` is zero or more batch dimensions
            upper (bool, optional): whether :math:`A` is upper or lower triangular. Default: ``True``.
            transpose (bool, optional): solves `op(A)X = b` where `op(A) = A^T` if this flag is ``True``,
                                        and `op(A) = A` if it is ``False``. Default: ``False``.
            unitriangular (bool, optional): whether :math:`A` is unit triangular.
                If True, the diagonal elements of :math:`A` are assumed to be
                1 and not referenced from :math:`A`. Default: ``False``.

        Keyword args:
            out ((Tensor, Tensor), optional): tuple of two tensors to write
                the output to. Ignored if `None`. Default: `None`.

        Returns:
            A namedtuple `(solution, cloned_coefficient)` where `cloned_coefficient`
            is a clone of :math:`A` and `solution` is the solution :math:`X` to :math:`AX = b`
            (or whatever variant of the system of equations, depending on the keyword arguments.)

        Examples::

            >>> A = torch.randn(2, 2).triu()
            >>> A
            tensor([[ 1.1527, -1.0753],
                    [ 0.0000,  0.7986]])
            >>> b = torch.randn(2, 3)
            >>> b
            tensor([[-0.0210,  2.3513, -1.5492],
                    [ 1.5429,  0.7403, -1.0243]])
            >>> torch.triangular_solve(b, A)
            torch.return_types.triangular_solve(
            solution=tensor([[ 1.7841,  2.9046, -2.5405],
                    [ 1.9320,  0.9270, -1.2826]]),
            cloned_coefficient=tensor([[ 1.1527, -1.0753],
                    [ 0.0000,  0.7986]]))
        """
    @staticmethod
    def tril(input, diagonal=..., out=...) -> Tensor:
        """
        tril(input, diagonal=0, *, out=None) -> Tensor

        Returns the lower triangular part of the matrix (2-D tensor) or batch of matrices
        :attr:`input`, the other elements of the result tensor :attr:`out` are set to 0.

        The lower triangular part of the matrix is defined as the elements on and
        below the diagonal.

        The argument :attr:`diagonal` controls which diagonal to consider. If
        :attr:`diagonal` = 0, all elements on and below the main diagonal are
        retained. A positive value includes just as many diagonals above the main
        diagonal, and similarly a negative value excludes just as many diagonals below
        the main diagonal. The main diagonal are the set of indices
        :math:`\\lbrace (i, i) \\rbrace` for :math:`i \\in [0, \\min\\{d_{1}, d_{2}\\} - 1]` where
        :math:`d_{1}, d_{2}` are the dimensions of the matrix.

        Args:
            input (Tensor): the input tensor.
            diagonal (int, optional): the diagonal to consider

        Keyword args:
            out (Tensor, optional): the output tensor.

        Example::

            >>> a = torch.randn(3, 3)
            >>> a
            tensor([[-1.0813, -0.8619,  0.7105],
                    [ 0.0935,  0.1380,  2.2112],
                    [-0.3409, -0.9828,  0.0289]])
            >>> torch.tril(a)
            tensor([[-1.0813,  0.0000,  0.0000],
                    [ 0.0935,  0.1380,  0.0000],
                    [-0.3409, -0.9828,  0.0289]])

            >>> b = torch.randn(4, 6)
            >>> b
            tensor([[ 1.2219,  0.5653, -0.2521, -0.2345,  1.2544,  0.3461],
                    [ 0.4785, -0.4477,  0.6049,  0.6368,  0.8775,  0.7145],
                    [ 1.1502,  3.2716, -1.1243, -0.5413,  0.3615,  0.6864],
                    [-0.0614, -0.7344, -1.3164, -0.7648, -1.4024,  0.0978]])
            >>> torch.tril(b, diagonal=1)
            tensor([[ 1.2219,  0.5653,  0.0000,  0.0000,  0.0000,  0.0000],
                    [ 0.4785, -0.4477,  0.6049,  0.0000,  0.0000,  0.0000],
                    [ 1.1502,  3.2716, -1.1243, -0.5413,  0.0000,  0.0000],
                    [-0.0614, -0.7344, -1.3164, -0.7648, -1.4024,  0.0000]])
            >>> torch.tril(b, diagonal=-1)
            tensor([[ 0.0000,  0.0000,  0.0000,  0.0000,  0.0000,  0.0000],
                    [ 0.4785,  0.0000,  0.0000,  0.0000,  0.0000,  0.0000],
                    [ 1.1502,  3.2716,  0.0000,  0.0000,  0.0000,  0.0000],
                    [-0.0614, -0.7344, -1.3164,  0.0000,  0.0000,  0.0000]])
        """
    @staticmethod
    def tril_indices(row, col, offset=..., dtype=..., device=..., layout=...) -> Tensor:
        """
        tril_indices(row, col, offset=0, *, dtype=torch.long, device='cpu', layout=torch.strided) -> Tensor

        Returns the indices of the lower triangular part of a :attr:`row`-by-
        :attr:`col` matrix in a 2-by-N Tensor, where the first row contains row
        coordinates of all indices and the second row contains column coordinates.
        Indices are ordered based on rows and then columns.

        The lower triangular part of the matrix is defined as the elements on and
        below the diagonal.

        The argument :attr:`offset` controls which diagonal to consider. If
        :attr:`offset` = 0, all elements on and below the main diagonal are
        retained. A positive value includes just as many diagonals above the main
        diagonal, and similarly a negative value excludes just as many diagonals below
        the main diagonal. The main diagonal are the set of indices
        :math:`\\lbrace (i, i) \\rbrace` for :math:`i \\in [0, \\min\\{d_{1}, d_{2}\\} - 1]`
        where :math:`d_{1}, d_{2}` are the dimensions of the matrix.

        .. note::
            When running on CUDA, ``row * col`` must be less than :math:`2^{59}` to
            prevent overflow during calculation.

        Args:
            row (``int``): number of rows in the 2-D matrix.
            col (``int``): number of columns in the 2-D matrix.
            offset (``int``): diagonal offset from the main diagonal.
                Default: if not provided, 0.

        Keyword args:
            dtype (:class:`torch.dtype`, optional): the desired data type of returned tensor,
                only support ``torch.int``, ``torch.long``. Default: if ``None``, ``torch.long``.
            device (:class:`torch.device`, optional): the desired device of returned tensor.
                Default: if ``None``, uses the current device for the default tensor type
                (see :func:`torch.set_default_device`). :attr:`device` will be the CPU
                for CPU tensor types and the current CUDA device for CUDA tensor types.
            layout (:class:`torch.layout`, optional): currently only support ``torch.strided``.

        Example::

            >>> a = torch.tril_indices(3, 3)
            >>> a
            tensor([[0, 1, 1, 2, 2, 2],
                    [0, 0, 1, 0, 1, 2]])

            >>> a = torch.tril_indices(4, 3, -1)
            >>> a
            tensor([[1, 2, 2, 3, 3, 3],
                    [0, 0, 1, 0, 1, 2]])

            >>> a = torch.tril_indices(4, 3, 1)
            >>> a
            tensor([[0, 0, 1, 1, 1, 2, 2, 2, 3, 3, 3],
                    [0, 1, 0, 1, 2, 0, 1, 2, 0, 1, 2]])
        """
    @staticmethod
    def triplet_margin_loss(*args, **kwargs): ...
    @staticmethod
    def triu(input, diagonal=..., out=...) -> Tensor:
        """
        triu(input, diagonal=0, *, out=None) -> Tensor

        Returns the upper triangular part of a matrix (2-D tensor) or batch of matrices
        :attr:`input`, the other elements of the result tensor :attr:`out` are set to 0.

        The upper triangular part of the matrix is defined as the elements on and
        above the diagonal.

        The argument :attr:`diagonal` controls which diagonal to consider. If
        :attr:`diagonal` = 0, all elements on and above the main diagonal are
        retained. A positive value excludes just as many diagonals above the main
        diagonal, and similarly a negative value includes just as many diagonals below
        the main diagonal. The main diagonal are the set of indices
        :math:`\\lbrace (i, i) \\rbrace` for :math:`i \\in [0, \\min\\{d_{1}, d_{2}\\} - 1]` where
        :math:`d_{1}, d_{2}` are the dimensions of the matrix.

        Args:
            input (Tensor): the input tensor.
            diagonal (int, optional): the diagonal to consider

        Keyword args:
            out (Tensor, optional): the output tensor.

        Example::

            >>> a = torch.randn(3, 3)
            >>> a
            tensor([[ 0.2309,  0.5207,  2.0049],
                    [ 0.2072, -1.0680,  0.6602],
                    [ 0.3480, -0.5211, -0.4573]])
            >>> torch.triu(a)
            tensor([[ 0.2309,  0.5207,  2.0049],
                    [ 0.0000, -1.0680,  0.6602],
                    [ 0.0000,  0.0000, -0.4573]])
            >>> torch.triu(a, diagonal=1)
            tensor([[ 0.0000,  0.5207,  2.0049],
                    [ 0.0000,  0.0000,  0.6602],
                    [ 0.0000,  0.0000,  0.0000]])
            >>> torch.triu(a, diagonal=-1)
            tensor([[ 0.2309,  0.5207,  2.0049],
                    [ 0.2072, -1.0680,  0.6602],
                    [ 0.0000, -0.5211, -0.4573]])

            >>> b = torch.randn(4, 6)
            >>> b
            tensor([[ 0.5876, -0.0794, -1.8373,  0.6654,  0.2604,  1.5235],
                    [-0.2447,  0.9556, -1.2919,  1.3378, -0.1768, -1.0857],
                    [ 0.4333,  0.3146,  0.6576, -1.0432,  0.9348, -0.4410],
                    [-0.9888,  1.0679, -1.3337, -1.6556,  0.4798,  0.2830]])
            >>> torch.triu(b, diagonal=1)
            tensor([[ 0.0000, -0.0794, -1.8373,  0.6654,  0.2604,  1.5235],
                    [ 0.0000,  0.0000, -1.2919,  1.3378, -0.1768, -1.0857],
                    [ 0.0000,  0.0000,  0.0000, -1.0432,  0.9348, -0.4410],
                    [ 0.0000,  0.0000,  0.0000,  0.0000,  0.4798,  0.2830]])
            >>> torch.triu(b, diagonal=-1)
            tensor([[ 0.5876, -0.0794, -1.8373,  0.6654,  0.2604,  1.5235],
                    [-0.2447,  0.9556, -1.2919,  1.3378, -0.1768, -1.0857],
                    [ 0.0000,  0.3146,  0.6576, -1.0432,  0.9348, -0.4410],
                    [ 0.0000,  0.0000, -1.3337, -1.6556,  0.4798,  0.2830]])
        """
    @staticmethod
    def triu_indices(row, col, offset=..., dtype=..., device=..., layout=...) -> Tensor:
        """
        triu_indices(row, col, offset=0, *, dtype=torch.long, device='cpu', layout=torch.strided) -> Tensor

        Returns the indices of the upper triangular part of a :attr:`row` by
        :attr:`col` matrix in a 2-by-N Tensor, where the first row contains row
        coordinates of all indices and the second row contains column coordinates.
        Indices are ordered based on rows and then columns.

        The upper triangular part of the matrix is defined as the elements on and
        above the diagonal.

        The argument :attr:`offset` controls which diagonal to consider. If
        :attr:`offset` = 0, all elements on and above the main diagonal are
        retained. A positive value excludes just as many diagonals above the main
        diagonal, and similarly a negative value includes just as many diagonals below
        the main diagonal. The main diagonal are the set of indices
        :math:`\\lbrace (i, i) \\rbrace` for :math:`i \\in [0, \\min\\{d_{1}, d_{2}\\} - 1]`
        where :math:`d_{1}, d_{2}` are the dimensions of the matrix.

        .. note::
            When running on CUDA, ``row * col`` must be less than :math:`2^{59}` to
            prevent overflow during calculation.

        Args:
            row (``int``): number of rows in the 2-D matrix.
            col (``int``): number of columns in the 2-D matrix.
            offset (``int``): diagonal offset from the main diagonal.
                Default: if not provided, 0.

        Keyword args:
            dtype (:class:`torch.dtype`, optional): the desired data type of returned tensor,
                only support ``torch.int``, ``torch.long``. Default: if ``None``, ``torch.long``.
            device (:class:`torch.device`, optional): the desired device of returned tensor.
                Default: if ``None``, uses the current device for the default tensor type
                (see :func:`torch.set_default_device`). :attr:`device` will be the CPU
                for CPU tensor types and the current CUDA device for CUDA tensor types.
            layout (:class:`torch.layout`, optional): currently only support ``torch.strided``.

        Example::

            >>> a = torch.triu_indices(3, 3)
            >>> a
            tensor([[0, 0, 0, 1, 1, 2],
                    [0, 1, 2, 1, 2, 2]])

            >>> a = torch.triu_indices(4, 3, -1)
            >>> a
            tensor([[0, 0, 0, 1, 1, 1, 2, 2, 3],
                    [0, 1, 2, 0, 1, 2, 1, 2, 2]])

            >>> a = torch.triu_indices(4, 3, 1)
            >>> a
            tensor([[0, 0, 1],
                    [1, 2, 2]])
        """
    @staticmethod
    def true_divide(dividend, divisor, out) -> Tensor:
        """
        true_divide(dividend, divisor, *, out) -> Tensor

        Alias for :func:`torch.div` with ``rounding_mode=None``.
        """
    @overload
    @staticmethod
    def trunc(input, out=...) -> Tensor:
        """
        trunc(input, *, out=None) -> Tensor

        Returns a new tensor with the truncated integer values of
        the elements of :attr:`input`.

        For integer inputs, follows the array-api convention of returning a
        copy of the input tensor.

        Args:
            input (Tensor): the input tensor.

        Keyword args:
            out (Tensor, optional): the output tensor.

        Example::

            >>> a = torch.randn(4)
            >>> a
            tensor([ 3.4742,  0.5466, -0.8008, -0.9079])
            >>> torch.trunc(a)
            tensor([ 3.,  0., -0., -0.])
        """
    @overload
    @staticmethod
    def trunc(a) -> Any:
        """
        trunc(input, *, out=None) -> Tensor

        Returns a new tensor with the truncated integer values of
        the elements of :attr:`input`.

        For integer inputs, follows the array-api convention of returning a
        copy of the input tensor.

        Args:
            input (Tensor): the input tensor.

        Keyword args:
            out (Tensor, optional): the output tensor.

        Example::

            >>> a = torch.randn(4)
            >>> a
            tensor([ 3.4742,  0.5466, -0.8008, -0.9079])
            >>> torch.trunc(a)
            tensor([ 3.,  0., -0., -0.])
        """
    @staticmethod
    def trunc_(*args, **kwargs): ...
    @staticmethod
    def unbind(input, dim=...) -> seq:
        """
        unbind(input, dim=0) -> seq

        Removes a tensor dimension.

        Returns a tuple of all slices along a given dimension, already without it.

        Arguments:
            input (Tensor): the tensor to unbind
            dim (int): dimension to remove

        Example::

            >>> torch.unbind(torch.tensor([[1, 2, 3],
            >>>                            [4, 5, 6],
            >>>                            [7, 8, 9]]))
            (tensor([1, 2, 3]), tensor([4, 5, 6]), tensor([7, 8, 9]))
        """
    @staticmethod
    def unbind_copy(*args, **kwargs):
        """
        Performs the same operation as :func:`torch.unbind`, but all output tensors
        are freshly created instead of aliasing the input.
        """
    @staticmethod
    def unflatten(input, dim, sizes) -> Tensor:
        """
        unflatten(input, dim, sizes) -> Tensor

        Expands a dimension of the input tensor over multiple dimensions.

        .. seealso::

            :func:`torch.flatten` the inverse of this function. It coalesces several dimensions into one.

        Args:
            input (Tensor): the input tensor.
            dim (int): Dimension to be unflattened, specified as an index into
                 ``input.shape``.
            sizes (Tuple[int]): New shape of the unflattened dimension.
                 One of its elements can be `-1` in which case the corresponding output
                 dimension is inferred. Otherwise, the product of ``sizes`` *must*
                 equal ``input.shape[dim]``.

        Returns:
            A View of input with the specified dimension unflattened.

        Examples::
            >>> torch.unflatten(torch.randn(3, 4, 1), 1, (2, 2)).shape
            torch.Size([3, 2, 2, 1])
            >>> torch.unflatten(torch.randn(3, 4, 1), 1, (-1, 2)).shape
            torch.Size([3, 2, 2, 1])
            >>> torch.unflatten(torch.randn(5, 12, 3), -2, (2, 2, 3, 1, 1)).shape
            torch.Size([5, 2, 2, 3, 1, 1, 3])
        """
    @staticmethod
    def unfold_copy(*args, **kwargs):
        """
        Performs the same operation as :func:`torch.unfold`, but all output tensors
        are freshly created instead of aliasing the input.
        """
    @staticmethod
    def unique_consecutive(*args, **kwargs): ...
    @staticmethod
    def unique_dim(*args, **kwargs): ...
    @staticmethod
    def unsafe_chunk(input, chunks, dim=...) -> ListofTensors:
        """
        unsafe_chunk(input, chunks, dim=0) -> List of Tensors

        Works like :func:`torch.chunk` but without enforcing the autograd restrictions
        on inplace modification of the outputs.

        .. warning::
            This function is safe to use as long as only the input, or only the outputs
            are modified inplace after calling this function. It is user's
            responsibility to ensure that is the case. If both the input and one or more
            of the outputs are modified inplace, gradients computed by autograd will be
            silently incorrect.
        """
    @staticmethod
    def unsafe_split(tensor, split_size_or_sections, dim=...) -> ListofTensors:
        """
        unsafe_split(tensor, split_size_or_sections, dim=0) -> List of Tensors

        Works like :func:`torch.split` but without enforcing the autograd restrictions
        on inplace modification of the outputs.

        .. warning::
            This function is safe to use as long as only the input, or only the outputs
            are modified inplace after calling this function. It is user's
            responsibility to ensure that is the case. If both the input and one or more
            of the outputs are modified inplace, gradients computed by autograd will be
            silently incorrect.
        """
    @staticmethod
    def unsafe_split_with_sizes(*args, **kwargs): ...
    @staticmethod
    def unsqueeze(input, dim) -> Tensor:
        """
        unsqueeze(input, dim) -> Tensor

        Returns a new tensor with a dimension of size one inserted at the
        specified position.

        The returned tensor shares the same underlying data with this tensor.

        A :attr:`dim` value within the range ``[-input.dim() - 1, input.dim() + 1)``
        can be used. Negative :attr:`dim` will correspond to :meth:`unsqueeze`
        applied at :attr:`dim` = ``dim + input.dim() + 1``.

        Args:
            input (Tensor): the input tensor.
            dim (int): the index at which to insert the singleton dimension

        Example::

            >>> x = torch.tensor([1, 2, 3, 4])
            >>> torch.unsqueeze(x, 0)
            tensor([[ 1,  2,  3,  4]])
            >>> torch.unsqueeze(x, 1)
            tensor([[ 1],
                    [ 2],
                    [ 3],
                    [ 4]])
        """
    @staticmethod
    def unsqueeze_copy(*args, **kwargs):
        """
        Performs the same operation as :func:`torch.unsqueeze`, but all output tensors
        are freshly created instead of aliasing the input.
        """
    @staticmethod
    def values_copy(*args, **kwargs):
        """
        Performs the same operation as :func:`torch.values`, but all output tensors
        are freshly created instead of aliasing the input.
        """
    @overload
    @staticmethod
    def vander(x, N=..., increasing=...) -> Tensor:
        """
        vander(x, N=None, increasing=False) -> Tensor

        Generates a Vandermonde matrix.

        The columns of the output matrix are elementwise powers of the input vector :math:`x^{(N-1)}, x^{(N-2)}, ..., x^0`.
        If increasing is True, the order of the columns is reversed :math:`x^0, x^1, ..., x^{(N-1)}`. Such a
        matrix with a geometric progression in each row is named for Alexandre-Theophile Vandermonde.

        Arguments:
            x (Tensor): 1-D input tensor.
            N (int, optional): Number of columns in the output. If N is not specified,
                a square array is returned :math:`(N = len(x))`.
            increasing (bool, optional): Order of the powers of the columns. If True,
                the powers increase from left to right, if False (the default) they are reversed.

        Returns:
            Tensor: Vandermonde matrix. If increasing is False, the first column is :math:`x^{(N-1)}`,
            the second :math:`x^{(N-2)}` and so forth. If increasing is True, the columns
            are :math:`x^0, x^1, ..., x^{(N-1)}`.

        Example::

            >>> x = torch.tensor([1, 2, 3, 5])
            >>> torch.vander(x)
            tensor([[  1,   1,   1,   1],
                    [  8,   4,   2,   1],
                    [ 27,   9,   3,   1],
                    [125,  25,   5,   1]])
            >>> torch.vander(x, N=3)
            tensor([[ 1,  1,  1],
                    [ 4,  2,  1],
                    [ 9,  3,  1],
                    [25,  5,  1]])
            >>> torch.vander(x, N=3, increasing=True)
            tensor([[ 1,  1,  1],
                    [ 1,  2,  4],
                    [ 1,  3,  9],
                    [ 1,  5, 25]])

        """
    @overload
    @staticmethod
    def vander(x) -> Any:
        """
        vander(x, N=None, increasing=False) -> Tensor

        Generates a Vandermonde matrix.

        The columns of the output matrix are elementwise powers of the input vector :math:`x^{(N-1)}, x^{(N-2)}, ..., x^0`.
        If increasing is True, the order of the columns is reversed :math:`x^0, x^1, ..., x^{(N-1)}`. Such a
        matrix with a geometric progression in each row is named for Alexandre-Theophile Vandermonde.

        Arguments:
            x (Tensor): 1-D input tensor.
            N (int, optional): Number of columns in the output. If N is not specified,
                a square array is returned :math:`(N = len(x))`.
            increasing (bool, optional): Order of the powers of the columns. If True,
                the powers increase from left to right, if False (the default) they are reversed.

        Returns:
            Tensor: Vandermonde matrix. If increasing is False, the first column is :math:`x^{(N-1)}`,
            the second :math:`x^{(N-2)}` and so forth. If increasing is True, the columns
            are :math:`x^0, x^1, ..., x^{(N-1)}`.

        Example::

            >>> x = torch.tensor([1, 2, 3, 5])
            >>> torch.vander(x)
            tensor([[  1,   1,   1,   1],
                    [  8,   4,   2,   1],
                    [ 27,   9,   3,   1],
                    [125,  25,   5,   1]])
            >>> torch.vander(x, N=3)
            tensor([[ 1,  1,  1],
                    [ 4,  2,  1],
                    [ 9,  3,  1],
                    [25,  5,  1]])
            >>> torch.vander(x, N=3, increasing=True)
            tensor([[ 1,  1,  1],
                    [ 1,  2,  4],
                    [ 1,  3,  9],
                    [ 1,  5, 25]])

        """
    @overload
    @staticmethod
    def vander(x, N=...) -> Any:
        """
        vander(x, N=None, increasing=False) -> Tensor

        Generates a Vandermonde matrix.

        The columns of the output matrix are elementwise powers of the input vector :math:`x^{(N-1)}, x^{(N-2)}, ..., x^0`.
        If increasing is True, the order of the columns is reversed :math:`x^0, x^1, ..., x^{(N-1)}`. Such a
        matrix with a geometric progression in each row is named for Alexandre-Theophile Vandermonde.

        Arguments:
            x (Tensor): 1-D input tensor.
            N (int, optional): Number of columns in the output. If N is not specified,
                a square array is returned :math:`(N = len(x))`.
            increasing (bool, optional): Order of the powers of the columns. If True,
                the powers increase from left to right, if False (the default) they are reversed.

        Returns:
            Tensor: Vandermonde matrix. If increasing is False, the first column is :math:`x^{(N-1)}`,
            the second :math:`x^{(N-2)}` and so forth. If increasing is True, the columns
            are :math:`x^0, x^1, ..., x^{(N-1)}`.

        Example::

            >>> x = torch.tensor([1, 2, 3, 5])
            >>> torch.vander(x)
            tensor([[  1,   1,   1,   1],
                    [  8,   4,   2,   1],
                    [ 27,   9,   3,   1],
                    [125,  25,   5,   1]])
            >>> torch.vander(x, N=3)
            tensor([[ 1,  1,  1],
                    [ 4,  2,  1],
                    [ 9,  3,  1],
                    [25,  5,  1]])
            >>> torch.vander(x, N=3, increasing=True)
            tensor([[ 1,  1,  1],
                    [ 1,  2,  4],
                    [ 1,  3,  9],
                    [ 1,  5, 25]])

        """
    @overload
    @staticmethod
    def vander(x, N=..., increasing=...) -> Any:
        """
        vander(x, N=None, increasing=False) -> Tensor

        Generates a Vandermonde matrix.

        The columns of the output matrix are elementwise powers of the input vector :math:`x^{(N-1)}, x^{(N-2)}, ..., x^0`.
        If increasing is True, the order of the columns is reversed :math:`x^0, x^1, ..., x^{(N-1)}`. Such a
        matrix with a geometric progression in each row is named for Alexandre-Theophile Vandermonde.

        Arguments:
            x (Tensor): 1-D input tensor.
            N (int, optional): Number of columns in the output. If N is not specified,
                a square array is returned :math:`(N = len(x))`.
            increasing (bool, optional): Order of the powers of the columns. If True,
                the powers increase from left to right, if False (the default) they are reversed.

        Returns:
            Tensor: Vandermonde matrix. If increasing is False, the first column is :math:`x^{(N-1)}`,
            the second :math:`x^{(N-2)}` and so forth. If increasing is True, the columns
            are :math:`x^0, x^1, ..., x^{(N-1)}`.

        Example::

            >>> x = torch.tensor([1, 2, 3, 5])
            >>> torch.vander(x)
            tensor([[  1,   1,   1,   1],
                    [  8,   4,   2,   1],
                    [ 27,   9,   3,   1],
                    [125,  25,   5,   1]])
            >>> torch.vander(x, N=3)
            tensor([[ 1,  1,  1],
                    [ 4,  2,  1],
                    [ 9,  3,  1],
                    [25,  5,  1]])
            >>> torch.vander(x, N=3, increasing=True)
            tensor([[ 1,  1,  1],
                    [ 1,  2,  4],
                    [ 1,  3,  9],
                    [ 1,  5, 25]])

        """
    @staticmethod
    def var(input, dim=..., correction=..., keepdim=..., out=...) -> Tensor:
        """
        var(input, dim=None, *, correction=1, keepdim=False, out=None) -> Tensor

        Calculates the variance over the dimensions specified by :attr:`dim`. :attr:`dim`
        can be a single dimension, list of dimensions, or ``None`` to reduce over all
        dimensions.

        The variance (:math:`\\sigma^2`) is calculated as

        .. math:: \\sigma^2 = \\frac{1}{\\max(0,~N - \\delta N)}\\sum_{i=0}^{N-1}(x_i-\\bar{x})^2

        where :math:`x` is the sample set of elements, :math:`\\bar{x}` is the
        sample mean, :math:`N` is the number of samples and :math:`\\delta N` is
        the :attr:`correction`.



        If :attr:`keepdim` is ``True``, the output tensor is of the same size
        as :attr:`input` except in the dimension(s) :attr:`dim` where it is of size 1.
        Otherwise, :attr:`dim` is squeezed (see :func:`torch.squeeze`), resulting in the
        output tensor having 1 (or ``len(dim)``) fewer dimension(s).


        Args:
            input (Tensor): the input tensor.
    
            dim (int or tuple of ints, optional): the dimension or dimensions to reduce.
                If ``None``, all dimensions are reduced.


        Keyword args:
            correction (int): difference between the sample size and sample degrees of freedom.
                Defaults to `Bessel's correction`_, ``correction=1``.

                .. versionchanged:: 2.0
                    Previously this argument was called ``unbiased`` and was a boolean
                    with ``True`` corresponding to ``correction=1`` and ``False`` being
                    ``correction=0``.
    
            keepdim (bool, optional): whether the output tensor has :attr:`dim` retained or not. Default: ``False``.

            out (Tensor, optional): the output tensor.

        Example:

            >>> a = torch.tensor(
            ...     [[ 0.2035,  1.2959,  1.8101, -0.4644],
            ...      [ 1.5027, -0.3270,  0.5905,  0.6538],
            ...      [-1.5745,  1.3330, -0.5596, -0.6548],
            ...      [ 0.1264, -0.5080,  1.6420,  0.1992]]
            ... )  # fmt: skip
            >>> torch.var(a, dim=1, keepdim=True)
            tensor([[1.0631],
                    [0.5590],
                    [1.4893],
                    [0.8258]])

        .. _Bessel's correction: https://en.wikipedia.org/wiki/Bessel%27s_correction

        """
    @staticmethod
    def var_mean(*args, **kwargs):
        """
        var_mean(input, dim=None, *, correction=1, keepdim=False, out=None) -> (Tensor, Tensor)

        Calculates the variance and mean over the dimensions specified by :attr:`dim`.
        :attr:`dim` can be a single dimension, list of dimensions, or ``None`` to
        reduce over all dimensions.

        The variance (:math:`\\sigma^2`) is calculated as

        .. math:: \\sigma^2 = \\frac{1}{\\max(0,~N - \\delta N)}\\sum_{i=0}^{N-1}(x_i-\\bar{x})^2

        where :math:`x` is the sample set of elements, :math:`\\bar{x}` is the
        sample mean, :math:`N` is the number of samples and :math:`\\delta N` is
        the :attr:`correction`.



        If :attr:`keepdim` is ``True``, the output tensor is of the same size
        as :attr:`input` except in the dimension(s) :attr:`dim` where it is of size 1.
        Otherwise, :attr:`dim` is squeezed (see :func:`torch.squeeze`), resulting in the
        output tensor having 1 (or ``len(dim)``) fewer dimension(s).


        Args:
            input (Tensor): the input tensor.
    
            dim (int or tuple of ints, optional): the dimension or dimensions to reduce.
                If ``None``, all dimensions are reduced.


        Keyword args:
            correction (int): difference between the sample size and sample degrees of freedom.
                Defaults to `Bessel's correction`_, ``correction=1``.

                .. versionchanged:: 2.0
                    Previously this argument was called ``unbiased`` and was a boolean
                    with ``True`` corresponding to ``correction=1`` and ``False`` being
                    ``correction=0``.
    
            keepdim (bool, optional): whether the output tensor has :attr:`dim` retained or not. Default: ``False``.

            out (Tensor, optional): the output tensor.

        Returns:
            A tuple (var, mean) containing the variance and mean.

        Example:

            >>> a = torch.tensor(
            ...     [[ 0.2035,  1.2959,  1.8101, -0.4644],
            ...      [ 1.5027, -0.3270,  0.5905,  0.6538],
            ...      [-1.5745,  1.3330, -0.5596, -0.6548],
            ...      [ 0.1264, -0.5080,  1.6420,  0.1992]]
            ... )  # fmt: skip
            >>> torch.var_mean(a, dim=0, keepdim=True)
            (tensor([[1.5926, 1.0056, 1.2005, 0.3646]]),
             tensor([[ 0.0645,  0.4485,  0.8707, -0.0665]]))

        .. _Bessel's correction: https://en.wikipedia.org/wiki/Bessel%27s_correction

        """
    @staticmethod
    def vdot(input, other, out=...) -> Tensor:
        """
        vdot(input, other, *, out=None) -> Tensor

        Computes the dot product of two 1D vectors along a dimension.

        In symbols, this function computes

        .. math::

            \\sum_{i=1}^n \\overline{x_i}y_i.

        where :math:`\\overline{x_i}` denotes the conjugate for complex
        vectors, and it is the identity for real vectors.

        .. note::

            Unlike NumPy's vdot, torch.vdot intentionally only supports computing the dot product
            of two 1D tensors with the same number of elements.

        .. seealso::

                :func:`torch.linalg.vecdot` computes the dot product of two batches of vectors along a dimension.

        Args:
            input (Tensor): first tensor in the dot product, must be 1D. Its conjugate is used if it's complex.
            other (Tensor): second tensor in the dot product, must be 1D.

        Keyword args:

        .. note:: out (Tensor, optional): the output tensor.


        Example::

            >>> torch.vdot(torch.tensor([2, 3]), torch.tensor([2, 1]))
            tensor(7)
            >>> a = torch.tensor((1 +2j, 3 - 1j))
            >>> b = torch.tensor((2 +1j, 4 - 0j))
            >>> torch.vdot(a, b)
            tensor([16.+1.j])
            >>> torch.vdot(b, a)
            tensor([16.-1.j])
        """
    @staticmethod
    def view_as_complex(input) -> Tensor:
        """
        view_as_complex(input) -> Tensor

        Returns a view of :attr:`input` as a complex tensor. For an input complex
        tensor of :attr:`size` :math:`m1, m2, \\dots, mi, 2`, this function returns a
        new complex tensor of :attr:`size` :math:`m1, m2, \\dots, mi` where the last
        dimension of the input tensor is expected to represent the real and imaginary
        components of complex numbers.

        .. warning::
            :func:`view_as_complex` is only supported for tensors with
            :class:`torch.dtype` ``torch.float64`` and ``torch.float32``.  The input is
            expected to have the last dimension of :attr:`size` 2. In addition, the
            tensor must have a `stride` of 1 for its last dimension. The strides of all
            other dimensions must be even numbers.

        Args:
            input (Tensor): the input tensor.

        Example::

            >>> x=torch.randn(4, 2)
            >>> x
            tensor([[ 1.6116, -0.5772],
                    [-1.4606, -0.9120],
                    [ 0.0786, -1.7497],
                    [-0.6561, -1.6623]])
            >>> torch.view_as_complex(x)
            tensor([(1.6116-0.5772j), (-1.4606-0.9120j), (0.0786-1.7497j), (-0.6561-1.6623j)])
        """
    @staticmethod
    def view_as_complex_copy(*args, **kwargs):
        """
        Performs the same operation as :func:`torch.view_as_complex`, but all output tensors
        are freshly created instead of aliasing the input.
        """
    @staticmethod
    def view_as_real(input) -> Tensor:
        """
        view_as_real(input) -> Tensor

        Returns a view of :attr:`input` as a real tensor. For an input complex tensor of
        :attr:`size` :math:`m1, m2, \\dots, mi`, this function returns a new
        real tensor of size :math:`m1, m2, \\dots, mi, 2`, where the last dimension of size 2
        represents the real and imaginary components of complex numbers.

        .. warning::
            :func:`view_as_real` is only supported for tensors with ``complex dtypes``.

        Args:
            input (Tensor): the input tensor.

        Example::

            >>> x=torch.randn(4, dtype=torch.cfloat)
            >>> x
            tensor([(0.4737-0.3839j), (-0.2098-0.6699j), (0.3470-0.9451j), (-0.5174-1.3136j)])
            >>> torch.view_as_real(x)
            tensor([[ 0.4737, -0.3839],
                    [-0.2098, -0.6699],
                    [ 0.3470, -0.9451],
                    [-0.5174, -1.3136]])
        """
    @staticmethod
    def view_as_real_copy(*args, **kwargs):
        """
        Performs the same operation as :func:`torch.view_as_real`, but all output tensors
        are freshly created instead of aliasing the input.
        """
    @staticmethod
    def view_copy(*args, **kwargs):
        """
        Performs the same operation as :func:`torch.view`, but all output tensors
        are freshly created instead of aliasing the input.
        """
    @staticmethod
    def vsplit(input, indices_or_sections) -> ListofTensors:
        """
        vsplit(input, indices_or_sections) -> List of Tensors

        Splits :attr:`input`, a tensor with two or more dimensions, into multiple tensors
        vertically according to :attr:`indices_or_sections`. Each split is a view of
        :attr:`input`.

        This is equivalent to calling torch.tensor_split(input, indices_or_sections, dim=0)
        (the split dimension is 0), except that if :attr:`indices_or_sections` is an integer
        it must evenly divide the split dimension or a runtime error will be thrown.

        This function is based on NumPy's :func:`numpy.vsplit`.

        Args:
            input (Tensor): tensor to split.
            indices_or_sections (int or list or tuple of ints): See argument in :func:`torch.tensor_split`.

        Example::

            >>> t = torch.arange(16.0).reshape(4,4)
            >>> t
            tensor([[ 0.,  1.,  2.,  3.],
                    [ 4.,  5.,  6.,  7.],
                    [ 8.,  9., 10., 11.],
                    [12., 13., 14., 15.]])
            >>> torch.vsplit(t, 2)
            (tensor([[0., 1., 2., 3.],
                     [4., 5., 6., 7.]]),
             tensor([[ 8.,  9., 10., 11.],
                     [12., 13., 14., 15.]]))
            >>> torch.vsplit(t, [3, 6])
            (tensor([[ 0.,  1.,  2.,  3.],
                     [ 4.,  5.,  6.,  7.],
                     [ 8.,  9., 10., 11.]]),
             tensor([[12., 13., 14., 15.]]),
             tensor([], size=(0, 4)))

        """
    @staticmethod
    def vstack(tensors, out=...) -> Tensor:
        """
        vstack(tensors, *, out=None) -> Tensor

        Stack tensors in sequence vertically (row wise).

        This is equivalent to concatenation along the first axis after all 1-D tensors have been reshaped by :func:`torch.atleast_2d`.

        Args:
            tensors (sequence of Tensors): sequence of tensors to concatenate

        Keyword args:
            out (Tensor, optional): the output tensor.

        Example::

            >>> a = torch.tensor([1, 2, 3])
            >>> b = torch.tensor([4, 5, 6])
            >>> torch.vstack((a,b))
            tensor([[1, 2, 3],
                    [4, 5, 6]])
            >>> a = torch.tensor([[1],[2],[3]])
            >>> b = torch.tensor([[4],[5],[6]])
            >>> torch.vstack((a,b))
            tensor([[1],
                    [2],
                    [3],
                    [4],
                    [5],
                    [6]])


        """
    @staticmethod
    def where(condition, input, other, out=...) -> Tensor:
        """
        where(condition, input, other, *, out=None) -> Tensor

        Return a tensor of elements selected from either :attr:`input` or :attr:`other`, depending on :attr:`condition`.

        The operation is defined as:

        .. math::
            \\text{out}_i = \\begin{cases}
                \\text{input}_i & \\text{if } \\text{condition}_i \\\\\n                \\text{other}_i & \\text{otherwise} \\\\\n            \\end{cases}

        .. note::
            The tensors :attr:`condition`, :attr:`input`, :attr:`other` must be :ref:`broadcastable <broadcasting-semantics>`.

        Arguments:
            condition (BoolTensor): When True (nonzero), yield input, otherwise yield other
            input (Tensor or Scalar): value (if :attr:`input` is a scalar) or values selected at indices
                                  where :attr:`condition` is ``True``
            other (Tensor or Scalar): value (if :attr:`other` is a scalar) or values selected at indices
                                  where :attr:`condition` is ``False``

        Keyword args:
            out (Tensor, optional): the output tensor.

        Returns:
            Tensor: A tensor of shape equal to the broadcasted shape of :attr:`condition`, :attr:`input`, :attr:`other`

        Example::

            >>> x = torch.randn(3, 2)
            >>> y = torch.ones(3, 2)
            >>> x
            tensor([[-0.4620,  0.3139],
                    [ 0.3898, -0.7197],
                    [ 0.0478, -0.1657]])
            >>> torch.where(x > 0, 1.0, 0.0)
            tensor([[0., 1.],
                    [1., 0.],
                    [1., 0.]])
            >>> torch.where(x > 0, x, y)
            tensor([[ 1.0000,  0.3139],
                    [ 0.3898,  1.0000],
                    [ 0.0478,  1.0000]])
            >>> x = torch.randn(2, 2, dtype=torch.double)
            >>> x
            tensor([[ 1.0779,  0.0383],
                    [-0.8785, -1.1089]], dtype=torch.float64)
            >>> torch.where(x > 0, x, 0.)
            tensor([[1.0779, 0.0383],
                    [0.0000, 0.0000]], dtype=torch.float64)

        .. function:: where(condition) -> tuple of LongTensor
           :noindex:

        ``torch.where(condition)`` is identical to
        ``torch.nonzero(condition, as_tuple=True)``.

        .. note::
            See also :func:`torch.nonzero`.
        """
    @staticmethod
    def xlogy(input, other, out=...) -> Tensor:
        """
        xlogy(input, other, *, out=None) -> Tensor

        Alias for :func:`torch.special.xlogy`.
        """
    @staticmethod
    def xlogy_(*args, **kwargs): ...
    @staticmethod
    def zero_(*args, **kwargs): ...
    @staticmethod
    def zeros(*args, **kwargs):
        """
        zeros(*size, *, out=None, dtype=None, layout=torch.strided, device=None, requires_grad=False) -> Tensor

        Returns a tensor filled with the scalar value `0`, with the shape defined
        by the variable argument :attr:`size`.

        Args:
            size (int...): a sequence of integers defining the shape of the output tensor.
                Can be a variable number of arguments or a collection like a list or tuple.

        Keyword args:
            out (Tensor, optional): the output tensor.
            dtype (:class:`torch.dtype`, optional): the desired data type of returned tensor.
                Default: if ``None``, uses a global default (see :func:`torch.set_default_dtype`).
            layout (:class:`torch.layout`, optional): the desired layout of returned Tensor.
                Default: ``torch.strided``.
            device (:class:`torch.device`, optional): the desired device of returned tensor.
                Default: if ``None``, uses the current device for the default tensor type
                (see :func:`torch.set_default_device`). :attr:`device` will be the CPU
                for CPU tensor types and the current CUDA device for CUDA tensor types.
            requires_grad (bool, optional): If autograd should record operations on the
                returned tensor. Default: ``False``.

        Example::

            >>> torch.zeros(2, 3)
            tensor([[ 0.,  0.,  0.],
                    [ 0.,  0.,  0.]])

            >>> torch.zeros(5)
            tensor([ 0.,  0.,  0.,  0.,  0.])
        """
    @overload
    @staticmethod
    def zeros_like(input, dtype=..., layout=..., device=..., requires_grad=..., memory_format=...) -> Tensor:
        """
        zeros_like(input, *, dtype=None, layout=None, device=None, requires_grad=False, memory_format=torch.preserve_format) -> Tensor

        Returns a tensor filled with the scalar value `0`, with the same size as
        :attr:`input`. ``torch.zeros_like(input)`` is equivalent to
        ``torch.zeros(input.size(), dtype=input.dtype, layout=input.layout, device=input.device)``.

        .. warning::
            As of 0.4, this function does not support an :attr:`out` keyword. As an alternative,
            the old ``torch.zeros_like(input, out=output)`` is equivalent to
            ``torch.zeros(input.size(), out=output)``.

        Args:
            input (Tensor): the size of :attr:`input` will determine size of the output tensor.

        Keyword args:
            dtype (:class:`torch.dtype`, optional): the desired data type of returned Tensor.
                Default: if ``None``, defaults to the dtype of :attr:`input`.
            layout (:class:`torch.layout`, optional): the desired layout of returned tensor.
                Default: if ``None``, defaults to the layout of :attr:`input`.
            device (:class:`torch.device`, optional): the desired device of returned tensor.
                Default: if ``None``, defaults to the device of :attr:`input`.
            requires_grad (bool, optional): If autograd should record operations on the
                returned tensor. Default: ``False``.
            memory_format (:class:`torch.memory_format`, optional): the desired memory format of
                returned Tensor. Default: ``torch.preserve_format``.

        Example::

            >>> input = torch.empty(2, 3)
            >>> torch.zeros_like(input)
            tensor([[ 0.,  0.,  0.],
                    [ 0.,  0.,  0.]])
        """
    @overload
    @staticmethod
    def zeros_like(input) -> Any:
        """
        zeros_like(input, *, dtype=None, layout=None, device=None, requires_grad=False, memory_format=torch.preserve_format) -> Tensor

        Returns a tensor filled with the scalar value `0`, with the same size as
        :attr:`input`. ``torch.zeros_like(input)`` is equivalent to
        ``torch.zeros(input.size(), dtype=input.dtype, layout=input.layout, device=input.device)``.

        .. warning::
            As of 0.4, this function does not support an :attr:`out` keyword. As an alternative,
            the old ``torch.zeros_like(input, out=output)`` is equivalent to
            ``torch.zeros(input.size(), out=output)``.

        Args:
            input (Tensor): the size of :attr:`input` will determine size of the output tensor.

        Keyword args:
            dtype (:class:`torch.dtype`, optional): the desired data type of returned Tensor.
                Default: if ``None``, defaults to the dtype of :attr:`input`.
            layout (:class:`torch.layout`, optional): the desired layout of returned tensor.
                Default: if ``None``, defaults to the layout of :attr:`input`.
            device (:class:`torch.device`, optional): the desired device of returned tensor.
                Default: if ``None``, defaults to the device of :attr:`input`.
            requires_grad (bool, optional): If autograd should record operations on the
                returned tensor. Default: ``False``.
            memory_format (:class:`torch.memory_format`, optional): the desired memory format of
                returned Tensor. Default: ``torch.preserve_format``.

        Example::

            >>> input = torch.empty(2, 3)
            >>> torch.zeros_like(input)
            tensor([[ 0.,  0.,  0.],
                    [ 0.,  0.,  0.]])
        """
    @overload
    @staticmethod
    def zeros_like(input, out=...) -> Any:
        """
        zeros_like(input, *, dtype=None, layout=None, device=None, requires_grad=False, memory_format=torch.preserve_format) -> Tensor

        Returns a tensor filled with the scalar value `0`, with the same size as
        :attr:`input`. ``torch.zeros_like(input)`` is equivalent to
        ``torch.zeros(input.size(), dtype=input.dtype, layout=input.layout, device=input.device)``.

        .. warning::
            As of 0.4, this function does not support an :attr:`out` keyword. As an alternative,
            the old ``torch.zeros_like(input, out=output)`` is equivalent to
            ``torch.zeros(input.size(), out=output)``.

        Args:
            input (Tensor): the size of :attr:`input` will determine size of the output tensor.

        Keyword args:
            dtype (:class:`torch.dtype`, optional): the desired data type of returned Tensor.
                Default: if ``None``, defaults to the dtype of :attr:`input`.
            layout (:class:`torch.layout`, optional): the desired layout of returned tensor.
                Default: if ``None``, defaults to the layout of :attr:`input`.
            device (:class:`torch.device`, optional): the desired device of returned tensor.
                Default: if ``None``, defaults to the device of :attr:`input`.
            requires_grad (bool, optional): If autograd should record operations on the
                returned tensor. Default: ``False``.
            memory_format (:class:`torch.memory_format`, optional): the desired memory format of
                returned Tensor. Default: ``torch.preserve_format``.

        Example::

            >>> input = torch.empty(2, 3)
            >>> torch.zeros_like(input)
            tensor([[ 0.,  0.,  0.],
                    [ 0.,  0.,  0.]])
        """
    @overload
    @staticmethod
    def zeros_like(input) -> Any:
        """
        zeros_like(input, *, dtype=None, layout=None, device=None, requires_grad=False, memory_format=torch.preserve_format) -> Tensor

        Returns a tensor filled with the scalar value `0`, with the same size as
        :attr:`input`. ``torch.zeros_like(input)`` is equivalent to
        ``torch.zeros(input.size(), dtype=input.dtype, layout=input.layout, device=input.device)``.

        .. warning::
            As of 0.4, this function does not support an :attr:`out` keyword. As an alternative,
            the old ``torch.zeros_like(input, out=output)`` is equivalent to
            ``torch.zeros(input.size(), out=output)``.

        Args:
            input (Tensor): the size of :attr:`input` will determine size of the output tensor.

        Keyword args:
            dtype (:class:`torch.dtype`, optional): the desired data type of returned Tensor.
                Default: if ``None``, defaults to the dtype of :attr:`input`.
            layout (:class:`torch.layout`, optional): the desired layout of returned tensor.
                Default: if ``None``, defaults to the layout of :attr:`input`.
            device (:class:`torch.device`, optional): the desired device of returned tensor.
                Default: if ``None``, defaults to the device of :attr:`input`.
            requires_grad (bool, optional): If autograd should record operations on the
                returned tensor. Default: ``False``.
            memory_format (:class:`torch.memory_format`, optional): the desired memory format of
                returned Tensor. Default: ``torch.preserve_format``.

        Example::

            >>> input = torch.empty(2, 3)
            >>> torch.zeros_like(input)
            tensor([[ 0.,  0.,  0.],
                    [ 0.,  0.,  0.]])
        """
    @staticmethod
    def __and__(, other): ...
    @staticmethod
    def __lshift__(, other): ...
    @staticmethod
    def __or__(, other): ...
    @staticmethod
    def __rshift__(, other): ...
    @staticmethod
    def __xor__(, other): ...

class _WeakTensorRef:
    def __init__(self, arg0: object) -> None:
        """__init__(self: torch._C._WeakTensorRef, arg0: object) -> None"""
    def _pybind11_conduit_v1_(self, *args, **kwargs): ...
    def expired(self) -> bool:
        """expired(self: torch._C._WeakTensorRef) -> bool"""

class _mps_MetalKernel:
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def _pybind11_conduit_v1_(self, *args, **kwargs): ...
    def __call__(self, *args, threads: object = ..., group_size: object = ..., arg_casts: object = ...) -> None:
        """__call__(self: torch._C._mps_MetalKernel, *args, threads: object = None, group_size: object = None, arg_casts: object = None) -> None"""
    @property
    def max_threads_per_threadgroup(self) -> int:
        """(arg0: torch._C._mps_MetalKernel) -> int"""
    @property
    def static_thread_group_memory_length(self) -> int:
        """(arg0: torch._C._mps_MetalKernel) -> int"""
    @property
    def thread_execution_width(self) -> int:
        """(arg0: torch._C._mps_MetalKernel) -> int"""

class _mps_ShaderLibrary:
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def _pybind11_conduit_v1_(self, *args, **kwargs): ...
    def __dir__(self) -> list[str]:
        """__dir__(self: torch._C._mps_ShaderLibrary) -> list[str]"""
    def __getattr__(self, name):
        """__getattr__(self: torch._C._mps_ShaderLibrary, arg0: str) -> at::native::mps::MetalKernelFunction"""

def _abort(*args, **kwargs): ...
def _accelerator_exchangeDevice(arg0: int) -> int:
    """_accelerator_exchangeDevice(arg0: int) -> int"""
def _accelerator_getAccelerator() -> torch.device | None:
    """_accelerator_getAccelerator() -> Optional[torch.device]"""
def _accelerator_getDeviceIndex() -> int:
    """_accelerator_getDeviceIndex() -> int"""
def _accelerator_getStream(arg0: int) -> torch.Stream:
    """_accelerator_getStream(arg0: int) -> torch.Stream"""
def _accelerator_hooks_device_count() -> int:
    """_accelerator_hooks_device_count() -> int"""
def _accelerator_hooks_exchange_device(arg0: int) -> int:
    """_accelerator_hooks_exchange_device(arg0: int) -> int"""
def _accelerator_hooks_get_current_device() -> int:
    """_accelerator_hooks_get_current_device() -> int"""
def _accelerator_hooks_maybe_exchange_device(arg0: int) -> int:
    """_accelerator_hooks_maybe_exchange_device(arg0: int) -> int"""
def _accelerator_hooks_set_current_device(arg0: int) -> None:
    """_accelerator_hooks_set_current_device(arg0: int) -> None"""
def _accelerator_maybeExchangeDevice(arg0: int) -> int:
    """_accelerator_maybeExchangeDevice(arg0: int) -> int"""
def _accelerator_setDeviceIndex(arg0: int) -> None:
    """_accelerator_setDeviceIndex(arg0: int) -> None"""
def _accelerator_setStream(arg0: torch.Stream) -> None:
    """_accelerator_setStream(arg0: torch.Stream) -> None"""
def _accelerator_synchronizeDevice(arg0: int) -> None:
    """_accelerator_synchronizeDevice(arg0: int) -> None"""
def _activate_gpu_trace() -> None:
    """_activate_gpu_trace() -> None"""
def _add_cached_tensor(arg0: torch.Tensor) -> None:
    """_add_cached_tensor(arg0: torch.Tensor) -> None"""
def _add_docstr(*args, **kwargs): ...
def _any_output_is_alias_to_input_or_output(*args, **kwargs): ...
def _any_requires_grad(*args, **kwargs): ...
def _are_functorch_transforms_active() -> bool:
    """_are_functorch_transforms_active() -> bool"""
def _autograd_init(*args, **kwargs): ...
def _awaitable(*args, **kwargs) -> _Await:
    """_awaitable(*args, **kwargs) -> torch._C._Await"""
def _awaitable_nowait(arg0: object) -> _Await:
    """_awaitable_nowait(arg0: object) -> torch._C._Await"""
def _awaitable_wait(arg0: _Await) -> object:
    """_awaitable_wait(arg0: torch._C._Await) -> object"""
def _backport_for_mobile(arg0: str, arg1: str, arg2: int) -> bool:
    """_backport_for_mobile(arg0: str, arg1: str, arg2: int) -> bool"""
def _backport_for_mobile_from_buffer(arg0: str, arg1: str, arg2: int) -> bool:
    """_backport_for_mobile_from_buffer(arg0: str, arg1: str, arg2: int) -> bool"""
def _backport_for_mobile_from_buffer_to_buffer(arg0: str, arg1: int) -> bytes:
    """_backport_for_mobile_from_buffer_to_buffer(arg0: str, arg1: int) -> bytes"""
def _backport_for_mobile_to_buffer(arg0: str, arg1: int) -> bytes:
    """_backport_for_mobile_to_buffer(arg0: str, arg1: int) -> bytes"""
def _c10d_init(*args, **kwargs): ...
def _calculate_package_version_based_on_upgraders(arg0: bool) -> None:
    """_calculate_package_version_based_on_upgraders(arg0: bool) -> None"""
def _can_use_cudnn_attention(arg0: _SDPAParams, arg1: bool) -> bool:
    """_can_use_cudnn_attention(arg0: torch._C._SDPAParams, arg1: bool) -> bool"""
def _can_use_flash_attention(arg0: _SDPAParams, arg1: bool) -> bool:
    """_can_use_flash_attention(arg0: torch._C._SDPAParams, arg1: bool) -> bool"""
def _can_use_mem_efficient_attention(arg0: _SDPAParams, arg1: bool) -> bool:
    """_can_use_mem_efficient_attention(arg0: torch._C._SDPAParams, arg1: bool) -> bool"""
def _check_onnx_proto(proto_string: str) -> None:
    """_check_onnx_proto(proto_string: str) -> None"""
def _check_schema_allow_fake_script_object(arg0, *args, **kwargs) -> bool:
    """_check_schema_allow_fake_script_object(arg0: c10::FunctionSchema, *args, **kwargs) -> bool"""
def _check_sparse_tensor_invariants(*args, **kwargs): ...
def _collect_all(arg0: list[Future]) -> Future:
    """_collect_all(arg0: list[torch._C.Future]) -> torch._C.Future"""
def _commit_update(arg0: torch.Tensor) -> None:
    """_commit_update(arg0: torch.Tensor) -> None"""
def _compile_graph_to_code_table(arg0: str, arg1: Graph) -> IValue:
    """_compile_graph_to_code_table(arg0: str, arg1: torch._C.Graph) -> IValue"""
def _construct_storage_from_data_pointer(arg0: int, arg1: torch.device, arg2: int) -> torch.StorageBase:
    """_construct_storage_from_data_pointer(arg0: int, arg1: torch.device, arg2: int) -> torch.StorageBase"""
def _conv_determine_backend_memory_format(arg0: torch.Tensor, arg1: torch.Tensor, arg2: _ConvBackend) -> torch.memory_format:
    """_conv_determine_backend_memory_format(arg0: torch.Tensor, arg1: torch.Tensor, arg2: torch._C._ConvBackend) -> torch.memory_format"""
def _crash_if_aten_asan(*args, **kwargs): ...
def _crash_if_csrc_asan(*args, **kwargs): ...
def _crash_if_csrc_ubsan(*args, **kwargs): ...
def _crash_if_debug_asserts_fail(*args, **kwargs): ...
def _crash_if_vptr_ubsan(*args, **kwargs): ...
def _create_function_from_graph(arg0: str, arg1: Graph) -> ScriptFunction:
    """_create_function_from_graph(arg0: str, arg1: torch._C.Graph) -> torch._C.ScriptFunction"""
def _create_function_from_trace(name: str, func: Callable, input_tuple: tuple, var_name_lookup_fn: Callable, strict: bool, force_outplace: bool, argument_names: list[str] = ...) -> ScriptFunction:
    """_create_function_from_trace(name: str, func: Callable, input_tuple: tuple, var_name_lookup_fn: Callable, strict: bool, force_outplace: bool, argument_names: list[str] = []) -> torch._C.ScriptFunction"""
def _create_function_from_trace_with_dict(name: str, func: Callable, input_dict: dict, var_name_lookup_fn: Callable, strict: bool, force_outplace: bool, argument_names: list[str] = ...) -> ScriptFunction:
    """_create_function_from_trace_with_dict(name: str, func: Callable, input_dict: dict, var_name_lookup_fn: Callable, strict: bool, force_outplace: bool, argument_names: list[str] = []) -> torch._C.ScriptFunction"""
def _create_graph_by_tracing(func: Callable, inputs: list[IValue], var_name_lookup_fn: Callable, strict: bool, force_outplace: bool, self=..., argument_names: list[str] = ...) -> tuple[Graph, list[IValue]]:
    """_create_graph_by_tracing(func: Callable, inputs: list[IValue], var_name_lookup_fn: Callable, strict: bool, force_outplace: bool, self: torch::jit::Module = None, argument_names: list[str] = []) -> tuple[torch._C.Graph, list[IValue]]"""
def _create_module_with_type(arg0: ClassType) -> ScriptModule:
    """_create_module_with_type(arg0: torch._C.ClassType) -> torch._C.ScriptModule"""
def _create_object_with_type(arg0: ClassType) -> ScriptObject:
    """_create_object_with_type(arg0: torch._C.ClassType) -> torch._C.ScriptObject"""
def _current_autograd_node(*args, **kwargs): ...
def _current_graph_task_execution_order(*args, **kwargs): ...
def _current_graph_task_id(*args, **kwargs): ...
def _cxx_flags(*args, **kwargs): ...
def _data_address(arg0: torch.Tensor) -> int:
    """_data_address(arg0: torch.Tensor) -> int

    Gets the memory address of the Tensor's data pointer.
    """
def _debug_get_fusion_group_inlining() -> bool:
    """_debug_get_fusion_group_inlining() -> bool"""
def _debug_only_are_vmap_fallback_warnings_enabled(*args, **kwargs): ...
def _debug_only_display_vmap_fallback_warnings(*args, **kwargs): ...
def _debug_set_autodiff_subgraph_inlining(arg0: bool) -> None:
    """_debug_set_autodiff_subgraph_inlining(arg0: bool) -> None"""
def _debug_set_fusion_group_inlining(arg0: bool) -> None:
    """_debug_set_fusion_group_inlining(arg0: bool) -> None"""
def _demangle(arg0: str) -> str:
    """_demangle(arg0: str) -> str"""
def _disabled_torch_dispatch_impl(*args, **kwargs): ...
def _disabled_torch_function_impl(*args, **kwargs): ...
def _dispatch_call_boxed(arg0: _DispatchOperatorHandle, *args, **kwargs) -> object:
    """_dispatch_call_boxed(arg0: torch._C._DispatchOperatorHandle, *args, **kwargs) -> object"""
def _dispatch_check_all_invariants() -> None:
    """_dispatch_check_all_invariants() -> None"""
def _dispatch_check_invariants(arg0: str) -> None:
    """_dispatch_check_invariants(arg0: str) -> None"""
def _dispatch_dump(arg0: str) -> str:
    """_dispatch_dump(arg0: str) -> str"""
def _dispatch_dump_table(arg0: str) -> str:
    """_dispatch_dump_table(arg0: str) -> str"""
def _dispatch_find_dangling_impls() -> list[str]:
    """_dispatch_find_dangling_impls() -> list[str]"""
def _dispatch_find_schema_or_throw(arg0: str, arg1: str) -> _DispatchOperatorHandle:
    """_dispatch_find_schema_or_throw(arg0: str, arg1: str) -> torch._C._DispatchOperatorHandle"""
def _dispatch_get_all_op_names() -> list[str]:
    """_dispatch_get_all_op_names() -> list[str]"""
def _dispatch_get_backend_keyset_from_autograd(arg0: DispatchKey) -> DispatchKeySet:
    """_dispatch_get_backend_keyset_from_autograd(arg0: torch._C.DispatchKey) -> torch._C.DispatchKeySet"""
def _dispatch_get_registrations_for_dispatch_key(dispatch_key: str = ...) -> list[str]:
    """_dispatch_get_registrations_for_dispatch_key(dispatch_key: str = '') -> list[str]"""
def _dispatch_has_backend_fallback(arg0: DispatchKey) -> bool:
    """_dispatch_has_backend_fallback(arg0: torch._C.DispatchKey) -> bool"""
def _dispatch_has_computed_kernel_for_dispatch_key(arg0: str, arg1: str) -> bool:
    """_dispatch_has_computed_kernel_for_dispatch_key(arg0: str, arg1: str) -> bool"""
def _dispatch_has_kernel(arg0: str) -> bool:
    """_dispatch_has_kernel(arg0: str) -> bool"""
def _dispatch_has_kernel_for_any_dispatch_key(arg0: str, arg1) -> bool:
    """_dispatch_has_kernel_for_any_dispatch_key(arg0: str, arg1: c10::DispatchKeySet) -> bool"""
def _dispatch_has_kernel_for_dispatch_key(arg0: str, arg1) -> bool:
    """_dispatch_has_kernel_for_dispatch_key(arg0: str, arg1: c10::DispatchKey) -> bool"""
def _dispatch_isTensorSubclassLike(arg0: torch.Tensor) -> bool:
    """_dispatch_isTensorSubclassLike(arg0: torch.Tensor) -> bool"""
def _dispatch_is_alias_key(arg0: DispatchKey) -> bool:
    """_dispatch_is_alias_key(arg0: torch._C.DispatchKey) -> bool"""
def _dispatch_is_included_in_alias(arg0: DispatchKey, arg1: DispatchKey) -> bool:
    """_dispatch_is_included_in_alias(arg0: torch._C.DispatchKey, arg1: torch._C.DispatchKey) -> bool"""
def _dispatch_is_main_interpreter() -> bool:
    """_dispatch_is_main_interpreter() -> bool"""
def _dispatch_kernel_for_dispatch_key_is_fallthrough(arg0: str, arg1) -> bool:
    """_dispatch_kernel_for_dispatch_key_is_fallthrough(arg0: str, arg1: c10::DispatchKey) -> bool"""
def _dispatch_key_for_device(arg0: str) -> str:
    """_dispatch_key_for_device(arg0: str) -> str"""
def _dispatch_key_name(arg0) -> str:
    """_dispatch_key_name(arg0: c10::DispatchKey) -> str"""
def _dispatch_key_parse(*args, **kwargs):
    """_dispatch_key_parse(arg0: c10::DispatchKey) -> c10::DispatchKey"""
def _dispatch_key_set(arg0: torch.Tensor) -> str:
    """_dispatch_key_set(arg0: torch.Tensor) -> str"""
def _dispatch_keys(arg0: torch.Tensor) -> DispatchKeySet:
    """_dispatch_keys(arg0: torch.Tensor) -> torch._C.DispatchKeySet"""
def _dispatch_keyset_full() -> DispatchKeySet:
    """_dispatch_keyset_full() -> torch._C.DispatchKeySet"""
def _dispatch_keyset_full_after(arg0: DispatchKey) -> DispatchKeySet:
    """_dispatch_keyset_full_after(arg0: torch._C.DispatchKey) -> torch._C.DispatchKeySet"""
def _dispatch_keyset_to_string(arg0: DispatchKeySet) -> str:
    """_dispatch_keyset_to_string(arg0: torch._C.DispatchKeySet) -> str"""
def _dispatch_library(kind: str, name: str, dispatch: str, file: str = ..., linenum: int = ...) -> _DispatchModule:
    """_dispatch_library(kind: str, name: str, dispatch: str, file: str = '/dev/null', linenum: int = 0) -> torch._C._DispatchModule"""
def _dispatch_num_backends() -> int:
    """_dispatch_num_backends() -> int"""
def _dispatch_print_registrations_for_dispatch_key(dispatch_key: str = ...) -> None:
    """_dispatch_print_registrations_for_dispatch_key(dispatch_key: str = '') -> None"""
def _dispatch_pystub(arg0: str, arg1: str) -> tuple[str, str] | None:
    """_dispatch_pystub(arg0: str, arg1: str) -> Optional[tuple[str, str]]"""
def _dispatch_set_report_error_callback(arg0: _DispatchOperatorHandle, arg1: object) -> None:
    """_dispatch_set_report_error_callback(arg0: torch._C._DispatchOperatorHandle, arg1: object) -> None"""
def _dispatch_tls_is_dispatch_key_excluded(arg0) -> bool:
    """_dispatch_tls_is_dispatch_key_excluded(arg0: c10::DispatchKey) -> bool"""
def _dispatch_tls_is_dispatch_key_included(arg0) -> bool:
    """_dispatch_tls_is_dispatch_key_included(arg0: c10::DispatchKey) -> bool"""
def _dispatch_tls_local_exclude_set() -> DispatchKeySet:
    """_dispatch_tls_local_exclude_set() -> torch._C.DispatchKeySet"""
def _dispatch_tls_local_include_set() -> DispatchKeySet:
    """_dispatch_tls_local_include_set() -> torch._C.DispatchKeySet"""
def _dispatch_tls_set_dispatch_key_excluded(arg0, arg1: bool) -> None:
    """_dispatch_tls_set_dispatch_key_excluded(arg0: c10::DispatchKey, arg1: bool) -> None"""
def _dispatch_tls_set_dispatch_key_included(arg0, arg1: bool) -> None:
    """_dispatch_tls_set_dispatch_key_included(arg0: c10::DispatchKey, arg1: bool) -> None"""
def _dist_autograd_init(*args, **kwargs): ...
def _dump_local_tls_set() -> None:
    """_dump_local_tls_set() -> None"""
def _dump_upgraders_map() -> dict[str, Graph]:
    """_dump_upgraders_map() -> dict[str, torch._C.Graph]"""
def _enable_mobile_interface_call_export() -> None:
    """_enable_mobile_interface_call_export() -> None"""
def _enter_dual_level(*args, **kwargs): ...
def _error_if_any_worker_fails(*args, **kwargs): ...
def _exit_dual_level(*args, **kwargs): ...
def _export_operator_list(arg0: LiteScriptModule) -> set:
    """_export_operator_list(arg0: torch._C.LiteScriptModule) -> set"""
def _export_opnames(arg0: ScriptModule) -> list:
    """_export_opnames(arg0: torch._C.ScriptModule) -> list"""
def _faulty_agent_init(*args, **kwargs): ...
def _freeze_module(*args, **kwargs):
    """_freeze_module(module: torch::jit::Module, preservedAttrs: list[str] = [], freezeInterfaces: bool = True, preserveParameters: bool = False) -> torch::jit::Module"""
def _from_dlpack(*args, **kwargs): ...
def _functionality_to_backend_keys(*args, **kwargs):
    """_functionality_to_backend_keys(arg0: c10::DispatchKey) -> list[c10::DispatchKey]"""
def _functionalization_reapply_views_tls() -> bool:
    """_functionalization_reapply_views_tls() -> bool"""
@overload
def _fuse_to_static_module(module: ScriptModule, min_size: int = ...) -> None:
    """_fuse_to_static_module(*args, **kwargs)
    Overloaded function.

    1. _fuse_to_static_module(module: torch._C.ScriptModule, min_size: int = 4) -> None

    2. _fuse_to_static_module(graph: torch._C.Graph, min_size: int = 4) -> None
    """
@overload
def _fuse_to_static_module(graph: Graph, min_size: int = ...) -> None:
    """_fuse_to_static_module(*args, **kwargs)
    Overloaded function.

    1. _fuse_to_static_module(module: torch._C.ScriptModule, min_size: int = 4) -> None

    2. _fuse_to_static_module(graph: torch._C.Graph, min_size: int = 4) -> None
    """
def _fx_map_aggregate(*args, **kwargs):
    """Recursively apply a function to every element in an aggregate object."""
def _fx_map_arg(*args, **kwargs):
    """Recursively apply a function to every Node in an aggregate object."""
def _generate_upgraders_graph() -> dict[str, Graph]:
    """_generate_upgraders_graph() -> dict[str, torch._C.Graph]"""
def _get_accelerator(check: bool | None = ...) -> torch.device:
    """_get_accelerator(check: Optional[bool] = None) -> torch.device"""
def _get_autograd_fallback_mode() -> str:
    """_get_autograd_fallback_mode() -> str"""
def _get_backcompat_broadcast_warn(*args, **kwargs): ...
def _get_backcompat_keepdim_warn(*args, **kwargs): ...
def _get_blas_preferred_backend() -> _BlasBackend:
    """_get_blas_preferred_backend() -> torch._C._BlasBackend"""
def _get_caught_jit_exception_class_name() -> str:
    """_get_caught_jit_exception_class_name() -> str"""
def _get_caught_jit_exception_original_msg() -> str:
    """_get_caught_jit_exception_original_msg() -> str"""
def _get_constant_bool_symnode(arg0: int) -> _SymNode:
    """_get_constant_bool_symnode(arg0: int) -> torch._C._SymNode"""
def _get_cpp_backtrace(*args, **kwargs): ...
def _get_cpu_allow_fp16_reduced_precision_reduction(*args, **kwargs): ...
def _get_cpu_capability(*args, **kwargs): ...
def _get_cublas_allow_bf16_reduced_precision_reduction(*args, **kwargs): ...
def _get_cublas_allow_fp16_accumulation(*args, **kwargs): ...
def _get_cublas_allow_fp16_reduced_precision_reduction(*args, **kwargs): ...
def _get_cublas_allow_tf32(*args, **kwargs): ...
def _get_cudnn_allow_tf32(*args, **kwargs): ...
def _get_cudnn_batch_norm_reserve_space_size(input: torch.Tensor, training: bool) -> None:
    """_get_cudnn_batch_norm_reserve_space_size(input: torch.Tensor, training: bool) -> None"""
def _get_cudnn_benchmark(*args, **kwargs): ...
def _get_cudnn_deterministic(*args, **kwargs): ...
def _get_cudnn_enabled(*args, **kwargs): ...
def _get_cudnn_sdp_enabled(*args, **kwargs): ...
def _get_custom_class_python_wrapper(arg0: str, arg1: str) -> ScriptClass:
    """_get_custom_class_python_wrapper(arg0: str, arg1: str) -> torch._C.ScriptClass"""
def _get_default_device(*args, **kwargs): ...
def _get_deterministic_algorithms(*args, **kwargs): ...
def _get_deterministic_algorithms_warn_only(*args, **kwargs): ...
def _get_deterministic_fill_uninitialized_memory(*args, **kwargs): ...
def _get_dispatch_mode(*args, **kwargs): ...
def _get_dispatch_stack_at(*args, **kwargs): ...
def _get_file_format(arg0: str) -> str:
    """_get_file_format(arg0: str) -> str"""
def _get_flash_sdp_enabled(*args, **kwargs): ...
def _get_float32_matmul_precision(*args, **kwargs): ...
def _get_function_stack_at(*args, **kwargs): ...
def _get_graph_executor_optimize(new_settings: bool | None = ...) -> bool:
    """_get_graph_executor_optimize(new_settings: Optional[bool] = None) -> bool"""
def _get_linalg_preferred_backend() -> _LinalgBackend:
    """_get_linalg_preferred_backend() -> torch._C._LinalgBackend"""
def _get_math_sdp_allow_fp16_bf16_reduction(*args, **kwargs): ...
def _get_math_sdp_enabled(*args, **kwargs): ...
def _get_max_operator_version() -> int:
    """_get_max_operator_version() -> int"""
def _get_mem_efficient_sdp_enabled(*args, **kwargs): ...
def _get_mkldnn_deterministic(*args, **kwargs): ...
def _get_mkldnn_enabled(*args, **kwargs): ...
def _get_mobile_model_contained_types(arg0: str) -> set[str]:
    """_get_mobile_model_contained_types(arg0: str) -> set[str]"""
def _get_mobile_model_contained_types_from_buffer(arg0: str) -> set[str]:
    """_get_mobile_model_contained_types_from_buffer(arg0: str) -> set[str]"""
def _get_model_bytecode_version(arg0: str) -> int:
    """_get_model_bytecode_version(arg0: str) -> int"""
def _get_model_bytecode_version_from_buffer(arg0: str) -> int:
    """_get_model_bytecode_version_from_buffer(arg0: str) -> int"""
def _get_model_extra_files(arg0: str, arg1: dict) -> dict:
    """_get_model_extra_files(arg0: str, arg1: dict) -> dict"""
def _get_model_extra_files_from_buffer(arg0: str, arg1: dict) -> dict:
    """_get_model_extra_files_from_buffer(arg0: str, arg1: dict) -> dict"""
def _get_model_ops_and_info(arg0: str) -> dict[str, OperatorInfo]:
    """_get_model_ops_and_info(arg0: str) -> dict[str, torch._C.OperatorInfo]"""
def _get_model_ops_and_info_from_buffer(arg0: str) -> dict[str, OperatorInfo]:
    """_get_model_ops_and_info_from_buffer(arg0: str) -> dict[str, torch._C.OperatorInfo]"""
def _get_module_info_from_flatbuffer(arg0: str) -> dict:
    """_get_module_info_from_flatbuffer(arg0: str) -> dict"""
def _get_nested_int(arg0: int, arg1: int) -> int | torch.SymInt:
    """_get_nested_int(arg0: int, arg1: int) -> Union[int, torch.SymInt]"""
def _get_nnpack_enabled(*args, **kwargs): ...
def _get_obj_in_tls(arg0: str) -> object:
    """_get_obj_in_tls(arg0: str) -> object"""
def _get_onednn_allow_tf32(*args, **kwargs): ...
def _get_operation_overload(arg0: str, arg1: str) -> tuple | None:
    """_get_operation_overload(arg0: str, arg1: str) -> Optional[tuple]"""
def _get_operator_version_map() -> dict[str, list[_UpgraderEntry]]:
    """_get_operator_version_map() -> dict[str, list[torch._C._UpgraderEntry]]"""
def _get_overrideable_sdp_enabled(*args, **kwargs): ...
def _get_privateuse1_backend_name(*args, **kwargs): ...
def _get_qengine(*args, **kwargs): ...
def _get_rocm_fa_preferred_backend() -> _ROCmFABackend:
    """_get_rocm_fa_preferred_backend() -> torch._C._ROCmFABackend"""
def _get_schema(*args, **kwargs):
    """_get_schema(arg0: str, arg1: str) -> c10::FunctionSchema"""
def _get_sdp_priority_order(*args, **kwargs): ...
def _get_sm_carveout_experimental() -> int | None:
    """_get_sm_carveout_experimental() -> Optional[int]"""
def _get_tensor_metadata(arg0: torch.Tensor) -> dict[str, bool]:
    """_get_tensor_metadata(arg0: torch.Tensor) -> dict[str, bool]"""
def _get_thread_name(*args, **kwargs): ...
def _get_torch_function_state() -> _TorchFunctionState:
    """_get_torch_function_state() -> torch._C._TorchFunctionState"""
def _get_tracing_state() -> TracingState:
    """_get_tracing_state() -> torch._C.TracingState"""
def _get_upgrader_ranges(arg0: str) -> list[_UpgraderRange]:
    """_get_upgrader_ranges(arg0: str) -> list[torch._C._UpgraderRange]"""
def _get_upgraders_entry_map() -> dict[str, str]:
    """_get_upgraders_entry_map() -> dict[str, str]"""
def _get_upgraders_map_size() -> int:
    """_get_upgraders_map_size() -> int"""
def _get_value_trace(arg0: torch.Tensor) -> Value:
    """_get_value_trace(arg0: torch.Tensor) -> torch._C.Value"""
def _get_version_calculator_flag() -> bool:
    """_get_version_calculator_flag() -> bool"""
def _get_warnAlways(*args, **kwargs): ...
def _group_tensors_by_device_and_dtype(arg0: list[list[torch.Tensor | None]], arg1: bool) -> dict[tuple[torch.device, torch.dtype], tuple[list[list[torch.Tensor | None]], list[int]]]:
    """_group_tensors_by_device_and_dtype(arg0: list[list[Optional[torch.Tensor]]], arg1: bool) -> dict[tuple[torch.device, torch.dtype], tuple[list[list[Optional[torch.Tensor]]], list[int]]]"""
def _hack_do_not_use_clone_module_with_class(*args, **kwargs):
    """_hack_do_not_use_clone_module_with_class(arg0: torch::jit::Module, arg1: list[str], arg2: list[str]) -> torch::jit::Module"""
def _has_distributed(*args, **kwargs): ...
def _has_storage(arg0: torch.Tensor) -> bool:
    """_has_storage(arg0: torch.Tensor) -> bool"""
def _has_tensorexpr_cpp_tests() -> bool:
    """_has_tensorexpr_cpp_tests() -> bool"""
def _has_torch_function(*args, **kwargs):
    """Check for __torch_function__ implementations in the elements of an iterable
        or if a __torch_function__ mode is enabled.  Considers exact ``Tensor`` s
        and ``Parameter`` s non-dispatchable.  Use this to guard a call to
        :func:`handle_torch_function`; don't use it to test if something
        is Tensor-like, use :func:`is_tensor_like` instead.
        Arguments
        ---------
        relevant_args : iterable
            Iterable or arguments to check for __torch_function__ methods.
        Returns
        -------
        bool
            True if any of the elements of relevant_args have __torch_function__
            implementations, False otherwise.
        See Also
        ________
        torch.is_tensor_like
            Checks if something is a Tensor-like, including an exact ``Tensor``.
    """
def _has_torch_function_unary(*args, **kwargs):
    """Special case of `has_torch_function` for single inputs.
        Instead of:
          `has_torch_function((t,))`
        call:
          `has_torch_function_unary(t)`
        which skips unnecessary packing and unpacking work.
    """
def _has_torch_function_variadic(*args, **kwargs):
    """Special case of `has_torch_function` that skips tuple creation.

        This uses the METH_FASTCALL protocol introduced in Python 3.7

        Instead of:
          `has_torch_function((a, b))`
        call:
          `has_torch_function_variadic(a, b)`
        which skips unnecessary packing and unpacking work.
    """
def _import_ir_module_from_package(arg0: CompilationUnit, arg1: PyTorchFileReader, arg2: DeserializationStorageContext, arg3: object, arg4: str) -> ScriptModule:
    """_import_ir_module_from_package(arg0: torch._C.CompilationUnit, arg1: torch._C.PyTorchFileReader, arg2: torch._C.DeserializationStorageContext, arg3: object, arg4: str) -> torch._C.ScriptModule"""
def _increment_version(*args, **kwargs): ...
def _infer_size(*args, **kwargs): ...
def _initExtension(*args, **kwargs): ...
def _init_names(*args, **kwargs): ...
def _is_alias_of(arg0: object, arg1: object) -> bool:
    """_is_alias_of(arg0: object, arg1: object) -> bool"""
def _is_any_autocast_enabled(*args, **kwargs): ...
def _is_autocast_available(*args, **kwargs): ...
def _is_cached_tensor(arg0: torch.Tensor) -> bool:
    """_is_cached_tensor(arg0: torch.Tensor) -> bool"""
def _is_cow_tensor(arg0: torch.Tensor) -> bool:
    """_is_cow_tensor(arg0: torch.Tensor) -> bool

    Checks if a tensor's data pointer is COW
    """
def _is_default_mobile_cpu_allocator_set(*args, **kwargs): ...
def _is_flash_attention_available() -> bool:
    """_is_flash_attention_available() -> bool"""
def _is_fwd_grad_enabled(*args, **kwargs): ...
def _is_key_in_tls(arg0: str) -> bool:
    """_is_key_in_tls(arg0: str) -> bool"""
def _is_multithreading_enabled(*args, **kwargs):
    """Returns True if multithreading is currently enabled."""
def _is_torch_function_all_disabled(*args, **kwargs): ...
def _is_torch_function_enabled(*args, **kwargs): ...
def _is_torch_function_mode_enabled(*args, **kwargs): ...
def _is_tracing() -> bool:
    """_is_tracing() -> bool"""
def _is_view_replay_enabled(*args, **kwargs):
    """Returns True if view-replay is currently enabled."""
def _is_xnnpack_enabled(*args, **kwargs): ...
def _ivalue_debug_python_object(arg0: object) -> object:
    """_ivalue_debug_python_object(arg0: object) -> object"""
def _ivalue_tags_match(arg0: ScriptModule, arg1: ScriptModule) -> bool:
    """_ivalue_tags_match(arg0: torch._C.ScriptModule, arg1: torch._C.ScriptModule) -> bool"""
def _jit_assert_is_instance(arg0: object, arg1) -> None:
    """_jit_assert_is_instance(arg0: object, arg1: c10::Type) -> None"""
def _jit_can_fuse_on_cpu() -> bool:
    """_jit_can_fuse_on_cpu() -> bool"""
def _jit_can_fuse_on_cpu_legacy() -> bool:
    """_jit_can_fuse_on_cpu_legacy() -> bool"""
def _jit_can_fuse_on_gpu() -> bool:
    """_jit_can_fuse_on_gpu() -> bool"""
def _jit_cat_wo_conditionals(arg0: bool) -> None:
    """_jit_cat_wo_conditionals(arg0: bool) -> None"""
def _jit_check_alias_annotation(arg0, arg1: tuple, arg2: str) -> None:
    """_jit_check_alias_annotation(arg0: torch::jit::Graph, arg1: tuple, arg2: str) -> None"""
def _jit_clear_class_registry() -> None:
    """_jit_clear_class_registry() -> None"""
def _jit_debug_fuser_num_cached_kernel_specs() -> int:
    """_jit_debug_fuser_num_cached_kernel_specs() -> int"""
def _jit_debug_module_iterators(arg0: ScriptModule) -> dict:
    """_jit_debug_module_iterators(arg0: torch._C.ScriptModule) -> dict"""
def _jit_decay_packed_param_input_types(arg0) -> None:
    """_jit_decay_packed_param_input_types(arg0: torch::jit::Graph) -> None"""
def _jit_decomposition_graph_for_node(*args, **kwargs):
    """_jit_decomposition_graph_for_node(arg0: torch::jit::Node) -> Optional[torch::jit::Graph]"""
def _jit_differentiate(*args, **kwargs):
    """_jit_differentiate(arg0: torch::jit::Graph) -> torch::jit::Gradient"""
def _jit_erase_non_input_shape_information(arg0) -> None:
    """_jit_erase_non_input_shape_information(arg0: torch::jit::Graph) -> None"""
def _jit_flatten(arg0: object) -> tuple[list[torch.Tensor], IODescriptor]:
    """_jit_flatten(arg0: object) -> tuple[list[torch.Tensor], torch._C.IODescriptor]"""
def _jit_fuser_get_fused_kernel_code(arg0, arg1: list[torch.Tensor]) -> str:
    """_jit_fuser_get_fused_kernel_code(arg0: torch::jit::Graph, arg1: list[torch.Tensor]) -> str"""
def _jit_get_all_schemas() -> list[FunctionSchema]:
    """_jit_get_all_schemas() -> list[torch._C.FunctionSchema]"""
def _jit_get_custom_class_schemas() -> list[FunctionSchema]:
    """_jit_get_custom_class_schemas() -> list[torch._C.FunctionSchema]"""
def _jit_get_emit_hooks() -> tuple[Callable[[ScriptModule], None], Callable[[ScriptFunction], None]]:
    """_jit_get_emit_hooks() -> tuple[Callable[[torch._C.ScriptModule], None], Callable[[torch._C.ScriptFunction], None]]"""
def _jit_get_inline_everything_mode() -> bool:
    """_jit_get_inline_everything_mode() -> bool"""
def _jit_get_logging_option() -> str:
    """_jit_get_logging_option() -> str"""
def _jit_get_num_profiled_runs() -> int:
    """_jit_get_num_profiled_runs() -> int"""
def _jit_get_operation(qualified_name: str) -> tuple:
    """_jit_get_operation(qualified_name: str) -> tuple"""
def _jit_get_schemas_for_operator(arg0: str) -> list[FunctionSchema]:
    """_jit_get_schemas_for_operator(arg0: str) -> list[torch._C.FunctionSchema]"""
def _jit_get_te_cuda_pointwise_block_count() -> int:
    """_jit_get_te_cuda_pointwise_block_count() -> int"""
def _jit_get_te_cuda_pointwise_block_size() -> int:
    """_jit_get_te_cuda_pointwise_block_size() -> int"""
def _jit_get_te_cuda_pointwise_loop_levels() -> int:
    """_jit_get_te_cuda_pointwise_loop_levels() -> int"""
def _jit_get_te_generate_block_code() -> bool:
    """_jit_get_te_generate_block_code() -> bool"""
def _jit_get_te_must_use_llvm_cpu() -> bool:
    """_jit_get_te_must_use_llvm_cpu() -> bool"""
def _jit_get_tracer_state_warn() -> bool:
    """_jit_get_tracer_state_warn() -> bool"""
def _jit_has_cpp_tests() -> bool:
    """_jit_has_cpp_tests() -> bool"""
def _jit_init() -> bool:
    """_jit_init() -> bool"""
def _jit_interpret_graph(arg0, arg1: tuple) -> object:
    """_jit_interpret_graph(arg0: torch::jit::Graph, arg1: tuple) -> object

    Interpret a JIT graph with given inputs without running any optimization passes on it
    """
def _jit_is_onnx_log_enabled() -> bool:
    """_jit_is_onnx_log_enabled() -> bool

    Returns whether ONNX logging is enabled or disabled.
    """
def _jit_is_script_object(arg0: object) -> bool:
    """_jit_is_script_object(arg0: object) -> bool"""
def _jit_llga_enabled() -> bool:
    """_jit_llga_enabled() -> bool"""
def _jit_nvfuser_can_be_enabled() -> None:
    """_jit_nvfuser_can_be_enabled() -> None"""
def _jit_nvfuser_clear_comparison_callback() -> None:
    """_jit_nvfuser_clear_comparison_callback() -> None"""
def _jit_nvfuser_enabled() -> None:
    """_jit_nvfuser_enabled() -> None"""
def _jit_nvfuser_horizontal_mode() -> None:
    """_jit_nvfuser_horizontal_mode() -> None"""
def _jit_nvfuser_set_comparison_callback(arg0: bool, arg1: Callable) -> None:
    """_jit_nvfuser_set_comparison_callback(arg0: bool, arg1: Callable) -> None"""
def _jit_nvfuser_single_node_mode() -> None:
    """_jit_nvfuser_single_node_mode() -> None"""
def _jit_object_is_non_holding(arg0) -> bool:
    """_jit_object_is_non_holding(arg0: torch::jit::Node) -> bool"""
def _jit_onnx_convert_pattern_from_subblock(*args, **kwargs):
    """_jit_onnx_convert_pattern_from_subblock(arg0: torch::jit::Block, arg1: torch::jit::Node, arg2: dict, arg3: set) -> list[torch::jit::Value]"""
def _jit_onnx_create_full_scope_name(arg0: str, arg1: str) -> str:
    """_jit_onnx_create_full_scope_name(arg0: str, arg1: str) -> str

    Create a full scope name from class name and variable name.
    """
def _jit_onnx_list_model_parameters(*args, **kwargs):
    """_jit_onnx_list_model_parameters(arg0: torch::jit::Module) -> tuple[torch::jit::Module, list[IValue]]"""
def _jit_onnx_log(*args) -> None:
    """_jit_onnx_log(*args) -> None

    Write `args` to the previously specified ONNX log stream.
    """
def _jit_opt_conditionals(arg0: bool) -> None:
    """_jit_opt_conditionals(arg0: bool) -> None"""
def _jit_override_can_fuse_on_cpu(arg0: bool) -> None:
    """_jit_override_can_fuse_on_cpu(arg0: bool) -> None"""
def _jit_override_can_fuse_on_cpu_legacy(arg0: bool) -> None:
    """_jit_override_can_fuse_on_cpu_legacy(arg0: bool) -> None"""
def _jit_override_can_fuse_on_gpu(arg0: bool) -> None:
    """_jit_override_can_fuse_on_gpu(arg0: bool) -> None"""
def _jit_pass_autocast(arg0) -> None:
    """_jit_pass_autocast(arg0: torch::jit::Graph) -> None"""
def _jit_pass_batch_mm(arg0) -> None:
    """_jit_pass_batch_mm(arg0: torch::jit::Graph) -> None"""
def _jit_pass_canonicalize(*args, **kwargs):
    """_jit_pass_canonicalize(graph: torch::jit::Graph, keep_unique_names: bool = True) -> torch::jit::Graph"""
def _jit_pass_canonicalize_graph_fuser_ops(arg0) -> None:
    """_jit_pass_canonicalize_graph_fuser_ops(arg0: torch::jit::Graph) -> None"""
def _jit_pass_complete_shape_analysis(arg0, arg1: tuple, arg2: bool) -> None:
    """_jit_pass_complete_shape_analysis(arg0: torch::jit::Graph, arg1: tuple, arg2: bool) -> None"""
def _jit_pass_concat_frozen_linear(arg0) -> bool:
    """_jit_pass_concat_frozen_linear(arg0: torch::jit::Graph) -> bool"""
def _jit_pass_constant_loop_unrolling(arg0) -> bool:
    """_jit_pass_constant_loop_unrolling(arg0: torch::jit::Graph) -> bool"""
def _jit_pass_constant_pooling(arg0) -> None:
    """_jit_pass_constant_pooling(arg0: torch::jit::Graph) -> None"""
def _jit_pass_constant_propagation(graph) -> bool:
    """_jit_pass_constant_propagation(graph: torch::jit::Graph) -> bool"""
def _jit_pass_constant_propagation_immutable_types(arg0) -> bool:
    """_jit_pass_constant_propagation_immutable_types(arg0: torch::jit::Graph) -> bool"""
def _jit_pass_convert_frozen_ops_to_mkldnn(arg0) -> None:
    """_jit_pass_convert_frozen_ops_to_mkldnn(arg0: torch::jit::Graph) -> None"""
def _jit_pass_create_autodiff_subgraphs(graph, threshold: object = ...) -> None:
    """_jit_pass_create_autodiff_subgraphs(graph: torch::jit::Graph, threshold: object = None) -> None"""
def _jit_pass_create_functional_graphs(arg0) -> None:
    """_jit_pass_create_functional_graphs(arg0: torch::jit::Graph) -> None"""
def _jit_pass_cse(arg0) -> bool:
    """_jit_pass_cse(arg0: torch::jit::Graph) -> bool"""
def _jit_pass_custom_pattern_based_rewrite(arg0: str, arg1: str, arg2) -> None:
    """_jit_pass_custom_pattern_based_rewrite(arg0: str, arg1: str, arg2: torch::jit::Module) -> None"""
def _jit_pass_custom_pattern_based_rewrite_graph(pattern: str, fused_node_name: str, g, value_name_pairs: list[tuple[str, str]] = ...) -> None:
    """_jit_pass_custom_pattern_based_rewrite_graph(pattern: str, fused_node_name: str, g: torch::jit::Graph, value_name_pairs: list[tuple[str, str]] = []) -> None"""
def _jit_pass_dbr_quant_remove_redundant_aliases(*args, **kwargs):
    """_jit_pass_dbr_quant_remove_redundant_aliases(arg0: torch::jit::Module) -> torch::jit::Module"""
def _jit_pass_dce(arg0) -> None:
    """_jit_pass_dce(arg0: torch::jit::Graph) -> None"""
def _jit_pass_dce_allow_deleting_nodes_with_side_effects(arg0) -> None:
    """_jit_pass_dce_allow_deleting_nodes_with_side_effects(arg0: torch::jit::Graph) -> None"""
def _jit_pass_dce_graph(arg0) -> None:
    """_jit_pass_dce_graph(arg0: torch::jit::Graph) -> None"""
def _jit_pass_decompose_ops(arg0) -> None:
    """_jit_pass_decompose_ops(arg0: torch::jit::Graph) -> None"""
def _jit_pass_dedup_module_uses(arg0) -> None:
    """_jit_pass_dedup_module_uses(arg0: torch::jit::Module) -> None"""
def _jit_pass_erase_number_types(arg0) -> None:
    """_jit_pass_erase_number_types(arg0: torch::jit::Graph) -> None"""
def _jit_pass_erase_shape_information(arg0) -> None:
    """_jit_pass_erase_shape_information(arg0: torch::jit::Graph) -> None"""
def _jit_pass_filter_non_tensor_arguments(arg0: dict[str, IValue]) -> dict[str, torch.Tensor]:
    """_jit_pass_filter_non_tensor_arguments(arg0: dict[str, IValue]) -> dict[str, torch.Tensor]"""
def _jit_pass_fixup_onnx_controlflow_node(*args, **kwargs):
    """_jit_pass_fixup_onnx_controlflow_node(arg0: torch::jit::Node, arg1: int) -> list[torch::jit::Value]"""
def _jit_pass_fold_convbn(*args, **kwargs):
    """_jit_pass_fold_convbn(arg0: torch::jit::Module) -> torch::jit::Module"""
def _jit_pass_fold_frozen_conv_add_or_sub(arg0) -> bool:
    """_jit_pass_fold_frozen_conv_add_or_sub(arg0: torch::jit::Graph) -> bool"""
def _jit_pass_fold_frozen_conv_bn(arg0) -> bool:
    """_jit_pass_fold_frozen_conv_bn(arg0: torch::jit::Graph) -> bool"""
def _jit_pass_fold_frozen_conv_mul_or_div(arg0) -> bool:
    """_jit_pass_fold_frozen_conv_mul_or_div(arg0: torch::jit::Graph) -> bool"""
def _jit_pass_fold_frozen_linear_bn(arg0) -> bool:
    """_jit_pass_fold_frozen_linear_bn(arg0: torch::jit::Graph) -> bool"""
def _jit_pass_fold_prepacking_ops(arg0) -> None:
    """_jit_pass_fold_prepacking_ops(arg0: torch::jit::Module) -> None"""
def _jit_pass_functional_to_inplace_activation(arg0) -> bool:
    """_jit_pass_functional_to_inplace_activation(arg0: torch::jit::Graph) -> bool"""
def _jit_pass_fuse(arg0, arg1: bool) -> None:
    """_jit_pass_fuse(arg0: torch::jit::Graph, arg1: bool) -> None"""
def _jit_pass_fuse_add_relu(arg0) -> None:
    """_jit_pass_fuse_add_relu(arg0: torch::jit::Graph) -> None"""
def _jit_pass_fuse_addmm(arg0) -> bool:
    """_jit_pass_fuse_addmm(arg0: torch::jit::Graph) -> bool"""
def _jit_pass_fuse_clamp_w_prepacked_linear_conv(arg0) -> None:
    """_jit_pass_fuse_clamp_w_prepacked_linear_conv(arg0: torch::jit::Module) -> None"""
def _jit_pass_fuse_frozen_conv_add_relu(arg0) -> None:
    """_jit_pass_fuse_frozen_conv_add_relu(arg0: torch::jit::Graph) -> None"""
def _jit_pass_fuse_linear(arg0) -> None:
    """_jit_pass_fuse_linear(arg0: torch::jit::Graph) -> None"""
def _jit_pass_fuse_quantized_add_relu(arg0) -> None:
    """_jit_pass_fuse_quantized_add_relu(arg0: torch::jit::Graph) -> None"""
def _jit_pass_fuse_tensorexprs(arg0) -> None:
    """_jit_pass_fuse_tensorexprs(arg0: torch::jit::Graph) -> None"""
def _jit_pass_inline(arg0) -> None:
    """_jit_pass_inline(arg0: torch::jit::Graph) -> None"""
def _jit_pass_inline_fork_wait(arg0) -> None:
    """_jit_pass_inline_fork_wait(arg0: torch::jit::Graph) -> None"""
def _jit_pass_inline_functional_graphs(arg0) -> None:
    """_jit_pass_inline_functional_graphs(arg0: torch::jit::Graph) -> None"""
def _jit_pass_inplace_to_functional_activation(arg0) -> bool:
    """_jit_pass_inplace_to_functional_activation(arg0: torch::jit::Graph) -> bool"""
def _jit_pass_insert_observer_method_for_ondevice_ptq(*args, **kwargs):
    """_jit_pass_insert_observer_method_for_ondevice_ptq(module: torch::jit::Module, method_name: str, qconfig_dict: dict, inplace: bool, quant_type_int: int = 1) -> torch::jit::Module"""
def _jit_pass_insert_observers(*args, **kwargs):
    """_jit_pass_insert_observers(module: torch::jit::Module, method_name: str, qconfig_dict: dict, inplace: bool, quant_type_int: int = 1) -> torch::jit::Module"""
@overload
def _jit_pass_insert_prepack_unpack(arg0) -> None:
    """_jit_pass_insert_prepack_unpack(*args, **kwargs)
    Overloaded function.

    1. _jit_pass_insert_prepack_unpack(arg0: torch::jit::Graph) -> None

    2. _jit_pass_insert_prepack_unpack(arg0: torch::jit::Module) -> None
    """
@overload
def _jit_pass_insert_prepack_unpack(arg0) -> None:
    """_jit_pass_insert_prepack_unpack(*args, **kwargs)
    Overloaded function.

    1. _jit_pass_insert_prepack_unpack(arg0: torch::jit::Graph) -> None

    2. _jit_pass_insert_prepack_unpack(arg0: torch::jit::Module) -> None
    """
@overload
def _jit_pass_insert_prepacked_ops(arg0) -> None:
    """_jit_pass_insert_prepacked_ops(*args, **kwargs)
    Overloaded function.

    1. _jit_pass_insert_prepacked_ops(arg0: torch::jit::Graph) -> None

    2. _jit_pass_insert_prepacked_ops(arg0: torch::jit::Module) -> None
    """
@overload
def _jit_pass_insert_prepacked_ops(arg0) -> None:
    """_jit_pass_insert_prepacked_ops(*args, **kwargs)
    Overloaded function.

    1. _jit_pass_insert_prepacked_ops(arg0: torch::jit::Graph) -> None

    2. _jit_pass_insert_prepacked_ops(arg0: torch::jit::Module) -> None
    """
def _jit_pass_insert_quant_dequant(*args, **kwargs):
    """_jit_pass_insert_quant_dequant(module: torch::jit::Module, method_name: str, inplace: bool, debug: bool, quant_type_int: int = 1) -> torch::jit::Module"""
def _jit_pass_insert_quant_dequant_for_ondevice_ptq(*args, **kwargs):
    """_jit_pass_insert_quant_dequant_for_ondevice_ptq(module: torch::jit::Module, method_name: str, inplace: bool, debug: bool, quant_type_int: int = 1) -> torch::jit::Module"""
def _jit_pass_integer_value_refinement(arg0) -> bool:
    """_jit_pass_integer_value_refinement(arg0: torch::jit::Graph) -> bool"""
def _jit_pass_lint(arg0) -> None:
    """_jit_pass_lint(arg0: torch::jit::Graph) -> None"""
def _jit_pass_loop_unrolling(arg0) -> bool:
    """_jit_pass_loop_unrolling(arg0: torch::jit::Graph) -> bool"""
def _jit_pass_lower_all_tuples(arg0) -> None:
    """_jit_pass_lower_all_tuples(arg0: torch::jit::Graph) -> None"""
def _jit_pass_lower_graph(*args, **kwargs):
    """_jit_pass_lower_graph(arg0: torch::jit::Graph, arg1: torch::jit::Module) -> tuple[torch::jit::Graph, list[IValue]]"""
def _jit_pass_metal_fold_prepacking_ops(arg0) -> None:
    """_jit_pass_metal_fold_prepacking_ops(arg0: torch::jit::Module) -> None"""
def _jit_pass_metal_fuse_clamp_w_prepacked_conv(arg0) -> None:
    """_jit_pass_metal_fuse_clamp_w_prepacked_conv(arg0: torch::jit::Module) -> None"""
@overload
def _jit_pass_metal_insert_prepacked_ops(arg0) -> None:
    """_jit_pass_metal_insert_prepacked_ops(*args, **kwargs)
    Overloaded function.

    1. _jit_pass_metal_insert_prepacked_ops(arg0: torch::jit::Graph) -> None

    2. _jit_pass_metal_insert_prepacked_ops(arg0: torch::jit::Module) -> None
    """
@overload
def _jit_pass_metal_insert_prepacked_ops(arg0) -> None:
    """_jit_pass_metal_insert_prepacked_ops(*args, **kwargs)
    Overloaded function.

    1. _jit_pass_metal_insert_prepacked_ops(arg0: torch::jit::Graph) -> None

    2. _jit_pass_metal_insert_prepacked_ops(arg0: torch::jit::Module) -> None
    """
def _jit_pass_metal_optimize_for_mobile(*args, **kwargs):
    """_jit_pass_metal_optimize_for_mobile(arg0: torch::jit::Module, arg1: list[str]) -> torch::jit::Module"""
def _jit_pass_onnx(*args, **kwargs):
    """_jit_pass_onnx(arg0: torch::jit::Graph, arg1: torch::onnx::OperatorExportTypes) -> torch::jit::Graph"""
def _jit_pass_onnx_assign_output_shape(arg0, arg1: list[torch.Tensor], arg2, arg3: bool, arg4: bool, arg5: int) -> None:
    """_jit_pass_onnx_assign_output_shape(arg0: torch::jit::Graph, arg1: list[torch.Tensor], arg2: torch::jit::python::IODescriptor, arg3: bool, arg4: bool, arg5: int) -> None"""
def _jit_pass_onnx_assign_scoped_names_for_node_and_value(arg0) -> None:
    """_jit_pass_onnx_assign_scoped_names_for_node_and_value(arg0: torch::jit::Graph) -> None

    Assign informative scoped names for nodes and values.
    """
def _jit_pass_onnx_autograd_function_process(arg0) -> None:
    """_jit_pass_onnx_autograd_function_process(arg0: torch::jit::Graph) -> None"""
def _jit_pass_onnx_block(arg0, arg1, arg2, arg3: dict, arg4: set, arg5: bool) -> dict:
    """_jit_pass_onnx_block(arg0: torch::jit::Block, arg1: torch::jit::Block, arg2: torch::onnx::OperatorExportTypes, arg3: dict, arg4: set, arg5: bool) -> dict"""
def _jit_pass_onnx_cast_all_constant_to_floating(arg0) -> None:
    """_jit_pass_onnx_cast_all_constant_to_floating(arg0: torch::jit::Graph) -> None"""
def _jit_pass_onnx_clear_scope_records() -> None:
    """_jit_pass_onnx_clear_scope_records() -> None"""
def _jit_pass_onnx_constant_fold(arg0, arg1: dict[str, IValue], arg2: int) -> dict[str, IValue]:
    """_jit_pass_onnx_constant_fold(arg0: torch::jit::Graph, arg1: dict[str, IValue], arg2: int) -> dict[str, IValue]"""
def _jit_pass_onnx_deduplicate_initializers(arg0, arg1: dict[str, IValue], arg2: bool) -> dict[str, IValue]:
    """_jit_pass_onnx_deduplicate_initializers(arg0: torch::jit::Graph, arg1: dict[str, IValue], arg2: bool) -> dict[str, IValue]"""
def _jit_pass_onnx_eliminate_unused_items(arg0, arg1: dict[str, IValue]) -> dict[str, IValue]:
    """_jit_pass_onnx_eliminate_unused_items(arg0: torch::jit::Graph, arg1: dict[str, IValue]) -> dict[str, IValue]"""
def _jit_pass_onnx_eval_peephole(arg0, arg1: dict[str, IValue]) -> dict[str, IValue]:
    """_jit_pass_onnx_eval_peephole(arg0: torch::jit::Graph, arg1: dict[str, IValue]) -> dict[str, IValue]"""
def _jit_pass_onnx_function_extraction(*args, **kwargs):
    """_jit_pass_onnx_function_extraction(arg0: torch::jit::Graph, arg1: set[str], arg2: list[str]) -> dict[torch::jit::Node, dict[str, str]]"""
def _jit_pass_onnx_function_substitution(arg0) -> None:
    """_jit_pass_onnx_function_substitution(arg0: torch::jit::Graph) -> None"""
def _jit_pass_onnx_graph_shape_type_inference(graph, params_dict: dict[str, IValue], opset_version: int) -> None:
    """_jit_pass_onnx_graph_shape_type_inference(graph: torch::jit::Graph, params_dict: dict[str, IValue], opset_version: int) -> None"""
def _jit_pass_onnx_lint(arg0) -> None:
    """_jit_pass_onnx_lint(arg0: torch::jit::Graph) -> None"""
def _jit_pass_onnx_node_shape_type_inference(arg0, arg1: dict[str, IValue], arg2: int) -> None:
    """_jit_pass_onnx_node_shape_type_inference(arg0: torch::jit::Node, arg1: dict[str, IValue], arg2: int) -> None"""
def _jit_pass_onnx_peephole(arg0, arg1: int, arg2: bool) -> None:
    """_jit_pass_onnx_peephole(arg0: torch::jit::Graph, arg1: int, arg2: bool) -> None"""
def _jit_pass_onnx_preprocess(arg0) -> None:
    """_jit_pass_onnx_preprocess(arg0: torch::jit::Graph) -> None"""
def _jit_pass_onnx_preprocess_caffe2(arg0) -> None:
    """_jit_pass_onnx_preprocess_caffe2(arg0: torch::jit::Graph) -> None"""
def _jit_pass_onnx_quantization_insert_permutes(arg0, arg1: dict[str, IValue]) -> dict[str, IValue]:
    """_jit_pass_onnx_quantization_insert_permutes(arg0: torch::jit::Graph, arg1: dict[str, IValue]) -> dict[str, IValue]"""
def _jit_pass_onnx_remove_inplace_ops_for_onnx(arg0, arg1) -> None:
    """_jit_pass_onnx_remove_inplace_ops_for_onnx(arg0: torch::jit::Graph, arg1: torch::jit::Module) -> None"""
def _jit_pass_onnx_remove_print(arg0) -> None:
    """_jit_pass_onnx_remove_print(arg0: torch::jit::Graph) -> None"""
def _jit_pass_onnx_scalar_type_analysis(graph, lowprecision_cast: bool = ..., opset_version: int) -> None:
    """_jit_pass_onnx_scalar_type_analysis(graph: torch::jit::Graph, lowprecision_cast: bool = True, opset_version: int) -> None"""
def _jit_pass_onnx_set_dynamic_input_shape(arg0, arg1: dict[str, dict[int, str]], arg2: list[str]) -> None:
    """_jit_pass_onnx_set_dynamic_input_shape(arg0: torch::jit::Graph, arg1: dict[str, dict[int, str]], arg2: list[str]) -> None"""
def _jit_pass_onnx_track_scope_attributes(arg0, arg1: dict[str, IValue]) -> None:
    """_jit_pass_onnx_track_scope_attributes(arg0: torch::jit::Graph, arg1: dict[str, IValue]) -> None"""
def _jit_pass_onnx_unpack_quantized_weights(arg0, arg1: dict[str, IValue]) -> dict[str, IValue]:
    """_jit_pass_onnx_unpack_quantized_weights(arg0: torch::jit::Graph, arg1: dict[str, IValue]) -> dict[str, IValue]"""
def _jit_pass_optimize_for_inference(module, other_methods: list[str] = ...) -> None:
    """_jit_pass_optimize_for_inference(module: torch::jit::Module, other_methods: list[str] = []) -> None"""
def _jit_pass_optimize_for_mobile(*args, **kwargs):
    """_jit_pass_optimize_for_mobile(arg0: torch::jit::Module, arg1: set[MobileOptimizerType], arg2: list[str]) -> torch::jit::Module"""
def _jit_pass_optimize_frozen_graph(arg0, arg1: bool) -> None:
    """_jit_pass_optimize_frozen_graph(arg0: torch::jit::Graph, arg1: bool) -> None"""
def _jit_pass_pattern_based_rewrite(*args, **kwargs):
    """_jit_pass_pattern_based_rewrite(arg0: torch::jit::Module) -> torch::jit::Module"""
def _jit_pass_peephole(graph, disable_shape_peepholes: bool = ...) -> bool:
    """_jit_pass_peephole(graph: torch::jit::Graph, disable_shape_peepholes: bool = False) -> bool"""
def _jit_pass_peephole_list_idioms(graph, refine_list_len: bool = ...) -> bool:
    """_jit_pass_peephole_list_idioms(graph: torch::jit::Graph, refine_list_len: bool = False) -> bool"""
def _jit_pass_prepare_division_for_onnx(arg0) -> None:
    """_jit_pass_prepare_division_for_onnx(arg0: torch::jit::Graph) -> None"""
def _jit_pass_propagate_device(arg0) -> bool:
    """_jit_pass_propagate_device(arg0: torch::jit::Graph) -> bool"""
def _jit_pass_propagate_dtype(arg0) -> bool:
    """_jit_pass_propagate_dtype(arg0: torch::jit::Graph) -> bool"""
def _jit_pass_propagate_shapes_on_graph(arg0) -> None:
    """_jit_pass_propagate_shapes_on_graph(arg0: torch::jit::Graph) -> None"""
def _jit_pass_propagate_shapes_on_graph_and_build_compute(*args, **kwargs):
    """_jit_pass_propagate_shapes_on_graph_and_build_compute(*args, **kwargs)
    Overloaded function.

    1. _jit_pass_propagate_shapes_on_graph_and_build_compute(arg0: torch::jit::Graph) -> Optional[torch::jit::ShapeComputeGraphMapping]

    2. _jit_pass_propagate_shapes_on_graph_and_build_compute(arg0: torch::jit::Graph, arg1: torch::jit::Node) -> Optional[torch::jit::ShapeComputeGraphMapping]

    3. _jit_pass_propagate_shapes_on_graph_and_build_compute(arg0: torch::jit::Graph, arg1: torch::jit::Node, arg2: torch::jit::Node) -> Optional[torch::jit::ShapeComputeGraphMapping]
    """
def _jit_pass_quant_finalize(*args, **kwargs):
    """_jit_pass_quant_finalize(module: torch::jit::Module, quant_type_int: int = 1, preserved_attrs: list[str] = []) -> torch::jit::Module"""
def _jit_pass_quant_finalize_for_ondevice_ptq(*args, **kwargs):
    """_jit_pass_quant_finalize_for_ondevice_ptq(module: torch::jit::Module, quant_type_int: int = 1, preserved_attrs: str = []) -> torch::jit::Module"""
def _jit_pass_quant_fusion(arg0) -> None:
    """_jit_pass_quant_fusion(arg0: torch::jit::Graph) -> None"""
def _jit_pass_refine_integer_values(arg0) -> bool:
    """_jit_pass_refine_integer_values(arg0: torch::jit::Graph) -> bool"""
def _jit_pass_refine_tuple_types(arg0) -> None:
    """_jit_pass_refine_tuple_types(arg0: torch::jit::Graph) -> None"""
def _jit_pass_remove_dropout(arg0) -> None:
    """_jit_pass_remove_dropout(arg0: torch::jit::Module) -> None"""
def _jit_pass_remove_expands(arg0) -> None:
    """_jit_pass_remove_expands(arg0: torch::jit::Graph) -> None"""
def _jit_pass_remove_inplace_ops(arg0) -> None:
    """_jit_pass_remove_inplace_ops(arg0: torch::jit::Graph) -> None"""
def _jit_pass_remove_mutation(arg0) -> bool:
    """_jit_pass_remove_mutation(arg0: torch::jit::Graph) -> bool"""
def _jit_pass_replace_old_ops_with_upgraders(arg0) -> None:
    """_jit_pass_replace_old_ops_with_upgraders(arg0: torch::jit::Graph) -> None"""
def _jit_pass_replicate_dequantize(arg0) -> None:
    """_jit_pass_replicate_dequantize(arg0: torch::jit::Graph) -> None"""
def _jit_pass_run_decompositions(arg0) -> None:
    """_jit_pass_run_decompositions(arg0: torch::jit::Graph) -> None"""
def _jit_pass_specialize_autogradzero(arg0) -> None:
    """_jit_pass_specialize_autogradzero(arg0: torch::jit::Graph) -> None"""
@overload
def _jit_pass_swap_functional_linear(arg0) -> None:
    """_jit_pass_swap_functional_linear(*args, **kwargs)
    Overloaded function.

    1. _jit_pass_swap_functional_linear(arg0: torch::jit::Graph) -> None

    2. _jit_pass_swap_functional_linear(arg0: torch::jit::Module) -> None
    """
@overload
def _jit_pass_swap_functional_linear(arg0) -> None:
    """_jit_pass_swap_functional_linear(*args, **kwargs)
    Overloaded function.

    1. _jit_pass_swap_functional_linear(arg0: torch::jit::Graph) -> None

    2. _jit_pass_swap_functional_linear(arg0: torch::jit::Module) -> None
    """
@overload
def _jit_pass_transform_conv1d_to_conv2d(arg0) -> None:
    """_jit_pass_transform_conv1d_to_conv2d(*args, **kwargs)
    Overloaded function.

    1. _jit_pass_transform_conv1d_to_conv2d(arg0: torch::jit::Graph) -> None

    2. _jit_pass_transform_conv1d_to_conv2d(arg0: torch::jit::Module) -> None
    """
@overload
def _jit_pass_transform_conv1d_to_conv2d(arg0) -> None:
    """_jit_pass_transform_conv1d_to_conv2d(*args, **kwargs)
    Overloaded function.

    1. _jit_pass_transform_conv1d_to_conv2d(arg0: torch::jit::Graph) -> None

    2. _jit_pass_transform_conv1d_to_conv2d(arg0: torch::jit::Module) -> None
    """
def _jit_pass_transpose_frozen_linear(arg0) -> bool:
    """_jit_pass_transpose_frozen_linear(arg0: torch::jit::Graph) -> bool"""
def _jit_pass_vulkan_fold_prepacking_ops(arg0) -> None:
    """_jit_pass_vulkan_fold_prepacking_ops(arg0: torch::jit::Module) -> None"""
def _jit_pass_vulkan_fuse_clamp_w_prepacked_conv(arg0) -> None:
    """_jit_pass_vulkan_fuse_clamp_w_prepacked_conv(arg0: torch::jit::Module) -> None"""
@overload
def _jit_pass_vulkan_insert_prepacked_ops(arg0) -> None:
    """_jit_pass_vulkan_insert_prepacked_ops(*args, **kwargs)
    Overloaded function.

    1. _jit_pass_vulkan_insert_prepacked_ops(arg0: torch::jit::Graph) -> None

    2. _jit_pass_vulkan_insert_prepacked_ops(arg0: torch::jit::Module) -> None
    """
@overload
def _jit_pass_vulkan_insert_prepacked_ops(arg0) -> None:
    """_jit_pass_vulkan_insert_prepacked_ops(*args, **kwargs)
    Overloaded function.

    1. _jit_pass_vulkan_insert_prepacked_ops(arg0: torch::jit::Graph) -> None

    2. _jit_pass_vulkan_insert_prepacked_ops(arg0: torch::jit::Module) -> None
    """
def _jit_pass_vulkan_optimize_for_mobile(*args, **kwargs):
    """_jit_pass_vulkan_optimize_for_mobile(arg0: torch::jit::Module, arg1: set[MobileOptimizerType], arg2: list[str]) -> torch::jit::Module"""
def _jit_register_decomposition_for_schema(arg0, arg1) -> None:
    """_jit_register_decomposition_for_schema(arg0: c10::FunctionSchema, arg1: torch::jit::Graph) -> None"""
def _jit_register_shape_compute_graph_for_node(arg0, arg1) -> None:
    """_jit_register_shape_compute_graph_for_node(arg0: torch::jit::Node, arg1: torch::jit::Graph) -> None"""
def _jit_resolve_packet(arg0: str, *args, **kwargs) -> str:
    """_jit_resolve_packet(arg0: str, *args, **kwargs) -> str"""
def _jit_run_cpp_tests() -> None:
    """_jit_run_cpp_tests() -> None"""
def _jit_script_class_compile(arg0: str, arg1: _jit_tree_views.ClassDef, arg2: dict[str, dict[str, object]], arg3: Callable[[str], object]) -> ClassType:
    """_jit_script_class_compile(arg0: str, arg1: torch._C._jit_tree_views.ClassDef, arg2: dict[str, dict[str, object]], arg3: Callable[[str], object]) -> torch._C.ClassType"""
def _jit_script_compile(arg0: str, arg1: _jit_tree_views.Def, arg2: Callable[[str], object], arg3: dict[str, object]) -> ScriptFunction:
    """_jit_script_compile(arg0: str, arg1: torch._C._jit_tree_views.Def, arg2: Callable[[str], object], arg3: dict[str, object]) -> torch._C.ScriptFunction"""
def _jit_script_compile_overload(arg0: str, arg1: _jit_tree_views.Decl, arg2: _jit_tree_views.Def, arg3: Callable[[str], object], arg4: dict[str, object], arg5: object) -> ScriptFunction:
    """_jit_script_compile_overload(arg0: str, arg1: torch._C._jit_tree_views.Decl, arg2: torch._C._jit_tree_views.Def, arg3: Callable[[str], object], arg4: dict[str, object], arg5: object) -> torch._C.ScriptFunction"""
def _jit_script_interface_compile(arg0: str, arg1: _jit_tree_views.ClassDef, arg2: Callable[[str], object], arg3: bool) -> str:
    """_jit_script_interface_compile(arg0: str, arg1: torch._C._jit_tree_views.ClassDef, arg2: Callable[[str], object], arg3: bool) -> str"""
def _jit_set_autocast_mode(arg0: bool) -> bool:
    """_jit_set_autocast_mode(arg0: bool) -> bool"""
def _jit_set_bailout_depth(arg0: int) -> int:
    """_jit_set_bailout_depth(arg0: int) -> int"""
def _jit_set_emit_hooks(arg0: Callable[[ScriptModule], None], arg1: Callable[[ScriptFunction], None]) -> None:
    """_jit_set_emit_hooks(arg0: Callable[[torch._C.ScriptModule], None], arg1: Callable[[torch._C.ScriptFunction], None]) -> None"""
def _jit_set_fusion_strategy(arg0: list[tuple[str, int]]) -> list[tuple[str, int]]:
    """_jit_set_fusion_strategy(arg0: list[tuple[str, int]]) -> list[tuple[str, int]]"""
def _jit_set_inline_everything_mode(arg0: bool) -> None:
    """_jit_set_inline_everything_mode(arg0: bool) -> None"""
def _jit_set_llga_enabled(arg0: bool) -> bool:
    """_jit_set_llga_enabled(arg0: bool) -> bool"""
def _jit_set_logging_option(arg0: str) -> None:
    """_jit_set_logging_option(arg0: str) -> None"""
def _jit_set_logging_stream(arg0: str) -> None:
    """_jit_set_logging_stream(arg0: str) -> None"""
def _jit_set_num_profiled_runs(arg0: int) -> int:
    """_jit_set_num_profiled_runs(arg0: int) -> int"""
def _jit_set_nvfuser_enabled(arg0: bool) -> None:
    """_jit_set_nvfuser_enabled(arg0: bool) -> None"""
def _jit_set_nvfuser_guard_mode(arg0: bool) -> None:
    """_jit_set_nvfuser_guard_mode(arg0: bool) -> None"""
def _jit_set_nvfuser_horizontal_mode(arg0: bool) -> None:
    """_jit_set_nvfuser_horizontal_mode(arg0: bool) -> None"""
def _jit_set_nvfuser_single_node_mode(arg0: bool) -> None:
    """_jit_set_nvfuser_single_node_mode(arg0: bool) -> None"""
def _jit_set_nvfuser_skip_node_kind(arg0: str, arg1: bool) -> None:
    """_jit_set_nvfuser_skip_node_kind(arg0: str, arg1: bool) -> None"""
def _jit_set_onnx_log_enabled(arg0: bool) -> None:
    """_jit_set_onnx_log_enabled(arg0: bool) -> None

    Enables or disables ONNX logging.
    """
def _jit_set_onnx_log_output_stream(arg0: str) -> None:
    """_jit_set_onnx_log_output_stream(arg0: str) -> None

    Set specific file stream for ONNX logging.
    """
def _jit_set_profiling_executor(arg0: bool) -> bool:
    """_jit_set_profiling_executor(arg0: bool) -> bool"""
def _jit_set_profiling_mode(arg0: bool) -> bool:
    """_jit_set_profiling_mode(arg0: bool) -> bool"""
def _jit_set_symbolic_shapes_test_mode(arg0: bool) -> bool:
    """_jit_set_symbolic_shapes_test_mode(arg0: bool) -> bool"""
def _jit_set_te_cuda_pointwise_block_count(arg0: int) -> int:
    """_jit_set_te_cuda_pointwise_block_count(arg0: int) -> int"""
def _jit_set_te_cuda_pointwise_block_size(arg0: int) -> int:
    """_jit_set_te_cuda_pointwise_block_size(arg0: int) -> int"""
def _jit_set_te_cuda_pointwise_loop_levels(arg0: int) -> int:
    """_jit_set_te_cuda_pointwise_loop_levels(arg0: int) -> int"""
def _jit_set_te_generate_block_code(arg0: bool) -> bool:
    """_jit_set_te_generate_block_code(arg0: bool) -> bool"""
def _jit_set_te_must_use_llvm_cpu(arg0: bool) -> None:
    """_jit_set_te_must_use_llvm_cpu(arg0: bool) -> None"""
def _jit_set_texpr_dynamic_shape_enabled(arg0: bool) -> None:
    """_jit_set_texpr_dynamic_shape_enabled(arg0: bool) -> None"""
def _jit_set_texpr_fuser_enabled(arg0: bool) -> None:
    """_jit_set_texpr_fuser_enabled(arg0: bool) -> None"""
def _jit_set_texpr_reductions_enabled(arg0: bool) -> bool:
    """_jit_set_texpr_reductions_enabled(arg0: bool) -> bool"""
def _jit_set_tracer_state_warn(arg0: bool) -> None:
    """_jit_set_tracer_state_warn(arg0: bool) -> None"""
def _jit_set_utf8_decoding_ignore(arg0: bool) -> None:
    """_jit_set_utf8_decoding_ignore(arg0: bool) -> None"""
def _jit_shape_compute_graph_for_node(*args, **kwargs):
    """_jit_shape_compute_graph_for_node(arg0: torch::jit::Node) -> Optional[torch::jit::Graph]"""
def _jit_symbolic_shapes_test_mode_enabled() -> bool:
    """_jit_symbolic_shapes_test_mode_enabled() -> bool"""
def _jit_texpr_dynamic_shape_enabled() -> bool:
    """_jit_texpr_dynamic_shape_enabled() -> bool"""
def _jit_texpr_fallback_allowed() -> bool:
    """_jit_texpr_fallback_allowed() -> bool"""
def _jit_texpr_fuser_enabled() -> bool:
    """_jit_texpr_fuser_enabled() -> bool"""
def _jit_texpr_reductions_enabled() -> bool:
    """_jit_texpr_reductions_enabled() -> bool"""
def _jit_texpr_set_fallback_allowed(arg0: bool) -> bool:
    """_jit_texpr_set_fallback_allowed(arg0: bool) -> bool"""
def _jit_to_backend(arg0: str, arg1: object, arg2: dict) -> object:
    """_jit_to_backend(arg0: str, arg1: object, arg2: dict) -> object"""
def _jit_to_backend_selective(arg0: object, arg1: Callable, arg2: list[str]) -> object:
    """_jit_to_backend_selective(arg0: object, arg1: Callable, arg2: list[str]) -> object"""
@overload
def _jit_to_static_module(arg0: Graph) -> StaticModule:
    """_jit_to_static_module(*args, **kwargs)
    Overloaded function.

    1. _jit_to_static_module(arg0: torch._C.Graph) -> torch._C.StaticModule

    2. _jit_to_static_module(arg0: torch._C.ScriptModule) -> torch._C.StaticModule
    """
@overload
def _jit_to_static_module(arg0: ScriptModule) -> StaticModule:
    """_jit_to_static_module(*args, **kwargs)
    Overloaded function.

    1. _jit_to_static_module(arg0: torch._C.Graph) -> torch._C.StaticModule

    2. _jit_to_static_module(arg0: torch._C.ScriptModule) -> torch._C.StaticModule
    """
def _jit_trace_graph(*args, **kwargs):
    """_jit_trace_graph(arg0: torch::jit::Graph, arg1: tuple) -> torch::jit::Graph"""
def _jit_trace_module(arg0, arg1: tuple) -> None:
    """_jit_trace_module(arg0: torch::jit::Module, arg1: tuple) -> None"""
def _jit_try_infer_type(*args, **kwargs):
    """_jit_try_infer_type(arg0: object) -> c10::InferredType"""
def _jit_unflatten(arg0: list[torch.Tensor], arg1: IODescriptor) -> object:
    """_jit_unflatten(arg0: list[torch.Tensor], arg1: torch._C.IODescriptor) -> object"""
def _last_executed_optimized_graph() -> Graph:
    """_last_executed_optimized_graph() -> torch._C.Graph

    Retrieve the optimized graph that was run the last time the graph executor ran on this thread
    """
def _len_torch_dispatch_stack(*args, **kwargs): ...
def _len_torch_function_stack(*args, **kwargs): ...
def _llvm_enabled() -> bool:
    """_llvm_enabled() -> bool"""
def _load_for_lite_interpreter(arg0: str, arg1: object) -> LiteScriptModule:
    """_load_for_lite_interpreter(arg0: str, arg1: object) -> torch._C.LiteScriptModule"""
def _load_for_lite_interpreter_from_buffer(arg0: str, arg1: object) -> LiteScriptModule:
    """_load_for_lite_interpreter_from_buffer(arg0: str, arg1: object) -> torch._C.LiteScriptModule"""
def _load_jit_module_from_bytes(arg0: str) -> ScriptModule:
    """_load_jit_module_from_bytes(arg0: str) -> torch._C.ScriptModule"""
def _load_jit_module_from_file(arg0: str) -> ScriptModule:
    """_load_jit_module_from_file(arg0: str) -> torch._C.ScriptModule"""
def _load_mobile_module_from_bytes(arg0: str) -> LiteScriptModule:
    """_load_mobile_module_from_bytes(arg0: str) -> torch._C.LiteScriptModule"""
def _load_mobile_module_from_file(arg0: str) -> LiteScriptModule:
    """_load_mobile_module_from_file(arg0: str) -> torch._C.LiteScriptModule"""
def _log_api_usage_metadata(arg0: str, arg1: dict[str, str]) -> None:
    """_log_api_usage_metadata(arg0: str, arg1: dict[str, str]) -> None"""
def _log_api_usage_once(arg0: str) -> None:
    """_log_api_usage_once(arg0: str) -> None"""
def _logging_set_logger(*args, **kwargs):
    """_logging_set_logger(arg0: torch::jit::logging::LoggerBase) -> torch::jit::logging::LoggerBase"""
def _maybe_call_torch_function_for_op_packet(arg0: object, *args, **kwargs) -> tuple:
    """_maybe_call_torch_function_for_op_packet(arg0: object, *args, **kwargs) -> tuple"""
def _meta_in_tls_dispatch_include() -> bool:
    """_meta_in_tls_dispatch_include() -> bool"""
def _mps_acquireEvent(*args, **kwargs): ...
def _mps_compileShader(arg0: str) -> _mps_ShaderLibrary:
    """_mps_compileShader(arg0: str) -> torch._C._mps_ShaderLibrary"""
def _mps_currentAllocatedMemory(*args, **kwargs): ...
def _mps_deviceSynchronize(*args, **kwargs): ...
def _mps_driverAllocatedMemory(*args, **kwargs): ...
def _mps_elapsedTimeOfEvents(*args, **kwargs): ...
def _mps_emptyCache(*args, **kwargs): ...
def _mps_get_default_generator(*args, **kwargs): ...
def _mps_isCaptureEnabled() -> bool:
    """_mps_isCaptureEnabled() -> bool"""
def _mps_isCapturing() -> bool:
    """_mps_isCapturing() -> bool"""
def _mps_is_available(*args, **kwargs): ...
def _mps_is_in_bad_fork(*args, **kwargs): ...
def _mps_is_on_macos_or_newer(*args, **kwargs): ...
def _mps_profilerStartTrace(*args, **kwargs): ...
def _mps_profilerStopTrace(*args, **kwargs): ...
def _mps_queryEvent(*args, **kwargs): ...
def _mps_recommendedMaxMemory(*args, **kwargs): ...
def _mps_recordEvent(*args, **kwargs): ...
def _mps_releaseEvent(*args, **kwargs): ...
def _mps_setMemoryFraction(*args, **kwargs): ...
def _mps_startCapture(arg0: str) -> None:
    """_mps_startCapture(arg0: str) -> None"""
def _mps_stopCapture() -> None:
    """_mps_stopCapture() -> None"""
def _mps_synchronizeEvent(*args, **kwargs): ...
def _mps_waitForEvent(*args, **kwargs): ...
def _mtia_attachOutOfMemoryObserver(arg0: Callable) -> None:
    """_mtia_attachOutOfMemoryObserver(arg0: Callable) -> None"""
def _mtia_deviceSynchronize() -> None:
    """_mtia_deviceSynchronize() -> None"""
def _mtia_emptyCache() -> None:
    """_mtia_emptyCache() -> None"""
def _mtia_exchangeDevice(arg0: int) -> int:
    """_mtia_exchangeDevice(arg0: int) -> int"""
def _mtia_getCurrentRawStream(arg0: int) -> int:
    """_mtia_getCurrentRawStream(arg0: int) -> int"""
def _mtia_getCurrentStream(arg0: int) -> torch.Stream:
    """_mtia_getCurrentStream(arg0: int) -> torch.Stream"""
def _mtia_getDefaultStream(arg0: int) -> torch.Stream:
    """_mtia_getDefaultStream(arg0: int) -> torch.Stream"""
def _mtia_getDeviceCapability(arg0: int) -> object:
    """_mtia_getDeviceCapability(arg0: int) -> object"""
def _mtia_getDeviceCount() -> int:
    """_mtia_getDeviceCount() -> int"""
def _mtia_getDeviceProperties(arg0: int) -> object:
    """_mtia_getDeviceProperties(arg0: int) -> object"""
def _mtia_init() -> None:
    """_mtia_init() -> None"""
def _mtia_isBuilt() -> bool:
    """_mtia_isBuilt() -> bool"""
def _mtia_isInBadFork() -> bool:
    """_mtia_isInBadFork() -> bool"""
def _mtia_maybeExchangeDevice(arg0: int) -> int:
    """_mtia_maybeExchangeDevice(arg0: int) -> int"""
def _mtia_memorySnapshot() -> object:
    """_mtia_memorySnapshot() -> object"""
def _mtia_memoryStats(arg0: int) -> object:
    """_mtia_memoryStats(arg0: int) -> object"""
def _mtia_recordMemoryHistory(arg0: str | None, arg1: str, arg2: int) -> None:
    """_mtia_recordMemoryHistory(arg0: Optional[str], arg1: str, arg2: int) -> None"""
def _mtia_resetPeakMemoryStats(arg0: int) -> None:
    """_mtia_resetPeakMemoryStats(arg0: int) -> None"""
def _mtia_setCurrentStream(arg0: torch.Stream) -> None:
    """_mtia_setCurrentStream(arg0: torch.Stream) -> None"""
def _multiprocessing_init(*args, **kwargs): ...
def _new_symbolic_shape_symbol() -> int:
    """_new_symbolic_shape_symbol() -> int"""
def _nn_module_to_mobile(arg0: ScriptModule) -> LiteScriptModule:
    """_nn_module_to_mobile(arg0: torch._C.ScriptModule) -> torch._C.LiteScriptModule"""
def _non_sym_sizes(arg0: torch.Tensor) -> tuple[int, ...]:
    """_non_sym_sizes(arg0: torch.Tensor) -> Tuple[int, ...]"""
def _only_lift_cpu_tensors() -> bool:
    """_only_lift_cpu_tensors() -> bool"""
def _overlaps(arg0: object, arg1: object) -> bool:
    """_overlaps(arg0: object, arg1: object) -> bool"""
def _parallel_info(*args, **kwargs): ...
def _parse_dispatch_key(arg0: str) -> DispatchKey | None:
    """_parse_dispatch_key(arg0: str) -> Optional[torch._C.DispatchKey]"""
def _parse_source_def(arg0: str) -> _jit_tree_views.Def:
    """_parse_source_def(arg0: str) -> torch._C._jit_tree_views.Def"""
def _pickle_load_obj(arg0: bytes) -> IValue:
    """_pickle_load_obj(arg0: bytes) -> IValue"""
def _pickle_save(arg0: IValue) -> bytes:
    """_pickle_save(arg0: IValue) -> bytes"""
def _pop_torch_dispatch_stack(*args, **kwargs): ...
def _pop_torch_function_stack(*args, **kwargs): ...
def _propagate_and_assign_input_shapes(arg0: Graph, arg1: list[torch.Tensor], arg2: list[int], arg3: bool, arg4: bool) -> Graph:
    """_propagate_and_assign_input_shapes(arg0: torch._C.Graph, arg1: list[torch.Tensor], arg2: list[int], arg3: bool, arg4: bool) -> torch._C.Graph"""
def _propagate_shapes(arg0: Graph, arg1: list[torch.Tensor], arg2: bool) -> Graph:
    """_propagate_shapes(arg0: torch._C.Graph, arg1: list[torch.Tensor], arg2: bool) -> torch._C.Graph"""
def _propagate_xla_data(arg0: torch.Tensor, arg1: torch.Tensor) -> None:
    """_propagate_xla_data(arg0: torch.Tensor, arg1: torch.Tensor) -> None"""
def _push_on_torch_dispatch_stack(*args, **kwargs): ...
def _push_on_torch_function_stack(*args, **kwargs): ...
def _quantize_ondevice_ptq_dynamic(arg0: LiteScriptModule, arg1: str) -> None:
    """_quantize_ondevice_ptq_dynamic(arg0: torch._C.LiteScriptModule, arg1: str) -> None"""
def _register_py_class_for_device(arg0: str, arg1: object) -> None:
    """_register_py_class_for_device(arg0: str, arg1: object) -> None"""
def _remove_cached_tensor(arg0: torch.Tensor) -> None:
    """_remove_cached_tensor(arg0: torch.Tensor) -> None"""
def _remove_worker_pids(*args, **kwargs): ...
def _rename_privateuse1_backend(*args, **kwargs): ...
def _replace_(arg0: torch.Tensor, arg1: torch.Tensor) -> None:
    """_replace_(arg0: torch.Tensor, arg1: torch.Tensor) -> None"""
def _replace_overloaded_method_decl(arg0: _jit_tree_views.Decl, arg1: _jit_tree_views.Def, arg2: str) -> _jit_tree_views.Def:
    """_replace_overloaded_method_decl(arg0: torch._C._jit_tree_views.Decl, arg1: torch._C._jit_tree_views.Def, arg2: str) -> torch._C._jit_tree_views.Def"""
def _resolve_type(arg0: str, arg1: _jit_tree_views.SourceRange, arg2: Callable[[str], object]) -> Type:
    """_resolve_type(arg0: str, arg1: torch._C._jit_tree_views.SourceRange, arg2: Callable[[str], object]) -> torch._C.Type"""
def _resolve_type_from_object(arg0: object, arg1: _jit_tree_views.SourceRange, arg2: Callable[[str], object]) -> Type:
    """_resolve_type_from_object(arg0: object, arg1: torch._C._jit_tree_views.SourceRange, arg2: Callable[[str], object]) -> torch._C.Type"""
def _rpc_init(*args, **kwargs): ...
def _run_emit_module_hook(arg0: ScriptModule) -> None:
    """_run_emit_module_hook(arg0: torch._C.ScriptModule) -> None"""
def _run_tensorexpr_cpp_tests() -> None:
    """_run_tensorexpr_cpp_tests() -> None"""
def _save_jit_module(arg0: ScriptModule, arg1: str, arg2: dict[str, str]) -> None:
    """_save_jit_module(arg0: torch._C.ScriptModule, arg1: str, arg2: dict[str, str]) -> None"""
def _save_jit_module_to_bytes(arg0: ScriptModule, arg1: dict[str, str]) -> bytes:
    """_save_jit_module_to_bytes(arg0: torch._C.ScriptModule, arg1: dict[str, str]) -> bytes"""
def _save_mobile_module(arg0: LiteScriptModule, arg1: str, arg2: dict[str, str]) -> None:
    """_save_mobile_module(arg0: torch._C.LiteScriptModule, arg1: str, arg2: dict[str, str]) -> None"""
def _save_mobile_module_to_bytes(arg0: LiteScriptModule, arg1: dict[str, str]) -> bytes:
    """_save_mobile_module_to_bytes(arg0: torch._C.LiteScriptModule, arg1: dict[str, str]) -> bytes"""
def _save_parameters(arg0: dict[str, torch.Tensor], arg1: str, arg2: bool) -> None:
    """_save_parameters(arg0: dict[str, torch.Tensor], arg1: str, arg2: bool) -> None"""
def _select_batch_norm_backend(input: torch.Tensor, weight: torch.Tensor, bias: torch.Tensor, running_mean: torch.Tensor, running_var: torch.Tensor, training: bool, eps: float) -> _BatchNormBackend:
    """_select_batch_norm_backend(input: torch.Tensor, weight: torch.Tensor, bias: torch.Tensor, running_mean: torch.Tensor, running_var: torch.Tensor, training: bool, eps: float) -> torch._C._BatchNormBackend"""
@overload
def _select_conv_backend(input: torch.Tensor, weight: torch.Tensor, bias: torch.Tensor | None, stride: list[int], padding: list[int], dilation: list[int], transposed: bool, output_padding: list[int], groups: int | torch.SymInt) -> _ConvBackend:
    """_select_conv_backend(*args, **kwargs)
    Overloaded function.

    1. _select_conv_backend(input: torch.Tensor, weight: torch.Tensor, bias: Optional[torch.Tensor], stride: List[int], padding: List[int], dilation: List[int], transposed: bool, output_padding: List[int], groups: Union[int, torch.SymInt]) -> torch._C._ConvBackend

    2. _select_conv_backend(input: torch.Tensor, weight: torch.Tensor, bias: Optional[torch.Tensor], stride: List[int], padding: List[int], dilation: List[int], transposed: bool, output_padding: List[int], groups: Union[int, torch.SymInt], bias_sizes: Optional[list[Union[int, torch.SymInt]]]) -> torch._C._ConvBackend
    """
@overload
def _select_conv_backend(input: torch.Tensor, weight: torch.Tensor, bias: torch.Tensor | None, stride: list[int], padding: list[int], dilation: list[int], transposed: bool, output_padding: list[int], groups: int | torch.SymInt, bias_sizes: list[int | torch.SymInt] | None) -> _ConvBackend:
    """_select_conv_backend(*args, **kwargs)
    Overloaded function.

    1. _select_conv_backend(input: torch.Tensor, weight: torch.Tensor, bias: Optional[torch.Tensor], stride: List[int], padding: List[int], dilation: List[int], transposed: bool, output_padding: List[int], groups: Union[int, torch.SymInt]) -> torch._C._ConvBackend

    2. _select_conv_backend(input: torch.Tensor, weight: torch.Tensor, bias: Optional[torch.Tensor], stride: List[int], padding: List[int], dilation: List[int], transposed: bool, output_padding: List[int], groups: Union[int, torch.SymInt], bias_sizes: Optional[list[Union[int, torch.SymInt]]]) -> torch._C._ConvBackend
    """
def _set_autograd_fallback_mode(arg0: str) -> None:
    """_set_autograd_fallback_mode(arg0: str) -> None"""
def _set_backcompat_broadcast_warn(*args, **kwargs): ...
def _set_backcompat_keepdim_warn(*args, **kwargs): ...
def _set_blas_preferred_backend(arg0: _BlasBackend) -> None:
    """_set_blas_preferred_backend(arg0: torch._C._BlasBackend) -> None"""
def _set_cached_tensors_enabled(arg0: bool) -> None:
    """_set_cached_tensors_enabled(arg0: bool) -> None"""
def _set_check_sparse_tensor_invariants(*args, **kwargs): ...
def _set_conj(arg0: torch.Tensor, arg1: bool) -> None:
    """_set_conj(arg0: torch.Tensor, arg1: bool) -> None"""
def _set_cpu_allow_fp16_reduced_precision_reduction(*args, **kwargs): ...
def _set_cublas_allow_bf16_reduced_precision_reduction(*args, **kwargs): ...
def _set_cublas_allow_fp16_accumulation(*args, **kwargs): ...
def _set_cublas_allow_fp16_reduced_precision_reduction(*args, **kwargs): ...
def _set_cublas_allow_tf32(*args, **kwargs): ...
def _set_cudnn_allow_tf32(*args, **kwargs): ...
def _set_cudnn_benchmark(*args, **kwargs): ...
def _set_cudnn_deterministic(*args, **kwargs): ...
def _set_cudnn_enabled(*args, **kwargs): ...
def _set_default_dtype(*args, **kwargs): ...
def _set_default_mobile_cpu_allocator(*args, **kwargs): ...
def _set_default_tensor_type(*args, **kwargs): ...
def _set_deterministic_algorithms(*args, **kwargs): ...
def _set_deterministic_fill_uninitialized_memory(*args, **kwargs): ...
def _set_dispatch_mode(*args, **kwargs): ...
def _set_float32_matmul_precision(*args, **kwargs): ...
def _set_fwd_grad_enabled(*args, **kwargs): ...
def _set_grad_enabled(*args, **kwargs): ...
def _set_graph_executor_optimize(arg0: bool) -> None:
    """_set_graph_executor_optimize(arg0: bool) -> None"""
def _set_linalg_preferred_backend(arg0: _LinalgBackend) -> None:
    """_set_linalg_preferred_backend(arg0: torch._C._LinalgBackend) -> None"""
def _set_math_sdp_allow_fp16_bf16_reduction(*args, **kwargs): ...
def _set_meta_in_tls_dispatch_include(arg0: bool) -> None:
    """_set_meta_in_tls_dispatch_include(arg0: bool) -> None"""
def _set_mkldnn_deterministic(*args, **kwargs): ...
def _set_mkldnn_enabled(*args, **kwargs): ...
def _set_multithreading_enabled(*args, **kwargs): ...
def _set_neg(arg0: torch.Tensor, arg1: bool) -> None:
    """_set_neg(arg0: torch.Tensor, arg1: bool) -> None"""
def _set_nnpack_enabled(*args, **kwargs): ...
def _set_onednn_allow_tf32(*args, **kwargs): ...
def _set_only_lift_cpu_tensors(arg0: bool) -> None:
    """_set_only_lift_cpu_tensors(arg0: bool) -> None"""
def _set_qengine(*args, **kwargs): ...
def _set_rocm_fa_preferred_backend(arg0: _ROCmFABackend) -> None:
    """_set_rocm_fa_preferred_backend(arg0: torch._C._ROCmFABackend) -> None"""
def _set_sdp_priority_order(*args, **kwargs): ...
def _set_sdp_use_cudnn(*args, **kwargs): ...
def _set_sdp_use_flash(*args, **kwargs): ...
def _set_sdp_use_math(*args, **kwargs): ...
def _set_sdp_use_mem_efficient(*args, **kwargs): ...
def _set_sdp_use_overrideable(*args, **kwargs): ...
def _set_should_use_format_with_string_table(arg0: bool) -> None:
    """_set_should_use_format_with_string_table(arg0: bool) -> None"""
def _set_sm_carveout_experimental(arg0: int | None) -> None:
    """_set_sm_carveout_experimental(arg0: Optional[int]) -> None"""
def _set_tensor_metadata(arg0: torch.Tensor, arg1: dict[str, bool]) -> None:
    """_set_tensor_metadata(arg0: torch.Tensor, arg1: dict[str, bool]) -> None"""
def _set_thread_name(*args, **kwargs): ...
def _set_throw_on_mutable_data_ptr(arg0: torch.Tensor) -> None:
    """_set_throw_on_mutable_data_ptr(arg0: torch.Tensor) -> None"""
def _set_torch_function_state(arg0: _TorchFunctionState) -> None:
    """_set_torch_function_state(arg0: torch._C._TorchFunctionState) -> None"""
def _set_tracing_state(arg0: TracingState) -> None:
    """_set_tracing_state(arg0: torch._C.TracingState) -> None"""
def _set_value_trace(arg0: torch.Tensor, arg1: Value) -> None:
    """_set_value_trace(arg0: torch.Tensor, arg1: torch._C.Value) -> None"""
def _set_view_replay_enabled(*args, **kwargs): ...
def _set_warnAlways(*args, **kwargs): ...
def _set_warn_deprecated_on_mutable_data_ptr(arg0: torch.Tensor) -> None:
    """_set_warn_deprecated_on_mutable_data_ptr(arg0: torch.Tensor) -> None"""
def _set_worker_pids(*args, **kwargs): ...
def _set_worker_signal_handlers(*args, **kwargs): ...
def _should_allow_numbers_as_tensors(arg0: str) -> bool:
    """_should_allow_numbers_as_tensors(arg0: str) -> bool"""
def _show_config(*args, **kwargs): ...
def _stash_obj_in_tls(arg0: str, arg1: object) -> None:
    """_stash_obj_in_tls(arg0: str, arg1: object) -> None"""
def _storage_Use_Count(arg0: int) -> int:
    """_storage_Use_Count(arg0: int) -> int"""
def _storage_address(arg0: torch.Tensor) -> int:
    """_storage_address(arg0: torch.Tensor) -> int

    Gets the memory address of the Tensor's StorageImpl.
    """
def _storage_id(arg0: torch.Tensor) -> int:
    """_storage_id(arg0: torch.Tensor) -> int"""
def _supported_qengines(*args, **kwargs): ...
def _swap_tensor_impl(*args, **kwargs): ...
def _tensor_impl_raw_handle(arg0: torch.Tensor) -> capsule:
    """_tensor_impl_raw_handle(arg0: torch.Tensor) -> capsule"""
def _test_only_add_entry_to_op_version_map(arg0: str, arg1: _UpgraderEntry) -> None:
    """_test_only_add_entry_to_op_version_map(arg0: str, arg1: torch._C._UpgraderEntry) -> None"""
def _test_only_populate_upgraders(arg0: dict[str, str]) -> None:
    """_test_only_populate_upgraders(arg0: dict[str, str]) -> None"""
def _test_only_remove_entry_to_op_version_map(arg0: str) -> None:
    """_test_only_remove_entry_to_op_version_map(arg0: str) -> None"""
def _test_only_remove_upgraders(arg0: dict[str, str]) -> None:
    """_test_only_remove_upgraders(arg0: dict[str, str]) -> None"""
def _to_dlpack(*args, **kwargs):
    '''to_dlpack(tensor) -> PyCapsule

    Returns an opaque object (a "DLPack capsule") representing the tensor.

    .. note::
      ``to_dlpack`` is a legacy DLPack interface. The capsule it returns
      cannot be used for anything in Python other than use it as input to
      ``from_dlpack``. The more idiomatic use of DLPack is to call
      ``from_dlpack`` directly on the tensor object - this works when that
      object has a ``__dlpack__`` method, which PyTorch and most other
      libraries indeed have now.

    .. warning::
      Only call ``from_dlpack`` once per capsule produced with ``to_dlpack``.
      Behavior when a capsule is consumed multiple times is undefined.

    Args:
        tensor: a tensor to be exported

    The DLPack capsule shares the tensor\'s memory.
    '''
def _to_functionality_key(*args, **kwargs):
    """_to_functionality_key(arg0: c10::DispatchKey) -> c10::DispatchKey"""
def _tracer_set_force_outplace(arg0: bool) -> None:
    """_tracer_set_force_outplace(arg0: bool) -> None"""
def _tracer_set_get_unique_name_fn(arg0: Callable) -> None:
    """_tracer_set_get_unique_name_fn(arg0: Callable) -> None"""
def _tracer_warn_use_python() -> None:
    """_tracer_warn_use_python() -> None"""
def _unsafe_reset_storage(arg0: torch.Tensor) -> None:
    """_unsafe_reset_storage(arg0: torch.Tensor) -> None"""
def _unset_default_mobile_cpu_allocator(*args, **kwargs): ...
def _unset_dispatch_mode(*args, **kwargs): ...
def _valgrind_supported_platform() -> bool:
    """_valgrind_supported_platform() -> bool"""
def _valgrind_toggle() -> None:
    """_valgrind_toggle() -> None"""
def _valgrind_toggle_and_dump_stats() -> None:
    """_valgrind_toggle_and_dump_stats() -> None"""
def _vmapmode_decrement_nesting(*args, **kwargs): ...
def _vmapmode_increment_nesting(*args, **kwargs): ...
def _warn(*args, **kwargs): ...
def _warn_deprecation(*args, **kwargs): ...
def _will_engine_execute_node(*args, **kwargs): ...
def _wrap_tensor_impl(arg0: capsule) -> object:
    """_wrap_tensor_impl(arg0: capsule) -> object"""
