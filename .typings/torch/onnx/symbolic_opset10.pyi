from torch import _C
from torch.onnx._internal import jit_utils

__all__ = ['dequantize', 'div', 'embedding_bag', 'fake_quantize_per_tensor_affine', 'flip', 'fmod', 'isfinite', 'isinf', 'nan_to_num', 'quantize_per_tensor', 'quantized_add_relu', 'quantized_add', 'quantized_cat', 'quantized_conv1d_relu', 'quantized_conv2d_relu', 'quantized_conv3d_relu', 'quantized_conv1d', 'quantized_conv2d', 'quantized_conv3d', 'quantized_conv_transpose1d', 'quantized_conv_transpose2d', 'quantized_conv_transpose3d', 'quantized_group_norm', 'quantized_hardswish', 'quantized_instance_norm', 'quantized_layer_norm', 'quantized_leaky_relu', 'quantized_linear', 'quantized_linear_relu', 'quantized_mul', 'quantized_sigmoid', 'slice', 'sort', 'topk']

def div(g: jit_utils.GraphContext, self, other, *args): ...
def sort(g: jit_utils.GraphContext, self, dim, decending, out=None): ...
def topk(g: jit_utils.GraphContext, self, k, dim, largest, sorted, out=None): ...
def slice(g: jit_utils.GraphContext, self, *args): ...
def flip(g: jit_utils.GraphContext, input, dims): ...
def fmod(g: jit_utils.GraphContext, input, other): ...
def embedding_bag(g: jit_utils.GraphContext, embedding_matrix, indices, offsets, scale_grad_by_freq, mode, sparse, per_sample_weights, include_last_offset, padding_idx): ...
def fake_quantize_per_tensor_affine(g: jit_utils.GraphContext, inputs, scale, zero_point, quant_min: int = -128, quant_max: int = 127): ...
def isinf(g: jit_utils.GraphContext, input): ...
def isfinite(g: jit_utils.GraphContext, input): ...
def quantize_per_tensor(g: jit_utils.GraphContext, input, scale, zero_point, dtype): ...
def dequantize(g: jit_utils.GraphContext, input): ...
def nan_to_num(g: jit_utils.GraphContext, input, nan, posinf, neginf): ...
def quantized_linear(g: jit_utils.GraphContext, q_input, q_weight, bias, op_scale, op_zero_point): ...
def quantized_linear_relu(g: jit_utils.GraphContext, q_input, q_weight, bias, op_scale, op_zero_point): ...
def quantized_add(g: jit_utils.GraphContext, x, y, op_scale, op_zero_point): ...
def quantized_add_relu(g: jit_utils.GraphContext, x, y, op_scale, op_zero_point): ...
def quantized_mul(g: jit_utils.GraphContext, x, y, op_scale, op_zero_point): ...
def quantized_hardswish(g: jit_utils.GraphContext, x, op_scale, op_zero_point): ...
def quantized_sigmoid(g: jit_utils.GraphContext, x, op_scale, op_zero_point): ...
def quantized_leaky_relu(g: jit_utils.GraphContext, x, negative_slope, inplace, op_scale, op_zero_point): ...
def quantized_layer_norm(g: jit_utils.GraphContext, x, normalized_shape, weight, bias, eps, op_scale, op_zero_point): ...
def quantized_group_norm(g: jit_utils.GraphContext, x, num_groups, weight, bias, eps, op_scale, op_zero_point): ...
def quantized_instance_norm(g: jit_utils.GraphContext, q_input, weight, bias, eps, op_scale, op_zero_point): ...
def quantized_conv1d_relu(g: jit_utils.GraphContext, q_input, q_weight, bias, stride, padding, dilation, groups, op_scale, op_zero_point): ...
def quantized_conv2d_relu(g: jit_utils.GraphContext, q_input, q_weight, bias, stride, padding, dilation, groups, op_scale, op_zero_point): ...
def quantized_conv3d_relu(g: jit_utils.GraphContext, q_input, q_weight, bias, stride, padding, dilation, groups, op_scale, op_zero_point): ...
def quantized_conv1d(g: jit_utils.GraphContext, q_input, q_weight, bias, stride, padding, dilation, groups, op_scale, op_zero_point): ...
def quantized_conv2d(g: jit_utils.GraphContext, q_input, q_weight, bias, stride, padding, dilation, groups, op_scale, op_zero_point): ...
def quantized_conv3d(g: jit_utils.GraphContext, q_input, q_weight, bias, stride, padding, dilation, groups, op_scale, op_zero_point): ...
def quantized_conv_transpose1d(g: jit_utils.GraphContext, q_input, q_weight, bias, stride, padding, output_padding, dilation, groups, op_scale, op_zero_point): ...
def quantized_conv_transpose2d(g: jit_utils.GraphContext, q_input, q_weight, bias, stride, padding, output_padding, dilation, groups, op_scale, op_zero_point): ...
def quantized_conv_transpose3d(g: jit_utils.GraphContext, q_input, q_weight, bias, stride, padding, output_padding, dilation, groups, op_scale, op_zero_point): ...
def quantized_cat(g: jit_utils.GraphContext, q_inputs: _C.Value, dim: int, op_scale: _C.Value, op_zero_point: _C.Value) -> _C.Value: ...
