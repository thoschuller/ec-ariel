import functools
from _typeshed import Incomplete
from torch._strobelight.compile_time_profiler import StrobelightCompileTimeProfiler as StrobelightCompileTimeProfiler
from typing import Any, Callable, TypeVar
from typing_extensions import ParamSpec

_T = TypeVar('_T')
_P = ParamSpec('_P')
log: Incomplete
torch_parent: str

def get_file_path(*path_components: str) -> str: ...
def get_file_path_2(*path_components: str) -> str: ...
def get_writable_path(path: str) -> str: ...
def prepare_multiprocessing_environment(path: str) -> None: ...
def resolve_library_path(path: str) -> str: ...
def throw_abstract_impl_not_imported_error(opname, module, context) -> None: ...
def compile_time_strobelight_meta(phase_name: str) -> Callable[[Callable[_P, _T]], Callable[_P, _T]]: ...
def signpost_event(category: str, name: str, parameters: dict[str, Any]): ...
def log_compilation_event(metrics) -> None: ...
def upload_graph(graph) -> None: ...
def set_pytorch_distributed_envs_from_justknobs() -> None: ...
def log_export_usage(**kwargs) -> None: ...
def log_trace_structured_event(*args, **kwargs) -> None: ...
def log_cache_bypass(*args, **kwargs) -> None: ...
def log_torchscript_usage(api: str, **kwargs): ...
def check_if_torch_exportable(): ...
def export_training_ir_rollout_check() -> bool: ...
def full_aoti_runtime_assert() -> bool: ...
def log_torch_jit_trace_exportability(api: str, type_of_export: str, export_outcome: str, result: str): ...
def justknobs_check(name: str, default: bool = True) -> bool:
    """
    This function can be used to killswitch functionality in FB prod,
    where you can toggle this value to False in JK without having to
    do a code push.  In OSS, we always have everything turned on all
    the time, because downstream users can simply choose to not update
    PyTorch.  (If more fine-grained enable/disable is needed, we could
    potentially have a map we lookup name in to toggle behavior.  But
    the point is that it's all tied to source code in OSS, since there's
    no live server to query.)

    This is the bare minimum functionality I needed to do some killswitches.
    We have a more detailed plan at
    https://docs.google.com/document/d/1Ukerh9_42SeGh89J-tGtecpHBPwGlkQ043pddkKb3PU/edit
    In particular, in some circumstances it may be necessary to read in
    a knob once at process start, and then use it consistently for the
    rest of the process.  Future functionality will codify these patterns
    into a better high level API.

    WARNING: Do NOT call this function at module import time, JK is not
    fork safe and you will break anyone who forks the process and then
    hits JK again.
    """
def justknobs_getval_int(name: str) -> int:
    """
    Read warning on justknobs_check
    """
def is_fb_unit_test() -> bool: ...
@functools.cache
def max_clock_rate(): ...
def get_mast_job_name_version() -> tuple[str, int] | None: ...

TEST_MASTER_ADDR: str
TEST_MASTER_PORT: int
USE_GLOBAL_DEPS: bool
USE_RTLD_GLOBAL_WITH_LIBTORCH: bool
REQUIRES_SET_PYTHON_MODULE: bool

def maybe_upload_prof_stats_to_manifold(profile_path: str) -> str | None: ...
def log_chromium_event_internal(event: dict[str, Any], stack: list[str], logger_uuid: str, start_time_ns: int): ...
def record_chromium_event_internal(event: dict[str, Any]): ...
def profiler_allow_cudagraph_cupti_lazy_reinit_cuda12(): ...
