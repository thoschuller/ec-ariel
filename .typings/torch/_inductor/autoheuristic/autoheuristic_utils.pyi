import torch
from _typeshed import Incomplete
from typing import Any, Callable

Feedback = float
Choice = str
Value = Any
CHOICE_COL: str
FEEDBACK_COL: str

class AHFeature:
    """
    The context, that AutoHeuristic stores, is a list of features. AutoHeuristic needs to know whether a feature is
    categorical (i.e., not a continuous variable) to learn a machine learning model.
    """
    name: Incomplete
    value: Incomplete
    is_categorical: Incomplete
    def __init__(self, name: str, value: Value, is_categorical: bool = False) -> None: ...

class AHOperation:
    """
    AHOperation can be used to augment the data collected by AutoHeuristic.
    One might for example store features like m, k, n, but also want to use
    features like m*n, or k*n, to learn a heuristic. Instead of storing features
    that can be created from the collected data, one can use AHOperation to
    create new features from the collected data.
    """
    name: Incomplete
    func: Incomplete
    is_categorical: Incomplete
    def __init__(self, name: str, func: Callable[[Any], Value], is_categorical: bool = False) -> None: ...
    def apply_operation(self, data: Any) -> None: ...

class AHContext:
    """
    This class is used to specify which information AutoHeuristic should store. For each choice, AutoHeursitic will
    store the context and the collected feedback. The context could be something like the shape of a tensor, i.e.,
    information that will help to learn a heuristic.
    """
    features: list[AHFeature]
    context_dict: dict[str, Value]
    def __init__(self) -> None: ...
    def add_feature(self, name: str, value: Value, is_categorical: bool = False) -> None: ...
    def get_numerical_and_categorical_features(self) -> tuple[list[str], list[str]]: ...
    def get_feature_names_csv(self) -> str: ...
    def get_feature_values_csv(self) -> str: ...
    def get_value(self, name: str) -> Value: ...
    def apply_operations(self, operations: list[AHOperation]) -> None: ...

class AHMetadata:
    shared_memory: Incomplete
    device_capa: Incomplete
    choices: Incomplete
    name: Incomplete
    def __init__(self, shared_memory: Any, device_capa: tuple[int, int], choices: list[Choice], name: str) -> None: ...
    def to_dict(self) -> dict[str, Value]: ...

def get_metadata_str_from_log(log_path: str) -> str: ...
def check_minsize(context: AHContext, minsize: int) -> bool: ...
def pad_mm_precondition(metadata: AHMetadata, context: AHContext) -> bool: ...
def get_mixedmm_precondition(metadata: AHMetadata, context: AHContext) -> bool: ...
def get_mult_dims_ops() -> list[AHOperation]: ...
def get_arith_intensity(data: Any) -> float: ...
def pad_mm_operations() -> list[AHOperation]: ...
def between_op(data: Any, dim: str, lower: int, upper: int) -> bool: ...
def between_ops() -> list[AHOperation]: ...
def pow2_op(data: Any, dim: str, exponent: int) -> bool: ...
def mm_operations() -> list[AHOperation]: ...
def mixed_mm_operations() -> list[AHOperation]: ...
def is_multiple(data: Any, dim: str, mult: int) -> bool: ...
def get_dims_multiple_ops() -> list[AHOperation]: ...
def get_dims_need_padding_ops() -> list[AHOperation]: ...
def get_is_contig_ops() -> list[AHOperation]: ...
def context_add_strides(context: AHContext, name: str, stride: tuple[int, ...]) -> None: ...
def context_add_using_tf32(context: AHContext, dtype: torch.dtype) -> None: ...
