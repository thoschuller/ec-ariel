import abc
import atexit
import dataclasses
import redis
from _typeshed import Incomplete
from abc import abstractmethod
from rfe.scubadata.scubadata_py3 import Sample as Sample_
from torch._dynamo.utils import dynamo_timed as dynamo_timed
from torch._inductor import config as config
from torch.monitor import _WaitCounter as _WaitCounter
from typing import Any, Callable, Generic, TypeVar
from typing_extensions import TypeAlias, override

log: Incomplete
Sample: TypeAlias = Sample_
_T = TypeVar('_T')
_U = TypeVar('_U')
remote_fx_cache_get_timed: Incomplete
remote_fx_cache_put_timed: Incomplete

class RemoteCacheBackend(Generic[_T], metaclass=abc.ABCMeta):
    """
    A backend implementation for accessing a remote/distributed cache.  Only
    works with bytes in/out.  For structured data use a RemoteCache.
    """
    _name: Incomplete
    def __init__(self) -> None: ...
    @abstractmethod
    def _get(self, key: str) -> _T | None: ...
    @abstractmethod
    def _put(self, key: str, data: _T) -> None: ...
    def get(self, key: str) -> _T | None: ...
    def put(self, key: str, data: _T) -> None: ...

class RemoteCacheSerde(Generic[_T, _U], metaclass=abc.ABCMeta):
    @abstractmethod
    def encode(self, data: _T) -> _U: ...
    @abstractmethod
    def decode(self, data: _U) -> _T: ...

JsonDataTy: Incomplete

class RemoteCacheJsonSerde(RemoteCacheSerde[JsonDataTy, bytes]):
    def encode(self, data: JsonDataTy) -> bytes: ...
    def decode(self, data: bytes) -> JsonDataTy: ...

class RemoteCachePassthroughSerde(RemoteCacheSerde[_T, _T]):
    def encode(self, data: _T) -> _T: ...
    def decode(self, data: _T) -> _T: ...

class RemoteCache(Generic[_T]):
    backend_override_cls: Callable[[], RemoteCacheBackend[Any]] | None
    backend: Incomplete
    serde: Incomplete
    def __init__(self, backend: RemoteCacheBackend[_U], serde: RemoteCacheSerde[_T, _U]) -> None: ...
    def get(self, key: str) -> _T | None: ...
    def put(self, key: str, value: _T) -> None: ...
    def _decode(self, data: _U, sample: Sample | None) -> _T: ...
    def _encode(self, value: _T, sample: Sample | None) -> object: ...
    def _get(self, key: str, sample: Sample | None) -> _T | None: ...
    def _backend_get(self, key: str) -> object: ...
    def _put(self, key: str, value: _T, sample: Sample | None) -> None: ...
    def _backend_put(self, key: str, data: object) -> None: ...
    def _create_sample(self) -> Sample | None: ...
    def _log_sample(self, sample: Sample | None) -> None: ...

class RedisRemoteCacheBackend(RemoteCacheBackend[bytes]):
    """
    A Redis implementation of a remote/distributed cache.
    """
    _redis: redis.Redis | None
    def __init__(self, cache_id: str) -> None: ...
    @override
    def _get(self, key: str) -> bytes | None: ...
    @override
    def _put(self, key: str, data: bytes) -> None: ...

class RedisRemoteCache(RemoteCache[JsonDataTy]):
    _key_fmt: Incomplete
    def __init__(self, cache_id: str) -> None: ...
    def _get_key(self, key: str) -> str: ...
    @override
    def _get(self, key: str, sample: Sample | None) -> JsonDataTy | None: ...
    @override
    def _put(self, key: str, value: JsonDataTy, sample: Sample | None) -> None: ...

class RemoteAutotuneCache(RedisRemoteCache): ...
class RemoteBundledAutotuneCache(RedisRemoteCache): ...
class RemoteFxGraphCache(RedisRemoteCache): ...
class RemoteAOTAutogradCache(RedisRemoteCache): ...
class RemoteDynamoPGOCache(RedisRemoteCache): ...

def create_cache(key: str, is_fbcode: bool, fb_cache_cls: str, oss_cache_cls: str) -> RemoteCache[JsonDataTy] | None: ...

@dataclasses.dataclass
class _CacheStat:
    miss: int = ...
    hit: int = ...
    put: int = ...
    exception: int = ...
    def __str__(self) -> str: ...

class _CacheStats:
    _stats: dict[str, _CacheStat]
    def __init__(self) -> None: ...
    def miss(self, name: str, count: int = 1) -> None: ...
    def hit(self, name: str, count: int = 1) -> None: ...
    def get(self, name: str, value: object | None) -> None: ...
    def put(self, name: str, count: int = 1) -> None: ...
    def exception(self, name: str, count: int = 1) -> None: ...

cache_stats: Incomplete

@atexit.register
def dump_cache_stats() -> None: ...
