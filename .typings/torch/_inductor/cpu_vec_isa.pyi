import dataclasses
import functools
import torch
from _typeshed import Incomplete
from torch._inductor import config as config
from typing import Any, Callable

_IS_WINDOWS: Incomplete

def _get_isa_dry_compile_fingerprint(isa_flags: str) -> str: ...

class VecISA:
    _bit_width: int
    _macro: list[str]
    _arch_flags: str
    _dtype_nelements: dict[torch.dtype, int]
    _avx_code: str
    _avx_py_load: str
    def bit_width(self) -> int: ...
    def nelements(self, dtype: torch.dtype = ...) -> int: ...
    def build_macro(self) -> list[str]: ...
    def build_arch_flags(self) -> str: ...
    def __hash__(self) -> int: ...
    def check_build(self, code: str) -> bool: ...
    def __bool__(self) -> bool: ...
    @functools.cache
    def __bool__impl(self, vec_isa_ok) -> bool: ...

@dataclasses.dataclass
class VecNEON(VecISA):
    _bit_width = ...
    _macro = ...
    _arch_flags = ...
    _dtype_nelements = ...
    def __str__(self) -> str: ...
    __hash__: Callable[[VecISA], Any] = ...

@dataclasses.dataclass
class VecSVE256(VecISA):
    _bit_width = ...
    _macro = ...
    _arch_flags = ...
    _dtype_nelements = ...
    def __str__(self) -> str: ...
    __hash__: Callable[[VecISA], Any] = ...

@dataclasses.dataclass
class VecAVX512(VecISA):
    _bit_width = ...
    _macro = ...
    _arch_flags = ...
    _dtype_nelements = ...
    def __str__(self) -> str: ...
    __hash__: Callable[[VecISA], Any] = ...

@dataclasses.dataclass
class VecAMX(VecAVX512):
    _arch_flags = ...
    def __str__(self) -> str: ...
    __hash__: Callable[[VecISA], Any] = ...
    _amx_code = ...
    @functools.cache
    def __bool__(self) -> bool: ...

@dataclasses.dataclass
class VecAVX2(VecISA):
    _bit_width = ...
    _macro = ...
    _arch_flags = ...
    _dtype_nelements = ...
    def __str__(self) -> str: ...
    __hash__: Callable[[VecISA], Any] = ...

@dataclasses.dataclass
class VecZVECTOR(VecISA):
    _bit_width = ...
    _macro = ...
    _arch_flags = ...
    _dtype_nelements = ...
    def __str__(self) -> str: ...
    __hash__: Callable[[VecISA], Any] = ...

@dataclasses.dataclass
class VecVSX(VecISA):
    _bit_width = ...
    _macro = ...
    _arch_flags = ...
    _dtype_nelements = ...
    def __str__(self) -> str: ...
    __hash__: Callable[[VecISA], Any] = ...

class InvalidVecISA(VecISA):
    _bit_width: int
    _macro: Incomplete
    _arch_flags: str
    _dtype_nelements: Incomplete
    def __str__(self) -> str: ...
    def __bool__(self) -> bool: ...
    __hash__: Callable[[VecISA], Any]

def x86_isa_checker() -> list[str]: ...

invalid_vec_isa: Incomplete
supported_vec_isa_list: Incomplete

def get_isa_from_cpu_capability(capability: str | None, vec_isa_list: list[VecISA], invalid_vec_isa: InvalidVecISA): ...
@functools.cache
def valid_vec_isa_list() -> list[VecISA]: ...
def pick_vec_isa() -> VecISA: ...
