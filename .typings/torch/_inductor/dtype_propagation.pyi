import functools
import sympy
import torch
from .ops_handler import OP_NAMES as OP_NAMES, OpsHandler as OpsHandler
from .utils import upcast_compute_type as upcast_compute_type
from .virtualized import OpsValue as OpsValue, V as V
from _typeshed import Incomplete
from collections.abc import Sequence
from torch._prims_common import ELEMENTWISE_TYPE_PROMOTION_KIND as ELEMENTWISE_TYPE_PROMOTION_KIND, type_to_dtype as type_to_dtype
from torch.utils._ordered_set import OrderedSet as OrderedSet
from typing import Any, Callable, Protocol, TypeVar

T = TypeVar('T')

class DTypeVar(Protocol):
    @property
    def dtype(self) -> torch.dtype: ...

DTypeArg: Incomplete

@functools.cache
def get_promoted_dtype(*args: Sequence[tuple[torch.dtype, bool]], type_promotion_kind: ELEMENTWISE_TYPE_PROMOTION_KIND | None = None): ...
def promote_types(args: Sequence[DTypeArg], type_promotion_kind: ELEMENTWISE_TYPE_PROMOTION_KIND | None = None): ...

class DtypePropagationOpsHandler:
    """
    Propagate dtype from args to output
    """
    _instance: DtypePropagationOpsHandler | None
    def __new__(cls): ...
    def __init__(self) -> None: ...
    @staticmethod
    def op_dtype_rule(*args: DTypeArg, type_promotion_kind: ELEMENTWISE_TYPE_PROMOTION_KIND) -> torch.dtype: ...
    @staticmethod
    def return_dtype(*args: DTypeArg, dtype: torch.dtype) -> torch.dtype: ...
    @staticmethod
    def constant(value: torch.types.Number, dtype: torch.dtype) -> torch.dtype: ...
    @staticmethod
    def load_seed(name: str, offset: int) -> torch.dtype: ...
    @staticmethod
    def randint64(seed: int, offset: int, low: int, high: int) -> torch.dtype: ...
    @staticmethod
    def masked(mask: DTypeArg, body: Callable[[], DTypeArg], other: DTypeArg) -> torch.dtype: ...
    @staticmethod
    def where(a: DTypeArg, b: DTypeArg, c: DTypeArg) -> torch.dtype: ...
    @staticmethod
    def index_expr(expr: sympy.Expr, dtype: torch.dtype) -> torch.dtype: ...
    @staticmethod
    def to_dtype(x: DTypeArg, dtype: torch.dtype, src_dtype: torch.dtype | None = None, use_compute_types: bool = True) -> torch.dtype: ...
    @staticmethod
    def to_dtype_bitcast(x: DTypeArg, dtype: torch.dtype, src_dtype: torch.dtype) -> torch.dtype: ...
    @staticmethod
    def gelu(x: DTypeArg) -> torch.dtype: ...
    @staticmethod
    def mul(a: DTypeArg, b: DTypeArg) -> torch.dtype: ...
    @staticmethod
    def truediv(a: DTypeArg, b: DTypeArg) -> torch.dtype: ...
    @staticmethod
    def pow(a: DTypeArg, b: DTypeArg) -> torch.dtype: ...
    @staticmethod
    def mod(a: DTypeArg, b: DTypeArg) -> torch.dtype: ...
    @staticmethod
    def indirect_indexing(x: DTypeArg, size: int, check: bool = True, wrap_neg: bool = True) -> torch.dtype: ...
    @staticmethod
    def randn(seed: int, offset: int) -> torch.dtype: ...
    @staticmethod
    def rand(seed: int, offset: int) -> torch.dtype: ...
    @staticmethod
    def store_reduction(name: str, index, value: DTypeArg) -> None: ...
    @staticmethod
    def reduction(dtype: torch.dtype, src_dtype: torch.dtype, reduction_type: str, value: DTypeArg) -> torch.dtype: ...
    @staticmethod
    def store(name: str, index, value: DTypeArg, mode: str | None = None) -> None: ...
    @staticmethod
    def load(name: str, index) -> torch.dtype: ...
    @staticmethod
    def floor(x: DTypeArg) -> torch.dtype: ...
    @staticmethod
    def ceil_to_int(x: DTypeArg, dtype: torch.dtype) -> torch.dtype: ...
    @staticmethod
    def int_truediv(x: DTypeArg, y: DTypeArg) -> torch.dtype: ...
    @staticmethod
    def scan(dtypes: tuple[torch.dtype, ...], combine_fn: Callable[[tuple[T, ...], tuple[T, ...]], tuple[T, ...]], values: tuple[T, ...]) -> tuple[torch.dtype, ...]: ...
    @staticmethod
    def fmod(x: DTypeArg, y: DTypeArg) -> torch.dtype: ...
    @staticmethod
    def round_to_int(x: DTypeArg, dtype: torch.dtype) -> torch.dtype: ...
    @staticmethod
    def identity(x: DTypeArg) -> torch.dtype: ...
    @staticmethod
    def frexp(x: DTypeArg) -> tuple[torch.dtype, torch.dtype]: ...
    @staticmethod
    def sort(dtypes: tuple[torch.dtype, ...], values: tuple[T, ...], stable: bool, descending: bool) -> tuple[torch.dtype, ...]: ...
    @staticmethod
    def trunc(x: DTypeArg) -> torch.dtype: ...
    @staticmethod
    def bucketize(values: DTypeArg, boundaries: tuple[str, sympy.Expr, sympy.Expr, sympy.Expr], boundary_indices: DTypeArg, indexing_dtype: torch.dtype, right: bool, sorter: tuple[str, sympy.Expr] | None = None, sorter_indices: T | None = None) -> torch.dtype: ...
    @staticmethod
    def rshift(x: DTypeArg, y: DTypeArg) -> torch.dtype: ...
    @staticmethod
    def round(x: DTypeArg) -> torch.dtype: ...
    @staticmethod
    def trunc_to_int(x: DTypeArg, dtype: torch.dtype) -> torch.dtype: ...
    @staticmethod
    def floor_to_int(x: DTypeArg, dtype: torch.dtype) -> torch.dtype: ...
    @staticmethod
    def truncdiv(x: DTypeArg, y: DTypeArg) -> torch.dtype: ...
    @staticmethod
    def floordiv(x: DTypeArg, y: DTypeArg) -> torch.dtype: ...
    @staticmethod
    def halide_clamp(value, size, check): ...
    @staticmethod
    def inline_asm_elementwise(*inputs, asm, constraints=None, dtype=..., is_pure: bool = True, pack: int = 1): ...
    @staticmethod
    def lshift(x: DTypeArg, y: DTypeArg) -> torch.dtype: ...
    @staticmethod
    def check_bounds(expr: sympy.Expr, size: sympy.Expr, lower: bool, upper: bool) -> None: ...
    def output(self, *args: DTypeArg) -> None: ...
    def placeholder(self, index: int) -> torch.dtype: ...

class _typecheck_DtypePropagation(DtypePropagationOpsHandler, OpsHandler[Any]): ...
