import sympy
import torch
from ..ops_handler import ReductionType as ReductionType, StoreMode as StoreMode
from ..scheduler import Scheduler as Scheduler, SchedulerNode as SchedulerNode
from ..utils import ceildiv as ceildiv, get_bounds_index_expr as get_bounds_index_expr, get_kernel_metadata as get_kernel_metadata
from ..virtualized import OpsWrapper as OpsWrapper, V as V, ops as ops
from .common import CSEVariable as CSEVariable, DTYPE_TO_COMPUTATION_DTYPE as DTYPE_TO_COMPUTATION_DTYPE, DeferredLine as DeferredLine, IndentedBuffer as IndentedBuffer, OpOverrides as OpOverrides, OpVarT as OpVarT, PythonPrinter as PythonPrinter
from .simd import IterationRangesEntry as IterationRangesEntry, SIMDKernel as SIMDKernel, SIMDScheduling as SIMDScheduling
from _typeshed import Incomplete
from torch.utils._cpp_embed_headers import _embed_headers as _embed_headers
from torch.utils._ordered_set import OrderedSet as OrderedSet
from torch.utils._sympy.printers import CppPrinter as CppPrinter, ExprPrinter as ExprPrinter_
from torch.utils._sympy.value_ranges import ValueRanges as ValueRanges
from typing import Any

log: Incomplete
DTYPE_TO_METAL: Incomplete

def value_to_metal(val: float | int | bool | str | CSEVariable) -> str: ...

class MetalExprPrinter(ExprPrinter_):
    """Converts sympy expression to Metal code snippet"""
    def _print_FloorDiv(self, expr: sympy.Expr) -> str: ...
    def _print_ModularIndexing(self, expr: sympy.Expr) -> str: ...
    def _print_Min(self, expr: sympy.Expr) -> str: ...
    def _print_Max(self, expr: sympy.Expr) -> str: ...
    def _print_Abs(self, expr: sympy.Expr) -> str: ...
    def _print_RoundToInt(self, expr: sympy.Expr) -> str: ...
    def _print_RoundDecimal(self, expr: sympy.Expr) -> str: ...
    def _print_IntTrueDiv(self, expr: sympy.Expr) -> str: ...
    def _print_PowByNatural(self, expr: sympy.Expr) -> str: ...
    def _print_ToFloat(self, expr: sympy.Expr) -> str: ...
    def _print_FloorToInt(self, expr: sympy.Expr) -> str: ...
    _print_floor = _print_FloorToInt
    def _print_TruncToInt(self, expr: sympy.Expr) -> str: ...
    def _print_OpaqueUnaryFn_log2(self, expr: sympy.Expr) -> str: ...

class MetalOverrides(OpOverrides):
    """Implements Metal-specific overrides for ops. Base class emits Python-friendly overrides."""
    @staticmethod
    def to_dtype(x: CSEVariable, dtype: torch.dtype, src_dtype: torch.dtype | None = None, use_compute_types: bool = True) -> str: ...
    @staticmethod
    def to_dtype_bitcast(x: CSEVariable, dtype: torch.dtype, src_dtype: torch.dtype) -> str: ...
    @staticmethod
    def constant(val: bool | float | int, dtype: torch.dtype) -> str: ...
    @staticmethod
    def index_expr(expr: sympy.Expr, dtype: torch.dtype) -> str: ...
    @staticmethod
    def masked(mask: CSEVariable, body: sympy.Expr, other: CSEVariable) -> str: ...
    @staticmethod
    def where(a: OpVarT, b: OpVarT, c: OpVarT) -> str: ...
    @staticmethod
    def remainder(a: OpVarT, b: OpVarT) -> str: ...
    @staticmethod
    def maximum(a: CSEVariable, b: CSEVariable) -> str: ...
    @staticmethod
    def minimum(a: CSEVariable, b: CSEVariable) -> str: ...
    @staticmethod
    def logical_or(a: CSEVariable, b: CSEVariable) -> str: ...
    @staticmethod
    def logical_and(a: CSEVariable, b: CSEVariable) -> str: ...
    @staticmethod
    def isnan(x: CSEVariable) -> str: ...
    @staticmethod
    def isinf(x: CSEVariable) -> str: ...
    @staticmethod
    def log(x: CSEVariable) -> str: ...
    @staticmethod
    def exp(x: CSEVariable) -> str: ...
    @staticmethod
    def abs(x: CSEVariable) -> str: ...
    @staticmethod
    def signbit(x: CSEVariable) -> str: ...
    @staticmethod
    def sin(x: CSEVariable) -> str: ...
    @staticmethod
    def sinc(x: CSEVariable) -> str: ...
    @staticmethod
    def cos(x: CSEVariable) -> str: ...
    @staticmethod
    def tan(x: CSEVariable) -> str: ...
    @staticmethod
    def asin(x: CSEVariable) -> str: ...
    @staticmethod
    def acos(x: CSEVariable) -> str: ...
    @staticmethod
    def atan(x: CSEVariable) -> str: ...
    @staticmethod
    def atan2(x: CSEVariable, y: CSEVariable) -> str: ...
    @staticmethod
    def sqrt(x: CSEVariable) -> str: ...
    @staticmethod
    def neg(x: CSEVariable) -> str: ...
    @staticmethod
    def rsqrt(x: CSEVariable) -> str: ...
    @staticmethod
    def tanh(x: CSEVariable) -> str: ...
    @staticmethod
    def atanh(x: CSEVariable) -> str: ...
    @staticmethod
    def floordiv(a: CSEVariable, b: CSEVariable) -> str: ...
    @staticmethod
    def floor(x: CSEVariable) -> str: ...
    @staticmethod
    def sign(x: CSEVariable) -> str: ...
    @staticmethod
    def fmod(a: CSEVariable, b: CSEVariable) -> str: ...
    @staticmethod
    def trunc(x: CSEVariable) -> str: ...
    @staticmethod
    def truncdiv(a: CSEVariable, b: CSEVariable) -> str: ...
    @staticmethod
    def ceil(x: CSEVariable) -> str: ...
    @staticmethod
    def rand(seed: CSEVariable, offset: CSEVariable) -> str: ...
    @staticmethod
    def randn(seed: CSEVariable, offset: CSEVariable) -> str: ...
    @staticmethod
    def randint64(seed: CSEVariable, offset: CSEVariable, low: CSEVariable, high: CSEVariable) -> str: ...
    @staticmethod
    def round(x: CSEVariable) -> str: ...
    @staticmethod
    def pow(a: CSEVariable, b: CSEVariable) -> str: ...
    def _special_unary(self, a: CSEVariable, name: str) -> str: ...
    def _special_binary(self, a: CSEVariable, b: CSEVariable, name: str) -> str: ...
    @classmethod
    def _initialize_special_ops(cls) -> None: ...

class MetalKernel(SIMDKernel):
    """Implement Metal codegen based on the SIMDKernel abstraction"""
    overrides = MetalOverrides
    suffix: str
    newvar_prefix: str
    max_threadgroup_size: int
    simd_group_size: int
    pexpr: Incomplete
    cexpr: Incomplete
    sexpr: Incomplete
    kexpr = sexpr
    headers: OrderedSet[str]
    multistage_reduction_entry: list[IterationRangesEntry]
    acc_var_ids: Incomplete
    def __init__(self, tiling: dict[str, sympy.Expr], **kwargs: Any) -> None: ...
    def dtype_to_str(self, dtype: torch.dtype) -> str: ...
    def load(self, name: str, index: sympy.Expr) -> CSEVariable:
        """Codegen a load from an InputBuffer"""
    def store(self, name: str, index: sympy.Expr, value: CSEVariable, mode: StoreMode = None) -> None: ...
    def store_reduction(self, name: str, index: sympy.Expr, value: CSEVariable) -> None: ...
    def _new_idxvar(self, dtype: str | torch.dtype, elem_count: int | None = None, default_value: Any | None = None, is_threadgroup: bool = True, bounds: ValueRanges[Any] = ...) -> CSEVariable: ...
    def reduction(self, dtype: torch.dtype, src_dtype: torch.dtype, reduction_type: ReductionType, value: CSEVariable | tuple[CSEVariable, ...]) -> CSEVariable | tuple[CSEVariable, ...]:
        """Caching wrapper around _reduction_nocache"""
    def _reduction_nocache(self, dtype: torch.dtype, src_dtype: torch.dtype, reduction_type: ReductionType, value: CSEVariable | tuple[CSEVariable, ...]) -> CSEVariable | tuple[CSEVariable, ...]:
        """Codegen a reduction operation.
        Only sum and prod operations are somewhat reasonable optimized"""
    def codegen_iteration_ranges_entry(self, entry: IterationRangesEntry) -> None: ...
    def codegen_body(self) -> None:
        """
        Concat output code from index_code, loads, compute, stores,
        suffix into self.body.

        For pointwise kernels, this is called just once at the end.

        For reduction kernels, this generates a loop over the reduction
        axis.
        """
    def codegen_kernel(self, name: str | None = None) -> str:
        """Called at the end to generate a final kernel string"""
    def call_kernel(self, name: str, node: Any = None) -> None:
        """Codegen a call to this kernel"""
    def check_bounds(self, expr: sympy.Expr, size: sympy.Expr, lower: bool, upper: bool) -> None: ...

class MetalScheduling(SIMDScheduling):
    kernel_type = MetalKernel
    def __init__(self, scheduler: Scheduler | None) -> None: ...
    def define_kernel(self, src_code: str, node_schedule: list[SchedulerNode], kernel: MetalKernel) -> str: ...
