import sympy
import torch
from ...virtualized import V as V
from _typeshed import Incomplete
from collections.abc import Generator, Iterable, Iterator, Sequence
from contextlib import contextmanager
from torch._inductor.ir import ComputedBuffer as ComputedBuffer, Pointwise as Pointwise
from torch._inductor.ops_handler import DefaultHandler as DefaultHandler, WrapperHandler as WrapperHandler
from torch._inductor.scheduler import BaseSchedulerNode as BaseSchedulerNode
from torch._inductor.utils import DelayReplaceLine as DelayReplaceLine, IndentedBuffer as IndentedBuffer, OrderedSet as OrderedSet
from torch._inductor.virtualized import OpsValue as OpsValue
from typing import Any

_ACCUMULATOR_ARG_NAME: str

def scaled_mm_evt(scale_A_name: str, scale_B_name: str, bias_name: str | None, output_name: str) -> tuple[list[str], dict[str, Any], str]: ...

class CutlassEVTOpsMixIn:
    @staticmethod
    def _infix_bin_op(op: str, a: str, b: str) -> str: ...
    @staticmethod
    def _prefix_bin_op(op: str, a: str, b: str) -> str: ...
    @staticmethod
    def _prefix_un_op(op: str, a: str) -> str: ...
    @staticmethod
    def to_dtype(x: str, dtype: Any, src_dtype: torch.dtype | None = None, use_compute_types: bool = False) -> str: ...
    @staticmethod
    def constant(value: Any, dtype: Any) -> str: ...
    @staticmethod
    def mul(x0: str, x1: str) -> str: ...
    @staticmethod
    def truediv(x0: str, x1: str) -> str: ...
    @staticmethod
    def ge(x0: str, x1: str) -> str: ...
    @staticmethod
    def add(x0: str, x1: str) -> str: ...
    @staticmethod
    def relu(x0: str) -> str: ...
    @staticmethod
    def sigmoid(x0: str) -> str: ...
    @staticmethod
    def sub(x0: str, x1: str) -> str: ...
    @staticmethod
    def tanh(x0: str) -> str: ...

class MockCutlassHandler(CutlassEVTOpsMixIn, WrapperHandler):
    """Passthrough handler for cutlass ops, used for running epilogue nodes for memory planning"""

class _AssignmentFormatter(DefaultHandler):
    parent_handler: Incomplete
    def __init__(self, parent_handler: CutlassEVTCodegen) -> None: ...
    def _default(self, name: str, args: tuple[Any, ...], kwargs: dict[str, Any]) -> Any: ...

class CutlassEVTCodegen(CutlassEVTOpsMixIn):
    """
    Notes:
        * Used by CUTLASSGemmTemplate.
        * This class should not be instantiated by users, it is intended to be used
            by calling CutlassEVTCodegen.ir_to_evt_python_code(...)
            which instantiates this class as an ops handler for virtualized.V.ops.[op-name]
        * Extend this with more _op_<whatever> nodes to add support for new pointwise operations.
    """
    accumulator_node_name: str
    body: IndentedBuffer
    var_counter: Iterator[int]
    store_name_to_value: dict[str, OpsValue]
    reads: OrderedSet[str]
    var_name_to_buffer_name: dict[str, str]
    removed_buffers: OrderedSet[str]
    cur_node: ComputedBuffer | None
    name_to_buffer: Incomplete
    is_D_assigned: bool
    D_var_name: Incomplete
    def __init__(self, accumulator_node_name: str, removed_buffers: OrderedSet[str]) -> None:
        """

        Initializes a CutlassEVTEpilogueArgumentFormatter object. Do not instantiate directly.
        Use the CutlassEVTCodegen.ir_to_evt_python_code static method.

        Args:
            accumulator_node_name: The name of the accumulator node which should contain
                                          the Matmul result before fusion according to the IR graph.
            epilogue_nodes: The list of scheduler nodes to be fused into the epilogue
        """
    @staticmethod
    def ir_to_evt_python_code(cuda_template_node_name: str, epilogue_nodes: list[BaseSchedulerNode], removed_buffers: OrderedSet[str]) -> tuple[list[str], list[str], dict[str, Any], str]: ...
    def get_value(self) -> str: ...
    def finalize(self) -> None: ...
    @contextmanager
    def set_cur_node(self, node: ComputedBuffer) -> Generator[None, Any, Any]: ...
    def get_renames(self) -> dict[str, str]: ...
    def get_reads(self) -> list[str]: ...
    def get_writes(self) -> list[str]: ...
    def load(self, name: str, index: Any) -> str: ...
    last_stored_var_name: Incomplete
    def store(self, name: Any, index: Any = None, value: Any = None, mode: Any = None) -> None: ...
    def _get_cur_node(self) -> ComputedBuffer: ...
    @staticmethod
    def get_index_vars(node: ComputedBuffer) -> Sequence[sympy.Expr]: ...
    def _get_current_index_vars(self) -> Sequence[sympy.Expr]: ...
    def _check_indexing(self, name: str, index: sympy.Expr) -> None: ...
    def _stride_compatible(self, left: Iterable[sympy.Expr], right: Iterable[sympy.Expr]) -> bool: ...
    def _render_input_signature(self) -> str: ...
    def _render_return_statement(self) -> str: ...
    def _tmp_var(self) -> str: ...
