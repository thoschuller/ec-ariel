import sympy
import torch
from ..utils._ordered_set import OrderedSet as OrderedSet
from .utils import IndentedBuffer as IndentedBuffer, reduction_num_outputs as reduction_num_outputs, sympy_index_symbol as sympy_index_symbol, sympy_str as sympy_str
from _typeshed import Incomplete
from typing import Any, Callable, Generic, NamedTuple, TypeVar

T = TypeVar('T')
StoreMode: Incomplete
ReductionType: Incomplete

def _arg_str(a: object) -> str: ...

class OpsHandler(Generic[T]):
    """
    Protocol describing the set of valid operations on ``torch._inductor.virtualized.ops``,
    as well as the contract for op handlers.  The type T signifies the domain
    of the abstract analysis AKA what all the functions return / take as arguments
    anywhere compute occurs.

    While these operators are typically dtype polymorphic (e.g., you can use mul
    on both integers and floats), they do NOT do promotion and usually return the
    same dtype as the input.  You are expected to have handled type promotion
    during ATen decompositions.  Most operators correspond exactly to pointwise
    operations as defined by torch, so when in doubt about semantics, check the
    corresponding torch documentation.  These are all scalar operations (so they
    are defined to operate on a single element at a time.)

    For convenience, many operators take a src_dtype which indicates what the dtype
    of the input argument is.  Although in principle this can be derived by an
    analysis, providing this for ops where it is useful helps avoid having to repeatedly
    recompute dtype in code generation.

    Note that this often describes a class of static methods, for stateless
    ops handlers.

    Handlers are often defined using metaprogramming (e.g. _initialize_pointwise_overrides),
    which means you will not get type errors for those methods.  We have tests in
    test/inductor/test_op_completeness.py which check that all operators are implemented after
    all the metaprogramming has run.
    """
    def constant(self, value: bool | float | int, dtype: torch.dtype) -> T:
        """Produces a scalar constant of type dtype."""
    def load_seed(self, name: str, offset: T) -> T:
        """Computes inductor_prims.lookup_seed."""
    def rand(self, seed: T, offset: T) -> T:
        '''Computes inductor_prims.random with mode="rand".  offset has dtype int32.'''
    def randn(self, seed: T, offset: T) -> T:
        '''Computes inductor_prims.random with mode="randn".  offset has dtype int32.'''
    def randint64(self, seed: T, offset: T, low: T, high: T) -> T:
        """Computes inductor_prims.randint.  offset has dtype int32."""
    def masked(self, mask: T, body: Callable[[], T], other: T) -> T:
        """
        Computes body, but only perform loads/stores if the boolean mask
        evaluates to true.  For example, you would use this if you needed to
        perform an indirect load that may not be valid on some elements;
        without masking, invalid accesses can cause IMAs.  When mask is true,
        the result is the result of body; otherwise it is other. Here, `other`
        needs to be a constant.

        Contrast this with ops.where, which can multiplex between two values
        that have been unconditionally computed.
        """
    def where(self, condition: T, input: T, other: T) -> T:
        """
        Computes torch.where: when condition is true, return input; otherwise return other.
        """
    def index_expr(self, expr: sympy.Expr, dtype: torch.dtype) -> T:
        """
        Converts a sympy expression into a scalar of type dtype.  expr is typically
        an indexing expression, thus the name; however, it can also be used in
        non-indexing situations.
        """
    def to_dtype(self, x: T, dtype: torch.dtype, src_dtype: torch.dtype | None = None, use_compute_types: bool = True) -> T:
        """
        Convert x to dtype.  src_dtype can be optionally set to specify what the original
        dtype of x was, which can improve code generation (used by torch to(dtype=dtype)).
        """
    def trunc_to_int(self, x: T, dtype: torch.dtype) -> T:
        """
        Convert x to dtype with truncation semantics (similar to how the int
        constructor works in Python).  In Inductor codegen, this just decays
        to trunc and then to_dtype, but this composite operation helps
        roundtrips for Sympy evaluation.

        dtype is taken as an explicit parameter because the desired output
        dtype is typically the index dtype, which may vary between int32 and
        int64 depending on if we've shown that all the indexing operations can
        be done in int32.
        """
    def ceil_to_int(self, x: T, dtype: torch.dtype) -> T:
        """
        Convert x to dtype with ceiling semantics.  See also trunc_to_int.
        """
    def floor_to_int(self, x: T, dtype: torch.dtype) -> T:
        """
        Convert x to dtype with ceiling semantics.  See also trunc_to_int.
        """
    def round_to_int(self, x: T, dtype: torch.dtype) -> T:
        """
        Convert x to dtype with round-to-even semantics.  See also trunc_to_int.
        """
    def to_dtype_bitcast(self, x: T, dtype: torch.dtype, src_dtype: torch.dtype) -> T:
        """
        Reinterpret cast x to dtype (reinterpreting the bits in memory as another dtype.)
        src_dtype must be the original type of x.
        """
    def identity(self, x: T) -> T:
        """
        Returns x as is.  This is used to trigger CSE.
        """
    def indirect_indexing(self, x: T, size: sympy.Expr, check: bool = True, wrap_neg: bool = True) -> sympy.Expr:
        """
        Convert an integral x into a sympy.Expr that can be subsequently used in
        indexing computation.  'size' represents an upper bound on what valid
        indexes can be; when 'check' is True, we check that the x is in bounds.

        NB: This is typically mandatory to implement for any analysis, because you
        MUST return a valid sympy.Expr of some sort (even if it's a meaningless symbol).
        """
    def load(self, name: str, index: sympy.Expr) -> T:
        """
        Load from the memory location 'name', offset by some indexing expression 'index'.
        """
    def store(self, name: str, index: sympy.Expr, value: T, mode: StoreMode = None) -> None:
        """
        Store 'value' to the memory location 'name' offset by 'expr'.  If
        specified, 'mode' can require the store to be an atomic addition.
        """
    def reduction(self, dtype: torch.dtype, src_dtype: torch.dtype, reduction_type: ReductionType, value: T) -> T | tuple[T, ...]:
        """
        Perform a 'reduction_type' reduction on 'value' of dtype 'src_dtype',
        using 'dtype' as the accumulation dtype for the reduction.  The result
        is an intermediate computation which should be stored to the final
        location using 'ops.store_reduction'.

        Valid reduction types are .  For Welford reduction types, this
        function returns multiple outputs; consult reduction_num_outputs to
        determine the amount in metaprogramming applications.
        """
    def store_reduction(self, name: str, index: sympy.Expr, value: T) -> None:
        """
        Store the fully accumulated result of 'reduction' to the memory
        location 'name' offset by 'expr'.
        """
    def scan(self, dtypes: tuple[torch.dtype, ...], combine_fn: Callable[[tuple[T, ...], tuple[T, ...]], tuple[T, ...]], values: tuple[T, ...]) -> tuple[T, ...]:
        """
        Perform an associative scan on 'value'.
        """
    def sort(self, dtypes: tuple[torch.dtype, ...], values: tuple[T, ...], stable: bool, descending: bool) -> tuple[T, ...]:
        """
        Sort values along the reduction dimension.
        """
    def bucketize(self, values: T, boundaries: tuple[str, sympy.Expr, sympy.Expr, sympy.Expr], boundary_indices: T, indexing_dtype: torch.dtype, right: bool, sorter: tuple[str, sympy.Expr] | None = None, sorter_indices: T | None = None) -> T: ...
    def abs(self, x0: T) -> T: ...
    def exp(self, x0: T) -> T: ...
    def exp2(self, x0: T) -> T: ...
    def expm1(self, x0: T) -> T: ...
    def sqrt(self, x0: T) -> T: ...
    def relu(self, x0: T) -> T: ...
    def minimum(self, x0: T, x1: T) -> T: ...
    def maximum(self, x0: T, x1: T) -> T: ...
    def cos(self, x0: T) -> T: ...
    def sin(self, x0: T) -> T: ...
    def lgamma(self, x0: T) -> T: ...
    def erf(self, x0: T) -> T: ...
    def cosh(self, x0: T) -> T: ...
    def sinh(self, x0: T) -> T: ...
    def acos(self, x0: T) -> T: ...
    def acosh(self, x0: T) -> T: ...
    def asin(self, x0: T) -> T: ...
    def asinh(self, x0: T) -> T: ...
    def atan2(self, x0: T, x1: T) -> T: ...
    def atan(self, x0: T) -> T: ...
    def atanh(self, x0: T) -> T: ...
    def copysign(self, x0: T, x1: T) -> T: ...
    def erfc(self, x0: T) -> T: ...
    def erfinv(self, x0: T) -> T: ...
    def frexp(self, x0: T): ...
    def hypot(self, x0: T, x1: T) -> T: ...
    def log10(self, x0: T) -> T: ...
    def log2(self, x0: T) -> T: ...
    def nextafter(self, x0: T, x1: T) -> T: ...
    def logical_and(self, x0: T, x1: T) -> T: ...
    def logical_not(self, x0: T) -> T: ...
    def logical_or(self, x0: T, x1: T) -> T: ...
    def logical_xor(self, x0: T, x1: T) -> T: ...
    def bitwise_and(self, x0: T, x1: T) -> T: ...
    def bitwise_not(self, x0: T) -> T: ...
    def bitwise_or(self, x0: T, x1: T) -> T: ...
    def bitwise_xor(self, x0: T, x1: T) -> T: ...
    def bitwise_left_shift(self, x0: T, x1: T) -> T: ...
    def bitwise_right_shift(self, x0: T, x1: T) -> T: ...
    def rsqrt(self, x0: T) -> T: ...
    def log1p(self, x0: T) -> T: ...
    def tan(self, x0: T) -> T: ...
    def tanh(self, x0: T) -> T: ...
    def sigmoid(self, x0: T) -> T: ...
    def signbit(self, x0: T) -> T: ...
    def fmod(self, x0: T, x1: T) -> T: ...
    def log(self, x0: T) -> T: ...
    def isinf(self, x0: T) -> T: ...
    def isnan(self, x0: T) -> T: ...
    def round(self, x0: T) -> T: ...
    def floor(self, x0: T) -> T: ...
    def sign(self, x0: T) -> T: ...
    def trunc(self, x0: T) -> T: ...
    def ceil(self, x0: T) -> T: ...
    def neg(self, x0: T) -> T: ...
    def reciprocal(self, x0: T) -> T: ...
    def eq(self, x0: T, x1: T) -> T: ...
    def ne(self, x0: T, x1: T) -> T: ...
    def lt(self, x0: T, x1: T) -> T: ...
    def gt(self, x0: T, x1: T) -> T: ...
    def le(self, x0: T, x1: T) -> T: ...
    def ge(self, x0: T, x1: T) -> T: ...
    def add(self, x0: T, x1: T) -> T: ...
    def sub(self, x0: T, x1: T) -> T: ...
    def mul(self, x0: T, x1: T) -> T: ...
    def pow(self, x0: T, x1: T) -> T: ...
    def and_(self, x0: T, x1: T) -> T: ...
    def or_(self, x0: T, x1: T) -> T: ...
    def xor(self, x0: T, x1: T) -> T: ...
    def lshift(self, x0: T, x1: T) -> T: ...
    def rshift(self, x0: T, x1: T) -> T: ...
    def airy_ai(self, x: T) -> T: ...
    def bessel_j0(self, x: T) -> T: ...
    def bessel_j1(self, x: T) -> T: ...
    def bessel_y0(self, x: T) -> T: ...
    def bessel_y1(self, x: T) -> T: ...
    def digamma(self, x: T) -> T: ...
    def erfcx(self, x: T) -> T: ...
    def fma(self, x: T, y: T, z: T) -> T: ...
    def igamma(self, x: T, y: T) -> T: ...
    def igammac(self, x: T, y: T) -> T: ...
    def gammainc(self, x: T, y: T) -> T: ...
    def gammaincc(self, x: T, y: T) -> T: ...
    def i0(self, x: T) -> T: ...
    def i0e(self, x: T) -> T: ...
    def i1(self, x: T) -> T: ...
    def i1e(self, x: T) -> T: ...
    def log_ndtr(self, x: T) -> T: ...
    def modified_bessel_i0(self, x: T) -> T: ...
    def modified_bessel_i1(self, x: T) -> T: ...
    def modified_bessel_k0(self, x: T) -> T: ...
    def modified_bessel_k1(self, x: T) -> T: ...
    def ndtr(self, x: T) -> T: ...
    def ndtri(self, x: T) -> T: ...
    def polygamma(self, x: T, y: T) -> T: ...
    def scaled_modified_bessel_k0(self, x: T) -> T: ...
    def scaled_modified_bessel_k1(self, x: T) -> T: ...
    def spherical_bessel_j0(self, x: T) -> T: ...
    def zeta(self, x: T, y: T) -> T: ...
    def chebyshev_polynomial_t(self, x: T, y: T) -> T: ...
    def chebyshev_polynomial_u(self, x: T, y: T) -> T: ...
    def chebyshev_polynomial_v(self, x: T, y: T) -> T: ...
    def chebyshev_polynomial_w(self, x: T, y: T) -> T: ...
    def legendre_polynomial_p(self, x: T, y: T) -> T: ...
    def shifted_chebyshev_polynomial_t(self, x: T, y: T) -> T: ...
    def shifted_chebyshev_polynomial_u(self, x: T, y: T) -> T: ...
    def shifted_chebyshev_polynomial_v(self, x: T, y: T) -> T: ...
    def shifted_chebyshev_polynomial_w(self, x: T, y: T) -> T: ...
    def hermite_polynomial_h(self, x: T, y: T) -> T: ...
    def hermite_polynomial_he(self, x: T, y: T) -> T: ...
    def laguerre_polynomial_l(self, x: T, y: T) -> T: ...
    def truncdiv(self, x0: T, x1: T) -> T:
        """C-style trunc division between integers only.  Computes the true
        division of two numbers and rounds the result to zero.
        """
    def floordiv(self, x0: T, x1: T) -> T:
        """Python-style floor division between integers only.  Computes the
        true division of two numbers and floors the result.  If you want
        floor division for floats, do regular truediv and floor the result.
        """
    def truediv(self, x0: T, x1: T) -> T:
        """True division between floats.  Integer inputs are NOT valid.  To
        do Python-style (int, int) -> float division, use int_truediv"""
    def int_truediv(self, x0: T, x1: T) -> T:
        """True division between integers.  This is NOT the same as promoting
        to float and doing integer division, there is a bespoke algorithm for
        doing the division in higher precision than the above.
        """
    def mod(self, x0: T, x1: T) -> T:
        """C-style modulus, take sign from LHS (x0)."""
    def remainder(self, x0: T, x1: T) -> T:
        """Python-style modulus, take sign from RHS (x1)."""
    def square(self, x0: T) -> T: ...
    def check_bounds(self, expr: sympy.Expr, size: sympy.Expr, lower: bool, upper: bool) -> None: ...
    def halide_clamp(self, value: T, size: sympy.Expr, check: bool) -> T: ...
    def inline_asm_elementwise(self, *inputs: T, asm: str, constraints: str | None = None, dtype: torch.dtype = ..., is_pure: bool = True, pack: int = 1) -> T: ...
    def output(self, *args: T) -> None:
        """This is a fake op used in analysis but not codegen"""
    def placeholder(self, index: int) -> T:
        """This is a fake op used in analysis but not codegen"""

_ignore_op_re: Incomplete

def list_ops(cls): ...

OP_NAMES: Incomplete

class DefaultHandler(OpsHandler[Any]):
    def _default(self, name: str, args: tuple[Any, ...], kwargs: dict[str, Any]) -> Any:
        """
        Default implementation for all ops.  Override in a subclass to
        provide generic op behavior.

        Args:
            name: name of the op, see OpHandler.{name}
            args: positional args passed to the op
            kwargs: keyword args passed to the op

        Returns:
            return value of the op

        """
    def __getattr__(self, name: str) -> Any: ...
    @staticmethod
    def _call_default(target: str): ...
    @classmethod
    def _init_cls(cls) -> None:
        """
        Here we codegen many functions of the form:

            def add(self, a, b):
                return self._default('add', (a, b), {})

        and install them in cls.  This is the same as _call_default above,
        but is about 1.2x faster since CPython varargs parsing is slow.
        """

class NoopHandler(DefaultHandler):
    name: str
    def _default(self, name: str, args: tuple[Any, ...], kwargs: dict[str, Any]) -> Any: ...
    @staticmethod
    def masked(mask, body, other) -> None: ...
    @staticmethod
    def frexp(x) -> tuple[None, None]: ...
    @staticmethod
    def scan(dtypes, combine_fn, values) -> tuple[None, ...]: ...
    @staticmethod
    def sort(dtypes, values, stable, descending) -> tuple[None, ...]: ...
    @staticmethod
    def indirect_indexing(index_var, size, check: bool = True, wrap_neg: bool = True) -> sympy.Symbol: ...

class BasicMathOpsMixin:
    @staticmethod
    def add(a, b): ...
    @staticmethod
    def sub(a, b): ...
    @staticmethod
    def mul(a, b): ...
    @staticmethod
    def floordiv(a, b): ...
    @staticmethod
    def truediv(a, b): ...
    @staticmethod
    def mod(a, b): ...
    @staticmethod
    def pow(a, b): ...
    @staticmethod
    def lshift(a, b): ...
    @staticmethod
    def rshift(a, b): ...
    @staticmethod
    def and_(a, b): ...
    @staticmethod
    def or_(a, b): ...
    @staticmethod
    def xor(a, b): ...
    @staticmethod
    def eq(a, b): ...
    @staticmethod
    def ne(a, b): ...
    @staticmethod
    def lt(a, b): ...
    @staticmethod
    def gt(a, b): ...
    @staticmethod
    def le(a, b): ...
    @staticmethod
    def ge(a, b): ...
    @staticmethod
    def neg(a): ...

class MockHandler(BasicMathOpsMixin, DefaultHandler):
    name: str
    def _default(self, name: str, args: tuple[Any, ...], kwargs: dict[str, Any]) -> Any: ...
    @staticmethod
    def masked(mask, body, other) -> str: ...
    @staticmethod
    def frexp(x): ...
    @staticmethod
    def scan(dtypes, combine_fn, values): ...
    @staticmethod
    def sort(dtypes, values, stable, descending): ...
    @staticmethod
    def indirect_indexing(index_var, size, check: bool = True, wrap_neg: bool = True) -> sympy.Symbol: ...

class KernelFormatterHandler(DefaultHandler):
    parent_handler: Incomplete
    _output: Incomplete
    var_counter: Incomplete
    def __init__(self, parent_handler: OpsHandler[Any]) -> None: ...
    @staticmethod
    def ir_to_string(ir_fn, index, rindex=None) -> str: ...
    def indirect_indexing(self, *args, **kwargs) -> sympy.Symbol: ...
    def _write(self, line): ...
    def _default(self, name: str, args: tuple[Any, ...], kwargs: dict[str, Any]) -> Any: ...
    def reduction(self, dtype: torch.dtype, src_dtype: torch.dtype, reduction_type: ReductionType, value: str | tuple[str, ...]) -> str | tuple[str, ...]: ...
    def getvalue(self, result): ...

class WrapperHandler(DefaultHandler):
    _inner: Incomplete
    def __init__(self, inner: OpsHandler[Any]) -> None: ...
    def _default(self, name: str, args: tuple[Any, ...], kwargs: dict[str, Any]) -> Any: ...

class AddParenHandler(WrapperHandler):
    def _default(self, name: str, args: tuple[Any, ...], kwargs: dict[str, Any]) -> Any: ...

class OpCountResult(NamedTuple):
    num_ops: int
    used_ops: OrderedSet[str]
    read_buffers: list[str]
    nontrivial_read_count: int

class OpCounterCSE(DefaultHandler):
    """Shim to count how many ops are used"""
    parent_handler: Incomplete
    op_count: int
    var_names: dict[str, str]
    _used_ops: OrderedSet[str]
    _read_names: list[str]
    _nontrivial_read_count: int
    def __init__(self, inner: OpsHandler[Any]) -> None: ...
    def _default(self, name: str, args: tuple[Any, ...], kwargs: dict[str, Any]) -> Any: ...
    def _update_count(self, val): ...
    def indirect_indexing(self, *args, **kwargs): ...
    def load(self, name: str, index: sympy.Expr) -> str: ...
    def load_seed(self, name: str, offset: T): ...
    def bucketize(self, values: T, boundaries: tuple[str, sympy.Expr, sympy.Expr, sympy.Expr], boundary_indices: T, indexing_dtype: torch.dtype, right: bool, sorter: tuple[str, sympy.Expr] | None = None, sorter_indices: T | None = None) -> T:
        """
        See [Note: Inductor bucketize op]
        """
    def getvalue(self): ...

class ExtractConstantsHandler(NoopHandler):
    device: Incomplete
    def __init__(self, device: torch.device | None) -> None: ...
    def constant(self, value: Any, dtype: torch.dtype) -> torch._inductor.ir.Constant: ...

class SimpleCSEHandler(WrapperHandler):
    """Wraps the underlying handler with a CSE pass

    NOTE: Compared to codegen level CSE this is simplified as it
    doesn't support stores which require load cache invalidation.
    """
    cse_cache: dict[str, Any | tuple[Any, ...]]
    mock: Incomplete
    def __init__(self, inner: Any) -> None: ...
    def indirect_indexing(self, *args, **kwargs) -> sympy.Expr: ...
    def store(self, *args, **kwargs) -> None: ...
    def store_reduction(self, *args, **kwargs) -> None: ...
    def _default(self, name: str, args: tuple[Any, ...], kwargs: dict[str, Any]) -> Any: ...
