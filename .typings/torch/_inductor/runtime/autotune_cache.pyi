import dataclasses
from ..remote_cache import JsonDataTy as JsonDataTy, RemoteCache as RemoteCache, RemoteCacheBackend as RemoteCacheBackend, RemoteCacheJsonSerde as RemoteCacheJsonSerde, Sample as Sample, create_cache as create_cache
from .triton_compat import Config as Config, HAS_WARP_SPEC as HAS_WARP_SPEC
from _typeshed import Incomplete
from torch._inductor.runtime.runtime_utils import cache_dir as cache_dir
from torch.compiler._cache import CacheArtifact as CacheArtifact, CacheArtifactFactory as CacheArtifactFactory, CacheArtifactManager as CacheArtifactManager
from torch.utils._triton import has_triton as has_triton
from typing import Any
from typing_extensions import override

log: Incomplete
_InductorMetaTy = dict[str, object]

def inductor_meta_from_config() -> _InductorMetaTy: ...

class AutotuneCacheArtifact(CacheArtifact):
    @override
    def populate_cache(self) -> None: ...
    @override
    @staticmethod
    def type() -> str: ...
    @override
    @staticmethod
    def encode(content: JsonDataTy) -> bytes: ...

@dataclasses.dataclass
class AutotuneCache:
    configs_hash: str
    local_cache: tuple[RemoteCache[JsonDataTy], str] | None = ...
    remote_cache: tuple[RemoteCache[JsonDataTy], str] | None = ...
    @staticmethod
    def create(inductor_meta: _InductorMetaTy, filename: str, configs_hash: str) -> AutotuneCache | None: ...
    @staticmethod
    def _prepare_key(filename: str) -> str: ...
    def _read(self) -> dict[str, JsonDataTy] | None: ...
    def read_best(self, inductor_meta: _InductorMetaTy, configs: list[Config]) -> Config | None: ...
    def _setup_local_cache(self, inductor_meta: _InductorMetaTy, dirname: str, cache_key: str) -> None: ...
    remote_cache_full_key = ...
    is_fbcode = ...
    def _setup_remote_autotune_cache(self, inductor_meta: _InductorMetaTy, cache_key: str) -> None: ...
    def __getstate__(self) -> dict[str, Any]: ...
    def __setstate__(self, state: dict[str, Any]) -> None: ...
    def save(self, config: Config, time_taken_ns: int, found_by_coordesc: bool = False, triton_cache_hash: str | None = None) -> None: ...

class _AutotuneCacheBundlerImpl:
    """
    Caches a set of LocalAutotuneCacheBackend entries together in a single
    cache.
    """
    _key: str
    _cache: RemoteCache[JsonDataTy]
    _entries: dict[str, JsonDataTy]
    def end_compile(self) -> None: ...
    def put(self, basename: str, data: JsonDataTy) -> None: ...
    def __init__(self, key: str, cache: RemoteCache[JsonDataTy]) -> None: ...
    def sync(self) -> None: ...
    @classmethod
    def _should_use_bundled_autotune_remote_cache(cls, inductor_meta: _InductorMetaTy) -> bool: ...
    def _load_cache(self) -> bool: ...
    @staticmethod
    def _get_is_fbcode(inductor_meta: _InductorMetaTy) -> bool: ...
    @staticmethod
    def _get_backend_hash(inductor_meta: _InductorMetaTy) -> str: ...

class AutotuneCacheBundler:
    _bundler: _AutotuneCacheBundlerImpl | None
    def __init__(self) -> None: ...
    @classmethod
    def begin_compile(cls, inductor_meta: _InductorMetaTy, *, code: str | None = None, code_hash: str | None = None) -> None: ...
    @classmethod
    def end_compile(cls) -> None: ...
    @classmethod
    def sync(cls) -> None: ...
    @classmethod
    def put(cls, filename: str, data: JsonDataTy) -> None: ...

def _comment_stripped_hash(code: str) -> str: ...
def _should_use_remote_autotune_cache(inductor_meta: _InductorMetaTy) -> bool: ...
def _load_cached_autotuning(best_config: dict[str, JsonDataTy], configs_hash: str, configs: list[Config], inductor_meta: _InductorMetaTy) -> Config | None: ...

class _LocalAutotuneCacheBackend(RemoteCacheBackend[bytes]):
    @override
    def _get(self, key: str) -> bytes | None: ...
    @override
    def _put(self, key: str, data: bytes) -> None: ...

class LocalAutotuneCache(RemoteCache[JsonDataTy]):
    def __init__(self) -> None: ...
    @override
    def _get(self, key: str, sample: Sample | None) -> JsonDataTy | None: ...
    @override
    def _put(self, key: str, value: JsonDataTy, sample: Sample | None) -> None: ...

def _splitext_nodot(basename: str) -> tuple[str, str]: ...
