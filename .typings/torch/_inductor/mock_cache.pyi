import contextlib
import dataclasses
import threading
from _typeshed import Incomplete
from torch._inductor import config as config
from torch._inductor.remote_cache import RemoteCacheBackend as RemoteCacheBackend
from types import TracebackType
from typing import Any, Callable
from typing_extensions import Self, override

@dataclasses.dataclass
class Stats:
    num_put: int = ...
    num_get_hit: int = ...
    num_get_miss: int = ...
    def __iadd__(self, other: Stats) -> Self: ...
    def reset(self) -> None: ...
    def __str__(self) -> str: ...
    def __eq__(self, other: object) -> bool: ...

class _GlobalItemStats(Stats):
    cache: dict[str, object]
    def __init__(self) -> None: ...
    def reset(self) -> None: ...

class _GlobalStats(threading.local):
    autotune_local: Incomplete
    autotune_remote: Incomplete
    bundled_autotune: Incomplete
    fx_graph: Incomplete
    triton: Incomplete
    aot_autograd: Incomplete
    dynamo_pgo: Incomplete
    def __init__(self) -> None: ...
    def reset(self) -> None: ...
    def get_stat(self, name: str) -> _GlobalItemStats: ...
    def report(self) -> None: ...

global_stats: Incomplete

class MockBackend(RemoteCacheBackend[Any]):
    _name: Incomplete
    def __init__(self, name: str) -> None: ...
    @staticmethod
    def with_name(name: str) -> Callable[[], MockBackend]: ...
    @override
    def _get(self, key: str) -> Any | None: ...
    @override
    def _put(self, key: str, data: Any) -> None: ...

_CACHE_CONFIG_EN: Incomplete

class PatchCaches(contextlib.AbstractContextManager):
    @classmethod
    def setUp(cls) -> None: ...
    @classmethod
    def tearDown(cls) -> None: ...
    _stack: Incomplete
    def __init__(self) -> None: ...
    def __enter__(self) -> Self: ...
    def __exit__(self, exc_type: type[BaseException] | None, exc_value: BaseException | None, traceback: TracebackType | None) -> None: ...
