import torch
from .. import config as config
from ..pattern_matcher import Arg as Arg, CallFunction as CallFunction, Match as Match, register_graph_pattern as register_graph_pattern
from .split_cat import construct_pattern_matcher_pass as construct_pattern_matcher_pass
from _typeshed import Incomplete
from torch import Tensor as Tensor
from torch._dynamo.utils import counters as counters, is_node_meta_valid as is_node_meta_valid
from torch.fx.experimental.symbolic_shapes import statically_known_true as statically_known_true

aten: Incomplete
log: Incomplete
MIN_FIRST_DIMENSION_DECOMPOSITION: int
MAX_OTHER_DIMENSION_DECOMPOSITION: int
min_first_dimension_decomposition = MIN_FIRST_DIMENSION_DECOMPOSITION
max_other_dimension_decomposition = MAX_OTHER_DIMENSION_DECOMPOSITION

def check_device(a: Tensor, b: Tensor, device: str = 'cuda') -> bool: ...
def realize_inputs(inputs: list[torch.fx.Node]): ...
def should_decompose_bmm(mat1, mat2) -> bool: ...
def should_decompose_mm(mat1, mat2) -> bool: ...
def print_decompose_pattern(match: Match, inputs: list[torch.fx.Node]): ...
def decompose_bmm(match: Match, mat1: torch.fx.Node, mat2: torch.fx.Node): ...
def decompose_addmm(match: Match, mat1: torch.fx.Node, mat2: torch.fx.Node, mat3: torch.fx.Node): ...
def decompose_mm(match: Match, mat1: torch.fx.Node, mat2: torch.fx.Node): ...
