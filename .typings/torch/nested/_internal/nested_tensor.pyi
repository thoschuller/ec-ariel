from typing import *
import torch
from _typeshed import Incomplete
from torch._C import DispatchKey as DispatchKey, DispatchKeySet as DispatchKeySet
from torch._prims_common import is_expandable_to as is_expandable_to
from torch.nested._internal.nested_int import NestedIntNode as NestedIntNode
from torch.utils.weak import WeakTensorKeyDictionary as WeakTensorKeyDictionary
from typing import Any

_tensor_id_counter: int
_tensor_symint_registry: Incomplete

def get_tensor_symint(tensor, *, coeff: int = 1): ...
def _get_sdpa_extreme_seqlen(func, tensor): ...
def _store_val_in_tensor(val) -> torch.Tensor: ...
def _load_val_from_tensor(t: torch.Tensor): ...
def _rebuild_njt(constructor_kwargs): ...

class NestedTensor(torch.Tensor):
    _values: torch.Tensor
    _offsets: torch.Tensor
    _lengths: Optional[torch.Tensor]
    _size: tuple[int, ...]
    _strides: tuple[int, ...]
    _ragged_idx: int
    _metadata_cache: Dict[str, Any]
    @staticmethod
    def __new__(cls, values, offsets, *, lengths=None, **kwargs): ...
    def __init__(self, values, offsets, *, lengths=None, **kwargs) -> None: ...
    def values(self): ...
    def offsets(self): ...
    def lengths(self): ...
    def _get_max_seqlen(self): ...
    def _get_min_seqlen(self): ...
    @property
    def _max_seqlen_tensor(self) -> Optional[torch.Tensor]: ...
    @_max_seqlen_tensor.setter
    def _max_seqlen_tensor(self, val: Optional[torch.Tensor]) -> None: ...
    @property
    def _min_seqlen_tensor(self) -> Optional[torch.Tensor]: ...
    @_min_seqlen_tensor.setter
    def _min_seqlen_tensor(self, val: Optional[torch.Tensor]) -> None: ...
    @property
    def _max_seqlen(self): ...
    @property
    def _min_seqlen(self): ...
    @property
    def _maybe_max_seqlen(self) -> Optional[int]: ...
    @property
    def _maybe_min_seqlen(self) -> Optional[int]: ...
    def __repr__(self) -> str: ...
    def __reduce_ex__(self, proto): ...
    def __tensor_flatten__(self): ...
    @staticmethod
    def __tensor_unflatten__(inner_tensors: Dict, meta, outer_size, outer_stride): ...
    @classmethod
    def __torch_dispatch__(cls, func, types, args=(), kwargs=None): ...
    @classmethod
    def __torch_function__(cls, func, types, args=(), kwargs=None): ...

class ViewBufferFromNested(torch.autograd.Function):
    @staticmethod
    def forward(ctx, x: NestedTensor): ...
    @staticmethod
    def backward(ctx, gO: torch.Tensor): ...

class ViewNestedFromBuffer(torch.autograd.Function):
    @staticmethod
    def forward(ctx, values: torch.Tensor, offsets: torch.Tensor, metadata_cache: Optional[Dict[str, Any]] = None): ...
    @staticmethod
    def backward(ctx, gO: NestedTensor): ...

def buffer_from_jagged(jagged): ...
def jagged_from_list(tensors: List[torch.Tensor], offsets: Optional[torch.Tensor], dtype=None, device=None) -> tuple[NestedTensor, torch.Tensor]:
    """Constructs a NestedTensor backed by jagged layout from a list of tensors"""
def jagged_from_tensor_and_lengths(tensor: torch.Tensor, starts: torch.Tensor, lengths: torch.Tensor) -> tuple[NestedTensor, torch.Tensor, Optional[torch.Tensor]]:
    """Constructs a NestedTensor backed by jagged layout from a tensor, starts of sequences, and sequence lengths"""

_dummy_instance: Optional[torch.Tensor]

def _nt_view_dummy() -> torch.Tensor: ...
def nested_view_from_values_offsets(values, offsets, ragged_idx: int = 1, min_seqlen=None, max_seqlen=None): ...
def nested_view_from_values_offsets_lengths(values, offsets, lengths, ragged_idx: int = 1, min_seqlen=None, max_seqlen=None): ...
def nested_from_padded(padded, offsets, ragged_idx: int = 1, min_seqlen=None, max_seqlen=None, sum_S=None): ...
