import torch
from _typeshed import Incomplete
from typing import Any
from typing_extensions import TypeIs

__all__ = ['MaskedTensor', 'is_masked_tensor']

def is_masked_tensor(obj: Any, /) -> TypeIs['MaskedTensor']:
    """Returns True if the input is a MaskedTensor, else False

    Args:
        a: any input

    Examples:

        >>> # xdoctest: +SKIP
        >>> from torch.masked import MaskedTensor
        >>> data = torch.arange(6).reshape(2, 3)
        >>> mask = torch.tensor([[True, False, False], [True, True, False]])
        >>> mt = MaskedTensor(data, mask)
        >>> is_masked_tensor(mt)
        True
    """

class MaskedTensor(torch.Tensor):
    @staticmethod
    def __new__(cls, data, mask, requires_grad: bool = False): ...
    _masked_data: Incomplete
    _masked_mask: Incomplete
    def _preprocess_data(self, data, mask) -> None: ...
    def _validate_members(self) -> None: ...
    def __init__(self, data, mask, requires_grad: bool = False) -> None: ...
    @staticmethod
    def _from_values(data, mask):
        """Differentiable constructor for MaskedTensor"""
    def _set_data_mask(self, data, mask) -> None: ...
    def __repr__(self) -> str: ...
    @classmethod
    def __torch_function__(cls, func, types, args=(), kwargs=None): ...
    @classmethod
    def unary(cls, fn, data, mask): ...
    @classmethod
    def __torch_dispatch__(cls, func, types, args, kwargs): ...
    def __lt__(self, other): ...
    def to_tensor(self, value): ...
    def get_data(self): ...
    def get_mask(self): ...
    def is_sparse_coo(self): ...
    def is_sparse_csr(self): ...
    @property
    def is_sparse(self): ...
