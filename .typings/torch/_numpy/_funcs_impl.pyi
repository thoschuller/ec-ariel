from . import _dtypes_impl as _dtypes_impl, _util as _util
from ._normalizations import ArrayLike as ArrayLike, ArrayLikeOrScalar as ArrayLikeOrScalar, CastingModes as CastingModes, DTypeLike as DTypeLike, NDArray as NDArray, NotImplementedType as NotImplementedType, OutArray as OutArray
from _typeshed import Incomplete
from collections.abc import Sequence
from torch import broadcast_shapes as broadcast_shapes

def copy(a: ArrayLike, order: NotImplementedType = 'K', subok: NotImplementedType = False): ...
def copyto(dst: NDArray, src: ArrayLike, casting: CastingModes | None = 'same_kind', where: NotImplementedType = None): ...
def atleast_1d(*arys: ArrayLike): ...
def atleast_2d(*arys: ArrayLike): ...
def atleast_3d(*arys: ArrayLike): ...
def _concat_check(tup, dtype, out) -> None: ...
def _concat_cast_helper(tensors, out=None, dtype=None, casting: str = 'same_kind'):
    """Figure out dtypes, cast if necessary."""
def _concatenate(tensors, axis: int = 0, out=None, dtype=None, casting: CastingModes | None = 'same_kind'): ...
def concatenate(ar_tuple: Sequence[ArrayLike], axis: int = 0, out: OutArray | None = None, dtype: DTypeLike | None = None, casting: CastingModes | None = 'same_kind'): ...
def vstack(tup: Sequence[ArrayLike], *, dtype: DTypeLike | None = None, casting: CastingModes | None = 'same_kind'): ...
row_stack = vstack

def hstack(tup: Sequence[ArrayLike], *, dtype: DTypeLike | None = None, casting: CastingModes | None = 'same_kind'): ...
def dstack(tup: Sequence[ArrayLike], *, dtype: DTypeLike | None = None, casting: CastingModes | None = 'same_kind'): ...
def column_stack(tup: Sequence[ArrayLike], *, dtype: DTypeLike | None = None, casting: CastingModes | None = 'same_kind'): ...
def stack(arrays: Sequence[ArrayLike], axis: int = 0, out: OutArray | None = None, *, dtype: DTypeLike | None = None, casting: CastingModes | None = 'same_kind'): ...
def append(arr: ArrayLike, values: ArrayLike, axis=None): ...
def _split_helper(tensor, indices_or_sections, axis, strict: bool = False): ...
def _split_helper_int(tensor, indices_or_sections, axis, strict: bool = False): ...
def _split_helper_list(tensor, indices_or_sections, axis): ...
def array_split(ary: ArrayLike, indices_or_sections, axis: int = 0): ...
def split(ary: ArrayLike, indices_or_sections, axis: int = 0): ...
def hsplit(ary: ArrayLike, indices_or_sections): ...
def vsplit(ary: ArrayLike, indices_or_sections): ...
def dsplit(ary: ArrayLike, indices_or_sections): ...
def kron(a: ArrayLike, b: ArrayLike): ...
def vander(x: ArrayLike, N=None, increasing: bool = False): ...
def linspace(start: ArrayLike, stop: ArrayLike, num: int = 50, endpoint: bool = True, retstep: bool = False, dtype: DTypeLike | None = None, axis: int = 0): ...
def geomspace(start: ArrayLike, stop: ArrayLike, num: int = 50, endpoint: bool = True, dtype: DTypeLike | None = None, axis: int = 0): ...
def logspace(start, stop, num: int = 50, endpoint: bool = True, base: float = 10.0, dtype: DTypeLike | None = None, axis: int = 0): ...
def arange(start: ArrayLikeOrScalar | None = None, stop: ArrayLikeOrScalar | None = None, step: ArrayLikeOrScalar | None = 1, dtype: DTypeLike | None = None, *, like: NotImplementedType = None): ...
def empty(shape, dtype: DTypeLike | None = None, order: NotImplementedType = 'C', *, like: NotImplementedType = None): ...
def empty_like(prototype: ArrayLike, dtype: DTypeLike | None = None, order: NotImplementedType = 'K', subok: NotImplementedType = False, shape=None): ...
def full(shape, fill_value: ArrayLike, dtype: DTypeLike | None = None, order: NotImplementedType = 'C', *, like: NotImplementedType = None): ...
def full_like(a: ArrayLike, fill_value, dtype: DTypeLike | None = None, order: NotImplementedType = 'K', subok: NotImplementedType = False, shape=None): ...
def ones(shape, dtype: DTypeLike | None = None, order: NotImplementedType = 'C', *, like: NotImplementedType = None): ...
def ones_like(a: ArrayLike, dtype: DTypeLike | None = None, order: NotImplementedType = 'K', subok: NotImplementedType = False, shape=None): ...
def zeros(shape, dtype: DTypeLike | None = None, order: NotImplementedType = 'C', *, like: NotImplementedType = None): ...
def zeros_like(a: ArrayLike, dtype: DTypeLike | None = None, order: NotImplementedType = 'K', subok: NotImplementedType = False, shape=None): ...
def _xy_helper_corrcoef(x_tensor, y_tensor=None, rowvar: bool = True):
    """Prepare inputs for cov and corrcoef."""
def corrcoef(x: ArrayLike, y: ArrayLike | None = None, rowvar: bool = True, bias=None, ddof=None, *, dtype: DTypeLike | None = None): ...
def cov(m: ArrayLike, y: ArrayLike | None = None, rowvar: bool = True, bias: bool = False, ddof=None, fweights: ArrayLike | None = None, aweights: ArrayLike | None = None, *, dtype: DTypeLike | None = None): ...
def _conv_corr_impl(a, v, mode): ...
def convolve(a: ArrayLike, v: ArrayLike, mode: str = 'full'): ...
def correlate(a: ArrayLike, v: ArrayLike, mode: str = 'valid'): ...
def bincount(x: ArrayLike, /, weights: ArrayLike | None = None, minlength: int = 0): ...
def where(condition: ArrayLike, x: ArrayLikeOrScalar | None = None, y: ArrayLikeOrScalar | None = None, /): ...
def ndim(a: ArrayLike): ...
def shape(a: ArrayLike): ...
def size(a: ArrayLike, axis=None): ...
def expand_dims(a: ArrayLike, axis): ...
def flip(m: ArrayLike, axis=None): ...
def flipud(m: ArrayLike): ...
def fliplr(m: ArrayLike): ...
def rot90(m: ArrayLike, k: int = 1, axes=(0, 1)): ...
def broadcast_to(array: ArrayLike, shape, subok: NotImplementedType = False): ...
def broadcast_arrays(*args: ArrayLike, subok: NotImplementedType = False): ...
def meshgrid(*xi: ArrayLike, copy: bool = True, sparse: bool = False, indexing: str = 'xy'): ...
def indices(dimensions, dtype: DTypeLike | None = ..., sparse: bool = False): ...
def tril(m: ArrayLike, k: int = 0): ...
def triu(m: ArrayLike, k: int = 0): ...
def tril_indices(n, k: int = 0, m=None): ...
def triu_indices(n, k: int = 0, m=None): ...
def tril_indices_from(arr: ArrayLike, k: int = 0): ...
def triu_indices_from(arr: ArrayLike, k: int = 0): ...
def tri(N, M=None, k: int = 0, dtype: DTypeLike | None = None, *, like: NotImplementedType = None): ...
def isclose(a: ArrayLike, b: ArrayLike, rtol: float = 1e-05, atol: float = 1e-08, equal_nan: bool = False): ...
def allclose(a: ArrayLike, b: ArrayLike, rtol: float = 1e-05, atol: float = 1e-08, equal_nan: bool = False): ...
def _tensor_equal(a1, a2, equal_nan: bool = False): ...
def array_equal(a1: ArrayLike, a2: ArrayLike, equal_nan: bool = False): ...
def array_equiv(a1: ArrayLike, a2: ArrayLike): ...
def nan_to_num(x: ArrayLike, copy: NotImplementedType = True, nan: float = 0.0, posinf=None, neginf=None): ...
def take(a: ArrayLike, indices: ArrayLike, axis=None, out: OutArray | None = None, mode: NotImplementedType = 'raise'): ...
def take_along_axis(arr: ArrayLike, indices: ArrayLike, axis): ...
def put(a: NDArray, indices: ArrayLike, values: ArrayLike, mode: NotImplementedType = 'raise'): ...
def put_along_axis(arr: ArrayLike, indices: ArrayLike, values: ArrayLike, axis): ...
def choose(a: ArrayLike, choices: Sequence[ArrayLike], out: OutArray | None = None, mode: NotImplementedType = 'raise'): ...
def unique(ar: ArrayLike, return_index: NotImplementedType = False, return_inverse: bool = False, return_counts: bool = False, axis=None, *, equal_nan: NotImplementedType = True): ...
def nonzero(a: ArrayLike): ...
def argwhere(a: ArrayLike): ...
def flatnonzero(a: ArrayLike): ...
def clip(a: ArrayLike, min: ArrayLike | None = None, max: ArrayLike | None = None, out: OutArray | None = None): ...
def repeat(a: ArrayLike, repeats: ArrayLikeOrScalar, axis=None): ...
def tile(A: ArrayLike, reps): ...
def resize(a: ArrayLike, new_shape=None): ...
def diagonal(a: ArrayLike, offset: int = 0, axis1: int = 0, axis2: int = 1): ...
def trace(a: ArrayLike, offset: int = 0, axis1: int = 0, axis2: int = 1, dtype: DTypeLike | None = None, out: OutArray | None = None): ...
def eye(N, M=None, k: int = 0, dtype: DTypeLike | None = None, order: NotImplementedType = 'C', *, like: NotImplementedType = None): ...
def identity(n, dtype: DTypeLike | None = None, *, like: NotImplementedType = None): ...
def diag(v: ArrayLike, k: int = 0): ...
def diagflat(v: ArrayLike, k: int = 0): ...
def diag_indices(n, ndim: int = 2): ...
def diag_indices_from(arr: ArrayLike): ...
def fill_diagonal(a: ArrayLike, val: ArrayLike, wrap: bool = False): ...
def vdot(a: ArrayLike, b: ArrayLike, /): ...
def tensordot(a: ArrayLike, b: ArrayLike, axes: int = 2): ...
def dot(a: ArrayLike, b: ArrayLike, out: OutArray | None = None): ...
def inner(a: ArrayLike, b: ArrayLike, /): ...
def outer(a: ArrayLike, b: ArrayLike, out: OutArray | None = None): ...
def cross(a: ArrayLike, b: ArrayLike, axisa: int = -1, axisb: int = -1, axisc: int = -1, axis=None): ...
def einsum(*operands, out=None, dtype=None, order: str = 'K', casting: str = 'safe', optimize: bool = False): ...
def _sort_helper(tensor, axis, kind, order): ...
def sort(a: ArrayLike, axis: int = -1, kind=None, order: NotImplementedType = None): ...
def argsort(a: ArrayLike, axis: int = -1, kind=None, order: NotImplementedType = None): ...
def searchsorted(a: ArrayLike, v: ArrayLike, side: str = 'left', sorter: ArrayLike | None = None): ...
def moveaxis(a: ArrayLike, source, destination): ...
def swapaxes(a: ArrayLike, axis1, axis2): ...
def rollaxis(a: ArrayLike, axis, start: int = 0): ...
def roll(a: ArrayLike, shift, axis=None): ...
def squeeze(a: ArrayLike, axis=None): ...
def reshape(a: ArrayLike, newshape, order: NotImplementedType = 'C'): ...
def transpose(a: ArrayLike, axes=None): ...
def ravel(a: ArrayLike, order: NotImplementedType = 'C'): ...
def diff(a: ArrayLike, n: int = 1, axis: int = -1, prepend: ArrayLike | None = None, append: ArrayLike | None = None): ...
def angle(z: ArrayLike, deg: bool = False): ...
def sinc(x: ArrayLike): ...
def gradient(f: ArrayLike, *varargs, axis=None, edge_order: int = 1): ...
def round(a: ArrayLike, decimals: int = 0, out: OutArray | None = None): ...
around = round
round_ = round

def real_if_close(a: ArrayLike, tol: int = 100): ...
def real(a: ArrayLike): ...
def imag(a: ArrayLike): ...
def iscomplex(x: ArrayLike): ...
def isreal(x: ArrayLike): ...
def iscomplexobj(x: ArrayLike): ...
def isrealobj(x: ArrayLike): ...
def isneginf(x: ArrayLike, out: OutArray | None = None): ...
def isposinf(x: ArrayLike, out: OutArray | None = None): ...
def i0(x: ArrayLike): ...
def isscalar(a): ...
def hamming(M): ...
def hanning(M): ...
def kaiser(M, beta): ...
def blackman(M): ...
def bartlett(M): ...

array_type: Incomplete
array_precision: Incomplete

def common_type(*tensors: ArrayLike): ...
def histogram(a: ArrayLike, bins: ArrayLike = 10, range=None, normed=None, weights: ArrayLike | None = None, density=None): ...
def histogram2d(x, y, bins: int = 10, range: ArrayLike | None = None, normed=None, weights: ArrayLike | None = None, density=None): ...
def histogramdd(sample, bins: int = 10, range: ArrayLike | None = None, normed=None, weights: ArrayLike | None = None, density=None): ...
def min_scalar_type(a: ArrayLike, /): ...
def pad(array: ArrayLike, pad_width: ArrayLike, mode: str = 'constant', **kwargs): ...
