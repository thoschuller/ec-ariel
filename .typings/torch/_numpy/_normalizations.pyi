import typing
from . import _dtypes as _dtypes, _dtypes_impl as _dtypes_impl, _util as _util
from _typeshed import Incomplete

ArrayLike = typing.TypeVar('ArrayLike')
Scalar = int | float | complex | bool
ArrayLikeOrScalar = ArrayLike | Scalar
DTypeLike = typing.TypeVar('DTypeLike')
AxisLike = typing.TypeVar('AxisLike')
NDArray = typing.TypeVar('NDArray')
CastingModes = typing.TypeVar('CastingModes')
KeepDims = typing.TypeVar('KeepDims')
OutArray = typing.TypeVar('OutArray')
NotImplementedType = typing.TypeVar('NotImplementedType')

def normalize_array_like(x, parm=None): ...
def normalize_array_like_or_scalar(x, parm=None): ...
def normalize_optional_array_like_or_scalar(x, parm=None): ...
def normalize_optional_array_like(x, parm=None): ...
def normalize_seq_array_like(x, parm=None): ...
def normalize_dtype(dtype, parm=None): ...
def normalize_not_implemented(arg, parm) -> None: ...
def normalize_axis_like(arg, parm=None): ...
def normalize_ndarray(arg, parm=None): ...
def normalize_outarray(arg, parm=None): ...
def normalize_casting(arg, parm=None): ...

normalizers: Incomplete

def maybe_normalize(arg, parm):
    """Normalize arg if a normalizer is registered."""
def maybe_copy_to(out, result, promote_scalar_result: bool = False): ...
def wrap_tensors(result): ...
def array_or_scalar(values, py_type=..., return_scalar: bool = False): ...
def normalizer(_func=None, *, promote_scalar_result: bool = False): ...
