from . import _dtypes as _dtypes, _dtypes_impl as _dtypes_impl, _funcs as _funcs, _ufuncs as _ufuncs, _util as _util
from ._normalizations import ArrayLike as ArrayLike, NotImplementedType as NotImplementedType, normalize_array_like as normalize_array_like, normalizer as normalizer
from _typeshed import Incomplete

newaxis: Incomplete
FLAGS: Incomplete
SHORTHAND_TO_FLAGS: Incomplete

class Flags:
    _flag_to_value: Incomplete
    def __init__(self, flag_to_value: dict) -> None: ...
    def __getattr__(self, attr: str): ...
    def __getitem__(self, key): ...
    def __setattr__(self, attr, value) -> None: ...
    def __setitem__(self, key, value) -> None: ...

def create_method(fn, name=None): ...

methods: Incomplete
dunder: Incomplete
ri_dunder: Incomplete

def _upcast_int_indices(index): ...

class _Unspecified: ...

class ndarray:
    tensor: Incomplete
    def __init__(self, t=None) -> None: ...
    fn: Incomplete
    conj: Incomplete
    conjugate: Incomplete
    method: Incomplete
    plain: Incomplete
    rvar: Incomplete
    ivar: Incomplete
    __divmod__: Incomplete
    __rdivmod__: Incomplete
    @property
    def shape(self): ...
    @property
    def size(self): ...
    @property
    def ndim(self): ...
    @property
    def dtype(self): ...
    @property
    def strides(self): ...
    @property
    def itemsize(self): ...
    @property
    def flags(self): ...
    @property
    def data(self): ...
    @property
    def nbytes(self): ...
    @property
    def T(self): ...
    @property
    def real(self): ...
    @real.setter
    def real(self, value) -> None: ...
    @property
    def imag(self): ...
    @imag.setter
    def imag(self, value) -> None: ...
    def astype(self, dtype, order: str = 'K', casting: str = 'unsafe', subok: bool = True, copy: bool = True): ...
    @normalizer
    def copy(self, order: NotImplementedType = 'C'): ...
    @normalizer
    def flatten(self, order: NotImplementedType = 'C'): ...
    def resize(self, *new_shape, refcheck: bool = False) -> None: ...
    def view(self, dtype=..., type=...): ...
    @normalizer
    def fill(self, value: ArrayLike): ...
    def tolist(self): ...
    def __iter__(self): ...
    def __str__(self) -> str: ...
    __repr__: Incomplete
    def __eq__(self, other): ...
    def __ne__(self, other): ...
    def __index__(self) -> int: ...
    def __bool__(self) -> bool: ...
    def __int__(self) -> int: ...
    def __float__(self) -> float: ...
    def __complex__(self) -> complex: ...
    def is_integer(self): ...
    def __len__(self) -> int: ...
    def __contains__(self, x) -> bool: ...
    def transpose(self, *axes): ...
    def reshape(self, *shape, order: str = 'C'): ...
    def sort(self, axis: int = -1, kind=None, order=None) -> None: ...
    def item(self, *args): ...
    def __getitem__(self, index): ...
    def __setitem__(self, index, value) -> None: ...
    take: Incomplete
    put: Incomplete
    def __dlpack__(self, *, stream=None): ...
    def __dlpack_device__(self): ...

def _tolist(obj):
    """Recursively convert tensors into lists."""
def array(obj, dtype=None, *, copy: bool = True, order: str = 'K', subok: bool = False, ndmin: int = 0, like=None): ...
def asarray(a, dtype=None, order: str = 'K', *, like=None): ...
def ascontiguousarray(a, dtype=None, *, like=None): ...
def from_dlpack(x, /): ...
def _extract_dtype(entry): ...
def can_cast(from_, to, casting: str = 'safe'): ...
def result_type(*arrays_and_dtypes): ...
