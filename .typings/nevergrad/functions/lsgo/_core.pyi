import numpy as np
from _typeshed import Incomplete
from typing import Callable

def sphere(x: np.ndarray) -> float: ...

class Elliptic:
    weights: Incomplete
    def __init__(self, dimension: int) -> None: ...
    def __call__(self, x: np.ndarray) -> float: ...

def elliptic(x: np.ndarray) -> float: ...
def rastrigin(x: np.ndarray) -> float: ...
def ackley(x: np.ndarray) -> float: ...
def schwefel_1_2(x: np.ndarray) -> float: ...
def rosenbrock(x: np.ndarray) -> float: ...
def irregularity(x: np.ndarray) -> np.ndarray: ...

class Asymmetry:
    beta: Incomplete
    _weights: np.ndarray | None
    def __init__(self, beta: float = 0.2) -> None: ...
    def _get_weights(self, dimension: int) -> np.ndarray: ...
    def __call__(self, x: np.ndarray) -> np.ndarray: ...

class Illconditionning:
    alpha: Incomplete
    _weights: np.ndarray | None
    def __init__(self, alpha: float = 10.0) -> None: ...
    def _get_weights(self, dimension: int) -> np.ndarray: ...
    def __call__(self, x: np.ndarray) -> np.ndarray: ...

class Translation:
    translation: Incomplete
    def __init__(self, translation: np.ndarray) -> None: ...
    def __call__(self, x: np.ndarray) -> np.ndarray: ...

class Indexing:
    indices: Incomplete
    outdim: Incomplete
    indim: Incomplete
    def __init__(self, indices: np.ndarray, indim: int) -> None: ...
    def __call__(self, x: np.ndarray) -> np.ndarray: ...
    @classmethod
    def from_split(cls, permutation: np.ndarray, dimensions: list[int], overlap: int = 0) -> list['Indexing']: ...

class Rotation:
    rotation: Incomplete
    def __init__(self, rotation: np.ndarray) -> None: ...
    def __call__(self, x: np.ndarray) -> np.ndarray: ...
    @classmethod
    def from_random(cls, dimension: int, random_state: np.random.RandomState | None = None) -> Rotation: ...

def split(permutation: np.ndarray, dimensions: list[int], overlap: int = 0) -> list[np.ndarray]: ...
def apply_transforms(x: np.ndarray, transforms: list[Callable[[np.ndarray], np.ndarray]]) -> np.ndarray: ...
