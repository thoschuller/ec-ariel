import numpy as np
from _typeshed import Incomplete
from nevergrad.functions import ExperimentFunction as ExperimentFunction
from nevergrad.parametrization import parameter as p

class _Game:
    verbose: bool
    history1: Incomplete
    history2: Incomplete
    batawaf: bool
    converter: Incomplete
    def __init__(self) -> None: ...
    def get_list_of_games(self): ...
    def play_game(self, game, policy1=None, policy2=None): ...
    def guesswho_play_noturn(self, decks, policy): ...
    def guesswho_play(self, policy, decks, turn): ...
    def guesswho_play_game(self, policy1, policy2, init: int = 24): ...
    def flip_play_game(self, policy1, policy2): ...
    def flip_match(self, a, b): ...
    def flip_play_game_nosym(self, policy1, policy2): ...
    def flip_value(self, visible1, visible2, l1, l2, stack, policy1): ...
    def war_play_game(self, policy1, policy2, batawaf: bool = False): ...
    def war_decide(self, policy, num_cards, list_of_cards): ...

class Game(ExperimentFunction):
    """
    Parameters
    ----------
    nint intaum_stocks: number of stocks to be managed
    depth: number of layers in the neural networks
    width: number of neurons per hidden layer
    """
    game: Incomplete
    game_object: Incomplete
    def __init__(self, game: str = 'war') -> None: ...
    def _simulate_game(self, x: np.ndarray) -> float: ...
    def evaluation_function(self, *recommendations: p.Parameter) -> float: ...
